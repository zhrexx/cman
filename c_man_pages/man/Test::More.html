<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:54:10 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Test::More</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Test::More</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#I love it when a plan comes together">I love it when a plan comes together</a><br/>
<a href="#Test names">Test names</a><br/>
<a href="#I'm ok, you're not ok.">I'm ok, you're not ok.</a><br/>
<a href="#Module tests">Module tests</a><br/>
<a href="#Complex data structures">Complex data structures</a><br/>
<a href="#Diagnostics">Diagnostics</a><br/>
<a href="#Conditional tests">Conditional tests</a><br/>
<a href="#Test control">Test control</a><br/>
<a href="#Discouraged comparison functions">Discouraged comparison functions</a><br/>
<a href="#Extending and Embedding Test::More">Extending and Embedding Test::More</a><br/>
<a href="#EXIT CODES">EXIT CODES</a><br/>
<a href="#COMPATIBILITY">COMPATIBILITY</a><br/>
<a href="#CAVEATS and NOTES">CAVEATS and NOTES</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#ALTERNATIVES">ALTERNATIVES</a><br/>
<a href="#ADDITIONAL LIBRARIES">ADDITIONAL LIBRARIES</a><br/>
<a href="#OTHER COMPONENTS">OTHER COMPONENTS</a><br/>
<a href="#BUNDLES">BUNDLES</a><br/>
<a href="#AUTHORS">AUTHORS</a><br/>
<a href="#MAINTAINERS">MAINTAINERS</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#SOURCE">SOURCE</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Test::More
− yet another framework for writing test scripts</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use Test::More
tests =&gt; 23; <br/>
# or <br/>
use Test::More skip_all =&gt; $reason; <br/>
# or <br/>
use Test::More; # see done_testing() <br/>
require_ok( 'Some::Module' ); <br/>
# Various ways to say "ok" <br/>
ok($got eq $expected, $test_name); <br/>
is ($got, $expected, $test_name); <br/>
isnt($got, $expected, $test_name); <br/>
# Rather than print STDERR "# here's what went
wrong\n" <br/>
diag("here's what went wrong"); <br/>
like ($got, qr/expected/, $test_name); <br/>
unlike($got, qr/expected/, $test_name); <br/>
cmp_ok($got, '==', $expected, $test_name); <br/>
is_deeply($got_complex_structure,
$expected_complex_structure, $test_name); <br/>
SKIP: { <br/>
skip $why, $how_many unless $have_some_feature; <br/>
ok( foo(), $test_name ); <br/>
is( foo(42), 23, $test_name ); <br/>
}; <br/>
TODO: { <br/>
local $TODO = $why; <br/>
ok( foo(), $test_name ); <br/>
is( foo(42), 23, $test_name ); <br/>
}; <br/>
can_ok($module, @methods); <br/>
isa_ok($object, $class); <br/>
pass($test_name); <br/>
fail($test_name); <br/>
BAIL_OUT($why); <br/>
# UNIMPLEMENTED!!! <br/>
my @status = Test::More::status;</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>STOP!</b> If
you're just getting started writing tests, have a look at
Test2::Suite first.</p>
<p style="margin-left:9%; margin-top: 1em">This is a drop
in replacement for Test::Simple which you can switch to once
you get the hang of basic testing.</p>
<p style="margin-left:9%; margin-top: 1em">The purpose of
this module is to provide a wide range of testing utilities.
Various ways to say "ok" with better diagnostics,
facilities to skip tests, test future features and compare
complicated data structures. While you can do almost
anything with a simple ok() function, it doesn't provide
good diagnostic output.</p>
<h3>I love it when a plan comes together
<a name="I love it when a plan comes together"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Before anything
else, you need a testing plan. This basically declares how
many tests your script is going to run to protect against
premature failure.</p>
<p style="margin-left:9%; margin-top: 1em">The preferred
way to do this is to declare a plan when you "use
Test::More".</p>
<p style="margin-left:9%; margin-top: 1em">use Test::More
tests =&gt; 23;</p>
<p style="margin-left:9%; margin-top: 1em">There are cases
when you will not know beforehand how many tests your script
is going to run. In this case, you can declare your tests at
the end.</p>
<p style="margin-left:9%; margin-top: 1em">use Test::More;
<br/>
... run your tests ... <br/>
done_testing( $number_of_tests_run );</p>
<p style="margin-left:9%; margin-top: 1em"><b>NOTE</b>
done_testing() should never be called in an "END { ...
}" block.</p>
<p style="margin-left:9%; margin-top: 1em">Sometimes you
really don't know how many tests were run, or it's too
difficult to calculate. In which case you can leave off
$number_of_tests_run.</p>
<p style="margin-left:9%; margin-top: 1em">In some cases,
you'll want to completely skip an entire testing script.</p>
<p style="margin-left:9%; margin-top: 1em">use Test::More
skip_all =&gt; $skip_reason;</p>
<p style="margin-left:9%; margin-top: 1em">Your script will
declare a skip with the reason why you skipped and exit
immediately with a zero (success). See Test::Harness for
details.</p>
<p style="margin-left:9%; margin-top: 1em">If you want to
control what functions Test::More will export, you have to
use the 'import' option. For example, to import everything
but 'fail', you'd do:</p>
<p style="margin-left:9%; margin-top: 1em">use Test::More
tests =&gt; 23, import =&gt; ['!fail'];</p>
<p style="margin-left:9%; margin-top: 1em">Alternatively,
you can use the plan() function. Useful for when you have to
calculate the number of tests.</p>
<p style="margin-left:9%; margin-top: 1em">use Test::More;
<br/>
plan tests =&gt; keys %Stuff * 3;</p>
<p style="margin-left:9%; margin-top: 1em">or for deciding
between running the tests at all:</p>
<p style="margin-left:9%; margin-top: 1em">use Test::More;
<br/>
if( $ˆO eq 'MacOS' ) { <br/>
plan skip_all =&gt; 'Test irrelevant on MacOS'; <br/>
} <br/>
else { <br/>
plan tests =&gt; 42; <br/>
} <b><br/>
done_testing</b></p>
<p style="margin-left:14%;">done_testing(); <br/>
done_testing($number_of_tests);</p>
<p style="margin-left:14%; margin-top: 1em">If you don't
know how many tests you're going to run, you can issue the
plan when you're done running tests.</p>
<p style="margin-left:14%; margin-top: 1em">$number_of_tests
is the same as plan(), it's the number of tests you expected
to run. You can omit this, in which case the number of tests
you ran doesn't matter, just the fact that your tests ran to
conclusion.</p>
<p style="margin-left:14%; margin-top: 1em">This is safer
than and replaces the "no_plan" plan.</p>
<p style="margin-left:14%; margin-top: 1em"><b>Note:</b>
You must never put done_testing() inside an "END { ...
}" block. The plan is there to ensure your test does
not exit before testing has completed. If you use an END
block you completely bypass this protection.</p>
<h3>Test names
<a name="Test names"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">By convention,
each test is assigned a number in order. This is largely
done automatically for you. However, it's often very useful
to assign a name to each test. Which would you rather
see:</p>
<p style="margin-left:9%; margin-top: 1em">ok 4 <br/>
not ok 5 <br/>
ok 6</p>
<p style="margin-left:9%; margin-top: 1em">or</p>
<p style="margin-left:9%; margin-top: 1em">ok 4 −
basic multi−variable <br/>
not ok 5 − simple exponential <br/>
ok 6 − force == mass * acceleration</p>
<p style="margin-left:9%; margin-top: 1em">The later gives
you some idea of what failed. It also makes it easier to
find the test in your script, simply search for "simple
exponential".</p>
<p style="margin-left:9%; margin-top: 1em">All test
functions take a name argument. It's optional, but highly
suggested that you use it.</p>
<h3>I'm ok, you're not ok.
<a name="I'm ok, you're not ok."></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The basic
purpose of this module is to print out either "ok
#" or "not ok #" depending on if a given test
succeeded or failed. Everything else is just gravy.</p>
<p style="margin-left:9%; margin-top: 1em">All of the
following print "ok" or "not ok"
depending on if the test succeeded or failed. They all also
return true or false, respectively.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>ok</b></p></td>
<td width="88%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">ok($got eq
$expected, $test_name);</p>
<p style="margin-left:14%; margin-top: 1em">This simply
evaluates any expression ("$got eq $expected" is
just a simple example) and uses that to determine if the
test succeeded or failed. A true expression passes, a false
one fails. Very simple.</p>
<p style="margin-left:14%; margin-top: 1em">For
example:</p>
<p style="margin-left:14%; margin-top: 1em">ok( $exp{9} ==
81, 'simple exponential' ); <br/>
ok( Film−&gt;can('db_Main'), 'set_db()' ); <br/>
ok( $p−&gt;tests == 4, 'saw tests' ); <br/>
ok( !grep(!defined $_, @items), 'all items defined' );</p>
<p style="margin-left:14%; margin-top: 1em">(Mnemonic:
"This is ok.")</p>
<p style="margin-left:14%; margin-top: 1em">$test_name is a
very short description of the test that will be printed out.
It makes it very easy to find a test in your script when it
fails and gives others an idea of your intentions.
$test_name is optional, but we <b>very</b> strongly
encourage its use.</p>
<p style="margin-left:14%; margin-top: 1em">Should an ok()
fail, it will produce some diagnostics:</p>
<p style="margin-left:14%; margin-top: 1em">not ok 18
− sufficient mucus <br/>
# Failed test 'sufficient mucus' <br/>
# in foo.t at line 42.</p>
<p style="margin-left:14%; margin-top: 1em">This is the
same as Test::Simple's ok() routine.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em"><b>is</b></p></td>
<td width="88%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em"><b>isnt</b></p>
<p style="margin-left:14%;">is ( $got, $expected,
$test_name ); <br/>
isnt( $got, $expected, $test_name );</p>
<p style="margin-left:14%; margin-top: 1em">Similar to
ok(), is() and isnt() compare their two arguments with
"eq" and "ne" respectively and use the
result of that to determine if the test succeeded or failed.
So these:</p>
<p style="margin-left:14%; margin-top: 1em"># Is the
ultimate answer 42? <br/>
is( ultimate_answer(), 42, "Meaning of Life" );
<br/>
# $foo isn't empty <br/>
isnt( $foo, '', "Got some foo" );</p>
<p style="margin-left:14%; margin-top: 1em">are similar to
these:</p>
<p style="margin-left:14%; margin-top: 1em">ok(
ultimate_answer() eq 42, "Meaning of Life" ); <br/>
ok( $foo ne '', "Got some foo" );</p>
<p style="margin-left:14%; margin-top: 1em">"undef"
will only ever match "undef". So you can test a
value against "undef" like this:</p>
<p style="margin-left:14%; margin-top: 1em">is($not_defined,
undef, "undefined as expected");</p>
<p style="margin-left:14%; margin-top: 1em">(Mnemonic:
"This is that." "This isn't that.")</p>
<p style="margin-left:14%; margin-top: 1em">So why use
these? They produce better diagnostics on failure. ok()
cannot know what you are testing for (beyond the name), but
is() and isnt() know what the test was and why it failed.
For example this test:</p>
<p style="margin-left:14%; margin-top: 1em">my $foo =
'waffle'; my $bar = 'yarblokos'; <br/>
is( $foo, $bar, 'Is foo the same as bar?' );</p>
<p style="margin-left:14%; margin-top: 1em">Will produce
something like this:</p>
<p style="margin-left:14%; margin-top: 1em">not ok 17
− Is foo the same as bar? <br/>
# Failed test 'Is foo the same as bar?' <br/>
# in foo.t at line 139. <br/>
# got: 'waffle' <br/>
# expected: 'yarblokos'</p>
<p style="margin-left:14%; margin-top: 1em">So you can
figure out what went wrong without rerunning the test.</p>
<p style="margin-left:14%; margin-top: 1em">You are
encouraged to use is() and isnt() over ok() where possible,
however do not be tempted to use them to find out if
something is true or false!</p>
<p style="margin-left:14%; margin-top: 1em"># XXX BAD! <br/>
is( exists $brooklyn{tree}, 1, 'A tree grows in Brooklyn'
);</p>
<p style="margin-left:14%; margin-top: 1em">This does not
check if "exists $brooklyn{tree}" is true, it
checks if it returns 1. Very different. Similar caveats
exist for false and 0. In these cases, use ok().</p>
<p style="margin-left:14%; margin-top: 1em">ok( exists
$brooklyn{tree}, 'A tree grows in Brooklyn' );</p>
<p style="margin-left:14%; margin-top: 1em">A simple call
to isnt() usually does not provide a strong test but there
are cases when you cannot say much more about a value than
that it is different from some other value:</p>
<p style="margin-left:14%; margin-top: 1em">new_ok $obj,
"Foo"; <br/>
my $clone = $obj−&gt;clone; <br/>
isa_ok $obj, "Foo",
"Foo−&gt;clone"; <br/>
isnt $obj, $clone, "clone() produces a different
object";</p>
<p style="margin-left:14%; margin-top: 1em">Historically we
supported an "isn't()" function as an alias of
isnt(), however in Perl 5.37.9 support for the use of
aprostrophe as a package separator was deprecated and by
Perl 5.42.0 support for it will have been removed
completely. Accordingly use of "isn't()" is also
deprecated, and will produce warnings when used unless
'deprecated' warnings are specifically disabled in the scope
where it is used. You are strongly advised to migrate to
using isnt() instead.</p>
<p style="margin-left:9%;"><b>like</b></p>
<p style="margin-left:14%;">like( $got, qr/expected/,
$test_name );</p>
<p style="margin-left:14%; margin-top: 1em">Similar to
ok(), like() matches $got against the regex
"qr/expected/".</p>
<p style="margin-left:14%; margin-top: 1em">So this:</p>
<p style="margin-left:14%; margin-top: 1em">like($got,
qr/expected/, 'this is like that');</p>
<p style="margin-left:14%; margin-top: 1em">is similar
to:</p>
<p style="margin-left:14%; margin-top: 1em">ok( $got
=˜ m/expected/, 'this is like that');</p>
<p style="margin-left:14%; margin-top: 1em">(Mnemonic
"This is like that".)</p>
<p style="margin-left:14%; margin-top: 1em">The second
argument is a regular expression. It may be given as a regex
reference (i.e. "qr//") or (for better
compatibility with older perls) as a string that looks like
a regex (alternative delimiters are currently not
supported):</p>
<p style="margin-left:14%; margin-top: 1em">like( $got,
'/expected/', 'this is like that' );</p>
<p style="margin-left:14%; margin-top: 1em">Regex options
may be placed on the end ('/expected/i').</p>
<p style="margin-left:14%; margin-top: 1em">Its advantages
over ok() are similar to that of is() and isnt(). Better
diagnostics on failure.</p>
<p style="margin-left:9%;"><b>unlike</b></p>
<p style="margin-left:14%;">unlike( $got, qr/expected/,
$test_name );</p>
<p style="margin-left:14%; margin-top: 1em">Works exactly
as like(), only it checks if $got <b>does not</b> match the
given pattern.</p>
<p style="margin-left:9%;"><b>cmp_ok</b></p>
<p style="margin-left:14%;">cmp_ok( $got, $op, $expected,
$test_name );</p>
<p style="margin-left:14%; margin-top: 1em">Halfway between
ok() and is() lies cmp_ok(). This allows you to compare two
arguments using any binary perl operator. The test passes if
the comparison is true and fails otherwise.</p>
<p style="margin-left:14%; margin-top: 1em"># ok( $got eq
$expected ); <br/>
cmp_ok( $got, 'eq', $expected, 'this eq that' ); <br/>
# ok( $got == $expected ); <br/>
cmp_ok( $got, '==', $expected, 'this == that' ); <br/>
# ok( $got &amp;&amp; $expected ); <br/>
cmp_ok( $got, '&amp;&amp;', $expected, 'this &amp;&amp;
that' ); <br/>
...etc...</p>
<p style="margin-left:14%; margin-top: 1em">Its advantage
over ok() is when the test fails you'll know what $got and
$expected were:</p>
<p style="margin-left:14%; margin-top: 1em">not ok 1 <br/>
# Failed test in foo.t at line 12. <br/>
# '23' <br/>
# &amp;&amp; <br/>
# undef</p>
<p style="margin-left:14%; margin-top: 1em">It's also
useful in those cases where you are comparing numbers and
is()'s use of "eq" will interfere:</p>
<p style="margin-left:14%; margin-top: 1em">cmp_ok(
$big_hairy_number, '==', $another_big_hairy_number );</p>
<p style="margin-left:14%; margin-top: 1em">It's especially
useful when comparing greater−than or
smaller−than relation between values:</p>
<p style="margin-left:14%; margin-top: 1em">cmp_ok(
$some_value, '&lt;=', $upper_limit );</p>
<p style="margin-left:9%;"><b>can_ok</b></p>
<p style="margin-left:14%;">can_ok($module, @methods); <br/>
can_ok($object, @methods);</p>
<p style="margin-left:14%; margin-top: 1em">Checks to make
sure the $module or $object can do these @methods (works
with functions, too).</p>
<p style="margin-left:14%; margin-top: 1em">can_ok('Foo',
qw(this that whatever));</p>
<p style="margin-left:14%; margin-top: 1em">is almost
exactly like saying:</p>
<p style="margin-left:14%; margin-top: 1em">ok(
Foo−&gt;can('this') &amp;&amp; <br/>
Foo−&gt;can('that') &amp;&amp; <br/>
Foo−&gt;can('whatever') <br/>
);</p>
<p style="margin-left:14%; margin-top: 1em">only without
all the typing and with a better interface. Handy for
quickly testing an interface.</p>
<p style="margin-left:14%; margin-top: 1em">No matter how
many @methods you check, a single can_ok() call counts as
one test. If you desire otherwise, use:</p>
<p style="margin-left:14%; margin-top: 1em">foreach my
$meth (@methods) { <br/>
can_ok('Foo', $meth); <br/>
}</p>
<p style="margin-left:9%;"><b>isa_ok</b></p>
<p style="margin-left:14%;">isa_ok($object, $class,
$object_name); <br/>
isa_ok($subclass, $class, $object_name); <br/>
isa_ok($ref, $type, $ref_name);</p>
<p style="margin-left:14%; margin-top: 1em">Checks to see
if the given "$object−&gt;isa($class)". Also
checks to make sure the object was defined in the first
place. Handy for this sort of thing:</p>
<p style="margin-left:14%; margin-top: 1em">my $obj =
Some::Module−&gt;new; <br/>
isa_ok( $obj, 'Some::Module' );</p>
<p style="margin-left:14%; margin-top: 1em">where you'd
otherwise have to write</p>
<p style="margin-left:14%; margin-top: 1em">my $obj =
Some::Module−&gt;new; <br/>
ok( defined $obj &amp;&amp;
$obj−&gt;isa('Some::Module') );</p>
<p style="margin-left:14%; margin-top: 1em">to safeguard
against your test script blowing up.</p>
<p style="margin-left:14%; margin-top: 1em">You can also
test a class, to make sure that it has the right
ancestor:</p>
<p style="margin-left:14%; margin-top: 1em">isa_ok( 'Vole',
'Rodent' );</p>
<p style="margin-left:14%; margin-top: 1em">It works on
references, too:</p>
<p style="margin-left:14%; margin-top: 1em">isa_ok(
$array_ref, 'ARRAY' );</p>
<p style="margin-left:14%; margin-top: 1em">The diagnostics
of this test normally just refer to 'the object'. If you'd
like them to be more specific, you can supply an
$object_name (for example 'Test customer').</p>
<p style="margin-left:9%;"><b>new_ok</b></p>
<p style="margin-left:14%;">my $obj = new_ok( $class );
<br/>
my $obj = new_ok( $class =&gt; \@args ); <br/>
my $obj = new_ok( $class =&gt; \@args, $object_name );</p>
<p style="margin-left:14%; margin-top: 1em">A convenience
function which combines creating an object and calling
isa_ok() on that object.</p>
<p style="margin-left:14%; margin-top: 1em">It is basically
equivalent to:</p>
<p style="margin-left:14%; margin-top: 1em">my $obj =
$class−&gt;new(@args); <br/>
isa_ok $obj, $class, $object_name;</p>
<p style="margin-left:14%; margin-top: 1em">If @args is not
given, an empty list will be used.</p>
<p style="margin-left:14%; margin-top: 1em">This function
only works on new() and it assumes new() will return just a
single object which isa $class.</p>
<p style="margin-left:9%;"><b>subtest</b></p>
<p style="margin-left:14%;">subtest $name =&gt; \&amp;code,
@args;</p>
<p style="margin-left:14%; margin-top: 1em">subtest() runs
the &amp;code as its own little test with its own plan and
its own result. The main test counts this as a single test
using the result of the whole subtest to determine if its ok
or not ok.</p>
<p style="margin-left:14%; margin-top: 1em">For
example...</p>
<p style="margin-left:14%; margin-top: 1em">use Test::More
tests =&gt; 3; <br/>
pass("First test"); <br/>
subtest 'An example subtest' =&gt; sub { <br/>
plan tests =&gt; 2; <br/>
pass("This is a subtest"); <br/>
pass("So is this"); <br/>
}; <br/>
pass("Third test");</p>
<p style="margin-left:14%; margin-top: 1em">This would
produce.</p>
<p style="margin-left:14%; margin-top: 1em">1..3 <br/>
ok 1 − First test <br/>
# Subtest: An example subtest <br/>
1..2 <br/>
ok 1 − This is a subtest <br/>
ok 2 − So is this <br/>
ok 2 − An example subtest <br/>
ok 3 − Third test</p>
<p style="margin-left:14%; margin-top: 1em">A subtest may
call "skip_all". No tests will be run, but the
subtest is considered a skip.</p>
<p style="margin-left:14%; margin-top: 1em">subtest
'skippy' =&gt; sub { <br/>
plan skip_all =&gt; 'cuz I said so'; <br/>
pass('this test will never be run'); <br/>
};</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the subtest passed, false otherwise.</p>
<p style="margin-left:14%; margin-top: 1em">Due to how
subtests work, you may omit a plan if you desire. This adds
an implicit done_testing() to the end of your subtest. The
following two subtests are equivalent:</p>
<p style="margin-left:14%; margin-top: 1em">subtest
'subtest with implicit done_testing()', sub { <br/>
ok 1, 'subtests with an implicit done testing should work';
<br/>
ok 1, '... and support more than one test'; <br/>
ok 1, '... no matter how many tests are run'; <br/>
}; <br/>
subtest 'subtest with explicit done_testing()', sub { <br/>
ok 1, 'subtests with an explicit done testing should work';
<br/>
ok 1, '... and support more than one test'; <br/>
ok 1, '... no matter how many tests are run'; <br/>
done_testing(); <br/>
};</p>
<p style="margin-left:14%; margin-top: 1em">Extra arguments
given to "subtest" are passed to the callback. For
example:</p>
<p style="margin-left:14%; margin-top: 1em">sub my_subtest
{ <br/>
my $range = shift; <br/>
... <br/>
} <br/>
for my $range (1, 10, 100, 1000) { <br/>
subtest "testing range $range", \&amp;my_subtest,
$range; <br/>
}</p>
<p style="margin-left:9%;"><b>pass <br/>
fail</b></p>
<p style="margin-left:14%;">pass($test_name); <br/>
fail($test_name);</p>
<p style="margin-left:14%; margin-top: 1em">Sometimes you
just want to say that the tests have passed. Usually the
case is you've got some complicated condition that is
difficult to wedge into an ok(). In this case, you can
simply use pass() (to declare the test ok) or fail (for not
ok). They are synonyms for ok(1) and ok(0).</p>
<p style="margin-left:14%; margin-top: 1em">Use these very,
very, very sparingly.</p>
<h3>Module tests
<a name="Module tests"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Sometimes you
want to test if a module, or a list of modules, can
successfully load. For example, you'll often want a first
test which simply loads all the modules in the distribution
to make sure they work before going on to do more
complicated testing.</p>
<p style="margin-left:9%; margin-top: 1em">For such
purposes we have "use_ok" and
"require_ok". <b><br/>
require_ok</b></p>
<p style="margin-left:14%;">require_ok($module); <br/>
require_ok($file);</p>
<p style="margin-left:14%; margin-top: 1em">Tries to
"require" the given $module or $file. If it loads
successfully, the test will pass. Otherwise it fails and
displays the load error.</p>
<p style="margin-left:14%; margin-top: 1em">"require_ok"
will guess whether the input is a module name or a
filename.</p>
<p style="margin-left:14%; margin-top: 1em">No exception
will be thrown if the load fails.</p>
<p style="margin-left:14%; margin-top: 1em"># require
Some::Module <br/>
require_ok "Some::Module"; <br/>
# require "Some/File.pl"; <br/>
require_ok "Some/File.pl"; <br/>
# stop testing if any of your modules will not load <br/>
for my $module (@module) { <br/>
require_ok $module or BAIL_OUT "Can't load
$module"; <br/>
}</p>
<p style="margin-left:9%;"><b>use_ok</b></p>
<p style="margin-left:14%;">BEGIN { use_ok($module); } <br/>
BEGIN { use_ok($module, @imports); }</p>
<p style="margin-left:14%; margin-top: 1em">Like
"require_ok", but it will "use" the
$module in question and only loads modules, not files.</p>
<p style="margin-left:14%; margin-top: 1em">If you just
want to test a module can be loaded, use
"require_ok".</p>
<p style="margin-left:14%; margin-top: 1em">If you just
want to load a module in a test, we recommend simply using
"use" directly. It will cause the test to
stop.</p>
<p style="margin-left:14%; margin-top: 1em">It's
recommended that you run use_ok() inside a BEGIN block so
its functions are exported at compile−time and
prototypes are properly honored.</p>
<p style="margin-left:14%; margin-top: 1em">If @imports are
given, they are passed through to the use. So this:</p>
<p style="margin-left:14%; margin-top: 1em">BEGIN {
use_ok('Some::Module', qw(foo bar)) }</p>
<p style="margin-left:14%; margin-top: 1em">is like doing
this:</p>
<p style="margin-left:14%; margin-top: 1em">use
Some::Module qw(foo bar);</p>
<p style="margin-left:14%; margin-top: 1em">Version numbers
can be checked like so:</p>
<p style="margin-left:14%; margin-top: 1em"># Just like
"use Some::Module 1.02" <br/>
BEGIN { use_ok('Some::Module', 1.02) }</p>
<p style="margin-left:14%; margin-top: 1em">Don't try to do
this:</p>
<p style="margin-left:14%; margin-top: 1em">BEGIN { <br/>
use_ok('Some::Module'); <br/>
...some code that depends on the use... <br/>
...happening at compile time... <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">because the
notion of "compile−time" is relative.
Instead, you want:</p>
<p style="margin-left:14%; margin-top: 1em">BEGIN {
use_ok('Some::Module') } <br/>
BEGIN { ...some code that depends on the use... }</p>
<p style="margin-left:14%; margin-top: 1em">If you want the
equivalent of "use Foo ()", use a module but not
import anything, use "require_ok".</p>
<p style="margin-left:14%; margin-top: 1em">BEGIN {
require_ok "Foo" }</p>
<h3>Complex data structures
<a name="Complex data structures"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Not everything
is a simple eq check or regex. There are times you need to
see if two data structures are equivalent. For these
instances Test::More provides a handful of useful
functions.</p>
<p style="margin-left:9%; margin-top: 1em"><b>NOTE</b> I'm
not quite sure what will happen with filehandles. <b><br/>
is_deeply</b></p>
<p style="margin-left:14%;">is_deeply( $got, $expected,
$test_name );</p>
<p style="margin-left:14%; margin-top: 1em">Similar to
is(), except that if $got and $expected are references, it
does a deep comparison walking each data structure to see if
they are equivalent. If the two structures are different, it
will display the place where they start differing.</p>
<p style="margin-left:14%; margin-top: 1em">is_deeply()
compares the dereferenced values of references, the
references themselves (except for their type) are ignored.
This means aspects such as blessing and ties are not
considered "different".</p>
<p style="margin-left:14%; margin-top: 1em">is_deeply()
currently has very limited handling of function reference
and globs. It merely checks if they have the same referent.
This may improve in the future.</p>
<p style="margin-left:14%; margin-top: 1em">Test::Differences
and Test::Deep provide more in−depth functionality
along these lines.</p>
<p style="margin-left:14%; margin-top: 1em"><b>NOTE
is_deeply()</b> has limitations when it comes to comparing
strings and refs:</p>
<p style="margin-left:14%; margin-top: 1em">my $path =
path('.'); <br/>
my $hash = {}; <br/>
is_deeply( $path, "$path" ); # ok <br/>
is_deeply( $hash, "$hash" ); # fail</p>
<p style="margin-left:14%; margin-top: 1em">This happens
because is_deeply will unoverload all arguments
unconditionally. It is probably best not to use is_deeply
with overloading. For legacy reasons this is not likely to
ever be fixed. If you would like a much better tool for this
you should see Test2::Suite Specifically
Test2::Tools::Compare has an is() function that works like
"is_deeply" with many improvements.</p>
<h3>Diagnostics
<a name="Diagnostics"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If you pick the
right test function, you'll usually get a good idea of what
went wrong when it failed. But sometimes it doesn't work out
that way. So here we have ways for you to write your own
diagnostic messages which are safer than just "print
STDERR". <b><br/>
diag</b></p>
<p style="margin-left:14%;">diag(@diagnostic_message);</p>
<p style="margin-left:14%; margin-top: 1em">Prints a
diagnostic message which is guaranteed not to interfere with
test output. Like "print" @diagnostic_message is
simply concatenated together.</p>
<p style="margin-left:14%; margin-top: 1em">Returns false,
so as to preserve failure.</p>
<p style="margin-left:14%; margin-top: 1em">Handy for this
sort of thing:</p>
<p style="margin-left:14%; margin-top: 1em">ok( grep(/foo/,
@users), "There's a foo user" ) or <br/>
diag("Since there's no foo, check that /etc/bar is set
up right");</p>
<p style="margin-left:14%; margin-top: 1em">which would
produce:</p>
<p style="margin-left:14%; margin-top: 1em">not ok 42
− There's a foo user <br/>
# Failed test 'There's a foo user' <br/>
# in foo.t at line 52. <br/>
# Since there's no foo, check that /etc/bar is set up
right.</p>
<p style="margin-left:14%; margin-top: 1em">You might
remember "ok() or diag()" with the mnemonic open()
or die().</p>
<p style="margin-left:14%; margin-top: 1em"><b>NOTE</b> The
exact formatting of the diagnostic output is still changing,
but it is guaranteed that whatever you throw at it won't
interfere with the test.</p>
<p style="margin-left:9%;"><b>note</b></p>
<p style="margin-left:14%;">note(@diagnostic_message);</p>
<p style="margin-left:14%; margin-top: 1em">Like diag(),
except the message will not be seen when the test is run in
a harness. It will only be visible in the verbose TAP
stream.</p>
<p style="margin-left:14%; margin-top: 1em">Handy for
putting in notes which might be useful for debugging, but
don't indicate a problem.</p>
<p style="margin-left:14%; margin-top: 1em">note("Tempfile
is $tempfile");</p>
<p style="margin-left:9%;"><b>explain</b></p>
<p style="margin-left:14%;">my @dump = explain
@diagnostic_message;</p>
<p style="margin-left:14%; margin-top: 1em">Will dump the
contents of any references in a human readable format.
Usually you want to pass this into "note" or
"diag".</p>
<p style="margin-left:14%; margin-top: 1em">Handy for
things like...</p>
<p style="margin-left:14%; margin-top: 1em">is_deeply($have,
$want) || diag explain $have;</p>
<p style="margin-left:14%; margin-top: 1em">or</p>
<p style="margin-left:14%; margin-top: 1em">note explain
\%args; <br/>
Some::Class−&gt;method(%args);</p>
<h3>Conditional tests
<a name="Conditional tests"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Sometimes
running a test under certain conditions will cause the test
script to die. A certain function or method isn't
implemented (such as fork() on MacOS), some resource isn't
available (like a net connection) or a module isn't
available. In these cases it's necessary to skip tests, or
declare that they are supposed to fail but will work in the
future (a todo test).</p>
<p style="margin-left:9%; margin-top: 1em">For more details
on the mechanics of skip and todo tests see
Test::Harness.</p>
<p style="margin-left:9%; margin-top: 1em">The way
Test::More handles this is with a named block. Basically, a
block of tests which can be skipped over or made todo. It's
best if I just show you... <b><br/>
SKIP: BLOCK</b></p>
<p style="margin-left:14%;">SKIP: { <br/>
skip $why, $how_many if $condition; <br/>
...normal testing code goes here... <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">This declares a
block of tests that might be skipped, $how_many tests there
are, $why and under what $condition to skip them. An example
is the easiest way to illustrate:</p>
<p style="margin-left:14%; margin-top: 1em">SKIP: { <br/>
eval { require HTML::Lint }; <br/>
skip "HTML::Lint not installed", 2 if $@; <br/>
my $lint = new HTML::Lint; <br/>
isa_ok( $lint, "HTML::Lint" ); <br/>
$lint−&gt;parse( $html ); <br/>
is( $lint−&gt;errors, 0, "No errors found in
HTML" ); <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">If the user
does not have HTML::Lint installed, the whole block of code
<i>won't be run at all</i>. Test::More will output special
ok's which Test::Harness interprets as skipped, but passing,
tests.</p>
<p style="margin-left:14%; margin-top: 1em">It's important
that $how_many accurately reflects the number of tests in
the SKIP block so the # of tests run will match up with your
plan. If your plan is "no_plan" $how_many is
optional and will default to 1.</p>
<p style="margin-left:14%; margin-top: 1em">It's perfectly
safe to nest SKIP blocks. Each SKIP block must have the
label "SKIP", or Test::More can't work its
magic.</p>
<p style="margin-left:14%; margin-top: 1em">You don't skip
tests which are failing because there's a bug in your
program, or for which you don't yet have code written. For
that you use TODO. Read on.</p>
<p style="margin-left:9%;"><b>TODO: BLOCK</b></p>
<p style="margin-left:14%;">TODO: { <br/>
local $TODO = $why if $condition; <br/>
...normal testing code goes here... <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">Declares a
block of tests you expect to fail and $why. Perhaps it's
because you haven't fixed a bug or haven't finished a new
feature:</p>
<p style="margin-left:14%; margin-top: 1em">TODO: { <br/>
local $TODO = "URI::Geller not finished"; <br/>
my $card = "Eight of clubs"; <br/>
is( URI::Geller−&gt;your_card, $card, 'Is THIS your
card?' ); <br/>
my $spoon; <br/>
URI::Geller−&gt;bend_spoon; <br/>
is( $spoon, 'bent', "Spoon bending, that's
original" ); <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">With a todo
block, the tests inside are expected to fail. Test::More
will run the tests normally, but print out special flags
indicating they are "todo". Test::Harness will
interpret failures as being ok. Should anything succeed, it
will report it as an unexpected success. You then know the
thing you had todo is done and can remove the TODO flag.</p>
<p style="margin-left:14%; margin-top: 1em">The nice part
about todo tests, as opposed to simply commenting out a
block of tests, is that it is like having a programmatic
todo list. You know how much work is left to be done, you're
aware of what bugs there are, and you'll know immediately
when they're fixed.</p>
<p style="margin-left:14%; margin-top: 1em">Once a todo
test starts succeeding, simply move it outside the block.
When the block is empty, delete it.</p>
<p style="margin-left:14%; margin-top: 1em">Note that, if
you leave $TODO unset or undef, Test::More reports failures
as normal. This can be useful to mark the tests as expected
to fail only in certain conditions, e.g.:</p>
<p style="margin-left:14%; margin-top: 1em">TODO: { <br/>
local $TODO = "$ˆO doesn't work yet. :(" if
!_os_is_supported($ˆO); <br/>
... <br/>
}</p>
<p style="margin-left:9%;"><b>todo_skip</b></p>
<p style="margin-left:14%;">TODO: { <br/>
todo_skip $why, $how_many if $condition; <br/>
...normal testing code... <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">With todo
tests, it's best to have the tests actually run. That way
you'll know when they start passing. Sometimes this isn't
possible. Often a failing test will cause the whole program
to die or hang, even inside an "eval BLOCK" with
and using "alarm". In these extreme cases you have
no choice but to skip over the broken tests entirely.</p>
<p style="margin-left:14%; margin-top: 1em">The syntax and
behavior is similar to a "SKIP: BLOCK" except the
tests will be marked as failing but todo. Test::Harness will
interpret them as passing.</p>
<p style="margin-left:9%;">When do I use SKIP vs. TODO?</p>
<p style="margin-left:14%;"><b>If it's something the user
might not be able to do</b>, use SKIP. This includes
optional modules that aren't installed, running under an OS
that doesn't have some feature (like fork() or symlinks), or
maybe you need an Internet connection and one isn't
available.</p>
<p style="margin-left:14%; margin-top: 1em"><b>If it's
something the programmer hasn't done yet</b>, use TODO. This
is for any code you haven't written yet, or bugs you have
yet to fix, but want to put tests in your testing script
(always a good idea).</p>
<h3>Test control
<a name="Test control"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>BAIL_OUT</b></p>
<p style="margin-left:14%;">BAIL_OUT($reason);</p>
<p style="margin-left:14%; margin-top: 1em">Indicates to
the harness that things are going so badly all testing
should terminate. This includes the running of any
additional test scripts.</p>
<p style="margin-left:14%; margin-top: 1em">This is
typically used when testing cannot continue such as a
critical module failing to compile or a necessary external
utility not being available such as a database connection
failing.</p>
<p style="margin-left:14%; margin-top: 1em">The test will
exit with 255.</p>
<p style="margin-left:14%; margin-top: 1em">For even better
control look at Test::Most.</p>
<h3>Discouraged comparison functions
<a name="Discouraged comparison functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The use of the
following functions is discouraged as they are not actually
testing functions and produce no diagnostics to help figure
out what went wrong. They were written before is_deeply()
existed because I couldn't figure out how to display a
useful diff of two arbitrary data structures.</p>
<p style="margin-left:9%; margin-top: 1em">These functions
are usually used inside an ok().</p>
<p style="margin-left:9%; margin-top: 1em">ok(
eq_array(\@got, \@expected) );</p>
<p style="margin-left:9%; margin-top: 1em">is_deeply() can
do that better and with diagnostics.</p>
<p style="margin-left:9%; margin-top: 1em">is_deeply(
\@got, \@expected );</p>
<p style="margin-left:9%; margin-top: 1em">They may be
deprecated in future versions. <b><br/>
eq_array</b></p>
<p style="margin-left:14%;">my $is_eq = eq_array(\@got,
\@expected);</p>
<p style="margin-left:14%; margin-top: 1em">Checks if two
arrays are equivalent. This is a deep check, so
multi−level structures are handled correctly.</p>
<p style="margin-left:9%;"><b>eq_hash</b></p>
<p style="margin-left:14%;">my $is_eq = eq_hash(\%got,
\%expected);</p>
<p style="margin-left:14%; margin-top: 1em">Determines if
the two hashes contain the same keys and values. This is a
deep check.</p>
<p style="margin-left:9%;"><b>eq_set</b></p>
<p style="margin-left:14%;">my $is_eq = eq_set(\@got,
\@expected);</p>
<p style="margin-left:14%; margin-top: 1em">Similar to
eq_array(), except the order of the elements is <b>not</b>
important. This is a deep check, but the irrelevancy of
order only applies to the top level.</p>
<p style="margin-left:14%; margin-top: 1em">ok(
eq_set(\@got, \@expected) );</p>
<p style="margin-left:14%; margin-top: 1em">Is better
written:</p>
<p style="margin-left:14%; margin-top: 1em">is_deeply(
[sort @got], [sort @expected] );</p>
<p style="margin-left:14%; margin-top: 1em"><b>NOTE</b> By
historical accident, this is not a true set comparison.
While the order of elements does not matter, duplicate
elements do.</p>
<p style="margin-left:14%; margin-top: 1em"><b>NOTE</b>
eq_set() does not know how to deal with references at the
top level. The following is an example of a comparison which
might not work:</p>
<p style="margin-left:14%; margin-top: 1em">eq_set([\1,
\2], [\2, \1]);</p>
<p style="margin-left:14%; margin-top: 1em">Test::Deep
contains much better set comparison functions.</p>
<h3>Extending and Embedding Test::More
<a name="Extending and Embedding Test::More"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Sometimes the
Test::More interface isn't quite enough. Fortunately,
Test::More is built on top of Test::Builder which provides a
single, unified backend for any test library to use. This
means two test libraries which both use Test::Builder
<b>can</b> be used together in the same program.</p>
<p style="margin-left:9%; margin-top: 1em">If you simply
want to do a little tweaking of how the tests behave, you
can access the underlying Test::Builder object like so:
<b><br/>
builder</b></p>
<p style="margin-left:14%;">my $test_builder =
Test::More−&gt;builder;</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
Test::Builder object underlying Test::More for you to play
with.</p>
<h2>EXIT CODES
<a name="EXIT CODES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">If all your
tests passed, Test::Builder will exit with zero (which is
normal). If anything failed it will exit with how many
failed. If you run less (or more) tests than you planned,
the missing (or extras) will be considered failures. If no
tests were ever run Test::Builder will throw a warning and
exit with 255. If the test died, even after having
successfully completed all its tests, it will still be
considered a failure and will exit with 255.</p>
<p style="margin-left:9%; margin-top: 1em">So the exit
codes are...</p>
<p style="margin-left:9%; margin-top: 1em">0 all tests
successful <br/>
255 test died or all passed but wrong # of tests run <br/>
any other number how many failed (including missing or
extras)</p>
<p style="margin-left:9%; margin-top: 1em">If you fail more
than 254 tests, it will be reported as 254.</p>
<p style="margin-left:9%; margin-top: 1em"><b>NOTE</b> This
behavior may go away in future versions.</p>
<h2>COMPATIBILITY
<a name="COMPATIBILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Test::More works
with Perls as old as 5.8.1.</p>
<p style="margin-left:9%; margin-top: 1em">Thread support
is not very reliable before 5.10.1, but that's because
threads are not very reliable before 5.10.1.</p>
<p style="margin-left:9%; margin-top: 1em">Although
Test::More has been a core module in versions of Perl since
5.6.2, Test::More has evolved since then, and not all of the
features you're used to will be present in the shipped
version of Test::More. If you are writing a module, don't
forget to indicate in your package metadata the minimum
version of Test::More that you require. For instance, if you
want to use done_testing() but want your test script to run
on Perl 5.10.0, you will need to explicitly require
Test::More &gt; 0.88.</p>
<p style="margin-left:9%; margin-top: 1em">Key feature
milestones include: <br/>
subtests</p>
<p style="margin-left:14%;">Subtests were released in
Test::More 0.94, which came with Perl 5.12.0. Subtests did
not implicitly call done_testing() until 0.96; the first
Perl with that fix was Perl 5.14.0 with 0.98.</p>
<p style="margin-left:9%;">done_testing()</p>
<p style="margin-left:14%;">This was released in Test::More
0.88 and first shipped with Perl in 5.10.1 as part of
Test::More 0.92.</p>
<p style="margin-left:9%;">cmp_ok()</p>
<p style="margin-left:14%;">Although cmp_ok() was
introduced in 0.40, 0.86 fixed an important bug to make it
safe for overloaded objects; the fixed first shipped with
Perl in 5.10.1 as part of Test::More 0.92.</p>
<p style="margin-left:9%;">new_ok() note() and
explain()</p>
<p style="margin-left:14%;">These were was released in
Test::More 0.82, and first shipped with Perl in 5.10.1 as
part of Test::More 0.92.</p>
<p style="margin-left:9%; margin-top: 1em">There is a full
version history in the Changes file, and the Test::More
versions included as core can be found using
Module::CoreList:</p>
<p style="margin-left:9%; margin-top: 1em">$ corelist
−a Test::More</p>
<h2>CAVEATS and NOTES
<a name="CAVEATS and NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">utf8 /
"Wide character in print"</p>
<p style="margin-left:14%;">If you use utf8 or other
non−ASCII characters with Test::More you might get a
"Wide character in print" warning. Using
"binmode STDOUT, ":utf8"" will not fix
it. Test::Builder (which powers Test::More) duplicates
STDOUT and STDERR. So any changes to them, including
changing their output disciplines, will not be seen by
Test::More.</p>
<p style="margin-left:14%; margin-top: 1em">One work around
is to apply encodings to STDOUT and STDERR as early as
possible and before Test::More (or any other Test module)
loads.</p>
<p style="margin-left:14%; margin-top: 1em">use open
':std', ':encoding(utf8)'; <br/>
use Test::More;</p>
<p style="margin-left:14%; margin-top: 1em">A more direct
work around is to change the filehandles used by
Test::Builder.</p>
<p style="margin-left:14%; margin-top: 1em">my $builder =
Test::More−&gt;builder; <br/>
binmode $builder−&gt;output,
":encoding(utf8)"; <br/>
binmode $builder−&gt;failure_output,
":encoding(utf8)"; <br/>
binmode $builder−&gt;todo_output,
":encoding(utf8)";</p>
<p style="margin-left:9%;">Overloaded objects</p>
<p style="margin-left:14%;">String overloaded objects are
compared <b>as strings</b> (or in cmp_ok()'s case, strings
or numbers as appropriate to the comparison op). This
prevents Test::More from piercing an object's interface
allowing better blackbox testing. So if a function starts
returning overloaded objects instead of bare strings your
tests won't notice the difference. This is good.</p>
<p style="margin-left:14%; margin-top: 1em">However, it
does mean that functions like is_deeply() cannot be used to
test the internals of string overloaded objects. In this
case I would suggest Test::Deep which contains more flexible
testing functions for complex data structures.</p>
<p style="margin-left:9%;">Threads</p>
<p style="margin-left:14%;">Test::More will only be aware
of threads if "use threads" has been done
<i>before</i> Test::More is loaded. This is ok:</p>
<p style="margin-left:14%; margin-top: 1em">use threads;
<br/>
use Test::More;</p>
<p style="margin-left:14%; margin-top: 1em">This may cause
problems:</p>
<p style="margin-left:14%; margin-top: 1em">use Test::More
<br/>
use threads;</p>
<p style="margin-left:14%; margin-top: 1em">5.8.1 and above
are supported. Anything below that has too many bugs.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This is a case
of convergent evolution with Joshua Pritikin's Test module.
I was largely unaware of its existence when I'd first
written my own ok() routines. This module exists because I
can't figure out how to easily wedge test names into Test's
interface (along with a few other problems).</p>
<p style="margin-left:9%; margin-top: 1em">The goal here is
to have a testing utility that's simple to learn, quick to
use and difficult to trip yourself up with while still
providing more flexibility than the existing Test.pm. As
such, the names of the most common routines are kept tiny,
special cases and magic side−effects are kept to a
minimum. WYSIWYG.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<h3>ALTERNATIVES
<a name="ALTERNATIVES"></a>
</h3>
<p style="margin-left:4%; margin-top: 1em">Test2::Suite is
the most recent and modern set of tools for testing.</p>
<p style="margin-left:9%; margin-top: 1em">Test::Simple if
all this confuses you and you just want to write some tests.
You can upgrade to Test::More later (it's forward
compatible).</p>
<p style="margin-left:9%; margin-top: 1em">Test::Legacy
tests written with Test.pm, the original testing module, do
not play well with other testing libraries. Test::Legacy
emulates the Test.pm interface and does play well with
others.</p>
<h3>ADDITIONAL LIBRARIES
<a name="ADDITIONAL LIBRARIES"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Test::Differences
for more ways to test complex data structures. And it plays
well with Test::More.</p>
<p style="margin-left:9%; margin-top: 1em">Test::Class is
like xUnit but more perlish.</p>
<p style="margin-left:9%; margin-top: 1em">Test::Deep gives
you more powerful complex data structure testing.</p>
<p style="margin-left:9%; margin-top: 1em">Test::Inline
shows the idea of embedded testing.</p>
<p style="margin-left:9%; margin-top: 1em">Mock::Quick The
ultimate mocking library. Easily spawn objects defined on
the fly. Can also override, block, or reimplement packages
as needed.</p>
<p style="margin-left:9%; margin-top: 1em">Test::FixtureBuilder
Quickly define fixture data for unit tests.</p>
<h3>OTHER COMPONENTS
<a name="OTHER COMPONENTS"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Test::Harness is
the test runner and output interpreter for Perl. It's the
thing that powers "make test" and where the
"prove" utility comes from.</p>
<h3>BUNDLES
<a name="BUNDLES"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Test::Most Most
commonly needed test functions and features.</p>
<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Michael G
Schwern &lt;schwern@pobox.com&gt; with much inspiration from
Joshua Pritikin's Test module and lots of help from Barrie
Slaymaker, Tony Bowden, blackstar.co.uk, chromatic, Fergal
Daly and the perl−qa gang.</p>
<h2>MAINTAINERS
<a name="MAINTAINERS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Chad Granum
&lt;exodist@cpan.org&gt;</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See
&lt;https://github.com/Test−More/test−more/issues&gt;
to report and view bugs.</p>
<h2>SOURCE
<a name="SOURCE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The source code
repository for Test::More can be found at
&lt;https://github.com/Test−More/test−more/&gt;.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2001−2008 by Michael G Schwern
&lt;schwern@pobox.com&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<p style="margin-left:9%; margin-top: 1em">See
&lt;https://dev.perl.org/licenses/&gt;</p>
<hr/>
</body>
</html>
