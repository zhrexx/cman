<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:46:36 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>curs_inopts</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">curs_inopts</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#cbreak, nocbreak">cbreak, nocbreak</a><br/>
<a href="#echo, noecho">echo, noecho</a><br/>
<a href="#halfdelay">halfdelay</a><br/>
<a href="#intrflush">intrflush</a><br/>
<a href="#keypad">keypad</a><br/>
<a href="#meta">meta</a><br/>
<a href="#nl, nonl">nl, nonl</a><br/>
<a href="#nodelay">nodelay</a><br/>
<a href="#notimeout">notimeout</a><br/>
<a href="#qiflush, noqiflush">qiflush, noqiflush</a><br/>
<a href="#raw, noraw">raw, noraw</a><br/>
<a href="#timeout, wtimeout">timeout, wtimeout</a><br/>
<a href="#typeahead">typeahead</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#EXTENSIONS">EXTENSIONS</a><br/>
<a href="#PORTABILITY">PORTABILITY</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>cbreak</b>,
<b>echo</b>, <b>halfdelay</b>, <b>intrflush</b>,
<b>is_cbreak</b>, <b>is_echo</b>, <b>is_nl</b>,
<b>is_raw</b>, <b>keypad</b>, <b>meta</b>, <b>nl</b>,
<b>nocbreak</b>, <b>nodelay</b>, <b>noecho</b>, <b>nonl</b>,
<b>noqiflush</b>, <b>noraw</b>, <b>notimeout</b>,
<b>qiflush</b>, <b>raw</b>, <b>timeout</b>, <b>wtimeout</b>,
<b>typeahead</b> − get and set <i>curses</i> terminal
input options</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;curses.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
cbreak(void); <br/>
int nocbreak(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
echo(void); <br/>
int noecho(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
intrflush(WINDOW *</b> <i>win /* ignored */</i><b>, bool</b>
<i>bf</i><b>); <br/>
int keypad(WINDOW *</b> <i>win</i><b>, bool</b>
<i>bf</i><b>); <br/>
int meta(WINDOW *</b> <i>win /* ignored */</i><b>, bool</b>
<i>bf</i><b>); <br/>
int nodelay(WINDOW *</b> <i>win</i><b>, bool</b>
<i>bf</i><b>); <br/>
int notimeout(WINDOW *</b> <i>win</i><b>, bool</b>
<i>bf</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int nl(void);
<br/>
int nonl(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
qiflush(void); <br/>
void noqiflush(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
raw(void); <br/>
int noraw(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
halfdelay(int</b> <i>tenths</i><b>); <br/>
void timeout(int</b> <i>delay</i><b>); <br/>
void wtimeout(WINDOW *</b> <i>win</i><b>, int</b>
<i>delay</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
typeahead(int</b> <i>fd</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><i>/* extensions
*/</i> <b><br/>
int is_cbreak(void); <br/>
int is_echo(void); <br/>
int is_nl(void); <br/>
int is_raw(void);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b><i>curses</i></b>
offers configurable parameters permitting an application to
control the handling of input from the terminal. Some are
global, applying to all windows; others apply only to a
specific window. The library does not automatically apply
such parameters to new or derived windows; an application
must configure each window for the desired behavior.</p>
<p style="margin-left:9%; margin-top: 1em">Some
descriptions below make reference to an <i>input character
reading function</i>: this is <b>wgetch</b>(3X) in the
non-wide character <i>curses</i> API and <b>wget_wch</b>(3X)
in the wide character API. In addition to the variant forms
of these described in <b>ncurses</b>(3X), the <i>curses</i>
functions <b>wgetstr</b>(3X) and <b>wget_wstr</b>(3X) and
their own variants call the appropriate input character
reading function.</p>
<h3>cbreak, nocbreak
<a name="cbreak, nocbreak"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Normally, the
terminal driver buffers typed characters, not delivering
them to an application until a line feed or carriage return
is typed. <b>cbreak</b> configures the terminal in <i>cbreak
mode</i>, which disables line buffering and erase and kill
character processing (the interrupt, quit, suspend, and flow
control characters are unaffected) and makes characters
typed by the user immediately available to the program.
<b>nocbreak</b> returns the terminal to normal
(“cooked”) mode.</p>
<p style="margin-left:9%; margin-top: 1em">The state of the
terminal is unknown to a <i>curses</i> application when it
starts; therefore, a program should call <b>cbreak</b> or
<b>nocbreak</b> explicitly. Most interactive programs using
<i>curses</i> set cbreak mode. Calling <b>cbreak</b>
overrides <b>raw</b>. The man page for the input character
reading function discusses how <b>cbreak</b> and
<b>nocbreak</b> interact with <b>echo</b> and
<b>noecho</b>.</p>
<h3>echo, noecho
<a name="echo, noecho"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>echo</b> and
<b>noecho</b> determine whether characters typed by the user
are written to the <i>curses</i> window by the input
character reading function as they are typed. <i>curses</i>
always disables the terminal driver’s own echoing. By
default, a <i>curses</i> screen’s echo option is set.
Authors of most interactive programs prefer to do their own
echoing in a controlled area of the screen, or not to echo
at all, so they call <b>noecho</b>. The man page for the
input character reading function discusses how <b>echo</b>
and <b>noecho</b> interact with <b>cbreak</b> and
<b>nocbreak</b>.</p>
<h3>halfdelay
<a name="halfdelay"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>halfdelay</b>
configures <i>half-delay mode</i>, which is similar to
cbreak mode in that characters typed by the user are
immediately available to the program. However, after
blocking for <i>tenths</i> tenths of seconds, an input
character reading function returns <b>ERR</b> if no input is
pending. The value of <i>tenths</i> must be between 1 and
255. Use <b>nocbreak</b> to leave half-delay mode.</p>
<h3>intrflush
<a name="intrflush"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>intrflush</b>
calls <b>qiflush</b> (see below) if <i>bf</i> is
<b>TRUE</b>, and <b>noqiflush</b> if <i>bf</i> is
<b>FALSE</b>. It ignores its <i>win</i> argument.</p>
<h3>keypad
<a name="keypad"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keypad</b>
enables recognition of a terminal’s function keys. If
enabled (<i>bf</i> is <b>TRUE</b>), the input character
reading function returns a value representing the function
key, such as <b>KEY_LEFT</b>. (Wide-character API users:
<b>wget_wch</b>(3X) returns <b>KEY_CODE_YES</b> to indicate
the availability of a function key code in its <i>wch</i>
parameter.) If disabled (<i>bf</i> is <b>FALSE</b>),
<i>curses</i> does not treat function keys specially and the
program has to interpret escape sequences itself. If the
terminal’s keypad can be turned on (made to transmit)
and off (made to work locally), <b>keypad</b> configures it
consistently with the <i>bf</i> parameter. By default, a
window’s keypad mode is off.</p>
<h3>meta
<a name="meta"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Initially,
whether the terminal returns 7- or 8-bit character codes on
input depends on the configuration of the terminal driver;
see <i>termios</i>(3). To force 8 bits to be returned, call
<b>meta(</b>...<b>, TRUE)</b>; this is equivalent, on POSIX
systems, to setting the CS8 flag on the terminal. To force 7
bits to be returned, call <b>meta(</b>...<b>, FALSE)</b>;
this is equivalent, on POSIX systems, to setting the CS7
flag on the terminal. The window argument, <i>win</i>, is
always ignored. If the <i>term- info</i> string capabilities
<b>meta_on</b> (<b>smm</b>) and <b>meta_off</b> (<b>rmm</b>)
are defined for the terminal type, enabling meta mode sends
<b>smm</b> to the terminal and disabling it sends <b>rmm</b>
to the terminal.</p>
<h3>nl, nonl
<a name="nl, nonl"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Initially,
whether the terminal reports a carriage return using the
character code for a line feed in cbreak or raw modes
depends on the configuration of the terminal driver; see
<i>termios</i>(3). <b>nl</b> configures the terminal to
perform this translation. <b>nonl</b> disables it. In normal
(or “cooked”) mode, the terminal driver always
translates carriage returns to line feeds.</p>
<h3>nodelay
<a name="nodelay"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>nodelay</b>
configures the input character reading function to be
non-blocking for window <i>win</i>. If no input is ready,
the reading function returns <b>ERR</b>. If disabled
(<i>bf</i> is <b>FALSE</b>), the reading function does not
return until it has input.</p>
<h3>notimeout
<a name="notimeout"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When the input
character reading function reads an ESC character, it sets a
timer while waiting for the next character.
<b>notimeout(</b><i>win</i><b>, TRUE)</b> disables this
timer. The purpose of the timeout is to distinguish
sequences produced by a function key from those typed by a
user. To configure the timeout rather than disabling it, see
<b>wtimeout</b> below.</p>
<h3>qiflush, noqiflush
<a name="qiflush, noqiflush"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>qiflush</b>
and <b>noqiflush</b> configure the terminal driver’s
treatment of its input and output queues when it handles the
interrupt, suspend, or quit characters in <i>cbreak</i> and
“cooked” modes; on POSIX systems, see
<i>termios</i>(3). The default behavior is inherited from
the terminal driver settings. Calling <b>qiflush</b>
configures the terminal to flush the queues when any of
these events occurs, giving the impression of faster
response to user input, but making the library’s model
of the screen contents incorrect. Calling <b>noqiflush</b>
prevents such flushing, but might frustrate impatient users
on slow connections if a <i>curses</i> update of the screen
is in progress when the event occurs; see <b>typeahead</b>
below for a mitigation of this problem. You may want to call
<b>noqiflush</b> in a signal handler if you want output to
continue after the handler exits as though the interrupt had
not occurred.</p>
<h3>raw, noraw
<a name="raw, noraw"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>raw</b>
configures the terminal to read input in <i>raw mode</i>,
which is similar to cbreak mode (see <b>cbreak</b> above)
except that it furthermore passes through the
terminal’s configured interrupt, quit, suspend, and
flow control characters uninterpreted to the application,
instead of generating a signal or acting on I/O flow. The
behavior of the terminal’s “Break” key (if
any) depends on terminal driver configuration parameters
that <i>curses</i> does not handle. <b>noraw</b> returns the
terminal to normal (“cooked”) mode.</p>
<h3>timeout, wtimeout
<a name="timeout, wtimeout"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>wtimeout</b>
configures whether a <i>curses</i> input character reading
function called on window <i>win</i> uses blocking or
non-blocking reads. If <i>delay</i> is negative, a blocking
read is used, waiting indefinitely for input. If
<i>delay</i> is zero, a non-blocking read is used; an input
character reading function returns <b>ERR</b> if no input is
pending. If <i>delay</i> is positive, an input character
reading function blocks for <i>delay</i> milliseconds, and
returns <b>ERR</b> if the delay elapses and there is still
no input pending. <b>timeout</b> calls <b>wtimeout</b> on
<b>stdscr</b>.</p>
<h3>typeahead
<a name="typeahead"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Normally, a
<i>curses</i> library checks the terminal for input while
updating the screen. If any is found, the update is
postponed until the next <b>wrefresh</b>(3X) or
<b>doupdate</b>(3X) call, allowing faster response to user
key strokes. The library tests the file descriptor
corresponding to the <i>FILE</i> stream pointer passed to
<b>newterm</b>(3X) (or <i>stdin</i> if <b>initscr</b>(3X)
was called), for pending input. <b>typeahead</b> instructs
<i>curses</i> to test file descriptor <i>fd</i> instead. An
<i>fd</i> of <b>−1</b> disables the check.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>timeout</b>
and <b>wtimeout</b> return no value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cbreak</b>,
<b>nocbreak</b>, <b>echo</b>, <b>noecho</b>,
<b>halfdelay</b>, <b>intrflush</b>, <b>keypad</b>,
<b>meta</b>, <b>nodelay</b>, <b>notimeout</b>, <b>nl</b>,
<b>nonl</b>, <b>raw</b>, <b>noraw</b>, and <b>typeahead</b>
return <b>OK</b> on success and <b>ERR</b> on failure.</p>
<p style="margin-left:9%; margin-top: 1em">In
<i>ncurses</i>, the functions in the previous paragraph
return <b>ERR</b> if</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the terminal is not initialized or</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p><i>win</i> is <b>NULL</b> (except for <b>intrflush</b>
and <b>meta</b>, which ignore its value).</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Further,
<b>halfdelay</b> returns <b>ERR</b> if <i>delay</i> is
outside the range 1..255.</p>
<p style="margin-left:9%; margin-top: 1em">See section
“EXTENSIONS” below for the return values of
<b>is_cbreak</b>, <b>is_echo</b>, <b>is_nl</b>, and
<b>is_raw</b>.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>echo</b>,
<b>noecho</b>, <b>halfdelay</b>, <b>intrflush</b>,
<b>meta</b>, <b>nl</b>, <b>nonl</b>, <b>nodelay</b>,
<b>notimeout</b>, <b>noqiflush</b>, <b>qiflush</b>,
<b>timeout</b>, and <b>wtimeout</b> may be implemented as
macros.</p>
<p style="margin-left:9%; margin-top: 1em"><b>noraw</b> and
<b>nocbreak</b> follow historical practice in that they
attempt to restore normal (“cooked”) mode from
raw and cbreak modes, respectively. Mixing
<b>raw</b>/<b>noraw</b> calls with
<b>cbreak</b>/<b>nocbreak</b> calls leads to terminal driver
control states that are hard to predict or understand; doing
so is not recommended.</p>
<h2>EXTENSIONS
<a name="EXTENSIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><i>ncurses</i>
provides four “is_” functions corresponding to
<b>cbreak</b>, <b>echo</b>, <b>nl</b>, and <b>raw</b>,
permitting their states to be queried by the
application.</p>
<p style="margin-left:9%; margin-top: 1em">In each case,
the function returns</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em"><b>1</b></p></td>
<td width="3%"></td>
<td width="44%">
<p style="margin-top: 1em">if the option is set,</p></td>
<td width="41%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>0</b></p></td>
<td width="3%"></td>
<td width="44%">
<p>if the option is reset, or</p></td>
<td width="41%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>−1</b></p></td>
<td width="3%"></td>
<td width="44%">
<p>if the library is not initialized.</p></td>
<td width="41%">
</td></tr>
</table>
<h2>PORTABILITY
<a name="PORTABILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Applications
employing <i>ncurses</i> extensions should condition their
use on the visibility of the <b>NCURSES_VERSION</b>
preprocessor macro.</p>
<p style="margin-left:9%; margin-top: 1em">Except as noted
in section “EXTENSIONS” above, X/Open Curses,
Issue 4 describes these functions. It specifies no error
conditions for them.</p>
<p style="margin-left:9%; margin-top: 1em">SVr4
<i>curses</i> describes a successful return value only as
“an integer value other than <b>ERR</b>”.</p>
<p style="margin-left:9%; margin-top: 1em"><i>ncurses</i>
follows X/Open Curses and the historical practice of
System V <i>curses</i>, clearing the terminal
driver’s “echo” flag when initializing the
screen. BSD <i>curses</i> did not, but its <i>raw</i>
function turned it off as a side effect. For best
portability, call <b>echo</b> or <b>noecho</b> explicitly
just after initialization, even if your program remains in
normal (“cooked”) mode.</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses is
ambiguous regarding whether <i>raw</i> should disable the
carriage return and line feed translation feature controlled
by <i>nl</i> and <i>nonl</i>. BSD <i>curses</i> did turn off
these translations; System V <i>curses</i> did not.
<i>ncurses</i> does so, on the assumption that a programmer
requesting raw input wants a clean (ideally, 8-bit clean)
connection that the operating system will not alter.</p>
<p style="margin-left:9%; margin-top: 1em">When
<b>keypad</b> is first enabled, <i>ncurses</i> loads the key
definitions for the current terminal description. If the
terminal description includes extended string capabilities,
for example, by using the <b>−x</b> option of
<b>tic</b>(1), then <i>ncurses</i> also defines keys for the
capabilities whose names begin with “k”.
Corresponding key codes are generated and (depending on
previous loads of terminal descriptions) may differ from one
execution of a program to the next. The generated key codes
are recognized by <b>keyname</b>(3X), which then returns a
name beginning with “k” denoting the
<i>terminfo</i> capability name rather than “K”,
used for <i>curses</i> key names. On the other hand, an
application can use <b>define_key</b>(3X) to bind a specific
key to a string of the programmer’s choice. This
feature enables an application to check for its presence
with <b>tigetstr</b>(3X), and reassign the key code to match
its own needs.</p>
<p style="margin-left:9%; margin-top: 1em">Low-level
applications can use <b>tigetstr</b>(3X) to obtain the
definition of any string capability. <i>curses</i>
applications use the input character reading function to
obtain key codes from input and rely upon the order in which
the string capabilities are loaded. Multiple key capability
strings can have the same value, but the input character
reading function can report only one key code. Most
<i>curses</i> implementations (including <i>ncurses</i>)
load key definitions in the order they appear in the
<b>strfnames</b> array of string capability names; see
<b>term_variables</b>(3X). The last capability read using a
particular definition determines the key code to be
reported. In <i>ncurses</i>, extended capabilities can be
interpreted as key definitions. These are loaded after the
predefined keys, and if a capability’s value is the
same as a previously loaded key definition, the later
definition is the one used.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">4BSD
<i>curses</i> (1980) introduced <i>echo</i>, <i>noecho</i>,
<i>nl</i>, <i>nonl</i>, <i>raw</i>, and <i>noraw</i>.</p>
<p style="margin-left:9%; margin-top: 1em">SVr2 (1984)
featured a new terminal driver, extending the <i>curses</i>
API to support it with <i>cbreak</i>, <i>nocbreak</i>,
<i>intrflush</i>, <i>keypad</i>, <i>meta</i>,
<i>nodelay</i>, and <i>typeahead</i>.</p>
<p style="margin-left:9%; margin-top: 1em">SVr3 (1987)
added <i>halfdelay</i>, <i>notimeout</i>, and
<i>wtimeout</i>. <i>qiflush</i> and <i>noqiflush</i>
appeared in SVr3.1 (1987), at which point <i>intrflush</i>
became a wrapper for either of these functions, depending on
the value of its Boolean argument. SVr3.1 also added
<i>timeout</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><i>ncurses</i>
6.5 (2024) introduced <i>is_cbreak</i>, <i>is_echo</i>,
<i>is_nl</i>, and <i>is_raw</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Formerly,
<i>ncurses</i> used <i>nl</i> and <i>nonl</i> to control the
conversion of newlines to carriage return/line feed on
output as well as input. X/Open Curses documents the use of
these functions only for input. This difference arose from
converting the <i>pcurses</i> source (1986), which used
<i>ioctl</i>(2) calls and the <i>sgttyb</i> structure, to
<i>termios</i> (the POSIX terminal API). In the former, both
input and output were controlled via a single option
“CRMOD”, while the latter separates these
features. Because that conversion interferes with output
optimization, <i>ncurses</i> 6.2 (2020) amended <i>nl</i>
and <i>nonl</i> to eliminate their effect on output.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>curses</b>(3X),
<b>curs_getch</b>(3X), <b>curs_initscr</b>(3X),
<b>curs_util</b>(3X), <b>define_key</b>(3X),
<b>termios</b>(3), <b>term_variables</b>(3X)</p>
<hr/>
</body>
</html>
