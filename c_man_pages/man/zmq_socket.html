<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:55:15 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>ZMQ_SOCKET</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">ZMQ_SOCKET</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Client−server pattern">Client−server pattern</a><br/>
<a href="#Radio−dish pattern">Radio−dish pattern</a><br/>
<a href="#Publish−subscribe pattern">Publish−subscribe pattern</a><br/>
<a href="#Pipeline pattern">Pipeline pattern</a><br/>
<a href="#Peer−to−peer pattern">Peer−to−peer pattern</a><br/>
<a href="#Request−reply pattern">Request−reply pattern</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#EXAMPLE">EXAMPLE</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHORS">AUTHORS</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">zmq_socket
− create 0MQ socket</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>void
*zmq_socket (void</b> <i>*context</i><b>, int</b>
<i>type</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<i>zmq_socket()</i> function shall create a 0MQ socket
within the specified <i>context</i> and return an opaque
handle to the newly created socket. The <i>type</i> argument
specifies the socket type, which determines the semantics of
communication over the socket.</p>
<p style="margin-left:9%; margin-top: 1em">The newly
created socket is initially unbound, and not associated with
any endpoints. In order to establish a message flow a socket
must first be connected to at least one endpoint with
<b>zmq_connect</b>(3), or at least one endpoint must be
created for accepting incoming connections with
<b>zmq_bind</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em"><b>Key
differences to conventional sockets</b>. Generally speaking,
conventional sockets present a <i>synchronous</i> interface
to either connection−oriented reliable byte streams
(SOCK_STREAM), or connection−less unreliable datagrams
(SOCK_DGRAM). In comparison, 0MQ sockets present an
abstraction of an asynchronous <i>message queue</i>, with
the exact queueing semantics depending on the socket type in
use. Where conventional sockets transfer streams of bytes or
discrete datagrams, 0MQ sockets transfer discrete
<i>messages</i>.</p>
<p style="margin-left:9%; margin-top: 1em">0MQ sockets
being <i>asynchronous</i> means that the timings of the
physical connection setup and tear down, reconnect and
effective delivery are transparent to the user and organized
by 0MQ itself. Further, messages may be <i>queued</i> in the
event that a peer is unavailable to receive them.</p>
<p style="margin-left:9%; margin-top: 1em">Conventional
sockets allow only strict one−to−one (two
peers), many−to−one (many clients, one server),
or in some cases one−to−many (multicast)
relationships. With the exception of <i>ZMQ_PAIR</i> and
<i>ZMQ_CHANNEL</i>, 0MQ sockets may be connected <b>to
multiple endpoints</b> using <i>zmq_connect()</i>, while
simultaneously accepting incoming connections <b>from
multiple endpoints</b> bound to the socket using
<i>zmq_bind()</i>, thus allowing many−to−many
relationships.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Thread
safety</b>. 0MQ has both thread safe socket type and
<i>not</i> thread safe socket types. Applications MUST NOT
use a <i>not</i> thread safe socket from multiple threads
under any circumstances. Doing so results in undefined
behaviour.</p>
<p style="margin-left:9%; margin-top: 1em">Following are
the thread safe sockets: * ZMQ_CLIENT * ZMQ_SERVER *
ZMQ_DISH * ZMQ_RADIO * ZMQ_SCATTER * ZMQ_GATHER * ZMQ_PEER *
ZMQ_CHANNEL</p>
<p style="margin-left:9%; margin-top: 1em"><b>Socket
types</b>. The following sections present the socket types
defined by 0MQ, grouped by the general <i>messaging
pattern</i> which is built from related socket types.</p>
<h3>Client−server pattern
<a name="Client−server pattern"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
client−server pattern is used to allow a single
<i>ZMQ_SERVER server</i> talk to one or more <i>ZMQ_CLIENT
clients</i>. The client always starts the conversation,
after which either peer can send messages asynchronously, to
the other.</p>
<p style="margin-left:9%; margin-top: 1em">The
client−server pattern is formally defined by
<b><font color="#0000FF">http://rfc.zeromq.org/spec:41</font></b><font color="#000000">.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Server−client
is still in draft phase.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_CLIENT</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
<i>ZMQ_CLIENT</i> socket talks to a <i>ZMQ_SERVER</i>
socket. Either peer can connect, though the usual and
recommended model is to bind the <i>ZMQ_SERVER</i> and
connect the <i>ZMQ_CLIENT</i>.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>If
the <i>ZMQ_CLIENT</i> socket has established a connection,
<b>zmq_send</b>(3) will accept messages, queue them, and
send them as rapidly as the network allows. The outgoing
buffer limit is defined by the high water mark for the
socket. If the outgoing buffer is full, or, for
connection−oriented transports, if the ZMQ_IMMEDIATE
option is set and there is no connected peer,
<b>zmq_send</b>(3) will block. The <i>ZMQ_CLIENT</i> socket
will not drop messages.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_CLIENT</i> socket is connected to multiple
<i>ZMQ_SERVER</i> sockets, outgoing messages are distributed
between connected peers on a round−robin basis.
Likewise, the <i>ZMQ_CLIENT</i> socket receives messages
fairly from each connected peer. This usage is sensible only
for stateless protocols.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_CLIENT</i>
sockets are threadsafe and can be used from multiple threads
at the same time. Note that replies from a <i>ZMQ_SERVER</i>
socket will go to the first client thread that calls
<b>zmq_msg_recv</b>(3). If you need to get replies back to
the originating thread, use one <i>ZMQ_CLIENT</i> socket per
thread.</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_CLIENT</i>
sockets are threadsafe. They do not accept the ZMQ_SNDMORE
option on sends not ZMQ_RCVMORE on receives. This limits
them to single part data. The intention is to extend the API
to allow scatter/gather of multi−part
data.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 1. Summary
of ZMQ_CLIENT characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_SERVER</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
<i>ZMQ_SERVER</i> socket talks to a set of <i>ZMQ_CLIENT</i>
sockets. A <i>ZMQ_SERVER</i> socket can only reply to an
incoming message: the <i>ZMQ_CLIENT</i> peer must always
initiate a conversation.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>Each
received message has a <i>routing_id</i> that is a
32−bit unsigned integer. The application can fetch
this with <b>zmq_msg_routing_id</b>(3). To send a message to
a given <i>ZMQ_CLIENT</i> peer the application must set the
peer’s <i>routing_id</i> on the message, using
<b>zmq_msg_set_routing_id</b>(3).</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>If
the <i>routing_id</i> is not specified, or does not refer to
a connected client peer, the send call will fail with
EHOSTUNREACH. If the outgoing buffer for the client peer is
full, the send call shall block, unless ZMQ_DONTWAIT is used
in the send, in which case it shall fail with EAGAIN. The
<i>ZMQ_SERVER</i> socket shall not drop messages in any
case.</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_SERVER</i>
sockets are threadsafe. They do not accept the ZMQ_SNDMORE
option on sends not ZMQ_RCVMORE on receives. This limits
them to single part data. The intention is to extend the API
to allow scatter/gather of multi−part
data.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 2. Summary
of ZMQ_SERVER characteristics</b></big></font></p>
<h3>Radio−dish pattern
<a name="Radio−dish pattern"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
radio−dish pattern is used for one−to−many
distribution of data from a single <i>publisher</i> to
multiple <i>subscribers</i> in a fan out fashion.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Radio−dish
is using groups (vs Pub−sub topics), Dish sockets can
join a group and each message sent by Radio sockets belong
to a group.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Groups
are null terminated strings limited to 16 chars length
(including null). The intention is to increase the length to
40 chars (including null). The encoding of groups shall be
UTF8.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Groups
are matched using exact matching (vs prefix matching of
PubSub).</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Radio−dish
is still in draft phase.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_RADIO</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_RADIO</i> is used by a
<i>publisher</i> to distribute data. Each message belong to
a group, a group is specified with
<b>zmq_msg_set_group</b>(3). Messages are distributed to all
members of a group. The <b>zmq_recv</b>(3) function is not
implemented for this socket type.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_RADIO</i> socket enters the <i>mute</i> state due
to having reached the high water mark for a
<i>subscriber</i>, then any messages that would be sent to
the <i>subscriber</i> in question shall instead be dropped
until the mute state ends. The <i>zmq_send()</i> function
shall never block for this socket type.</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_RADIO</i>
sockets are threadsafe. They do not accept the ZMQ_SNDMORE
option on sends. This limits them to single part
data.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 3. Summary
of ZMQ_RADIO characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_DISH</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_DISH</i> is used by a
<i>subscriber</i> to subscribe to groups distributed by a
<i>radio</i>. Initially a <i>ZMQ_DISH</i> socket is not
subscribed to any groups, use <b>zmq_join</b>(3) to join a
group. To get the group the message belong to call
<b>zmq_msg_group</b>(3). The <i>zmq_send()</i> function is
not implemented for this socket type.</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_DISH</i>
sockets are threadsafe. They do not accept ZMQ_RCVMORE on
receives. This limits them to single part
data.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 4. Summary
of ZMQ_DISH characteristics</b></big></font></p>
<h3>Publish−subscribe pattern
<a name="Publish−subscribe pattern"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
publish−subscribe pattern is used for
one−to−many distribution of data from a single
<i>publisher</i> to multiple <i>subscribers</i> in a fan out
fashion.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
publish−subscribe pattern is formally defined
by</font>
<b><font color="#0000FF">http://rfc.zeromq.org/spec:29</font></b><font color="#000000">.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_PUB</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_PUB</i> is used by a <i>publisher</i>
to distribute data. Messages sent are distributed in a fan
out fashion to all connected peers. The <b>zmq_recv</b>(3)
function is not implemented for this socket
type.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_PUB</i> socket enters the <i>mute</i> state due to
having reached the high water mark for a <i>subscriber</i>,
then any messages that would be sent to the
<i>subscriber</i> in question shall instead be dropped until
the mute state ends. The <i>zmq_send()</i> function shall
never block for this socket type.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 5. Summary
of ZMQ_PUB characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_SUB</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_SUB</i> is used by a <i>subscriber</i>
to subscribe to data distributed by a <i>publisher</i>.
Initially a <i>ZMQ_SUB</i> socket is not subscribed to any
messages, use the <i>ZMQ_SUBSCRIBE</i> option of
<b>zmq_setsockopt</b>(3) to specify which messages to
subscribe to. The <i>zmq_send()</i> function is not
implemented for this socket type.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 6. Summary
of ZMQ_SUB characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_XPUB</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>Same
as ZMQ_PUB except that you can receive subscriptions from
the peers in form of incoming messages. Subscription message
is a byte 1 (for subscriptions) or byte 0 (for
unsubscriptions) followed by the subscription body. Messages
without a sub/unsub prefix are also received, but have no
effect on subscription status.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 7. Summary
of ZMQ_XPUB characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_XSUB</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>Same
as ZMQ_SUB except that you subscribe by sending subscription
messages to the socket. Subscription message is a byte 1
(for subscriptions) or byte 0 (for unsubscriptions) followed
by the subscription body. Messages without a sub/unsub
prefix may also be sent, but have no effect on subscription
status.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 8. Summary
of ZMQ_XSUB characteristics</b></big></font></p>
<h3>Pipeline pattern
<a name="Pipeline pattern"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
pipeline pattern is used for distributing data to
<i>nodes</i> arranged in a pipeline. Data always flows down
the pipeline, and each stage of the pipeline is connected to
at least one <i>node</i>. When a pipeline stage is connected
to multiple <i>nodes</i> data is round−robined among
all connected <i>nodes</i>.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
pipeline pattern is formally defined by</font>
<b><font color="#0000FF">http://rfc.zeromq.org/spec:30</font></b><font color="#000000">.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_PUSH</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_PUSH</i> is used by a pipeline
<i>node</i> to send messages to downstream pipeline
<i>nodes</i>. Messages are round−robined to all
connected downstream <i>nodes</i>. The <i>zmq_recv()</i>
function is not implemented for this socket
type.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_PUSH</i> socket enters the <i>mute</i> state due to
having reached the high water mark for all downstream
<i>nodes</i>, or, for connection−oriented transports,
if the ZMQ_IMMEDIATE option is set and there are no
downstream <i>nodes</i> at all, then any <b>zmq_send</b>(3)
operations on the socket shall block until the mute state
ends or at least one downstream <i>node</i> becomes
available for sending; messages are not
discarded.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 9. Summary
of ZMQ_PUSH characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_PULL</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_PULL</i> is used by a pipeline
<i>node</i> to receive messages from upstream pipeline
<i>nodes</i>. Messages are fair−queued from among all
connected upstream <i>nodes</i>. The <i>zmq_send()</i>
function is not implemented for this socket
type.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 10. Summary
of ZMQ_PULL characteristics</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Scatter−gather
pattern</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">The
scatter−gather pattern is the thread−safe
version of the pipeline pattern. <br/>
The scatter−gather pattern is used for distributing
data to _nodes_ arranged in <br/>
a pipeline. Data always flows down the pipeline, and each
stage of the pipeline <br/>
is connected to at least one _node_. When a pipeline stage
is connected to <br/>
multiple _nodes_ data is round−robined among all
connected _nodes_.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">ZMQ_SCATTER
<br/>
ˆˆˆˆˆˆˆˆ <br/>
A socket of type 'ZMQ_SCATTER' is used by a
scatter−gather _node_ to send messages <br/>
to downstream scatter−gather _nodes_. Messages are
round−robined to all connected <br/>
downstream _nodes_. The _zmq_recv()_ function is not
implemented for this <br/>
socket type.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">When
a 'ZMQ_SCATTER' socket enters the 'mute' state due to having
reached the <br/>
high water mark for all downstream _nodes_, or, for
connection−oriented transports, <br/>
if the ZMQ_IMMEDIATE option is set and there are no
downstream _nodes_ at all, <br/>
then any linkzmq:zmq_send[3] operations on the socket shall
block until the mute <br/>
state ends or at least one downstream _node_ becomes
available for sending; <br/>
messages are not discarded.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">NOTE:
'ZMQ_SCATTER' sockets are threadsafe. They do not accept
ZMQ_RCVMORE on receives. <br/>
This limits them to single part data.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">[horizontal]
<br/>
.Summary of ZMQ_SCATTER characteristics <br/>
Compatible peer sockets:: 'ZMQ_SCATTER' <br/>
Direction:: Unidirectional <br/>
Send/receive pattern:: Send only <br/>
Incoming routing strategy:: N/A <br/>
Outgoing routing strategy:: Round−robin <br/>
Action in mute state:: Block</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">ZMQ_GATHER
<br/>
ˆˆˆˆˆˆˆˆ <br/>
A socket of type 'ZMQ_GATHER' is used by a
scatter−gather _node_ to receive messages <br/>
from upstream scatter−gather _nodes_. Messages are
fair−queued from among all <br/>
connected upstream _nodes_. The _zmq_send()_ function is not
implemented for <br/>
this socket type.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">NOTE:
'ZMQ_GATHER' sockets are threadsafe. They do not accept
ZMQ_RCVMORE on receives. <br/>
This limits them to single part data.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">[horizontal]
<br/>
.Summary of ZMQ_GATHER characteristics <br/>
Compatible peer sockets:: 'ZMQ_GATHER' <br/>
Direction:: Unidirectional <br/>
Send/receive pattern:: Receive only <br/>
Incoming routing strategy:: Fair−queued <br/>
Outgoing routing strategy:: N/A <br/>
Action in mute state:: Block</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">Exclusive
pair pattern</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
exclusive pair pattern is used to connect a peer to
precisely one other peer. This pattern is used for
inter−thread communication across the inproc
transport.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
exclusive pair pattern is formally defined by</font>
<b><font color="#0000FF">http://rfc.zeromq.org/spec:31</font></b><font color="#000000">.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_PAIR</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_PAIR</i> can only be connected to a
single peer at any one time. No message routing or filtering
is performed on messages sent over a <i>ZMQ_PAIR</i>
socket.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_PAIR</i> socket enters the <i>mute</i> state due to
having reached the high water mark for the connected peer,
or, for connection−oriented transports, if the
ZMQ_IMMEDIATE option is set and there is no connected peer,
then any <b>zmq_send</b>(3) operations on the socket shall
block until the peer becomes available for sending; messages
are not discarded.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>While
<i>ZMQ_PAIR</i> sockets can be used over transports other
than <b>zmq_inproc</b>(7), their inability to
auto−reconnect coupled with the fact new incoming
connections will be terminated while any previous
connections (including ones in a closing state) exist makes
them unsuitable for TCP in most cases.</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_PAIR</i>
sockets are designed for inter−thread communication
across the <b>zmq_inproc</b>(7) transport and do not
implement functionality such as
auto−reconnection.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 11. Summary
of ZMQ_PAIR characteristics</b></big></font></p>
<h3>Peer−to−peer pattern
<a name="Peer−to−peer pattern"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
peer−to−peer pattern is used to connect a peer
to multiple peers. Peer can both connect and bind and mix
both of them with the same socket. The
peer−to−peer pattern is useful to build
peer−to−peer networks (e.g zyre, bitcoin,
torrent) where a peer can both accept connections from other
peers or connect to them.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><b><big>Note</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Peer−to−peer
is still in draft phase.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_PEER</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
<i>ZMQ_PEER</i> socket talks to a set of <i>ZMQ_PEER</i>
sockets.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>To
connect and fetch the <i>routing_id</i> of the peer use
<b>zmq_connect_peer</b>(3).</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>Each
received message has a <i>routing_id</i> that is a
32−bit unsigned integer. The application can fetch
this with <b>zmq_msg_routing_id</b>(3).</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>To
send a message to a given <i>ZMQ_PEER</i> peer the
application must set the peer’s <i>routing_id</i> on
the message, using
<b>zmq_msg_set_routing_id</b>(3).</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>If
the <i>routing_id</i> is not specified, or does not refer to
a connected client peer, the send call will fail with
EHOSTUNREACH. If the outgoing buffer for the peer is full,
the send call shall block, unless ZMQ_DONTWAIT is used in
the send, in which case it shall fail with EAGAIN. The
<i>ZMQ_PEER</i> socket shall not drop messages in any
case.</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><b><big>Note</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><i>ZMQ_PEER</i>
sockets are threadsafe. They do not accept the ZMQ_SNDMORE
option on sends not ZMQ_RCVMORE on receives. This limits
them to single part data.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 12. Summary
of ZMQ_PEER characteristics</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Channel
pattern</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">The
channel pattern is the thread−safe version of the
exclusive pair pattern. <br/>
The channel pattern is used to connect a peer to precisely
one other <br/>
peer. This pattern is used for inter−thread
communication across the inproc <br/>
transport.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">NOTE:
Channel is still in draft phase.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">ZMQ_CHANNEL
<br/>
ˆˆˆˆˆˆˆˆ <br/>
A socket of type 'ZMQ_CHANNEL' can only be connected to a
single peer at any one <br/>
time. No message routing or filtering is performed on
messages sent over a <br/>
'ZMQ_CHANNEL' socket.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">When
a 'ZMQ_CHANNEL' socket enters the 'mute' state due to having
reached the <br/>
high water mark for the connected peer, or, for
connection−oriented transports, <br/>
if the ZMQ_IMMEDIATE option is set and there is no connected
peer, then <br/>
any linkzmq:zmq_send[3] operations on the socket shall block
until the peer <br/>
becomes available for sending; messages are not
discarded.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">While
'ZMQ_CHANNEL' sockets can be used over transports other than
linkzmq:zmq_inproc[7], <br/>
their inability to auto−reconnect coupled with the
fact new incoming connections will <br/>
be terminated while any previous connections (including ones
in a closing state) <br/>
exist makes them unsuitable for TCP in most
cases.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">NOTE:
'ZMQ_CHANNEL' sockets are designed for inter−thread
communication across <br/>
the linkzmq:zmq_inproc[7] transport and do not implement
functionality such <br/>
as auto−reconnection.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">NOTE:
'ZMQ_CHANNEL' sockets are threadsafe. They do not accept
ZMQ_RCVMORE on receives. <br/>
This limits them to single part data.</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">[horizontal]
<br/>
.Summary of ZMQ_CHANNEL characteristics <br/>
Compatible peer sockets:: 'ZMQ_CHANNEL' <br/>
Direction:: Bidirectional <br/>
Send/receive pattern:: Unrestricted <br/>
Incoming routing strategy:: N/A <br/>
Outgoing routing strategy:: N/A <br/>
Action in mute state:: Block</font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000">Native
Pattern</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
native pattern is used for communicating with TCP peers and
allows asynchronous requests and replies in either
direction.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_STREAM</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_STREAM</i> is used to send and receive
TCP data from a non−0MQ peer, when using the tcp://
transport. A <i>ZMQ_STREAM</i> socket can act as client
and/or server, sending and/or receiving TCP data
asynchronously.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
receiving TCP data, a <i>ZMQ_STREAM</i> socket shall prepend
a message part containing the <i>routing id</i> of the
originating peer to the message before passing it to the
application. Messages received are fair−queued from
among all connected peers.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
sending TCP data, a <i>ZMQ_STREAM</i> socket shall remove
the first part of the message and use it to determine the
<i>routing id</i> of the peer the message shall be routed
to, and unroutable messages shall cause an EHOSTUNREACH or
EAGAIN error.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>To
open a connection to a server, use the zmq_connect call, and
then fetch the socket routing id using the zmq_getsockopt
call with the ZMQ_ROUTING_ID option.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>To
close a specific connection, send the routing id frame
followed by a zero−length message (see EXAMPLE
section).</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a connection is made, a zero−length message will be
received by the application. Similarly, when the peer
disconnects (or the connection is lost), a zero−length
message will be received by the
application.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>You
must send one routing id frame followed by one data frame.
The ZMQ_SNDMORE flag is required for routing id frames but
is ignored on data frames.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 13. Summary
of ZMQ_STREAM characteristics</b></big></font></p>
<h3>Request−reply pattern
<a name="Request−reply pattern"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
request−reply pattern is used for sending requests
from a ZMQ_REQ <i>client</i> to one or more ZMQ_REP
<i>services</i>, and receiving subsequent replies to each
request sent.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
request−reply pattern is formally defined by</font>
<b><font color="#0000FF">http://rfc.zeromq.org/spec:28</font></b><font color="#000000">.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>ZMQ_REQ</big></b></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_REQ</i> is used by a <i>client</i> to
send requests to and receive replies from a <i>service</i>.
This socket type allows only an alternating sequence of
<i>zmq_send(request)</i> and subsequent
<i>zmq_recv(reply)</i> calls. Each request sent is
round−robined among all <i>services</i>, and each
reply received is matched with the last issued
request.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>For
connection−oriented transports, If the ZMQ_IMMEDIATE
option is set and there is no service available, then any
send operation on the socket shall block until at least one
<i>service</i> becomes available. The REQ socket shall not
discard messages.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 14. Summary
of ZMQ_REQ characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_REP</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_REP</i> is used by a <i>service</i> to
receive requests from and send replies to a <i>client</i>.
This socket type allows only an alternating sequence of
<i>zmq_recv(request)</i> and subsequent
<i>zmq_send(reply)</i> calls. Each request received is
fair−queued from among all <i>clients</i>, and each
reply sent is routed to the <i>client</i> that issued the
last request. If the original requester does not exist any
more the reply is silently discarded.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 15. Summary
of ZMQ_REP characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_DEALER</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_DEALER</i> is an advanced pattern used
for extending request/reply sockets. Each message sent is
round−robined among all connected peers, and each
message received is fair−queued from all connected
peers.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_DEALER</i> socket enters the <i>mute</i> state due
to having reached the high water mark for all peers, or, for
connection−oriented transports, if the ZMQ_IMMEDIATE
option is set and there are no peers at all, then any
<b>zmq_send</b>(3) operations on the socket shall block
until the mute state ends or at least one peer becomes
available for sending; messages are not
discarded.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_DEALER</i> socket is connected to a <i>ZMQ_REP</i>
socket each message sent must consist of an empty message
part, the <i>delimiter</i>, followed by one or more <i>body
parts</i>.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 16. Summary
of ZMQ_DEALER characteristics</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>ZMQ_ROUTER</b></big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>A
socket of type <i>ZMQ_ROUTER</i> is an advanced socket type
used for extending request/reply sockets. When receiving
messages a <i>ZMQ_ROUTER</i> socket shall prepend a message
part containing the <i>routing id</i> of the originating
peer to the message before passing it to the application.
Messages received are fair−queued from among all
connected peers. When sending messages a <i>ZMQ_ROUTER</i>
socket shall remove the first part of the message and use it
to determine the _routing id _ of the peer the message shall
be routed to. If the peer does not exist anymore, or has
never existed, the message shall be silently discarded.
However, if <i>ZMQ_ROUTER_MANDATORY</i> socket option is set
to <i>1</i>, the socket shall fail with EHOSTUNREACH in both
cases.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_ROUTER</i> socket enters the <i>mute</i> state due
to having reached the high water mark for all peers, then
any messages sent to the socket shall be dropped until the
mute state ends. Likewise, any messages routed to a peer for
which the individual high water mark has been reached shall
also be dropped. If, <i>ZMQ_ROUTER_MANDATORY</i> is set to
<i>1</i>, the socket shall block or return EAGAIN in both
cases.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_ROUTER</i> socket has <i>ZMQ_ROUTER_MANDATORY</i>
flag set to <i>1</i>, the socket shall generate
<i>ZMQ_POLLIN</i> events upon reception of messages from one
or more peers. Likewise, the socket shall generate
<i>ZMQ_POLLOUT</i> events when at least one message can be
sent to one or more peers.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>When
a <i>ZMQ_REQ</i> socket is connected to a <i>ZMQ_ROUTER</i>
socket, in addition to the <i>routing id</i> of the
originating peer each message received shall contain an
empty <i>delimiter</i> message part. Hence, the entire
structure of each received message as seen by the
application becomes: one or more <i>routing id</i> parts,
<i>delimiter</i> part, one or more <i>body parts</i>. When
sending replies to a <i>ZMQ_REQ</i> socket the application
must include the <i>delimiter</i> part.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big><b>Table 17. Summary
of ZMQ_ROUTER characteristics</b></big></font></p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
<i>zmq_socket()</i> function shall return an opaque handle
to the newly created socket if successful. Otherwise, it
shall return NULL and set <i>errno</i> to one of the values
defined below.</font></p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>EINVAL</b></font></p>
<p style="margin-left:14%;"><font color="#000000">The
requested socket <i>type</i> is invalid.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>EFAULT</b></font></p>
<p style="margin-left:14%;"><font color="#000000">The
provided <i>context</i> is invalid.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>EMFILE</b></font></p>
<p style="margin-left:14%;"><font color="#000000">The limit
on the total number of open 0MQ sockets has been
reached.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>ETERM</b></font></p>
<p style="margin-left:14%;"><font color="#000000">The
context specified was shutdown or terminated.</font></p>
<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>Creating
a simple HTTP server using ZMQ_STREAM</b>.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">void
*ctx = zmq_ctx_new (); <br/>
assert (ctx); <br/>
/* Create ZMQ_STREAM socket */ <br/>
void *socket = zmq_socket (ctx, ZMQ_STREAM); <br/>
assert (socket); <br/>
int rc = zmq_bind (socket, "tcp://*:8080"); <br/>
assert (rc == 0); <br/>
/* Data structure to hold the ZMQ_STREAM routing id */ <br/>
uint8_t routing_id [256]; <br/>
size_t routing_id_size = 256; <br/>
/* Data structure to hold the ZMQ_STREAM received data */
<br/>
uint8_t raw [256]; <br/>
size_t raw_size = 256; <br/>
while (1) { <br/>
/* Get HTTP request; routing id frame and then request */
<br/>
routing_id_size = zmq_recv (socket, routing_id, 256, 0);
<br/>
assert (routing_id_size &gt; 0); <br/>
do { <br/>
raw_size = zmq_recv (socket, raw, 256, 0); <br/>
assert (raw_size &gt;= 0); <br/>
} while (raw_size == 256); <br/>
/* Prepares the response */ <br/>
char http_response [] = <br/>
"HTTP/1.0 200 OK\r\n" <br/>
"Content−Type: text/plain\r\n" <br/>
"\r\n" <br/>
"Hello, World!"; <br/>
/* Sends the routing id frame followed by the response */
<br/>
zmq_send (socket, routing_id, routing_id_size, ZMQ_SNDMORE);
<br/>
zmq_send (socket, http_response, strlen (http_response), 0);
<br/>
/* Closes the connection by sending the routing id frame
followed by a zero response */ <br/>
zmq_send (socket, routing_id, routing_id_size, ZMQ_SNDMORE);
<br/>
zmq_send (socket, 0, 0, 0); <br/>
} <br/>
zmq_close (socket); <br/>
zmq_ctx_destroy (ctx);</font></p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>zmq_init</b>(3)
<b>zmq_setsockopt</b>(3) <b>zmq_bind</b>(3)
<b>zmq_connect</b>(3) <b>zmq_send</b>(3) <b>zmq_recv</b>(3)
<b>zmq_inproc</b>(7) <b>zmq</b>(7)</font></p>
<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">This
page was written by the 0MQ community. To make a change
please read the 0MQ Contribution Policy at</font>
<b><font color="#0000FF">http://www.zeromq.org/docs:contributing</font></b><font color="#000000">.</font></p>
<hr/>
</body>
</html>
