<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:40:48 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>KEYCTL</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">KEYCTL</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#KEY IDENTIFIERS">KEY IDENTIFIERS</a><br/>
<a href="#COMMAND SYNTAX">COMMAND SYNTAX</a><br/>
<a href="#Display the package version number">Display the package version number</a><br/>
<a href="#Query subsystem capabilities">Query subsystem capabilities</a><br/>
<a href="#Show actual key or keyring ID">Show actual key or keyring ID</a><br/>
<a href="#Show process keyrings">Show process keyrings</a><br/>
<a href="#Add a key to a keyring">Add a key to a keyring</a><br/>
<a href="#Request a key">Request a key</a><br/>
<a href="#Update a key">Update a key</a><br/>
<a href="#Create a keyring">Create a keyring</a><br/>
<a href="#Revoke a key">Revoke a key</a><br/>
<a href="#Clear a keyring">Clear a keyring</a><br/>
<a href="#Link a key to a keyring">Link a key to a keyring</a><br/>
<a href="#Unlink a key from a keyring or the session keyring tree">Unlink a key from a keyring or the session keyring tree</a><br/>
<a href="#Move a key between keyrings.">Move a key between keyrings.</a><br/>
<a href="#Search a keyring">Search a keyring</a><br/>
<a href="#Restrict a keyring">Restrict a keyring</a><br/>
<a href="#Read a key">Read a key</a><br/>
<a href="#List a keyring">List a keyring</a><br/>
<a href="#Describe a key">Describe a key</a><br/>
<a href="#Change the access controls on a key">Change the access controls on a key</a><br/>
<a href="#Set the permissions mask on a key">Set the permissions mask on a key</a><br/>
<a href="#Start a new session with fresh keyrings">Start a new session with fresh keyrings</a><br/>
<a href="#Instantiate a key">Instantiate a key</a><br/>
<a href="#Set the expiry time on a key">Set the expiry time on a key</a><br/>
<a href="#Retrieve a key’s security context">Retrieve a key’s security context</a><br/>
<a href="#Give the parent process a new session keyring">Give the parent process a new session keyring</a><br/>
<a href="#Remove dead keys from the session keyring tree">Remove dead keys from the session keyring tree</a><br/>
<a href="#Remove matching keys from the session keyring tree">Remove matching keys from the session keyring tree</a><br/>
<a href="#Get persistent keyring">Get persistent keyring</a><br/>
<a href="#Compute a Diffie-Hellman shared secret or public key">Compute a Diffie-Hellman shared secret or public key</a><br/>
<a href="#Compute a Diffie-Hellman shared secret and derive key material">Compute a Diffie-Hellman shared secret and derive key material</a><br/>
<a href="#Compute a Diffie-Hellman shared secret and apply KDF with other input">Compute a Diffie-Hellman shared secret and apply KDF with other input</a><br/>
<a href="#Perform public-key operations with an asymmetric key">Perform public-key operations with an asymmetric key</a><br/>
<a href="#Change notifications">Change notifications</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">keyctl −
key management facility control</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
−−version <b><br/>
keyctl</b> supports [&lt;cap&gt; | --raw] <b><br/>
keyctl</b> id [&lt;keyring&gt;] <b><br/>
keyctl</b> show [−x] [&lt;keyring&gt;] <b><br/>
keyctl</b> add [−x] &lt;type&gt; &lt;desc&gt;
&lt;data&gt; &lt;keyring&gt; <b><br/>
keyctl</b> padd [−x] &lt;type&gt; &lt;desc&gt;
&lt;keyring&gt; <b><br/>
keyctl</b> request &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;] <b><br/>
keyctl</b> request2 &lt;type&gt; &lt;desc&gt; &lt;info&gt;
[&lt;dest_keyring&gt;] <b><br/>
keyctl</b> prequest2 &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;] <b><br/>
keyctl</b> update [−x] &lt;key&gt; &lt;data&gt;
<b><br/>
keyctl</b> pupdate [−x] &lt;key&gt; <b><br/>
keyctl</b> newring &lt;name&gt; &lt;keyring&gt; <b><br/>
keyctl</b> revoke &lt;key&gt; <b><br/>
keyctl</b> clear &lt;keyring&gt; <b><br/>
keyctl</b> link &lt;key&gt; &lt;keyring&gt; <b><br/>
keyctl</b> unlink &lt;key&gt; [&lt;keyring&gt;] <b><br/>
keyctl</b> move [-f] &lt;key&gt; &lt;from_keyring&gt;
&lt;to_keyring&gt; <b><br/>
keyctl</b> search &lt;keyring&gt; &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;] <b><br/>
keyctl</b> restrict_keyring &lt;keyring&gt; [&lt;type&gt;
[&lt;restriction&gt;]] <b><br/>
keyctl</b> read &lt;key&gt; <b><br/>
keyctl</b> pipe &lt;key&gt; <b><br/>
keyctl</b> print &lt;key&gt; <b><br/>
keyctl</b> list &lt;keyring&gt; <b><br/>
keyctl</b> rlist &lt;keyring&gt; <b><br/>
keyctl</b> describe &lt;keyring&gt; <b><br/>
keyctl</b> rdescribe &lt;keyring&gt; [sep] <b><br/>
keyctl</b> chown &lt;key&gt; &lt;uid&gt; <b><br/>
keyctl</b> chgrp &lt;key&gt; &lt;gid&gt; <b><br/>
keyctl</b> setperm &lt;key&gt; &lt;mask&gt; <b><br/>
keyctl</b> new_session [&lt;name&gt;] <b><br/>
keyctl</b> session <b><br/>
keyctl</b> session − [&lt;prog&gt; &lt;arg1&gt;
&lt;arg2&gt; ...] <b><br/>
keyctl</b> session &lt;name&gt; [&lt;prog&gt; &lt;arg1&gt;
&lt;arg2&gt; ...] <b><br/>
keyctl</b> instantiate [−x] &lt;key&gt; &lt;data&gt;
&lt;keyring&gt; <b><br/>
keyctl</b> pinstantiate [−x] &lt;key&gt;
&lt;keyring&gt; <b><br/>
keyctl</b> negate &lt;key&gt; &lt;timeout&gt;
&lt;keyring&gt; <b><br/>
keyctl</b> reject &lt;key&gt; &lt;timeout&gt; &lt;error&gt;
&lt;keyring&gt; <b><br/>
keyctl</b> timeout &lt;key&gt; &lt;timeout&gt; <b><br/>
keyctl</b> security &lt;key&gt; <b><br/>
keyctl</b> reap [−v] <b><br/>
keyctl</b> purge &lt;type&gt; <b><br/>
keyctl</b> purge [−i] [−p] &lt;type&gt;
&lt;desc&gt; <b><br/>
keyctl</b> purge −s &lt;type&gt; &lt;desc&gt; <b><br/>
keyctl</b> get_persistent &lt;keyring&gt; [&lt;uid&gt;]
<b><br/>
keyctl</b> dh_compute &lt;private&gt; &lt;prime&gt;
&lt;base&gt; <b><br/>
keyctl</b> dh_compute_kdf &lt;private&gt; &lt;prime&gt;
&lt;base&gt; &lt;output_length&gt; &lt;hash_type&gt; <b><br/>
keyctl</b> dh_compute_kdf_oi [−x] &lt;private&gt;
&lt;prime&gt; &lt;base&gt; &lt;output_length&gt;
&lt;hash_type&gt; <b><br/>
keyctl</b> pkey_query &lt;key&gt; &lt;pass&gt; [k=v]*
<b><br/>
keyctl</b> pkey_encrypt &lt;key&gt; &lt;pass&gt;
&lt;datafile&gt; [k=v]* &gt;&lt;encfile&gt; <b><br/>
keyctl</b> pkey_decrypt &lt;key&gt; &lt;pass&gt;
&lt;encfile&gt; [k=v]* &gt;&lt;datafile&gt; <b><br/>
keyctl</b> pkey_sign &lt;key&gt; &lt;pass&gt;
&lt;datafile&gt; [k=v]* &gt;&lt;sigfile&gt; <b><br/>
keyctl</b> pkey_decrypt &lt;key&gt; &lt;pass&gt;
&lt;datafile&gt; &lt;sigfile&gt; [k=v]* <b><br/>
keyctl</b> watch [−f&lt;filters&gt;] &lt;key&gt;
<b><br/>
keyctl</b> watch_add &lt;fd&gt; &lt;key&gt; <b><br/>
keyctl</b> watch_rm &lt;fd&gt; &lt;key&gt; <b><br/>
keyctl</b> watch_session [−f &lt;filters&gt;] [-n
&lt;name&gt;] \ <br/>
&lt;notifylog&gt; &lt;gclog&gt; &lt;fd&gt; &lt;prog&gt;
[&lt;arg1&gt; &lt;arg2&gt; ...]</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This program is
used to control the key management facility in various ways
using a variety of subcommands.</p>
<h2>KEY IDENTIFIERS
<a name="KEY IDENTIFIERS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The key
identifiers passed to or returned from keyctl are, in
general, positive integers. There are, however, some special
values with special meanings that can be passed as
arguments: <br/>
No key: <b>0</b> <br/>
Thread keyring: <b>@t</b> or <b>−1</b></p>
<p style="margin-left:18%;">Each thread may have its own
keyring. This is searched first, before all others. The
thread keyring is replaced by (v)fork, exec and clone.</p>
<p style="margin-left:9%;">Process keyring: <b>@p</b> or
<b>−2</b></p>
<p style="margin-left:18%;">Each process (thread group) may
have its own keyring. This is shared between all members of
a group and will be searched after the thread keyring. The
process keyring is replaced by (v)fork and exec.</p>
<p style="margin-left:9%;">Session keyring: <b>@s</b> or
<b>−3</b></p>
<p style="margin-left:18%;">Each process subscribes to a
session keyring that is inherited across (v)fork, exec and
clone. This is searched after the process keyring. Session
keyrings can be named and an extant keyring can be joined in
place of a process’s current session keyring.</p>
<p style="margin-left:9%;">User specific keyring: <b>@u</b>
or <b>−4</b></p>
<p style="margin-left:18%;">This keyring is shared between
all the processes owned by a particular user. It isn’t
searched directly, but is normally linked to from the
session keyring.</p>
<p style="margin-left:9%;">User default session keyring:
<b>@us</b> or <b>−5</b></p>
<p style="margin-left:18%;">This is the default session
keyring for a particular user. Login processes that change
to a particular user will bind to this session until another
session is set.</p>
<p style="margin-left:9%;">Group specific keyring:
<b>@g</b> or <b>−6</b></p>
<p style="margin-left:18%;">This is a place holder for a
group specific keyring, but is not actually implemented yet
in the kernel.</p>
<p style="margin-left:9%;">Assumed request_key
authorisation key: <b>@a</b> or <b>−7</b></p>
<p style="margin-left:18%;">This selects the authorisation
key provided to the <b>request_key</b>() helper to permit it
to access the callers keyrings and instantiate the target
key.</p>
<p style="margin-left:9%;">Keyring by name:
<b>%:&lt;name&gt;</b></p>
<p style="margin-left:18%;">A named keyring. This will be
searched for in the process’s keyrings and in
<i>/proc/keys</i>.</p>
<p style="margin-left:9%;">Key by name:
<b>%&lt;type&gt;:&lt;name&gt;</b></p>
<p style="margin-left:18%;">A named key of the given type.
This will be searched for in the process’s keyrings
and in <i>/proc/keys</i>.</p>
<h2>COMMAND SYNTAX
<a name="COMMAND SYNTAX"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Any
non-ambiguous shortening of a command name may be used in
lieu of the full command name. This facility should not be
used in scripting as new commands may be added in future
that then cause ambiguity.</p>
<h3>Display the package version number
<a name="Display the package version number"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
−−version</b></p>
<p style="margin-left:9%; margin-top: 1em">This command
prints the package version number and build date and
exits:</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
−−version <br/>
keyctl from keyutils−1.5.3 (Built
2011−08−24)</p>
<h3>Query subsystem capabilities
<a name="Query subsystem capabilities"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
supports <b><br/>
keyctl</b> supports --raw <b><br/>
keyctl</b> supports &lt;cap&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command can
list the available capabilities:</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
supports <br/>
have_capabilities=0 <br/>
have_persistent_keyrings=1 <br/>
have_dh_compute=1 <br/>
have_public_key=1</p>
<p style="margin-left:9%; margin-top: 1em">produce a raw
hex dump of the capabilities list:</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
supports --raw <br/>
ff0f</p>
<p style="margin-left:9%; margin-top: 1em">or query a
specific capability:</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
supports pkey <br/>
echo $? <br/>
0</p>
<p style="margin-left:9%; margin-top: 1em">which exits 0 if
the capability is supported, 1 if it isn’t and 3 if
the name is not recognised. The capabilities supported are:
<b><br/>
capabilities</b></p>
<p style="margin-left:18%;">The kernel supports capability
querying. If not, the other capabilities will be queried as
best libkeyutils can manage.</p>
<p style="margin-left:9%;"><b>persistent_keyrings</b></p>
<p style="margin-left:18%;">The kernel supports persistent
keyrings.</p>
<p style="margin-left:9%;"><b>dh_compute</b></p>
<p style="margin-left:18%;">The kernel supports
Diffie-Hellman computation operations.</p>
<p style="margin-left:9%;"><b>public_key</b></p>
<p style="margin-left:18%;">The kernel supports public key
operations.</p>
<p style="margin-left:9%;"><b>big_key_type</b></p>
<p style="margin-left:18%;">The kernel supports the big_key
key type.</p>
<p style="margin-left:9%;"><b>key_invalidate</b></p>
<p style="margin-left:18%;">The kernel supports the
invalidate key operaiton.</p>
<p style="margin-left:9%;"><b>restrict_keyring</b></p>
<p style="margin-left:18%;">The kernel supports the
restrict_keyring operation.</p>
<p style="margin-left:9%;"><b>move_key</b></p>
<p style="margin-left:18%;">The kernel supports the move
key operation.</p>
<p style="margin-left:9%;"><b>ns_keyring_name</b></p>
<p style="margin-left:18%;">Keyring names are segregated
according to the user-namespace in which the keyrings are
created.</p>
<p style="margin-left:9%;"><b>ns_key_tag</b></p>
<p style="margin-left:18%;">Keys can get tagged with
namespace tags, allowing keys with the same type and
description, but different namespaces to coexist in the same
keyring. Tagging is done automatically according to the key
type.</p>
<h3>Show actual key or keyring ID
<a name="Show actual key or keyring ID"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl id
[&lt;key&gt;]</b></p>
<p style="margin-left:9%; margin-top: 1em">This command
looks up the real ID of a key or keyring from the identifier
given, which is typically a symbolic ID such as
"@s" indicating the session keyring, but can also
be a numeric ID or "%type:desc" notation. If a
special keyring is specified that isn’t created yet,
an error will be given rather than causing that keyring to
be created.</p>
<h3>Show process keyrings
<a name="Show process keyrings"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl show
[−x] [&lt;keyring&gt;]</b></p>
<p style="margin-left:9%; margin-top: 1em">By default this
command recursively shows what keyrings a process is
subscribed to and what keys and keyrings they contain. If a
keyring is specified then that keyring will be dumped
instead. If <b>−x</b> is specified then the keyring
IDs will be dumped in hex instead of decimal.</p>
<h3>Add a key to a keyring
<a name="Add a key to a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
add</b> [−x] &lt;type&gt; &lt;desc&gt; &lt;data&gt;
&lt;keyring&gt; <b><br/>
keyctl padd</b> [−x] &lt;type&gt; &lt;desc&gt;
&lt;keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
creates a key of the specified type and description;
instantiates it with the given data and attaches it to the
specified keyring. It then prints the new key’s ID on
stdout:</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl add
user mykey stuff @u <br/>
26</p>
<p style="margin-left:9%; margin-top: 1em">The <b>padd</b>
variant of the command reads the data from stdin rather than
taking it from the command line:</p>
<p style="margin-left:18%; margin-top: 1em">$ echo −n
stuff | keyctl padd user mykey @u 26</p>
<p style="margin-left:9%; margin-top: 1em">If
<b>−x</b> is given, then the data is hex-decoded with
whitespace being discarded.</p>
<h3>Request a key
<a name="Request a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
request</b> &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
<b><br/>
keyctl request2</b> &lt;type&gt; &lt;desc&gt; &lt;info&gt;
[&lt;dest_keyring&gt;] <b><br/>
keyctl prequest2</b> &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;]</p>
<p style="margin-left:9%; margin-top: 1em">These three
commands request the lookup of a key of the given type and
description. The process’s keyrings will be searched,
and if a match is found the matching key’s ID will be
printed to stdout; and if a destination keyring is given,
the key will be added to that keyring also.</p>
<p style="margin-left:9%; margin-top: 1em">If there is no
key, the first command will simply return the error ENOKEY
and fail. The second and third commands will create a
partial key with the type and description, and call out to
<i>/sbin/request−key</i> with that key and the extra
information supplied. This will then attempt to instantiate
the key in some manner, such that a valid key is
obtained.</p>
<p style="margin-left:9%; margin-top: 1em">The third
command is like the second, except that the callout
information is read from stdin rather than being passed on
the command line.</p>
<p style="margin-left:9%; margin-top: 1em">If a valid key
is obtained, the ID will be printed and the key attached as
if the original search had succeeded.</p>
<p style="margin-left:9%; margin-top: 1em">If there
wasn’t a valid key obtained, a temporary negative key
will be attached to the destination keyring if given and the
error "Requested key not available" will be
given.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
request2 user debug:hello wibble <br/>
23 <br/>
$ echo −n wibble | keyctl prequest2 user debug:hello
<br/>
23 <br/>
$ keyctl request user debug:hello <br/>
23</p>
<h3>Update a key
<a name="Update a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
update</b> [−x] &lt;key&gt; &lt;data&gt; <b><br/>
keyctl pupdate</b> [−x] &lt;key&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
replaces the data attached to a key with a new set of data.
If the type of the key doesn’t support update then
error "Operation not supported" will be
returned.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl update
23 zebra</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>pupdate</b> variant of the command reads the data from
stdin rather than taking it from the command line:</p>
<p style="margin-left:18%; margin-top: 1em">$ echo −n
zebra | keyctl pupdate 23 <br/>
$ echo 616263313233 | keyctl pupdate -x 23</p>
<p style="margin-left:9%; margin-top: 1em">If
<b>−x</b> is given, then the data is hex-decoded with
whitespace being discarded.</p>
<h3>Create a keyring
<a name="Create a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
newring</b> &lt;name&gt; &lt;keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
creates a new keyring of the specified name and attaches it
to the specified keyring. The ID of the new keyring will be
printed to stdout if successful.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
newring squelch @us <br/>
27</p>
<h3>Revoke a key
<a name="Revoke a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
revoke</b> &lt;key&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
marks a key as being revoked. Any further operations on that
key (apart from unlinking it) will return error "Key
has been revoked".</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl revoke
26 <br/>
$ keyctl describe 26 <br/>
keyctl_describe: Key has been revoked</p>
<h3>Clear a keyring
<a name="Clear a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
clear</b> &lt;keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
unlinks all the keys attached to the specified keyring.
Error "Not a directory" will be returned if the
key specified is not a keyring.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl clear
27</p>
<h3>Link a key to a keyring
<a name="Link a key to a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
link</b> &lt;key&gt; &lt;keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
makes a link from the key to the keyring if there’s
enough capacity to do so. Error "Not a directory"
will be returned if the destination is not a keyring. Error
"Permission denied" will be returned if the key
doesn’t have link permission or the keyring
doesn’t have write permission. Error "File table
overflow" will be returned if the keyring is full.
Error "Resource deadlock avoided" will be returned
if an attempt was made to introduce a recursive link.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl link
23 27 <br/>
$ keyctl link 27 27 <br/>
keyctl_link: Resource deadlock avoided</p>
<h3>Unlink a key from a keyring or the session keyring tree
<a name="Unlink a key from a keyring or the session keyring tree"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
unlink</b> &lt;key&gt; [&lt;keyring&gt;]</p>
<p style="margin-left:9%; margin-top: 1em">If the keyring
is specified, this command removes a link to the key from
the keyring. Error "Not a directory" will be
returned if the destination is not a keyring. Error
"Permission denied" will be returned if the
keyring doesn’t have write permission. Error "No
such file or directory" will be returned if the key is
not linked to by the keyring.</p>
<p style="margin-left:9%; margin-top: 1em">If the keyring
is not specified, this command performs a depth-first search
of the session keyring tree and removes all the links to the
nominated key that it finds (and that it is permitted to
remove). It prints the number of successful unlinks before
exiting.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl unlink
23 27</p>
<h3>Move a key between keyrings.
<a name="Move a key between keyrings."></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
move</b> [-f] &lt;key&gt; &lt;from_keyring&gt;
&lt;to_keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
moves a key from one keyring to another, atomically
combining "keyctl unlink &lt;key&gt;
&lt;from_keyring&gt;" and "keyctl link &lt;key&gt;
&lt;to_keyring&gt;".</p>
<p style="margin-left:9%; margin-top: 1em">If the
"-f" flag is present, any matching key will be
displaced from "to_keyring"; if not present, the
command will fail with the error message "File
exists" if the key would otherwise displace another key
from "to_keyring".</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl move
23 27 29 <br/>
$ keyctl move -f 71 @u @s</p>
<h3>Search a keyring
<a name="Search a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
search</b> &lt;keyring&gt; &lt;type&gt; &lt;desc&gt;
[&lt;dest_keyring&gt;]</p>
<p style="margin-left:9%; margin-top: 1em">This command
non-recursively searches a keyring for a key of a particular
type and description. If found, the ID of the key will be
printed on stdout and the key will be attached to the
destination keyring if present. Error "Requested key
not available" will be returned if the key is not
found.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl search
@us user debug:hello <br/>
23 <br/>
$ keyctl search @us user debug:bye <br/>
keyctl_search: Requested key not available</p>
<h3>Restrict a keyring
<a name="Restrict a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
restrict_keyring</b> &lt;keyring&gt; [&lt;type&gt;
[&lt;restriction&gt;]]</p>
<p style="margin-left:9%; margin-top: 1em">This command
limits the linkage of keys to the given keyring using a
provided restriction scheme. The scheme is associated with a
given key type, with further details provided in the
restriction option string. Options typically contain a
restriction name possibly followed by key ids or other data
relevant to the restriction. If no restriction scheme is
provided, the keyring will reject all links.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
restrict_keyring $1 asymmetric builtin_trusted</p>
<h3>Read a key
<a name="Read a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
read</b> &lt;key&gt; <b><br/>
keyctl pipe</b> &lt;key&gt; <b><br/>
keyctl print</b> &lt;key&gt;</p>
<p style="margin-left:9%; margin-top: 1em">These commands
read the payload of a key. "read" prints it on
stdout as a hex dump, "pipe" dumps the raw data to
stdout and "print" dumps it to stdout directly if
it’s entirely printable or as a hexdump preceded by
":hex:" if not.</p>
<p style="margin-left:9%; margin-top: 1em">If the key type
does not support reading of the payload, then error
"Operation not supported" will be returned.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl read
26 <br/>
1 bytes of data in key: <br/>
62 <br/>
$ keyctl print 26 <br/>
b <br/>
$ keyctl pipe 26 <br/>
$</p>
<h3>List a keyring
<a name="List a keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
list</b> &lt;keyring&gt; <b><br/>
keyctl rlist</b> &lt;keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">These commands
list the contents of a key as a keyring. "list"
pretty prints the contents and "rlist" just
produces a space-separated list of key IDs.</p>
<p style="margin-left:9%; margin-top: 1em">No attempt is
made to check that the specified keyring is a keyring.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl list
@us <br/>
2 keys in keyring: <br/>
22:
vrwsl−−−−−−−−−−
4043 −1 keyring: _uid.4043 <br/>
23:
vrwsl−−−−−−−−−−
4043 4043 user: debug:hello <br/>
$ keyctl rlist @us <br/>
22 23</p>
<h3>Describe a key
<a name="Describe a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
describe</b> &lt;keyring&gt; <b><br/>
keyctl rdescribe</b> &lt;keyring&gt; [sep]</p>
<p style="margin-left:9%; margin-top: 1em">These commands
fetch a description of a keyring. "describe"
pretty prints the description in the same fashion as the
"list" command; "rdescribe" prints the
raw data returned from the kernel.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
describe @us <br/>
−5:
vrwsl−−−−−−−−−−
4043 −1 keyring: _uid_ses.4043 <br/>
$ keyctl rdescribe @us <br/>
keyring;4043;−1;3f1f0000;_uid_ses.4043</p>
<p style="margin-left:9%; margin-top: 1em">The raw string
is
"&lt;type&gt;;&lt;uid&gt;;&lt;gid&gt;;&lt;perms&gt;;&lt;description&gt;",
where <i>uid</i> and <i>gid</i> are the decimal user and
group IDs, <i>perms</i> is the permissions mask in hex,
<i>type</i> and <i>description</i> are the type name and
description strings (neither of which will contain
semicolons).</p>
<h3>Change the access controls on a key
<a name="Change the access controls on a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
chown</b> &lt;key&gt; &lt;uid&gt; <b><br/>
keyctl chgrp</b> &lt;key&gt; &lt;gid&gt;</p>
<p style="margin-left:9%; margin-top: 1em">These two
commands change the UID and GID associated with evaluating a
key’s permissions mask. The UID also governs which
quota a key is taken out of.</p>
<p style="margin-left:9%; margin-top: 1em">The chown
command is not currently supported; attempting it will earn
the error "Operation not supported" at best.</p>
<p style="margin-left:9%; margin-top: 1em">For
non-superuser users, the GID may only be set to the
process’s GID or a GID in the process’s groups
list. The superuser may set any GID it likes.</p>
<p style="margin-left:18%; margin-top: 1em">$ sudo keyctl
chown 27 0 <br/>
keyctl_chown: Operation not supported <br/>
$ sudo keyctl chgrp 27 0</p>
<h3>Set the permissions mask on a key
<a name="Set the permissions mask on a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
setperm</b> &lt;key&gt; &lt;mask&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
changes the permission control mask on a key. The mask may
be specified as a hex number if it begins "0x", an
octal number if it begins "0" or a decimal number
otherwise.</p>
<p style="margin-left:9%; margin-top: 1em">The hex numbers
are a combination of:</p>
<p style="margin-left:18%; margin-top: 1em">Possessor UID
GID Other Permission Granted <br/>
======== ======== ======== ======== ================== <br/>
01000000 00010000 00000100 00000001 View <br/>
02000000 00020000 00000200 00000002 Read <br/>
04000000 00040000 00000400 00000004 Write <br/>
08000000 00080000 00000800 00000008 Search <br/>
10000000 00100000 00001000 00000010 Link <br/>
20000000 00200000 00002000 00000020 Set Attribute <br/>
3f000000 003f0000 00003f00 0000003f All</p>
<p style="margin-left:9%; margin-top: 1em"><i>View</i>
permits the type, description and other parameters of a key
to be viewed.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Read</i>
permits the payload (or keyring list) to be read if
supported by the type.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Write</i>
permits the payload (or keyring list) to be modified or
updated.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Search</i> on
a key permits it to be found when a keyring to which it is
linked is searched.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Link</i>
permits a key to be linked to a keyring.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Set
Attribute</i> permits a key to have its owner, group
membership, permissions mask and timeout changed.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
setperm 27 0x1f1f1f00</p>
<h3>Start a new session with fresh keyrings
<a name="Start a new session with fresh keyrings"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
session <br/>
keyctl session</b> − [&lt;prog&gt; &lt;arg1&gt;
&lt;arg2&gt; ...] <b><br/>
keyctl session</b> &lt;name&gt; [&lt;prog&gt; &lt;arg1&gt;
&lt;arg2&gt; ...]</p>
<p style="margin-left:9%; margin-top: 1em">These commands
join or create a new keyring and then run a shell or other
program with that keyring as the session key.</p>
<p style="margin-left:9%; margin-top: 1em">The variation
with no arguments just creates an anonymous session keyring
and attaches that as the session keyring; it then
exec’s $SHELL.</p>
<p style="margin-left:9%; margin-top: 1em">The variation
with a dash in place of a name creates an anonymous session
keyring and attaches that as the session keyring; it then
exec’s the supplied command, or $SHELL if one
isn’t supplied.</p>
<p style="margin-left:9%; margin-top: 1em">The variation
with a name supplied creates or joins the named keyring and
attaches that as the session keyring; it then exec’s
the supplied command, or $SHELL if one isn’t
supplied.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
rdescribe @s <br/>
keyring;4043;−1;3f1f0000;_uid_ses.4043</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
session <br/>
Joined session keyring: 28</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
rdescribe @s <br/>
keyring;4043;4043;3f1f0000;_ses.24082</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
session − <br/>
Joined session keyring: 29 <br/>
$ keyctl rdescribe @s <br/>
keyring;4043;4043;3f1f0000;_ses.24139</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
session − keyctl rdescribe @s <br/>
Joined session keyring: 30 <br/>
keyring;4043;4043;3f1f0000;_ses.24185</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
session fish <br/>
Joined session keyring: 34 <br/>
$ keyctl rdescribe @s <br/>
keyring;4043;4043;3f1f0000;fish</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
session fish keyctl rdesc @s <br/>
Joined session keyring: 35 <br/>
keyring;4043;4043;3f1f0000;fish</p>
<h3>Instantiate a key
<a name="Instantiate a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
instantiate</b> [−x] &lt;key&gt; &lt;data&gt;
&lt;keyring&gt; <b><br/>
keyctl pinstantiate</b> [−x] &lt;key&gt;
&lt;keyring&gt; <b><br/>
keyctl negate</b> &lt;key&gt; &lt;timeout&gt;
&lt;keyring&gt; <b><br/>
keyctl reject</b> &lt;key&gt; &lt;timeout&gt; &lt;error&gt;
&lt;keyring&gt;</p>
<p style="margin-left:9%; margin-top: 1em">These commands
are used to attach data to a partially set up key (as
created by the kernel and passed to
<i>/sbin/request−key</i>). "instantiate"
marks a key as being valid and attaches the data as the
payload. "negate" and "reject" mark a
key as invalid and sets a timeout on it so that it’ll
go away after a while. This prevents a lot of quickly
sequential requests from slowing the system down overmuch
when they all fail, as all subsequent requests will then
fail with error "Requested key not found" (if
negated) or the specified error (if rejected) until the
negative key has expired.</p>
<p style="margin-left:9%; margin-top: 1em">Reject’s
error argument can either be a UNIX error number or one of
’<b>rejected</b>’, ’<b>expired</b>’
or ’<b>revoked</b>’.</p>
<p style="margin-left:9%; margin-top: 1em">The newly
instantiated key will be attached to the specified
keyring.</p>
<p style="margin-left:9%; margin-top: 1em">These commands
may only be run from the program run by request−key -
a special authorisation key is set up by the kernel and
attached to the request−key’s session keyring.
This special key is revoked once the key to which it refers
has been instantiated one way or another.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
instantiate $1 "Debug $3" $4 <br/>
$ keyctl negate $1 30 $4 <br/>
$ keyctl reject $1 30 64 $4</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>pinstantiate</b> variant of the command reads the data
from stdin rather than taking it from the command line:</p>
<p style="margin-left:18%; margin-top: 1em">$ echo −n
"Debug $3" | keyctl pinstantiate $1 $4</p>
<p style="margin-left:9%; margin-top: 1em">If
<b>−x</b> is given, then the data is hex-decoded with
whitespace being discarded:</p>
<p style="margin-left:18%; margin-top: 1em">$ echo 01 02 03
04 | keyctl pinstantiate -x $1 $4</p>
<h3>Set the expiry time on a key
<a name="Set the expiry time on a key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
timeout</b> &lt;key&gt; &lt;timeout&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command is
used to set the timeout on a key, or clear an existing
timeout if the value specified is zero. The timeout is given
as a number of seconds into the future.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
timeout $1 45</p>
<h3>Retrieve a key’s security context
<a name="Retrieve a key’s security context"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
security</b> &lt;key&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command is
used to retrieve a key’s LSM security context. The
label is printed on stdout.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
security @s <br/>

unconfined_u:unconfined_r:unconfined_t:s0−s0:c0.c1023</p>
<h3>Give the parent process a new session keyring
<a name="Give the parent process a new session keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
new_session [&lt;name&gt;]</b></p>
<p style="margin-left:9%; margin-top: 1em">This command is
used to give the invoking process (typically a shell) a new
session keyring, discarding its old session keyring. If a
name is given, the keyring is given that name, otherwise it
will be given a name of "_ses" and will not be
manually joinable.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
session foo <br/>
Joined session keyring: 723488146 <br/>
$ keyctl show <br/>
Session Keyring <br/>
−3 −−alswrv 0 0 keyring: foo <br/>
$ keyctl new_session <br/>
490511412 <br/>
$ keyctl show <br/>
Session Keyring <br/>
−3 −−alswrv 0 0 keyring: _ses</p>
<p style="margin-left:9%; margin-top: 1em">Note that this
affects the <i>parent</i> of the process that invokes the
system call, and so may only affect processes with matching
credentials. Furthermore, the change does not take effect
till the parent process next transitions from kernel space
to user space - typically when the <b>wait</b>() system call
returns.</p>
<h3>Remove dead keys from the session keyring tree
<a name="Remove dead keys from the session keyring tree"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl
reap</b></p>
<p style="margin-left:9%; margin-top: 1em">This command
performs a depth-first search of the caller’s session
keyring tree and attempts to unlink any key that it finds
that is inaccessible due to expiry, revocation, rejection or
negation. It does not attempt to remove live keys that are
unavailable simply due to a lack of granted permission.</p>
<p style="margin-left:9%; margin-top: 1em">A key that is
designated reapable will only be removed from a keyring if
the caller has Write permission on that keyring, and only
keyrings that grant Search permission to the caller will be
searched.</p>
<p style="margin-left:9%; margin-top: 1em">The command
prints the number of keys reaped before it exits. If the
<b>−v</b> flag is passed then the reaped keys are
listed as they’re being reaped, together with the
success or failure of the unlink.</p>
<h3>Remove matching keys from the session keyring tree
<a name="Remove matching keys from the session keyring tree"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
purge &lt;type&gt; <b><br/>
keyctl</b> purge [−i] [−p] &lt;type&gt;
&lt;desc&gt; <b><br/>
keyctl</b> purge −s &lt;type&gt; &lt;desc&gt;</p>
<p style="margin-left:9%; margin-top: 1em">These commands
perform a depth-first search to find matching keys in the
caller’s session keyring tree and attempts to unlink
them. The number of keys successfully unlinked is printed at
the end.</p>
<p style="margin-left:9%; margin-top: 1em">The keyrings
must grant Read and View permission to the caller to be
searched, and the keys to be removed must also grant View
permission. Keys can only be removed from keyrings that
grant Write permission.</p>
<p style="margin-left:9%; margin-top: 1em">The first
variant purges all keys of the specified type.</p>
<p style="margin-left:9%; margin-top: 1em">The second
variant purges all keys of the specified type that also
match the given description literally. The −i flag
allows a case-independent match and the −p flag allows
a prefix match.</p>
<p style="margin-left:9%; margin-top: 1em">The third
variant purges all keys of the specified type and matching
description using the key type’s comparator in the
kernel to match the description. This permits the key type
to match a key with a variety of descriptions.</p>
<h3>Get persistent keyring
<a name="Get persistent keyring"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
get_persistent &lt;keyring&gt; [&lt;uid&gt;]</p>
<p style="margin-left:9%; margin-top: 1em">This command
gets the persistent keyring for either the current UID or
the specified UID and attaches it to the nominated keyring.
The persistent keyring’s ID will be printed on
stdout.</p>
<p style="margin-left:9%; margin-top: 1em">The kernel will
create the keyring if it doesn’t exist and every time
this command is called, will reset the expiration timeout on
the keyring to the value in:</p>
<p style="margin-left:18%; margin-top: 1em">/proc/sys/kernel/keys/persistent_keyring_expiry</p>
<p style="margin-left:9%; margin-top: 1em">(by default
three days). Should the timeout be reached, the persistent
keyring will be removed and everything it pins can then be
garbage collected.</p>
<p style="margin-left:9%; margin-top: 1em">If a UID other
than the process’s real or effective UIDs is
specified, then an error will be given if the process does
not have the CAP_SETUID capability.</p>
<h3>Compute a Diffie-Hellman shared secret or public key
<a name="Compute a Diffie-Hellman shared secret or public key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
dh_compute &lt;private&gt; &lt;prime&gt; &lt;base&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
computes either a Diffie-Hellman shared secret or the public
key corresponding to the provided private key using the
payloads of three keys. The computation is:</p>
<p style="margin-left:18%; margin-top: 1em">base ˆ
private (mod prime)</p>
<p style="margin-left:9%; margin-top: 1em">The three inputs
must be user keys with read permission. If the provided base
key contains the shared generator value, the public key will
be computed. If the provided base key contains the remote
public key value, the shared secret will be computed.</p>
<p style="margin-left:9%; margin-top: 1em">The result is
printed to stdout as a hex dump.</p>
<p style="margin-left:18%; margin-top: 1em">$ keyctl
dh_compute $1 $2 $3 <br/>
8 bytes of data in result: <br/>
00010203 04050607</p>
<h3>Compute a Diffie-Hellman shared secret and derive key material
<a name="Compute a Diffie-Hellman shared secret and derive key material"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
dh_compute_kdf &lt;private&gt; &lt;prime&gt; &lt;base&gt;
&lt;output_length&gt; &lt;hash_type&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command
computes a Diffie-Hellman shared secret and derives key
material from the shared secret using a key derivation
function (KDF). The shared secret is derived as outlined
above and is input to the KDF using the specified hash type.
The hash type must point to a hash name known to the kernel
crypto API.</p>
<p style="margin-left:9%; margin-top: 1em">The operation
derives key material of the length specified by the
caller.</p>
<p style="margin-left:9%; margin-top: 1em">The operation is
compliant to the specification of SP800-56A.</p>
<p style="margin-left:9%; margin-top: 1em">The result is
printed to stdout as hex dump.</p>
<h3>Compute a Diffie-Hellman shared secret and apply KDF with other input
<a name="Compute a Diffie-Hellman shared secret and apply KDF with other input"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
dh_compute_kdf_oi [−x] &lt;private&gt; &lt;prime&gt;
&lt;base&gt; &lt;output_length&gt; &lt;hash_type&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This command is
identical to the command <i>dh_compute_kdf</i> to generate a
Diffie-Hellman shared secret followed by a key derivation
operation. This command allows the caller to provide the
other input data (OI data) compliant to SP800-56A via
stdin.</p>
<p style="margin-left:9%; margin-top: 1em">If
<b>−x</b> is given, then the data passed to stdin is
hex-decoded with whitespace being discarded.</p>
<h3>Perform public-key operations with an asymmetric key
<a name="Perform public-key operations with an asymmetric key"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
pkey_query &lt;key&gt; &lt;pass&gt; [k=v]* <b><br/>
keyctl</b> pkey_encrypt &lt;key&gt; &lt;pass&gt;
&lt;datafile&gt; [k=v]* &gt; &lt;encfile&gt; <b><br/>
keyctl</b> pkey_decrypt &lt;key&gt; &lt;pass&gt;
&lt;encfile&gt; [k=v]* &gt; &lt;datafile&gt; <b><br/>
keyctl</b> pkey_sign &lt;key&gt; &lt;pass&gt;
&lt;datafile&gt; [k=v]* &gt; &lt;sigfile&gt; <b><br/>
keyctl</b> pkey_verify &lt;key&gt; &lt;pass&gt;
&lt;datafile&gt; &lt;sigfile&gt; [k=v]*</p>
<p style="margin-left:9%; margin-top: 1em">These commands
query an asymmetric key, encrypt data with it, decrypt the
encrypted data, generate a signature over some data and
verify that signature. For encrypt, decrypt and sign, the
resulting data is written to stdout; verify reads the data
and the signature files and compares them.</p>
<p style="margin-left:9%; margin-top: 1em">[<b>!</b>] NOTE
that the data is of very limited capacity, with no more bits
than the size of the key. For signatures, the caller is
expected to digest the actual data and pass in the result of
the digest as the datafile. The name of the digest should be
specified on the end of the command line as
"hash=&lt;name&gt;".</p>
<p style="margin-left:9%; margin-top: 1em">The <i>key</i>
ID indicates the key to use; <i>pass</i> is a placeholder
for future password provision and should be "0"
for the moment; <i>datafile</i> is the unencrypted data to
be encrypted, signed or to have its signature checked;
<i>encfile</i> is a file containing encrypted data; and
<i>sigfile</i> is a file containing a signature.</p>
<p style="margin-left:9%; margin-top: 1em">A list of
parameters in "key[=val]" form can be included on
the end of the command line. These specify things like the
digest algorithm used ("hash=&lt;name&gt;") or the
encoding form ("enc=&lt;type&gt;").</p>
<p style="margin-left:18%; margin-top: 1em">k=‘keyctl
padd asymmetric "" @s &lt;key.pkcs8.der‘
<br/>
keyctl pkey_query $k 0 enc=pkcs1 hash=sha256 <br/>
keyctl pkey_encrypt $k 0 foo.hash enc=pkcs1 &gt;foo.enc <br/>
keyctl pkey_decrypt $k 0 foo.enc enc=pkcs1 &gt;foo.hash <br/>
keyctl pkey_sign $k 0 foo.hash enc=pkcs1 hash=sha256
&gt;foo.sig <br/>
keyctl pkey_verify $k 0 foo.hash foo.sig enc=pkcs1
hash=sha256</p>
<p style="margin-left:9%; margin-top: 1em">See
asymmetric-key(7) for more information.</p>
<h3>Change notifications
<a name="Change notifications"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>
watch [−f&lt;filters&gt;] &lt;key&gt; <b><br/>
keyctl</b> watch_session [−f &lt;filters&gt;] [-n
&lt;name&gt;] \ <br/>
&lt;notifylog&gt; &lt;gclog&gt; &lt;fd&gt; &lt;prog&gt;
[&lt;arg1&gt; &lt;arg2&gt; ...] <b>keyctl</b> watch_add
&lt;fd&gt; &lt;key&gt; <b><br/>
keyctl</b> watch_rm &lt;fd&gt; &lt;key&gt;</p>
<p style="margin-left:9%; margin-top: 1em">The <b>watch</b>
command watches a single key, printing notifications to
stdout until the key is destroyed. Filters can be employed
to cut down the events that will be delivered. The
<i>filter</i> string is a series of letters, each one of
which enables a particular event subtype:</p>
<p style="margin-left:18%; margin-top: 1em"><b>i</b> - The
key has been instantiated <b><br/>
p</b> - The key has been updated <b><br/>
l</b> - A link has been added to a keyring <b><br/>
n</b> - A link has been removed from a keyring <b><br/>
c</b> - A keyring has been cleared <b><br/>
r</b> - A key has been revoked <b><br/>
v</b> - A key has been invalidated <b><br/>
s</b> - A key has had its attributes changed</p>
<p style="margin-left:9%; margin-top: 1em">The output of
the command looks like:</p>
<p style="margin-left:18%; margin-top: 1em">&lt;<i>keyid</i>&gt;
&lt;<i>event</i>&gt; [&lt;<i>aux</i>&gt;]</p>
<p style="margin-left:9%; margin-top: 1em">Where
<i>keyid</i> is the primary subject of the notification,
<i>op</i> is the event and <i>aux</i> is the secondary key
if there is one (such as link where the primary key is the
keyring secondary key is the key being linked in to it). For
example:</p>
<p style="margin-left:18%; margin-top: 1em">255913279 link
340681059 <br/>
255913279 clr</p>
<p style="margin-left:9%; margin-top: 1em">An additional
notication is generated when a key being watched is garbage
collected, e.g.:</p>
<p style="margin-left:18%; margin-top: 1em">255913279
gc</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>watch_session</b> command creates a new session keyring,
with name <i>name</i> if given, watches it for notifications
and runs program <i>prog</i> with it. The program is given
the specified arguments.</p>
<p style="margin-left:9%; margin-top: 1em">A second process
is forked off to monitor the notifications. The output from
that is directed to the files <i>notifylog</i> for most
notifications and <i>gclog</i> for key removal notifications
(which are asynchronous and may be deferred).</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>watch_queue</b>(7) device is exported to the program
attached to fd number <i>fd</i>. This can be passed by the
other two commands.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>watch_add</b> command adds a watch on <i>key</i> to the
<b>watch_queue</b> attached to <i>fd</i> as exported by
watch_session and the <b>watch_rm</b> caommand removes it. A
watch_queue can handle multiple keys and even non-keys
sources as well.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">There are a
number of common errors returned by this program:</p>
<p style="margin-left:9%; margin-top: 1em">"Not a
directory" - a key wasn’t a keyring.</p>
<p style="margin-left:9%; margin-top: 1em">"Requested
key not found" - the looked for key isn’t
available.</p>
<p style="margin-left:9%; margin-top: 1em">"Key has
been revoked" - a revoked key was accessed.</p>
<p style="margin-left:9%; margin-top: 1em">"Key has
expired" - an expired key was accessed.</p>
<p style="margin-left:9%; margin-top: 1em">"Permission
denied" - permission was denied by a UID/GID/mask
combination.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>keyctl</b>(1),
<b>keyctl</b>(2), <b>request_key</b>(2), <b>keyctl</b>(3),
<b>request−key.conf</b>(5), <b>keyrings</b>(7),
<b>request−key</b>(8)</p>
<hr/>
</body>
</html>
