<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:41:01 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>syscall</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">syscall</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#Architecture-specific requirements">Architecture-specific requirements</a><br/>
<a href="#Architecture calling conventions">Architecture calling conventions</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">syscall −
indirect system call</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;sys/syscall.h&gt;</b> /* Definition of <b>SYS_*</b>
constants */ <b><br/>
#include &lt;unistd.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>long
syscall(long</b> <i>number</i><b>, ...);</b></p>
<p style="margin-left:4%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<b>feature_test_macros</b>(7)):</p>
<p style="margin-left:9%; margin-top: 1em"><b>syscall</b>():
<br/>
Since glibc 2.19: <br/>
_DEFAULT_SOURCE <br/>
Before glibc 2.19: <br/>
_BSD_SOURCE || _SVID_SOURCE</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>syscall</b>()
is a small library function that invokes the system call
whose assembly language interface has the specified
<i>number</i> with the specified arguments. Employing
<b>syscall</b>() is useful, for example, when invoking a
system call that has no wrapper function in the C
library.</p>
<p style="margin-left:9%; margin-top: 1em"><b>syscall</b>()
saves CPU registers before making the system call, restores
the registers upon return from the system call, and stores
any error returned by the system call in
<b>errno</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">Symbolic
constants for system call numbers can be found in the header
file <i>&lt;sys/syscall.h&gt;</i>.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The return value
is defined by the system call being invoked. In general, a 0
return value indicates success. A −1 return value
indicates an error, and an error number is stored in
<i>errno</i>.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><b>ENOSYS</b></p></td>
<td width="1%"></td>
<td width="67%">
<p style="margin-top: 1em">The requested system call number
is not implemented.</p></td>
<td width="15%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Other errors are
specific to the invoked system call.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>syscall</b>()
first appeared in 4BSD.</p>
<h3>Architecture-specific requirements
<a name="Architecture-specific requirements"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Each
architecture ABI has its own requirements on how system call
arguments are passed to the kernel. For system calls that
have a glibc wrapper (e.g., most system calls), glibc
handles the details of copying arguments to the right
registers in a manner suitable for the architecture.
However, when using <b>syscall</b>() to make a system call,
the caller might need to handle architecture-dependent
details; this requirement is most commonly encountered on
certain 32-bit architectures.</p>
<p style="margin-left:9%; margin-top: 1em">For example, on
the ARM architecture Embedded ABI (EABI), a 64-bit value
(e.g., <i>long long</i>) must be aligned to an even register
pair. Thus, using <b>syscall</b>() instead of the wrapper
provided by glibc, the <b>readahead</b>(2) system call would
be invoked as follows on the ARM architecture with the EABI
in little endian mode:</p>
<p style="margin-left:14%; margin-top: 1em">syscall(SYS_readahead,
fd, 0, <br/>
(unsigned int) (offset &amp; 0xFFFFFFFF), <br/>
(unsigned int) (offset &gt;&gt; 32), <br/>
count);</p>
<p style="margin-left:9%; margin-top: 1em">Since the offset
argument is 64 bits, and the first argument (<i>fd</i>) is
passed in <i>r0</i>, the caller must manually split and
align the 64-bit value so that it is passed in the
<i>r2</i>/<i>r3</i> register pair. That means inserting a
dummy value into <i>r1</i> (the second argument of 0). Care
also must be taken so that the split follows endian
conventions (according to the C ABI for the platform).</p>
<p style="margin-left:9%; margin-top: 1em">Similar issues
can occur on MIPS with the O32 ABI, on PowerPC and parisc
with the 32-bit ABI, and on Xtensa.</p>
<p style="margin-left:9%; margin-top: 1em">Note that while
the parisc C ABI also uses aligned register pairs, it uses a
shim layer to hide the issue from user space.</p>
<p style="margin-left:9%; margin-top: 1em">The affected
system calls are <b>fadvise64_64</b>(2),
<b>ftruncate64</b>(2), <b>posix_fadvise</b>(2),
<b>pread64</b>(2), <b>pwrite64</b>(2), <b>readahead</b>(2),
<b>sync_file_range</b>(2), and <b>truncate64</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em">This does not
affect syscalls that manually split and assemble 64-bit
values such as <b>_llseek</b>(2), <b>preadv</b>(2),
<b>preadv2</b>(2), <b>pwritev</b>(2), and
<b>pwritev2</b>(2). Welcome to the wonderful world of
historical baggage.</p>
<h3>Architecture calling conventions
<a name="Architecture calling conventions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Every
architecture has its own way of invoking and passing
arguments to the kernel. The details for various
architectures are listed in the two tables below.</p>
<p style="margin-left:9%; margin-top: 1em">The first table
lists the instruction used to transition to kernel mode
(which might not be the fastest or best way to transition to
the kernel, so you might have to refer to <b>vdso</b>(7)),
the register used to indicate the system call number, the
register(s) used to return the system call result, and the
register used to signal an error.</p>
<p style="margin-left:9%; margin-top: 1em">Notes:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">On a few architectures, a
register is used as a boolean (0 indicating no error, and
−1 indicating an error) to signal that the system call
failed. The actual error value is still contained in the
return register. On sparc, the carry bit (<i>csr</i>) in the
processor status register (<i>psr</i>) is used instead of a
full register. On powerpc64, the summary overflow bit
(<i>SO</i>) in field 0 of the condition register
(<i>cr0</i>) is used.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>NR</i> is the system call number.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>For s390 and s390x, <i>NR</i> (the system call number)
may be passed directly with <i>svc NR</i> if it is less
than 256.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>On SuperH additional trap numbers are supported for
historic reasons, but <b>trapa</b>#31 is the recommended
"unified" ABI.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>The x32 ABI shares syscall table with x86-64 ABI, but
there are some nuances:</p></td></tr>
</table>
<p style="margin-left:13%;">•</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="83%">
<p style="margin-top: 1em">In order to indicate that a
system call is called under the x32 ABI, an additional bit,
<b>__X32_SYSCALL_BIT</b>, is bitwise ORed with the system
call number. The ABI used by a process affects some process
behaviors, including signal handling or system call
restarting.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p>Since x32 has different sizes for <i>long</i> and
pointer types, layouts of some (but not all; <i>struct
timeval</i> or <i>struct rlimit</i> are 64-bit, for example)
structures are different. In order to handle this,
additional system calls are added to the system call table,
starting from number 512 (without the
<b>__X32_SYSCALL_BIT</b>). For example, <b>__NR_readv</b> is
defined as 19 for the x86-64 ABI and as
<i>__X32_SYSCALL_BIT</i> | <b>515</b> for the x32 ABI. Most
of these additional system calls are actually identical to
the system calls used for providing i386 compat. There are
some notable exceptions, however, such as <b>preadv2</b>(2),
which uses <i>struct iovec</i> entities with 4-byte pointers
and sizes ("compat_iovec" in kernel terms), but
passes an 8-byte <i>pos</i> argument in a single register
and not two, as is done in every other ABI.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
</td></tr>
</table>
<p style="margin-left:13%; margin-top: 1em">Some
architectures (namely, Alpha, IA-64, MIPS, SuperH, sparc/32,
and sparc/64) use an additional register
("Retval2" in the above table) to pass back a
second return value from the <b>pipe</b>(2) system call;
Alpha uses this technique in the architecture-specific
<b>getxpid</b>(2), <b>getxuid</b>(2), and <b>getxgid</b>(2)
system calls as well. Other architectures do not use the
second return value register in the system call interface,
even if it is defined in the System V ABI.</p>
<p style="margin-left:9%; margin-top: 1em">The second table
shows the registers used to pass the system call
arguments.</p>
<p style="margin-left:9%; margin-top: 1em">Notes:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">The mips/o32 system call
convention passes arguments 5 through 8 on the user
stack.</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Note that these
tables don’t cover the entire calling
convention—some architectures may indiscriminately
clobber other registers not listed here.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#define
_GNU_SOURCE <br/>
#include &lt;signal.h&gt; <br/>
#include &lt;sys/syscall.h&gt; <br/>
#include &lt;sys/types.h&gt; <br/>
#include &lt;unistd.h&gt; <br/>
int <br/>
main(void) <br/>
{ <br/>
pid_t tid; <br/>
tid = syscall(SYS_gettid); <br/>
syscall(SYS_tgkill, getpid(), tid, SIGHUP); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>_syscall</b>(2),
<b>intro</b>(2), <b>syscalls</b>(2), <b>errno</b>(3),
<b>vdso</b>(7)</p>
<hr/>
</body>
</html>
