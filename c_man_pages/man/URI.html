<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:41:08 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>URI</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">URI</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#CONSTRUCTORS">CONSTRUCTORS</a><br/>
<a href="#COMMON METHODS">COMMON METHODS</a><br/>
<a href="#GENERIC METHODS">GENERIC METHODS</a><br/>
<a href="#SERVER METHODS">SERVER METHODS</a><br/>
<a href="#SCHEME−SPECIFIC SUPPORT">SCHEME−SPECIFIC SUPPORT</a><br/>
<a href="#CONFIGURATION VARIABLES">CONFIGURATION VARIABLES</a><br/>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#PARSING URIs WITH REGEXP">PARSING URIs WITH REGEXP</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<a href="#AUTHORS / ACKNOWLEDGMENTS">AUTHORS / ACKNOWLEDGMENTS</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">URI −
Uniform Resource Identifiers (absolute and relative)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use URI (); <br/>
$u1 = URI−&gt;new("http://www.example.com");
<br/>
$u2 = URI−&gt;new("foo", "http");
<br/>
$u3 = $u2−&gt;abs($u1); <br/>
$u4 = $u3−&gt;clone; <br/>
$u5 =
URI−&gt;new("HTTP://WWW.example.com:80")−&gt;canonical;
<br/>
$str = $u−&gt;as_string; <br/>
$str = "$u"; <br/>
$scheme = $u−&gt;scheme; <br/>
$opaque = $u−&gt;opaque; <br/>
$path = $u−&gt;path; <br/>
$frag = $u−&gt;fragment; <br/>
$u−&gt;scheme("ftp"); <br/>
$u−&gt;host("ftp.example.com"); <br/>
$u−&gt;path("cpan/");</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module
implements the "URI" class. Objects of this class
represent "Uniform Resource Identifier references"
as specified in RFC 2396 (and updated by RFC 2732).</p>
<p style="margin-left:9%; margin-top: 1em">A Uniform
Resource Identifier is a compact string of characters that
identifies an abstract or physical resource. A Uniform
Resource Identifier can be further classified as either a
Uniform Resource Locator (URL) or a Uniform Resource Name
(URN). The distinction between URL and URN does not matter
to the "URI" class interface. A
"URI−reference" is a URI that may have
additional information attached in the form of a fragment
identifier.</p>
<p style="margin-left:9%; margin-top: 1em">An absolute URI
reference consists of three parts: a <i>scheme</i>, a
<i>scheme−specific part</i> and a <i>fragment</i>
identifier. A subset of URI references share a common syntax
for hierarchical namespaces. For these, the
scheme−specific part is further broken down into
<i>authority</i>, <i>path</i> and <i>query</i> components.
These URIs can also take the form of relative URI
references, where the scheme (and usually also the
authority) component is missing, but implied by the context
of the URI reference. The three forms of URI reference
syntax are summarized as follows:</p>
<p style="margin-left:9%; margin-top: 1em">&lt;scheme&gt;:&lt;scheme−specific−part&gt;#&lt;fragment&gt;
<br/>

&lt;scheme&gt;://&lt;authority&gt;&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;
<br/>
&lt;path&gt;?&lt;query&gt;#&lt;fragment&gt;</p>
<p style="margin-left:9%; margin-top: 1em">The components
into which a URI reference can be divided depend on the
<i>scheme</i>. The "URI" class provides methods to
get and set the individual components. The methods available
for a specific "URI" object depend on the
scheme.</p>
<h2>CONSTRUCTORS
<a name="CONSTRUCTORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
methods construct new "URI" objects: <br/>
$uri = URI−&gt;new( $str ) <br/>
$uri = URI−&gt;new( $str, $scheme )</p>
<p style="margin-left:14%;">Constructs a new URI object.
The string representation of a URI is given as argument,
together with an optional scheme specification. Common URI
wrappers like "" and &lt;&gt;, as well as leading
and trailing white space, are automatically removed from the
$str argument before it is processed further.</p>
<p style="margin-left:14%; margin-top: 1em">The constructor
determines the scheme, maps this to an appropriate URI
subclass, constructs a new object of that class and returns
it.</p>
<p style="margin-left:14%; margin-top: 1em">If the scheme
isn't one of those that URI recognizes, you still get an URI
object back that you can access the generic methods on. The
"$uri−&gt;has_recognized_scheme" method can
be used to test for this.</p>
<p style="margin-left:14%; margin-top: 1em">The $scheme
argument is only used when $str is a relative URI. It can be
either a simple string that denotes the scheme, a string
containing an absolute URI reference, or an absolute
"URI" object. If no $scheme is specified for a
relative URI $str, then $str is simply treated as a generic
URI (no scheme−specific methods available).</p>
<p style="margin-left:14%; margin-top: 1em">The set of
characters available for building URI references is
restricted (see URI::Escape). Characters outside this set
are automatically escaped by the URI constructor.</p>
<p style="margin-left:9%;">$uri = URI−&gt;new_abs(
$str, $base_uri )</p>
<p style="margin-left:14%;">Constructs a new absolute URI
object. The $str argument can denote a relative or absolute
URI. If relative, then it is absolutized using $base_uri as
base. The $base_uri must be an absolute URI.</p>
<p style="margin-left:9%;">$uri = URI::file−&gt;new(
$filename ) <br/>
$uri = URI::file−&gt;new( $filename, $os )</p>
<p style="margin-left:14%;">Constructs a new <i>file</i>
URI from a file name. See URI::file.</p>
<p style="margin-left:9%;">$uri =
URI::file−&gt;new_abs( $filename ) <br/>
$uri = URI::file−&gt;new_abs( $filename, $os )</p>
<p style="margin-left:14%;">Constructs a new absolute
<i>file</i> URI from a file name. See URI::file.</p>
<p style="margin-left:9%;">$uri =
URI::file−&gt;cwd</p>
<p style="margin-left:14%;">Returns the current working
directory as a <i>file</i> URI. See URI::file.</p>
<p style="margin-left:9%;">$uri−&gt;clone</p>
<p style="margin-left:14%;">Returns a copy of the $uri.</p>
<h2>COMMON METHODS
<a name="COMMON METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The methods
described in this section are available for all
"URI" objects.</p>
<p style="margin-left:9%; margin-top: 1em">Methods that
give access to components of a URI always return the old
value of the component. The value returned is
"undef" if the component was not present. There is
generally a difference between a component that is empty
(represented as "") and a component that is
missing (represented as "undef"). If an accessor
method is given an argument, it updates the corresponding
component in addition to returning the old value of the
component. Passing an undefined argument removes the
component (if possible). The description of each accessor
method indicates whether the component is passed as an
escaped (percent−encoded) or an unescaped string. A
component that can be further divided into sub−parts
are usually passed escaped, as unescaping might change its
semantics.</p>
<p style="margin-left:9%; margin-top: 1em">The common
methods available for all URI are: <br/>
$uri−&gt;scheme <br/>
$uri−&gt;scheme( $new_scheme )</p>
<p style="margin-left:14%;">Sets and returns the scheme
part of the $uri. If the $uri is relative, then
$uri−&gt;scheme returns "undef". If called
with an argument, it updates the scheme of $uri, possibly
changing the class of $uri, and returns the old scheme
value. The method croaks if the new scheme name is illegal;
a scheme name must begin with a letter and must consist of
only US−ASCII letters, numbers, and a few special
marks: ".", "+", "−".
This restriction effectively means that the scheme must be
passed unescaped. Passing an undefined argument to the
scheme method makes the URI relative (if possible).</p>
<p style="margin-left:14%; margin-top: 1em">Letter case
does not matter for scheme names. The string returned by
$uri−&gt;scheme is always lowercase. If you want the
scheme just as it was written in the URI in its original
case, you can use the $uri−&gt;_scheme method
instead.</p>
<p style="margin-left:9%;">$uri−&gt;has_recognized_scheme</p>
<p style="margin-left:14%;">Returns TRUE if the URI scheme
is one that URI recognizes.</p>
<p style="margin-left:14%; margin-top: 1em">It will also be
TRUE for relative URLs where a recognized scheme was
provided to the constructor, even if
"$uri−&gt;scheme" returns "undef"
for these.</p>
<p style="margin-left:9%;">$uri−&gt;opaque <br/>
$uri−&gt;opaque( $new_opaque )</p>
<p style="margin-left:14%;">Sets and returns the
scheme−specific part of the $uri (everything between
the scheme and the fragment) as an escaped string.</p>
<p style="margin-left:9%;">$uri−&gt;path <br/>
$uri−&gt;path( $new_path )</p>
<p style="margin-left:14%;">Sets and returns the same value
as $uri−&gt;opaque unless the URI supports the generic
syntax for hierarchical namespaces. In that case the generic
method is overridden to set and return the part of the URI
between the <i>host name</i> and the <i>fragment</i>.</p>
<p style="margin-left:9%;">$uri−&gt;fragment <br/>
$uri−&gt;fragment( $new_frag )</p>
<p style="margin-left:14%;">Returns the fragment identifier
of a URI reference as an escaped string.</p>
<p style="margin-left:9%;">$uri−&gt;as_string</p>
<p style="margin-left:14%;">Returns a URI object to a plain
ASCII string. URI objects are also converted to plain
strings automatically by overloading. This means that $uri
objects can be used as plain strings in most Perl
constructs.</p>
<p style="margin-left:9%;">$uri−&gt;as_iri</p>
<p style="margin-left:14%;">Returns a Unicode string
representing the URI. Escaped UTF−8 sequences
representing non−ASCII characters are turned into
their corresponding Unicode code point.</p>
<p style="margin-left:9%;">$uri−&gt;canonical</p>
<p style="margin-left:14%;">Returns a normalized version of
the URI. The rules for normalization are
scheme−dependent. They usually involve lowercasing the
scheme and Internet host name components, removing the
explicit port specification if it matches the default port,
uppercasing all escape sequences, and unescaping octets that
can be better represented as plain characters.</p>
<p style="margin-left:14%; margin-top: 1em">For efficiency
reasons, if the $uri is already in normalized form, then a
reference to it is returned instead of a copy.</p>
<p style="margin-left:9%;">$uri−&gt;eq( $other_uri )
<br/>
URI::eq( $first_uri, $other_uri )</p>
<p style="margin-left:14%;">Tests whether two URI
references are equal. URI references that normalize to the
same string are considered equal. The method can also be
used as a plain function which can also test two string
arguments.</p>
<p style="margin-left:14%; margin-top: 1em">If you need to
test whether two "URI" object references denote
the same object, use the '==' operator.</p>
<p style="margin-left:9%;">$uri−&gt;abs( $base_uri
)</p>
<p style="margin-left:14%;">Returns an absolute URI
reference. If $uri is already absolute, then a reference to
it is simply returned. If the $uri is relative, then a new
absolute URI is constructed by combining the $uri and the
$base_uri, and returned.</p>
<p style="margin-left:9%;">$uri−&gt;rel( $base_uri
)</p>
<p style="margin-left:14%;">Returns a relative URI
reference if it is possible to make one that denotes the
same resource relative to $base_uri. If not, then $uri is
simply returned.</p>
<p style="margin-left:9%;">$uri−&gt;secure</p>
<p style="margin-left:14%;">Returns a TRUE value if the URI
is considered to point to a resource on a secure channel,
such as an SSL or TLS encrypted one.</p>
<h2>GENERIC METHODS
<a name="GENERIC METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
methods are available to schemes that use the common/generic
syntax for hierarchical namespaces. The descriptions of
schemes below indicate which these are. Unrecognized schemes
are assumed to support the generic syntax, and therefore the
following methods: <br/>
$uri−&gt;authority <br/>
$uri−&gt;authority( $new_authority )</p>
<p style="margin-left:14%;">Sets and returns the escaped
authority component of the $uri.</p>
<p style="margin-left:9%;">$uri−&gt;path <br/>
$uri−&gt;path( $new_path )</p>
<p style="margin-left:14%;">Sets and returns the escaped
path component of the $uri (the part between the host name
and the query or fragment). The path can never be undefined,
but it can be the empty string.</p>
<p style="margin-left:9%;">$uri−&gt;path_query <br/>
$uri−&gt;path_query( $new_path_query )</p>
<p style="margin-left:14%;">Sets and returns the escaped
path and query components as a single entity. The path and
the query are separated by a "?" character, but
the query can itself contain "?".</p>
<p style="margin-left:9%;">$uri−&gt;path_segments
<br/>
$uri−&gt;path_segments( $segment, ... )</p>
<p style="margin-left:14%;">Sets and returns the path. In a
scalar context, it returns the same value as
$uri−&gt;path. In a list context, it returns the
unescaped path segments that make up the path. Path segments
that have parameters are returned as an anonymous array. The
first element is the unescaped path segment proper;
subsequent elements are escaped parameter strings. Such an
anonymous array uses overloading so it can be treated as a
string too, but this string does not include the
parameters.</p>
<p style="margin-left:14%; margin-top: 1em">Note that
absolute paths have the empty string as their first
<i>path_segment</i>, i.e. the <i>path</i>
"/foo/bar" have 3 <i>path_segments</i>;
"", "foo" and "bar".</p>
<p style="margin-left:9%;">$uri−&gt;query <br/>
$uri−&gt;query( $new_query )</p>
<p style="margin-left:14%;">Sets and returns the escaped
query component of the $uri.</p>
<p style="margin-left:9%;">$uri−&gt;query_form <br/>
$uri−&gt;query_form( $key1 =&gt; $val1, $key2 =&gt;
$val2, ... ) <br/>
$uri−&gt;query_form( $key1 =&gt; $val1, $key2 =&gt;
$val2, ..., $delim ) <br/>
$uri−&gt;query_form( \@key_value_pairs ) <br/>
$uri−&gt;query_form( \@key_value_pairs, $delim ) <br/>
$uri−&gt;query_form( \%hash ) <br/>
$uri−&gt;query_form( \%hash, $delim )</p>
<p style="margin-left:14%;">Sets and returns query
components that use the
<i>application/x−www−form−urlencoded</i>
format. Key/value pairs are separated by "&amp;",
and the key is separated from the value by a "="
character.</p>
<p style="margin-left:14%; margin-top: 1em">The form can be
set either by passing separate key/value pairs, or via an
array or hash reference. Passing an empty array or an empty
hash removes the query component, whereas passing no
arguments at all leaves the component unchanged. The order
of keys is undefined if a hash reference is passed. The old
value is always returned as a list of separate key/value
pairs. Assigning this list to a hash is unwise as the keys
returned might repeat.</p>
<p style="margin-left:14%; margin-top: 1em">The values
passed when setting the form can be plain strings or
references to arrays of strings. Passing an array of values
has the same effect as passing the key repeatedly with one
value at a time. All the following statements have the same
effect:</p>
<p style="margin-left:14%; margin-top: 1em">$uri−&gt;query_form(foo
=&gt; 1, foo =&gt; 2); <br/>
$uri−&gt;query_form(foo =&gt; [1, 2]); <br/>
$uri−&gt;query_form([ foo =&gt; 1, foo =&gt; 2 ]);
<br/>
$uri−&gt;query_form([ foo =&gt; [1, 2] ]); <br/>
$uri−&gt;query_form({ foo =&gt; [1, 2] });</p>
<p style="margin-left:14%; margin-top: 1em">The $delim
parameter can be passed as ";" to force the
key/value pairs to be delimited by ";" instead of
"&amp;" in the query string. This practice is
often recommended for URLs embedded in HTML or XML documents
as this avoids the trouble of escaping the "&amp;"
character. You might also set the
$URI::DEFAULT_QUERY_FORM_DELIMITER variable to ";"
for the same global effect.</p>
<p style="margin-left:9%;">@keys = $u−&gt;query_param
<br/>
@values = $u−&gt;query_param( $key ) <br/>
$first_value = $u−&gt;query_param( $key ) <br/>
$u−&gt;query_param( $key, $value,... )</p>
<p style="margin-left:14%;">If $u−&gt;query_param is
called with no arguments, it returns all the distinct
parameter keys of the URI. In a scalar context it returns
the number of distinct keys.</p>
<p style="margin-left:14%; margin-top: 1em">When a $key
argument is given, the method returns the parameter values
with the given key. In a scalar context, only the first
parameter value is returned.</p>
<p style="margin-left:14%; margin-top: 1em">If additional
arguments are given, they are used to update successive
parameters with the given key. If any of the values provided
are array references, then the array is dereferenced to get
the actual values.</p>
<p style="margin-left:14%; margin-top: 1em">Please note
that you can supply multiple values to this method, but you
cannot supply multiple keys.</p>
<p style="margin-left:14%; margin-top: 1em">Do this:</p>
<p style="margin-left:14%; margin-top: 1em">$uri−&gt;query_param(
widget_id =&gt; 1, 5, 9 );</p>
<p style="margin-left:14%; margin-top: 1em">Do NOT do
this:</p>
<p style="margin-left:14%; margin-top: 1em">$uri−&gt;query_param(
widget_id =&gt; 1, frobnicator_id =&gt; 99 );</p>
<p style="margin-left:9%;">$u−&gt;query_param_append($key,
$value,...)</p>
<p style="margin-left:14%;">Adds new parameters with the
given key without touching any old parameters with the same
key. It can be explained as a more efficient version of:</p>
<p style="margin-left:14%; margin-top: 1em">$u−&gt;query_param($key,
<br/>
$u−&gt;query_param($key), <br/>
$value,...);</p>
<p style="margin-left:14%; margin-top: 1em">One difference
is that this expression would return the old values of $key,
whereas the <b>query_param_append()</b> method does not.</p>
<p style="margin-left:9%;">@values =
$u−&gt;query_param_delete($key) <br/>
$first_value = $u−&gt;query_param_delete($key)</p>
<p style="margin-left:14%;">Deletes all key/value pairs
with the given key. The old values are returned. In a scalar
context, only the first value is returned.</p>
<p style="margin-left:14%; margin-top: 1em">Using the
<b>query_param_delete()</b> method is slightly more
efficient than the equivalent:</p>
<p style="margin-left:14%; margin-top: 1em">$u−&gt;query_param($key,
[]);</p>
<p style="margin-left:9%;">$hashref =
$u−&gt;query_form_hash <br/>
$u−&gt;query_form_hash( \%new_form )</p>
<p style="margin-left:14%;">Returns a reference to a hash
that represents the query form's key/value pairs. If a key
occurs multiple times, then the hash value becomes an array
reference.</p>
<p style="margin-left:14%; margin-top: 1em">Note that
sequence information is lost. This means that:</p>
<p style="margin-left:14%; margin-top: 1em">$u−&gt;query_form_hash($u−&gt;query_form_hash);</p>
<p style="margin-left:14%; margin-top: 1em">is not
necessarily a no−op, as it may reorder the key/value
pairs. The values returned by the <b>query_param()</b>
method should stay the same though.</p>
<p style="margin-left:9%;">$uri−&gt;query_keywords
<br/>
$uri−&gt;query_keywords( $keywords, ... ) <br/>
$uri−&gt;query_keywords( \@keywords )</p>
<p style="margin-left:14%;">Sets and returns query
components that use the keywords separated by "+"
format.</p>
<p style="margin-left:14%; margin-top: 1em">The keywords
can be set either by passing separate keywords directly or
by passing a reference to an array of keywords. Passing an
empty array removes the query component, whereas passing no
arguments at all leaves the component unchanged. The old
value is always returned as a list of separate words.</p>
<h2>SERVER METHODS
<a name="SERVER METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">For schemes
where the <i>authority</i> component denotes an Internet
host, the following methods are available in addition to the
generic methods. <br/>
$uri−&gt;userinfo <br/>
$uri−&gt;userinfo( $new_userinfo )</p>
<p style="margin-left:14%;">Sets and returns the escaped
userinfo part of the authority component.</p>
<p style="margin-left:14%; margin-top: 1em">For some
schemes this is a user name and a password separated by a
colon. This practice is not recommended. Embedding passwords
in clear text (such as URI) has proven to be a security risk
in almost every case where it has been used.</p>
<p style="margin-left:9%;">$uri−&gt;host <br/>
$uri−&gt;host( $new_host )</p>
<p style="margin-left:14%;">Sets and returns the unescaped
hostname.</p>
<p style="margin-left:14%; margin-top: 1em">If the
$new_host string ends with a colon and a number, then this
number also sets the port.</p>
<p style="margin-left:14%; margin-top: 1em">For IPv6
addresses the brackets around the raw address is removed in
the return value from $uri−&gt;host. When setting the
host attribute to an IPv6 address you can use a raw address
or one enclosed in brackets. The address needs to be
enclosed in brackets if you want to pass in a new port value
as well.</p>
<p style="margin-left:14%; margin-top: 1em">my $uri =
URI−&gt;new("http://www.\xC3\xBCri−sample/foo/bar.html");
<br/>
print $u−&gt;host; #
www.xn−−ri−sample−fra0f</p>
<p style="margin-left:9%;">$uri−&gt;ihost</p>
<p style="margin-left:14%;">Returns the host in Unicode
form. Any IDNA A−labels (encoded unicode chars with
<i>xn−−</i> prefix) are turned into
U−labels (unicode chars).</p>
<p style="margin-left:14%; margin-top: 1em">my $uri =
URI−&gt;new("http://www.\xC3\xBCri−sample/foo/bar.html");
<br/>
print $u−&gt;ihost; # www.\xC3\xBCri−sample</p>
<p style="margin-left:9%;">$uri−&gt;port <br/>
$uri−&gt;port( $new_port )</p>
<p style="margin-left:14%;">Sets and returns the port. The
port is a simple integer that should be greater than 0.</p>
<p style="margin-left:14%; margin-top: 1em">If a port is
not specified explicitly in the URI, then the URI scheme's
default port is returned. If you don't want the default port
substituted, then you can use the $uri−&gt;_port
method instead.</p>
<p style="margin-left:9%;">$uri−&gt;host_port <br/>
$uri−&gt;host_port( $new_host_port )</p>
<p style="margin-left:14%;">Sets and returns the host and
port as a single unit. The returned value includes a port,
even if it matches the default port. The host part and the
port part are separated by a colon: ":".</p>
<p style="margin-left:14%; margin-top: 1em">For IPv6
addresses the bracketing is preserved; thus
URI−&gt;new("http://[::1]/")−&gt;host_port
returns "[::1]:80". Contrast this with
$uri−&gt;host which will remove the brackets.</p>
<p style="margin-left:9%;">$uri−&gt;default_port</p>
<p style="margin-left:14%;">Returns the default port of the
URI scheme to which $uri belongs. For <i>http</i> this is
the number 80, for <i>ftp</i> this is the number 21, etc.
The default port for a scheme can not be changed.</p>
<h2>SCHEME−SPECIFIC SUPPORT
<a name="SCHEME−SPECIFIC SUPPORT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Scheme−specific
support is provided for the following URI schemes. For
"URI" objects that do not belong to one of these,
you can only use the common and generic methods. <b><br/>
data</b>:</p>
<p style="margin-left:14%;">The <i>data</i> URI scheme is
specified in RFC 2397. It allows inclusion of small data
items as "immediate" data, as if it had been
included externally.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the data scheme support the common
methods and two new methods to access their
scheme−specific components: $uri−&gt;media_type
and $uri−&gt;data. See URI::data for details.</p>
<p style="margin-left:9%;"><b>file</b>:</p>
<p style="margin-left:14%;">An old specification of the
<i>file</i> URI scheme is found in RFC 1738. A new RFC 2396
based specification in not available yet, but file URI
references are in common use.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the file scheme support the common and
generic methods. In addition, they provide two methods for
mapping file URIs back to local file names;
$uri−&gt;file and $uri−&gt;dir. See URI::file
for details.</p>
<p style="margin-left:9%;"><b>ftp</b>:</p>
<p style="margin-left:14%;">An old specification of the
<i>ftp</i> URI scheme is found in RFC 1738. A new RFC 2396
based specification in not available yet, but ftp URI
references are in common use.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the ftp scheme support the common,
generic and server methods. In addition, they provide two
methods for accessing the userinfo sub−components:
$uri−&gt;user and $uri−&gt;password.</p>
<p style="margin-left:14%; margin-top: 1em">It also
supports accessing to the encryption mode
($uri−&gt;encrypt_mode), which has its own defaults
for <i>ftps</i> and <i>ftpes</i> URI schemes.</p>
<p style="margin-left:9%;"><b>gopher</b>:</p>
<p style="margin-left:14%;">The <i>gopher</i> URI scheme is
specified in
&lt;draft−murali−url−gopher−1996−12−04&gt;
and will hopefully be available as a RFC 2396 based
specification.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the gopher scheme support the common,
generic and server methods. In addition, they support some
methods for accessing gopher−specific path components:
$uri−&gt;gopher_type, $uri−&gt;selector,
$uri−&gt;search, $uri−&gt;string.</p>
<p style="margin-left:9%;"><b>http</b>:</p>
<p style="margin-left:14%;">The <i>http</i> URI scheme is
specified in RFC 2616. The scheme is used to reference
resources hosted by HTTP servers.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the http scheme support the common,
generic and server methods.</p>
<p style="margin-left:9%;"><b>https</b>:</p>
<p style="margin-left:14%;">The <i>https</i> URI scheme is
a Netscape invention which is commonly implemented. The
scheme is used to reference HTTP servers through SSL
connections. Its syntax is the same as http, but the default
port is different.</p>
<p style="margin-left:9%;"><b>geo</b>:</p>
<p style="margin-left:14%;">The <i>geo</i> URI scheme is
specified in RFC 5870
&lt;http://tools.ietf.org/html/rfc5870&gt;. The scheme is
used to reference physical location in a two− or
three−dimensional coordinate reference system in a
compact, simple, human−readable, and
protocol−independent way.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the geo scheme support the common
methods.</p>
<p style="margin-left:9%;"><b>icap</b>:</p>
<p style="margin-left:14%;">The <i>icap</i> URI scheme is
specified in RFC 3507
&lt;http://tools.ietf.org/html/rfc3507&gt;. The scheme is
used to reference resources hosted by ICAP servers.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the icap scheme support the common,
generic and server methods.</p>
<p style="margin-left:9%;"><b>icaps</b>:</p>
<p style="margin-left:14%;">The <i>icaps</i> URI scheme is
specified in RFC 3507
&lt;http://tools.ietf.org/html/rfc3507&gt; as well. The
scheme is used to reference ICAP servers through SSL
connections. Its syntax is the same as icap, including the
same default port.</p>
<p style="margin-left:9%;"><b>irc</b>:</p>
<p style="margin-left:14%;">The <i>irc</i> URI scheme is
specified in
draft−butcher−irc−url−04
&lt;https://datatracker.ietf.org/doc/html/draft-butcher-irc-url-04&gt;.
The scheme is used to reference IRC servers and their
resources.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the irc or ircs scheme support login
methods, and the following IRC−specific ones:
$uri−&gt;entity, $uri−&gt;flags,
$uri−&gt;options.</p>
<p style="margin-left:9%;"><b>ldap</b>:</p>
<p style="margin-left:14%;">The <i>ldap</i> URI scheme is
specified in RFC 2255. LDAP is the Lightweight Directory
Access Protocol. An ldap URI describes an LDAP search
operation to perform to retrieve information from an LDAP
directory.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the ldap scheme support the common,
generic and server methods as well as ldap−specific
methods: $uri−&gt;dn, $uri−&gt;attributes,
$uri−&gt;scope, $uri−&gt;filter,
$uri−&gt;extensions. See URI::ldap for details.</p>
<p style="margin-left:9%;"><b>ldapi</b>:</p>
<p style="margin-left:14%;">Like the <i>ldap</i> URI
scheme, but uses a UNIX domain socket. The server methods
are not supported, and the local socket path is available as
$uri−&gt;un_path. The <i>ldapi</i> scheme is used by
the OpenLDAP package. There is no real specification for it,
but it is mentioned in various OpenLDAP manual pages.</p>
<p style="margin-left:9%;"><b>ldaps</b>:</p>
<p style="margin-left:14%;">Like the <i>ldap</i> URI
scheme, but uses an SSL connection. This scheme is
deprecated, as the preferred way is to use the
<i>start_tls</i> mechanism.</p>
<p style="margin-left:9%;"><b>mailto</b>:</p>
<p style="margin-left:14%;">The <i>mailto</i> URI scheme is
specified in RFC 2368. The scheme was originally used to
designate the Internet mailing address of an individual or
service. It has (in RFC 2368) been extended to allow setting
of other mail header fields and the message body.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the mailto scheme support the common
methods and the generic query methods. In addition, they
support the following mailto−specific methods:
$uri−&gt;to, $uri−&gt;headers.</p>
<p style="margin-left:14%; margin-top: 1em">Note that the
"foo@example.com" part of a mailto is <i>not</i>
the "userinfo" and "host" but instead
the "path". This allows a mailto URI to contain
multiple comma separated email addresses.</p>
<p style="margin-left:9%;"><b>mms</b>:</p>
<p style="margin-left:14%;">The <i>mms</i> URL
specification can be found at &lt;http://sdp.ppona.com/&gt;.
"URI" objects belonging to the mms scheme support
the common, generic, and server methods, with the exception
of userinfo and query−related
sub−components.</p>
<p style="margin-left:9%;"><b>news</b>:</p>
<p style="margin-left:14%;">The <i>news</i>, <i>nntp</i>
and <i>snews</i> URI schemes are specified in
&lt;draft−gilman−news−url−01&gt; and
will hopefully be available as an RFC 2396 based
specification soon. (Update: as of April 2010, they are in
RFC 5538 &lt;https://tools.ietf.org/html/rfc5538&gt;.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the news scheme support the common,
generic and server methods. In addition, they provide some
methods to access the path: $uri−&gt;group and
$uri−&gt;message.</p>
<p style="margin-left:9%;"><b>nntp</b>:</p>
<p style="margin-left:14%;">See <i>news</i> scheme.</p>
<p style="margin-left:9%;"><b>nntps</b>:</p>
<p style="margin-left:14%;">See <i>news</i> scheme and RFC
5538 &lt;https://tools.ietf.org/html/rfc5538&gt;.</p>
<p style="margin-left:9%;"><b>otpauth</b>:</p>
<p style="margin-left:14%;">The <i>otpauth</i> URI scheme
is specified in
&lt;https://github.com/google/google−authenticator/wiki/Key−Uri−Format&gt;.
The scheme is used to encode secret keys for use in TOTP or
HOTP schemes.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the otpauth scheme support the common
methods.</p>
<p style="margin-left:9%;"><b>pop</b>:</p>
<p style="margin-left:14%;">The <i>pop</i> URI scheme is
specified in RFC 2384. The scheme is used to reference a
POP3 mailbox.</p>
<p style="margin-left:14%; margin-top: 1em">"URI"
objects belonging to the pop scheme support the common,
generic and server methods. In addition, they provide two
methods to access the userinfo components:
$uri−&gt;user and $uri−&gt;auth</p>
<p style="margin-left:9%;"><b>rlogin</b>:</p>
<p style="margin-left:14%;">An old specification of the
<i>rlogin</i> URI scheme is found in RFC 1738.
"URI" objects belonging to the rlogin scheme
support the common, generic and server methods.</p>
<p style="margin-left:9%;"><b>rtsp</b>:</p>
<p style="margin-left:14%;">The <i>rtsp</i> URL
specification can be found in section 3.2 of RFC 2326.
"URI" objects belonging to the rtsp scheme support
the common, generic, and server methods, with the exception
of userinfo and query−related
sub−components.</p>
<p style="margin-left:9%;"><b>rtspu</b>:</p>
<p style="margin-left:14%;">The <i>rtspu</i> URI scheme is
used to talk to RTSP servers over UDP instead of TCP. The
syntax is the same as rtsp.</p>
<p style="margin-left:9%;"><b>rsync</b>:</p>
<p style="margin-left:14%;">Information about rsync is
available from &lt;http://rsync.samba.org/&gt;.
"URI" objects belonging to the rsync scheme
support the common, generic and server methods. In addition,
they provide methods to access the userinfo
sub−components: $uri−&gt;user and
$uri−&gt;password.</p>
<p style="margin-left:9%;"><b>sip</b>:</p>
<p style="margin-left:14%;">The <i>sip</i> URI
specification is described in sections 19.1 and 25 of RFC
3261. "URI" objects belonging to the sip scheme
support the common, generic, and server methods with the
exception of path related sub−components. In addition,
they provide two methods to get and set <i>sip</i>
parameters: $uri−&gt;params_form and
$uri−&gt;params.</p>
<p style="margin-left:9%;"><b>sips</b>:</p>
<p style="margin-left:14%;">See <i>sip</i> scheme. Its
syntax is the same as sip, but the default port is
different.</p>
<p style="margin-left:9%;"><b>snews</b>:</p>
<p style="margin-left:14%;">See <i>news</i> scheme. Its
syntax is the same as news, but the default port is
different.</p>
<p style="margin-left:9%;"><b>telnet</b>:</p>
<p style="margin-left:14%;">An old specification of the
<i>telnet</i> URI scheme is found in RFC 1738.
"URI" objects belonging to the telnet scheme
support the common, generic and server methods.</p>
<p style="margin-left:9%;"><b>tn3270</b>:</p>
<p style="margin-left:14%;">These URIs are used like
<i>telnet</i> URIs but for connections to IBM mainframes.
"URI" objects belonging to the tn3270 scheme
support the common, generic and server methods.</p>
<p style="margin-left:9%;"><b>ssh</b>:</p>
<p style="margin-left:14%;">Information about ssh is
available at &lt;http://www.openssh.com/&gt;.
"URI" objects belonging to the ssh scheme support
the common, generic and server methods. In addition, they
provide methods to access the userinfo sub−components:
$uri−&gt;user and $uri−&gt;password.</p>
<p style="margin-left:9%;"><b>sftp</b>:</p>
<p style="margin-left:14%;">"URI" objects
belonging to the sftp scheme support the common, generic and
server methods. In addition, they provide methods to access
the userinfo sub−components: $uri−&gt;user and
$uri−&gt;password.</p>
<p style="margin-left:9%;"><b>urn</b>:</p>
<p style="margin-left:14%;">The syntax of Uniform Resource
Names is specified in RFC 2141. "URI" objects
belonging to the urn scheme provide the common methods, and
also the methods $uri−&gt;nid and $uri−&gt;nss,
which return the Namespace Identifier and the
Namespace−Specific String respectively.</p>
<p style="margin-left:14%; margin-top: 1em">The Namespace
Identifier basically works like the Scheme identifier of
URIs, and further divides the URN namespace. Namespace
Identifier assignments are maintained at
&lt;http://www.iana.org/assignments/urn−namespaces&gt;.</p>
<p style="margin-left:14%; margin-top: 1em">Letter case is
not significant for the Namespace Identifier. It is always
returned in lower case by the $uri−&gt;nid method. The
$uri−&gt;_nid method can be used if you want it in its
original case.</p>
<p style="margin-left:9%;"><b>urn</b>:<b>isbn</b>:</p>
<p style="margin-left:14%;">The "urn:isbn:"
namespace contains International Standard Book Numbers
(ISBNs) and is described in RFC 3187. A "URI"
object belonging to this namespace has the following extra
methods (if the Business::ISBN module is available):
$uri−&gt;isbn, $uri−&gt;isbn_publisher_code,
$uri−&gt;isbn_group_code (formerly isbn_country_code,
which is still supported by issues a deprecation warning),
$uri−&gt;isbn_as_ean.</p>
<p style="margin-left:9%;"><b>urn</b>:<b>oid</b>:</p>
<p style="margin-left:14%;">The "urn:oid:"
namespace contains Object Identifiers (OIDs) and is
described in RFC 3061. An object identifier consists of
sequences of digits separated by dots. A "URI"
object belonging to this namespace has an additional method
called $uri−&gt;oid that can be used to get/set the
oid value. In a list context, oid numbers are returned as
separate elements.</p>
<h2>CONFIGURATION VARIABLES
<a name="CONFIGURATION VARIABLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
configuration variables influence how the class and its
methods behave: <br/>
$URI::ABS_ALLOW_RELATIVE_SCHEME</p>
<p style="margin-left:14%;">Some older parsers used to
allow the scheme name to be present in the relative URL if
it was the same as the base URL scheme. RFC 2396 says that
this should be avoided, but you can enable this old
behaviour by setting the $URI::ABS_ALLOW_RELATIVE_SCHEME
variable to a TRUE value. The difference is demonstrated by
the following examples:</p>
<p style="margin-left:14%; margin-top: 1em">URI−&gt;new("http:foo")−&gt;abs("http://host/a/b")
<br/>
==&gt; "http:foo" <br/>
local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1; <br/>

URI−&gt;new("http:foo")−&gt;abs("http://host/a/b")
<br/>
==&gt; "http:/host/a/foo"</p>
<p style="margin-left:9%;">$URI::ABS_REMOTE_LEADING_DOTS</p>
<p style="margin-left:14%;">You can also have the
<b>abs()</b> method ignore excess ".." segments in
the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS to
a TRUE value. The difference is demonstrated by the
following examples:</p>
<p style="margin-left:14%; margin-top: 1em">URI−&gt;new("../../../foo")−&gt;abs("http://host/a/b")
<br/>
==&gt; "http://host/../../foo" <br/>
local $URI::ABS_REMOTE_LEADING_DOTS = 1; <br/>

URI−&gt;new("../../../foo")−&gt;abs("http://host/a/b")
<br/>
==&gt; "http://host/foo"</p>
<p style="margin-left:9%;">$URI::DEFAULT_QUERY_FORM_DELIMITER</p>
<p style="margin-left:14%;">This value can be set to
";" to have the query form "key=value"
pairs delimited by ";" instead of
"&amp;" which is the default.</p>
<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">URI_HAS_RESERVED_SQUARE_BRACKETS</p>
<p style="margin-left:14%;">Before version 5.11, URI
treated square brackets as reserved characters throughout
the whole URI string. However, these brackets are reserved
only within the authority/host part of the URI and nowhere
else (RFC 3986).</p>
<p style="margin-left:14%; margin-top: 1em">Starting with
version 5.11, URI takes this distinction into account.
Setting the environment variable
"URI_HAS_RESERVED_SQUARE_BRACKETS"
(programmatically or via the shell), restores the old
behavior.</p>
<p style="margin-left:14%; margin-top: 1em">#−−
restore 5.10 behavior programmatically <br/>
BEGIN { <br/>
$ENV{URI_HAS_RESERVED_SQUARE_BRACKETS} = 1; <br/>
} <br/>
use URI ();</p>
<p style="margin-left:14%; margin-top: 1em"><i>Note</i>:
This environment variable is just used during initialization
and has to be set <i><br/>
before</i> module URI is used/required. Changing it at run
time has no effect.</p>
<p style="margin-left:14%; margin-top: 1em">Its value can
be checked programmatically by accessing the constant
"URI::HAS_RESERVED_SQUARE_BRACKETS".</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">There are some
things that are not quite right:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="81%">
<p>Using regexp variables like $1 directly as arguments to
the URI accessor methods does not work too well with current
perl implementations. I would argue that this is actually a
bug in perl. The workaround is to quote them. Example:</p></td>
<td width="5%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">/(...)/ || die;
<br/>
$u−&gt;query("$1");</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">The escaping (percent encoding)
of chars in the 128 .. 255 range passed to the URI
constructor or when setting URI parts using the accessor
methods depend on the state of the internal UTF8 flag (see
utf8::is_utf8) of the string passed. If the UTF8 flag is set
the UTF−8 encoded version of the character is percent
encoded. If the UTF8 flag isn't set the Latin−1
version (byte) of the character is percent encoded. This
basically exposes the internal encoding of Perl strings.</p></td></tr>
</table>
<h2>PARSING URIs WITH REGEXP
<a name="PARSING URIs WITH REGEXP"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">As an
alternative to this module, the following (official) regular
expression can be used to decode a URI:</p>
<p style="margin-left:9%; margin-top: 1em">my($scheme,
$authority, $path, $query, $fragment) = <br/>
$uri =˜
m|(?:([ˆ:/?#]+):)?(?://([ˆ/?#]*))?([ˆ?#]*)(?:\?([ˆ#]*))?(?:#(.*))?|;</p>
<p style="margin-left:9%; margin-top: 1em">The
"URI::Split" module provides the function
<b>uri_split()</b> as a readable alternative.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">URI::file,
URI::WithBase, URI::Escape, URI::Split, URI::Heuristic</p>
<p style="margin-left:9%; margin-top: 1em">RFC 2396:
"Uniform Resource Identifiers (URI): Generic
Syntax", Berners−Lee, Fielding, Masinter, August
1998.</p>
<p style="margin-left:9%; margin-top: 1em">&lt;http://www.iana.org/assignments/uri−schemes&gt;</p>
<p style="margin-left:9%; margin-top: 1em">&lt;http://www.iana.org/assignments/urn−namespaces&gt;</p>
<p style="margin-left:9%; margin-top: 1em">&lt;http://www.w3.org/Addressing/&gt;</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
1995−2009 Gisle Aas.</p>
<p style="margin-left:9%; margin-top: 1em">Copyright 1995
Martijn Koster.</p>
<p style="margin-left:9%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<h2>AUTHORS / ACKNOWLEDGMENTS
<a name="AUTHORS / ACKNOWLEDGMENTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module is
based on the "URI::URL" module, which in turn was
(distantly) based on the "wwwurl.pl" code in the
libwww−perl for perl4 developed by Roy Fielding, as
part of the Arcadia project at the University of California,
Irvine, with contributions from Brooks Cutter.</p>
<p style="margin-left:9%; margin-top: 1em">"URI::URL"
was developed by Gisle Aas, Tim Bunce, Roy Fielding and
Martijn Koster with input from other people on the
libwww−perl mailing list.</p>
<p style="margin-left:9%; margin-top: 1em">"URI"
and related subclasses was developed by Gisle Aas.</p>
<hr/>
</body>
</html>
