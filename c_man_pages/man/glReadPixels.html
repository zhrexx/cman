<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:44:47 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GLREADPIXELS</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">GLREADPIXELS</h1>
<a href="#NAME">NAME</a><br/>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br/>
<a href="#PARAMETERS">PARAMETERS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#ASSOCIATED GETS">ASSOCIATED GETS</a><br/>
<a href="#VERSION SUPPORT">VERSION SUPPORT</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">glReadPixels,
glReadnPixels − read a block of pixels from the frame
buffer</p>
<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="86%">
<p style="margin-top: 1em"><b>void
glReadPixels(GLint </b><i>x</i><b>,
GLint </b><i>y</i><b>,
GLsizei </b><i>width</i><b>,
GLsizei </b><i>height</i><b>,
GLenum </b><i>format</i><b>,
GLenum </b><i>type</i><b>,
GLvoid * </b><i>data</i><b>);</b></p> </td>
<td width="5%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="86%">
<p style="margin-top: 1em"><b>void
glReadnPixels(GLint </b><i>x</i><b>,
GLint </b><i>y</i><b>,
GLsizei </b><i>width</i><b>,
GLsizei </b><i>height</i><b>,
GLenum </b><i>format</i><b>,
GLenum </b><i>type</i><b>,
GLsizei </b><i>bufSize</i><b>,
void *</b><i>data</i><b>);</b></p> </td>
<td width="5%">
</td></tr>
</table>
<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b><i>x</i></b>,
<i>y</i></p>
<p style="margin-left:14%;">Specify the window coordinates
of the first pixel that is read from the frame buffer. This
location is the lower left corner of a rectangular block of
pixels.</p>
<p style="margin-left:9%; margin-top: 1em"><i>width</i>,
<i>height</i></p>
<p style="margin-left:14%;">Specify the dimensions of the
pixel rectangle. <i>width</i> and <i>height</i> of one
correspond to a single pixel.</p>
<p style="margin-left:9%; margin-top: 1em"><i>format</i></p>
<p style="margin-left:14%;">Specifies the format of the
pixel data. The following symbolic values are accepted:
<b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
<b>GL_DEPTH_STENCIL</b>, <b>GL_RED</b>, <b>GL_GREEN</b>,
<b>GL_BLUE</b>, <b>GL_RGB</b>, <b>GL_BGR</b>,
<b>GL_RGBA</b>, and <b>GL_BGRA</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><i>type</i></p>
<p style="margin-left:14%;">Specifies the data type of the
pixel data. Must be one of <b>GL_UNSIGNED_BYTE</b>,
<b>GL_BYTE</b>, <b>GL_UNSIGNED_SHORT</b>, <b>GL_SHORT</b>,
<b>GL_UNSIGNED_INT</b>, <b>GL_INT</b>, <b>GL_HALF_FLOAT</b>,
<b>GL_FLOAT</b>, <b>GL_UNSIGNED_BYTE_3_3_2</b>,
<b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,
<b>GL_UNSIGNED_SHORT_5_6_5</b>,
<b>GL_UNSIGNED_SHORT_5_6_5_REV</b>,
<b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
<b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,
<b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
<b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
<b>GL_UNSIGNED_INT_8_8_8_8</b>,
<b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,
<b>GL_UNSIGNED_INT_10_10_10_2</b>,
<b>GL_UNSIGNED_INT_2_10_10_10_REV</b>,
<b>GL_UNSIGNED_INT_24_8</b>,
<b>GL_UNSIGNED_INT_10F_11F_11F_REV</b>,
<b>GL_UNSIGNED_INT_5_9_9_9_REV</b>, or
<b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><i>bufSize</i></p>
<p style="margin-left:14%;">Specifies the size of the
buffer <i>data</i> for <b>glReadnPixels</b> function.</p>
<p style="margin-left:9%; margin-top: 1em"><i>data</i></p>
<p style="margin-left:14%;">Returns the pixel data.</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glReadPixels</b>
and <b>glReadnPixels</b> return pixel data from the frame
buffer, starting with the pixel whose lower left corner is
at location (<i>x</i>, <i>y</i>), into client memory
starting at location <i>data</i>. Several parameters control
the processing of the pixel data before it is placed into
client memory. These parameters are set with
<b>glPixelStore</b>(). This reference page describes the
effects on <b>glReadPixels</b> and <b>glReadnPixels</b> of
most, but not all of the parameters specified by these three
commands.</p>
<p style="margin-left:9%; margin-top: 1em">If a
non−zero named buffer object is bound to the
<b>GL_PIXEL_PACK_BUFFER</b> target (see
<b>glBindBuffer</b>()) while a block of pixels is requested,
<i>data</i> is treated as a byte offset into the buffer
object's data store rather than a pointer to client
memory.</p>
<p style="margin-left:9%; margin-top: 1em"><b>glReadPixels</b>
and <b>glReadnPixels</b> return values from each pixel with
lower left corner at x + i y + j for 0 &lt;= i &lt; width
and 0 &lt;= j &lt; height. This pixel is said to be the ith
pixel in the jth row. Pixels are returned in row order from
the lowest to the highest row, left to right in each
row.</p>
<p style="margin-left:9%; margin-top: 1em"><i>format</i>
specifies the format for the returned pixel values; accepted
values are:</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_STENCIL_INDEX</b></p>
<p style="margin-left:14%;">Stencil values are read from
the stencil buffer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_DEPTH_COMPONENT</b></p>
<p style="margin-left:14%;">Depth values are read from the
depth buffer. Each component is converted to floating point
such that the minimum depth value maps to 0 and the maximum
value maps to 1. Each component is clamped to the range 0
1.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_DEPTH_STENCIL</b></p>
<p style="margin-left:14%;">Values are taken from both the
depth and stencil buffers. The <i>type</i> parameter must be
<b>GL_UNSIGNED_INT_24_8</b> or
<b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_RED</b>,
<b>GL_GREEN</b>, <b>GL_BLUE</b>, <b>GL_RGB</b>,
<b>GL_BGR</b>, <b>GL_RGBA</b>, <b>GL_BGRA</b></p>
<p style="margin-left:14%;">Color values are taken from the
color buffer.</p>
<p style="margin-left:9%; margin-top: 1em">Finally, the
indices or components are converted to the proper format, as
specified by <i>type</i>. If <i>format</i> is
<b>GL_STENCIL_INDEX</b> and <i>type</i> is not
<b>GL_FLOAT</b>, each index is masked with the mask value
given in the following table. If <i>type</i> is
<b>GL_FLOAT</b>, then each integer index is converted to
single−precision floating−point format.</p>
<p style="margin-left:9%; margin-top: 1em">If <i>format</i>
is <b>GL_RED</b>, <b>GL_GREEN</b>, <b>GL_BLUE</b>,
<b>GL_RGB</b>, <b>GL_BGR</b>, <b>GL_RGBA</b>, or
<b>GL_BGRA</b> and <i>type</i> is not <b>GL_FLOAT</b>, each
component is multiplied by the multiplier shown in the
following table. If type is <b>GL_FLOAT</b>, then each
component is passed as is (or converted to the client's
single−precision floating−point format if it is
different from the one used by the GL).</p>
<p style="margin-left:9%; margin-top: 1em">Return values
are placed in memory as follows. If <i>format</i> is
<b>GL_STENCIL_INDEX</b>, <b>GL_DEPTH_COMPONENT</b>,
<b>GL_RED</b>, <b>GL_GREEN</b>, or <b>GL_BLUE</b>, a single
value is returned and the data for the ith pixel in the jth
row is placed in location j ⁢ width + i. <b>GL_RGB</b>
and <b>GL_BGR</b> return three values, <b>GL_RGBA</b> and
<b>GL_BGRA</b> return four values for each pixel, with all
values corresponding to a single pixel occupying contiguous
space in <i>data</i>. Storage parameters set by
<b>glPixelStore</b>(), such as <b>GL_PACK_LSB_FIRST</b> and
<b>GL_PACK_SWAP_BYTES</b>, affect the way that data is
written into memory. See <b>glPixelStore</b>() for a
description.</p>
<p style="margin-left:9%; margin-top: 1em"><b>glReadnPixels</b>
function will only handle the call if <i>bufSize</i> is at
least of the size required to store the requested data.
Otherwise, it will generate a <b>GL_INVALID_OPERATION</b>
error.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Values for
pixels that lie outside the window connected to the current
GL context are undefined.</p>
<p style="margin-left:9%; margin-top: 1em">If an error is
generated, no change is made to the contents of
<i>data</i>.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_ENUM</b>
is generated if <i>format</i> or <i>type</i> is not an
accepted value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated if either <i>width</i> or <i>height</i> is
negative.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>format</i> is <b>GL_STENCIL_INDEX</b> and
there is no stencil buffer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>format</i> is <b>GL_DEPTH_COMPONENT</b>
and there is no depth buffer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>format</i> is <b>GL_DEPTH_STENCIL</b> and
there is no depth buffer or if there is no stencil
buffer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_ENUM</b>
is generated if <i>format</i> is <b>GL_DEPTH_STENCIL</b> and
<i>type</i> is not <b>GL_UNSIGNED_INT_24_8</b> or
<b>GL_FLOAT_32_UNSIGNED_INT_24_8_REV</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>type</i> is one of
<b>GL_UNSIGNED_BYTE_3_3_2</b>,
<b>GL_UNSIGNED_BYTE_2_3_3_REV</b>,
<b>GL_UNSIGNED_SHORT_5_6_5</b>, or
<b>GL_UNSIGNED_SHORT_5_6_5_REV</b> and <i>format</i> is not
<b>GL_RGB</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>type</i> is one of
<b>GL_UNSIGNED_SHORT_4_4_4_4</b>,
<b>GL_UNSIGNED_SHORT_4_4_4_4_REV</b>,
<b>GL_UNSIGNED_SHORT_5_5_5_1</b>,
<b>GL_UNSIGNED_SHORT_1_5_5_5_REV</b>,
<b>GL_UNSIGNED_INT_8_8_8_8</b>,
<b>GL_UNSIGNED_INT_8_8_8_8_REV</b>,
<b>GL_UNSIGNED_INT_10_10_10_2</b>, or
<b>GL_UNSIGNED_INT_2_10_10_10_REV</b> and <i>format</i> is
neither <b>GL_RGBA</b> nor <b>GL_BGRA</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if a non−zero buffer object name is bound
to the <b>GL_PIXEL_PACK_BUFFER</b> target and the buffer
object's data store is currently mapped.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if a non−zero buffer object name is bound
to the <b>GL_PIXEL_PACK_BUFFER</b> target and the data would
be packed to the buffer object such that the memory writes
required would exceed the data store size.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if a non−zero buffer object name is bound
to the <b>GL_PIXEL_PACK_BUFFER</b> target and <i>data</i> is
not evenly divisible into the number of bytes needed to
store in memory a datum indicated by <i>type</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <b>GL_READ_FRAMEBUFFER_BINDING</b> is
non−zero, the read framebuffer is complete, and the
value of <b>GL_SAMPLE_BUFFERS</b> for the read framebuffer
is greater than zero.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated by <b>glReadnPixels</b> if the buffer size
required to store the requested data is greater than
<i>bufSize</i>.</p>
<h2>ASSOCIATED GETS
<a name="ASSOCIATED GETS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glGet</b>()
with argument <b>GL_PIXEL_PACK_BUFFER_BINDING</b></p>
<h2>VERSION SUPPORT
<a name="VERSION SUPPORT"></a>
</h2>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glPixelStore</b>(),
<b>glReadBuffer</b>()</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright ©
1991−2006 Silicon Graphics, Inc. Copyright ©
2010−2014 Khronos Group. This document is licensed
under the SGI Free Software B License. For details, see
<b><font color="#0000FF">http://oss.sgi.com/projects/FreeB/</font></b><font color="#000000">.</font></p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Copyright
© 1991-2006 Silicon Graphics, Inc. <br/>
Copyright © 2010-2014 Khronos Group</font></p>
<hr/>
</body>
</html>
