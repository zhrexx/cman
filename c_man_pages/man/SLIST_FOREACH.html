<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:50:47 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SLIST</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">SLIST</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Creation">Creation</a><br/>
<a href="#Insertion">Insertion</a><br/>
<a href="#Traversal">Traversal</a><br/>
<a href="#Removal">Removal</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">SLIST_EMPTY,
SLIST_ENTRY, SLIST_FIRST, SLIST_FOREACH, SLIST_HEAD,
SLIST_HEAD_INITIALIZER, SLIST_INIT, SLIST_INSERT_AFTER,
SLIST_INSERT_HEAD, SLIST_NEXT, SLIST_REMOVE,
SLIST_REMOVE_HEAD − implementation of a singly linked
list</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;sys/queue.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_ENTRY(TYPE);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_HEAD(HEADNAME,
TYPE); <br/>
SLIST_HEAD SLIST_HEAD_INITIALIZER(SLIST_HEAD</b>
<i>head</i><b>); <br/>
void SLIST_INIT(SLIST_HEAD *</b><i>head</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
SLIST_EMPTY(SLIST_HEAD *</b><i>head</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
SLIST_INSERT_HEAD(SLIST_HEAD *</b><i>head</i><b>, <br/>
struct TYPE *</b><i>elm</i><b>, SLIST_ENTRY</b>
<i>NAME</i><b>); <br/>
void SLIST_INSERT_AFTER(struct TYPE *</b><i>listelm</i><b>,
<br/>
struct TYPE *</b><i>elm</i><b>, SLIST_ENTRY</b>
<i>NAME</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>struct TYPE
*SLIST_FIRST(SLIST_HEAD *</b><i>head</i><b>); <br/>
struct TYPE *SLIST_NEXT(struct TYPE *</b><i>elm</i><b>,
SLIST_ENTRY</b> <i>NAME</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_FOREACH(struct
TYPE *</b><i>var</i><b>, SLIST_HEAD *</b><i>head</i><b>,
SLIST_ENTRY</b> <i>NAME</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
SLIST_REMOVE(SLIST_HEAD *</b><i>head</i><b>, struct TYPE
*</b><i>elm</i><b>, <br/>
SLIST_ENTRY</b> <i>NAME</i><b>); <br/>
void SLIST_REMOVE_HEAD(SLIST_HEAD *</b><i>head</i><b>, <br/>
SLIST_ENTRY</b> <i>NAME</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These macros
define and operate on singly linked lists.</p>
<p style="margin-left:9%; margin-top: 1em">In the macro
definitions, <i>TYPE</i> is the name of a user-defined
structure, that must contain a field of type
<i>SLIST_ENTRY</i>, named <i>NAME</i>. The argument
<i>HEADNAME</i> is the name of a user-defined structure that
must be declared using the macro <b>SLIST_HEAD</b>().</p>
<h3>Creation
<a name="Creation"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">A singly linked
list is headed by a structure defined by the
<b>SLIST_HEAD</b>() macro. This structure contains a single
pointer to the first element on the list. The elements are
singly linked for minimum space and pointer manipulation
overhead at the expense of O(n) removal for arbitrary
elements. New elements can be added to the list after an
existing element or at the head of the list. An
<i>SLIST_HEAD</i> structure is declared as follows:</p>
<p style="margin-left:14%; margin-top: 1em">SLIST_HEAD(HEADNAME,
TYPE) head;</p>
<p style="margin-left:9%; margin-top: 1em">where <i>struct
HEADNAME</i> is the structure to be defined, and <i>struct
TYPE</i> is the type of the elements to be linked into the
list. A pointer to the head of the list can later be
declared as:</p>
<p style="margin-left:14%; margin-top: 1em">struct HEADNAME
*headp;</p>
<p style="margin-left:9%; margin-top: 1em">(The names
<i>head</i> and <i>headp</i> are user selectable.)</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_ENTRY</b>()
declares a structure that connects the elements in the
list.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_HEAD_INITIALIZER</b>()
evaluates to an initializer for the list <i>head</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_INIT</b>()
initializes the list referenced by <i>head</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_EMPTY</b>()
evaluates to true if there are no elements in the list.</p>
<h3>Insertion
<a name="Insertion"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_INSERT_HEAD</b>()
inserts the new element <i>elm</i> at the head of the
list.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_INSERT_AFTER</b>()
inserts the new element <i>elm</i> after the element
<i>listelm</i>.</p>
<h3>Traversal
<a name="Traversal"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_FIRST</b>()
returns the first element in the list, or NULL if the list
is empty.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_NEXT</b>()
returns the next element in the list.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_FOREACH</b>()
traverses the list referenced by <i>head</i> in the forward
direction, assigning each element in turn to <i>var</i>.</p>
<h3>Removal
<a name="Removal"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_REMOVE</b>()
removes the element <i>elm</i> from the list.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_REMOVE_HEAD</b>()
removes the element <i>elm</i> from the head of the list.
For optimum efficiency, elements being removed from the head
of the list should explicitly use this macro instead of the
generic <b>SLIST_REMOVE</b>().</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_EMPTY</b>()
returns nonzero if the list is empty, and zero if the list
contains at least one entry.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_FIRST</b>(),
and <b>SLIST_NEXT</b>() return a pointer to the first or
next <i>TYPE</i> structure, respectively.</p>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_HEAD_INITIALIZER</b>()
returns an initializer that can be assigned to the list
<i>head</i>.</p>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">BSD.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">4.4BSD.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>SLIST_FOREACH</b>()
doesn’t allow <i>var</i> to be removed or freed within
the loop, as it would interfere with the traversal.
<b>SLIST_FOREACH_SAFE</b>(), which is present on the BSDs
but is not present in glibc, fixes this limitation by
allowing <i>var</i> to safely be removed from the list and
freed from within the loop without interfering with the
traversal.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;stddef.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;sys/queue.h&gt; <br/>
struct entry { <br/>
int data; <br/>
SLIST_ENTRY(entry) entries; /* Singly linked list */ <br/>
}; <br/>
SLIST_HEAD(slisthead, entry); <br/>
int <br/>
main(void) <br/>
{ <br/>
struct entry *n1, *n2, *n3, *np; <br/>
struct slisthead head; /* Singly linked list <br/>
head */ <br/>
SLIST_INIT(&amp;head); /* Initialize the queue */ <br/>
n1 = malloc(sizeof(struct entry)); /* Insert at the head */
<br/>
SLIST_INSERT_HEAD(&amp;head, n1, entries); <br/>
n2 = malloc(sizeof(struct entry)); /* Insert after */ <br/>
SLIST_INSERT_AFTER(n1, n2, entries); <br/>
SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion */
<br/>
free(n2); <br/>
n3 = SLIST_FIRST(&amp;head); <br/>
SLIST_REMOVE_HEAD(&amp;head, entries); /* Deletion from the
head */ <br/>
free(n3); <br/>
for (unsigned int i = 0; i &lt; 5; i++) { <br/>
n1 = malloc(sizeof(struct entry)); <br/>
SLIST_INSERT_HEAD(&amp;head, n1, entries); <br/>
n1−&gt;data = i; <br/>
} <br/>
/* Forward traversal */ <br/>
SLIST_FOREACH(np, &amp;head, entries) <br/>
printf("%i\n", np−&gt;data); <br/>
while (!SLIST_EMPTY(&amp;head)) { /* List deletion */ <br/>
n1 = SLIST_FIRST(&amp;head); <br/>
SLIST_REMOVE_HEAD(&amp;head, entries); <br/>
free(n1); <br/>
} <br/>
SLIST_INIT(&amp;head); <br/>
exit(EXIT_SUCCESS); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>insque</b>(3),
<b>queue</b>(7)</p>
<hr/>
</body>
</html>
