<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:50:15 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>pthread_attr_init</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">pthread_attr_init</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#ATTRIBUTES">ATTRIBUTES</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#Program source">Program source</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">pthread_attr_init,
pthread_attr_destroy − initialize and destroy thread
attributes object</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX threads
library (<i>libpthread</i>, <i>−lpthread</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;pthread.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
pthread_attr_init(pthread_attr_t *</b><i>attr</i><b>); <br/>
int pthread_attr_destroy(pthread_attr_t
*</b><i>attr</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>pthread_attr_init</b>() function initializes the thread
attributes object pointed to by <i>attr</i> with default
attribute values. After this call, individual attributes of
the object can be set using various related functions
(listed under SEE ALSO), and then the object can be used in
one or more <b>pthread_create</b>(3) calls that create
threads.</p>
<p style="margin-left:9%; margin-top: 1em">Calling
<b>pthread_attr_init</b>() on a thread attributes object
that has already been initialized results in undefined
behavior.</p>
<p style="margin-left:9%; margin-top: 1em">When a thread
attributes object is no longer required, it should be
destroyed using the <b>pthread_attr_destroy</b>() function.
Destroying a thread attributes object has no effect on
threads that were created using that object.</p>
<p style="margin-left:9%; margin-top: 1em">Once a thread
attributes object has been destroyed, it can be
reinitialized using <b>pthread_attr_init</b>(). Any other
use of a destroyed thread attributes object has undefined
results.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On success,
these functions return 0; on error, they return a nonzero
error number.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1
documents an <b>ENOMEM</b> error for
<b>pthread_attr_init</b>(); on Linux these functions always
succeed (but portable and future-proof applications should
nevertheless handle a possible error return).</p>
<h2>ATTRIBUTES
<a name="ATTRIBUTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">For an
explanation of the terms used in this section, see
<b>attributes</b>(7).</p>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2008.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2001.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<i>pthread_attr_t</i> type should be treated as opaque: any
access to the object other than via pthreads functions is
nonportable and produces undefined results.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The program
below optionally makes use of <b>pthread_attr_init</b>() and
various related functions to initialize a thread attributes
object that is used to create a single thread. Once created,
the thread uses the <b>pthread_getattr_np</b>(3) function (a
nonstandard GNU extension) to retrieve the thread’s
attributes, and then displays those attributes.</p>
<p style="margin-left:9%; margin-top: 1em">If the program
is run with no command-line argument, then it passes NULL as
the <i>attr</i> argument of <b>pthread_create</b>(3), so
that the thread is created with default attributes. Running
the program on Linux/x86-32 with the NPTL threading
implementation, we see the following:</p>
<p style="margin-left:14%; margin-top: 1em">$ <b>ulimit
−s</b> # No stack limit ==&gt; default stack size is 2
MB <br/>
unlimited <br/>
$ <b>./a.out</b> <br/>
Thread attributes: <br/>
Detach state = PTHREAD_CREATE_JOINABLE <br/>
Scope = PTHREAD_SCOPE_SYSTEM <br/>
Inherit scheduler = PTHREAD_INHERIT_SCHED <br/>
Scheduling policy = SCHED_OTHER <br/>
Scheduling priority = 0 <br/>
Guard size = 4096 bytes <br/>
Stack address = 0x40196000 <br/>
Stack size = 0x201000 bytes</p>
<p style="margin-left:9%; margin-top: 1em">When we supply a
stack size as a command-line argument, the program
initializes a thread attributes object, sets various
attributes in that object, and passes a pointer to the
object in the call to <b>pthread_create</b>(3). Running the
program on Linux/x86-32 with the NPTL threading
implementation, we see the following:</p>
<p style="margin-left:14%; margin-top: 1em">$ <b>./a.out
0x3000000</b> <br/>
posix_memalign() allocated at 0x40197000 <br/>
Thread attributes: <br/>
Detach state = PTHREAD_CREATE_DETACHED <br/>
Scope = PTHREAD_SCOPE_SYSTEM <br/>
Inherit scheduler = PTHREAD_EXPLICIT_SCHED <br/>
Scheduling policy = SCHED_OTHER <br/>
Scheduling priority = 0 <br/>
Guard size = 0 bytes <br/>
Stack address = 0x40197000 <br/>
Stack size = 0x3000000 bytes</p>
<h3>Program source
<a name="Program source"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">#define
_GNU_SOURCE /* To get pthread_getattr_np() declaration */
<br/>
#include &lt;err.h&gt; <br/>
#include &lt;errno.h&gt; <br/>
#include &lt;pthread.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;unistd.h&gt; <br/>
static void <br/>
display_pthread_attr(pthread_attr_t *attr, char *prefix)
<br/>
{ <br/>
int s, i; <br/>
size_t v; <br/>
void *stkaddr; <br/>
struct sched_param sp; <br/>
s = pthread_attr_getdetachstate(attr, &amp;i); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_getdetachstate"); <br/>
printf("%sDetach state = %s\n", prefix, <br/>
(i == PTHREAD_CREATE_DETACHED) ?
"PTHREAD_CREATE_DETACHED" : <br/>
(i == PTHREAD_CREATE_JOINABLE) ?
"PTHREAD_CREATE_JOINABLE" : <br/>
"???"); <br/>
s = pthread_attr_getscope(attr, &amp;i); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_attr_getscope");
<br/>
printf("%sScope = %s\n", prefix, <br/>
(i == PTHREAD_SCOPE_SYSTEM) ?
"PTHREAD_SCOPE_SYSTEM" : <br/>
(i == PTHREAD_SCOPE_PROCESS) ?
"PTHREAD_SCOPE_PROCESS" : <br/>
"???"); <br/>
s = pthread_attr_getinheritsched(attr, &amp;i); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_getinheritsched"); <br/>
printf("%sInherit scheduler = %s\n", prefix, <br/>
(i == PTHREAD_INHERIT_SCHED) ?
"PTHREAD_INHERIT_SCHED" : <br/>
(i == PTHREAD_EXPLICIT_SCHED) ?
"PTHREAD_EXPLICIT_SCHED" : <br/>
"???"); <br/>
s = pthread_attr_getschedpolicy(attr, &amp;i); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_getschedpolicy"); <br/>
printf("%sScheduling policy = %s\n", prefix, <br/>
(i == SCHED_OTHER) ? "SCHED_OTHER" : <br/>
(i == SCHED_FIFO) ? "SCHED_FIFO" : <br/>
(i == SCHED_RR) ? "SCHED_RR" : <br/>
"???"); <br/>
s = pthread_attr_getschedparam(attr, &amp;sp); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_getschedparam"); <br/>
printf("%sScheduling priority = %d\n", prefix,
sp.sched_priority); <br/>
s = pthread_attr_getguardsize(attr, &amp;v); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_getguardsize"); <br/>
printf("%sGuard size = %zu bytes\n", prefix, v);
<br/>
s = pthread_attr_getstack(attr, &amp;stkaddr, &amp;v); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_attr_getstack");
<br/>
printf("%sStack address = %p\n", prefix, stkaddr);
<br/>
printf("%sStack size = %#zx bytes\n", prefix, v);
<br/>
} <br/>
static void * <br/>
thread_start(void *arg) <br/>
{ <br/>
int s; <br/>
pthread_attr_t gattr; <br/>
/* pthread_getattr_np() is a non−standard GNU
extension that <br/>
retrieves the attributes of the thread specified in its <br/>
first argument. */ <br/>
s = pthread_getattr_np(pthread_self(), &amp;gattr); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_getattr_np"); <br/>
printf("Thread attributes:\n"); <br/>
display_pthread_attr(&amp;gattr, "\t"); <br/>
exit(EXIT_SUCCESS); /* Terminate all threads */ <br/>
} <br/>
int <br/>
main(int argc, char *argv[]) <br/>
{ <br/>
pthread_t thr; <br/>
pthread_attr_t attr; <br/>
pthread_attr_t *attrp; /* NULL or &amp;attr */ <br/>
int s; <br/>
attrp = NULL; <br/>
/* If a command−line argument was supplied, use it to
set the <br/>
stack−size attribute and set a few other thread
attributes, <br/>
and set attrp pointing to thread attributes object. */ <br/>
if (argc &gt; 1) { <br/>
size_t stack_size; <br/>
void *sp; <br/>
attrp = &amp;attr; <br/>
s = pthread_attr_init(&amp;attr); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_attr_init"); <br/>
s = pthread_attr_setdetachstate(&amp;attr,
PTHREAD_CREATE_DETACHED); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_setdetachstate"); <br/>
s = pthread_attr_setinheritsched(&amp;attr,
PTHREAD_EXPLICIT_SCHED); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s,
"pthread_attr_setinheritsched"); <br/>
stack_size = strtoul(argv[1], NULL, 0); <br/>
s = posix_memalign(&amp;sp, sysconf(_SC_PAGESIZE),
stack_size); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "posix_memalign"); <br/>
printf("posix_memalign() allocated at %p\n", sp);
<br/>
s = pthread_attr_setstack(&amp;attr, sp, stack_size); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_attr_setstack");
<br/>
} <br/>
s = pthread_create(&amp;thr, attrp, &amp;thread_start,
NULL); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_create"); <br/>
if (attrp != NULL) { <br/>
s = pthread_attr_destroy(attrp); <br/>
if (s != 0) <br/>
errc(EXIT_FAILURE, s, "pthread_attr_destroy");
<br/>
} <br/>
pause(); /* Terminates when other thread calls exit() */
<br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>pthread_attr_setaffinity_np</b>(3),
<b>pthread_attr_setdetachstate</b>(3),
<b>pthread_attr_setguardsize</b>(3),
<b>pthread_attr_setinheritsched</b>(3),
<b>pthread_attr_setschedparam</b>(3),
<b>pthread_attr_setschedpolicy</b>(3),
<b>pthread_attr_setscope</b>(3),
<b>pthread_attr_setsigmask_np</b>(3),
<b>pthread_attr_setstack</b>(3),
<b>pthread_attr_setstackaddr</b>(3),
<b>pthread_attr_setstacksize</b>(3),
<b>pthread_create</b>(3), <b>pthread_getattr_np</b>(3),
<b>pthread_setattr_default_np</b>(3), <b>pthreads</b>(7)</p>
<hr/>
</body>
</html>
