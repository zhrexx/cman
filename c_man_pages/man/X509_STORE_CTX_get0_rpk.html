<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:53:01 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>X509_STORE_CTX_NEW</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">X509_STORE_CTX_NEW</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">X509_STORE_CTX_new_ex,
X509_STORE_CTX_new, X509_STORE_CTX_cleanup,
X509_STORE_CTX_free, X509_STORE_CTX_init,
X509_STORE_CTX_init_rpk, X509_STORE_CTX_set0_trusted_stack,
X509_STORE_CTX_set_cert, X509_STORE_CTX_set0_crls,
X509_STORE_CTX_set0_rpk, X509_STORE_CTX_get0_param,
X509_STORE_CTX_set0_param, X509_STORE_CTX_get0_untrusted,
X509_STORE_CTX_set0_untrusted,
X509_STORE_CTX_get_num_untrusted, X509_STORE_CTX_get0_chain,
X509_STORE_CTX_set0_verified_chain, X509_STORE_CTX_get0_rpk,
X509_STORE_CTX_set_default, X509_STORE_CTX_set_verify,
X509_STORE_CTX_verify_fn, X509_STORE_CTX_set_purpose,
X509_STORE_CTX_set_trust, X509_STORE_CTX_purpose_inherit
− X509_STORE_CTX initialisation</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/x509_vfy.h&gt; <br/>
X509_STORE_CTX *X509_STORE_CTX_new_ex(OSSL_LIB_CTX *libctx,
const char *propq); <br/>
X509_STORE_CTX *X509_STORE_CTX_new(void); <br/>
void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx); <br/>
void X509_STORE_CTX_free(X509_STORE_CTX *ctx); <br/>
int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE
*trust_store, <br/>
X509 *target, STACK_OF(X509) *untrusted); <br/>
int X509_STORE_CTX_init_rpk(X509_STORE_CTX *ctx, X509_STORE
*trust_store, <br/>
EVP_PKEY *rpk); <br/>
void X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx,
STACK_OF(X509) *sk); <br/>
void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509
*target); <br/>
void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx,
STACK_OF(X509_CRL) *sk); <br/>
void X509_STORE_CTX_set0_rpk(X509_STORE_CTX *ctx, EVP_PKEY
*target); <br/>
X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(const
X509_STORE_CTX *ctx); <br/>
void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx,
X509_VERIFY_PARAM *param); <br/>
STACK_OF(X509)* X509_STORE_CTX_get0_untrusted(const
X509_STORE_CTX *ctx); <br/>
void X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx,
STACK_OF(X509) *sk); <br/>
int X509_STORE_CTX_get_num_untrusted(const X509_STORE_CTX
*ctx); <br/>
STACK_OF(X509) *X509_STORE_CTX_get0_chain(const
X509_STORE_CTX *ctx); <br/>
void X509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *ctx,
STACK_OF(X509) *chain); <br/>
EVP_PKEY *X509_STORE_CTX_get0_rpk(const X509_STORE_CTX
*ctx); <br/>
int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const
char *name); <br/>
typedef int (*X509_STORE_CTX_verify_fn)(X509_STORE_CTX *);
<br/>
void X509_STORE_CTX_set_verify(X509_STORE_CTX *ctx,
X509_STORE_CTX_verify_fn verify); <br/>
int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int
purpose); <br/>
int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int
trust); <br/>
int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int
def_purpose, <br/>
int purpose, int trust);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These functions
initialise an <b>X509_STORE_CTX</b> structure for subsequent
use by <b>X509_verify_cert</b>(3) or
<b>X509_STORE_CTX_verify</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_new_ex()</b>
returns a newly initialised <b>X509_STORE_CTX</b> structure
associated with the specified library context <i>libctx</i>
and property query string <i>propq</i>. Any cryptographic
algorithms fetched while performing processing with the
X509_STORE_CTX will use that library context and property
query string.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_new()</b>
is the same as <b>X509_STORE_CTX_new_ex()</b> except that
the default library context and a NULL property query string
are used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_cleanup()</b>
internally cleans up an <b>X509_STORE_CTX</b> structure. It
is used by <b>X509_STORE_CTX_init()</b> and
<b>X509_STORE_CTX_free()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_free()</b>
completely frees up <i>ctx</i>. After this call <i>ctx</i>
is no longer valid. If <i>ctx</i> is NULL nothing is
done.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_init()</b>
sets up <i>ctx</i> for a subsequent verification
operation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_init()</b>
initializes the internal state and resources of the given
<i>ctx</i>. Among others, it sets the verification
parameters associcated with the method name
"default", which includes the "any"
purpose, and takes over callback function pointers from
<i>trust_store</i> (unless NULL). It must be called before
each call to <b>X509_verify_cert</b>(3) or
<b>X509_STORE_CTX_verify</b>(3), i.e., a context is only
good for one verification. If you want to verify a further
certificate or chain with the same <i>ctx</i> then you must
call <b>X509_STORE_CTX_init()</b> again. The trusted
certificate store is set to <i>trust_store</i> of type
<b>X509_STORE</b>. This may be NULL because there are no
trusted certificates or because they are provided simply as
a list using <b>X509_STORE_CTX_set0_trusted_stack()</b>. The
certificate to be verified is set to <i>target</i>, and a
list of additional certificates may be provided in
<i>untrusted</i>, which will be untrusted but may be used to
build the chain. The <i>target</i> certificate is not copied
(its reference count is not updated), and the caller must
not free it before verification is complete. Each of the
<i>trust_store</i>, <i>target</i> and <i>untrusted</i>
parameters can be NULL. Yet note that
<b>X509_verify_cert</b>(3) and
<b>X509_STORE_CTX_verify</b>(3) will need a verification
target. This can also be set using
<b>X509_STORE_CTX_set_cert()</b>. For
<b>X509_STORE_CTX_verify</b>(3), which takes by default the
first element of the list of untrusted certificates as its
verification target, this can be also set indirectly using
<b>X509_STORE_CTX_set0_untrusted()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_init_rpk()</b>
sets up <i>ctx</i> for a subsequent verification operation
for the <i>target</i> raw public key. It behaves similarly
to <b>X509_STORE_CTX_init()</b>. The <i>target</i> raw
public key can also be supplied separately, via
<b>X509_STORE_CTX_set0_rpk()</b>. The <i>target</i> public
key is not copied (its reference count is not updated), and
the caller must not free it before verification is
complete.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_trusted_stack()</b>
sets the set of trusted certificates of <i>ctx</i> to
<i>sk</i>. This is an alternative way of specifying trusted
certificates instead of using an <b>X509_STORE</b> where its
complexity is not needed or to make sure that only the given
set <i>sk</i> of certificates are trusted.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set_cert()</b>
sets the target certificate to be verified in <i>ctx</i> to
<i>target</i>. The target certificate is not copied (its
reference count is not updated), and the caller must not
free it before verification is complete.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_rpk()</b>
sets the target raw public key to be verified in <i>ctx</i>
to <i>target</i>, a non−NULL raw public key preempts
any target certificate, which is then ignored. The
<i>target</i> public key is not copied (its reference count
is not updated), and the caller must not free it before
verification is complete.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_verified_chain()</b>
sets the validated chain to <i>chain</i>. Ownership of the
chain is transferred to <i>ctx</i>, and so it should not be
free'd by the caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_chain()</b>
returns the internal pointer used by the <i>ctx</i> that
contains the constructed (output) chain.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_rpk()</b>
returns the internal pointer used by the <i>ctx</i> that
contains the raw public key.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_crls()</b>
sets a set of CRLs to use to aid certificate verification to
<i>sk</i>. These CRLs will only be used if CRL verification
is enabled in the associated <b>X509_VERIFY_PARAM</b>
structure. This might be used where additional
"useful" CRLs are supplied as part of a protocol,
for example in a PKCS#7 structure.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_param()</b>
retrieves an internal pointer to the verification parameters
associated with <i>ctx</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_param()</b>
sets the internal verification parameter pointer to
<i>param</i>. After this call <b>param</b> should not be
used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_untrusted()</b>
retrieves an internal pointer to the stack of untrusted
certificates associated with <i>ctx</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_untrusted()</b>
sets the internal pointer to the stack of untrusted
certificates associated with <i>ctx</i> to <i>sk</i>.
<b>X509_STORE_CTX_verify()</b> will take the first element,
if any, as its default target if the target certificate is
not set explicitly.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get_num_untrusted()</b>
returns the number of untrusted certificates that were used
in building the chain. This is can be used after calling
<b>X509_verify_cert</b>(3) and similar functions. With
<b>X509_STORE_CTX_verify</b>(3), this does not count the
first chain element.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_chain()</b>
returns the internal pointer used by the <i>ctx</i> that
contains the validated chain.</p>
<p style="margin-left:9%; margin-top: 1em">Details of the
chain building and checking process are described in
"Certification Path Building" in
<b>openssl−verification−options</b>(1) and
"Certification Path Validation" in
<b>openssl−verification−options</b>(1).</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set0_verified_chain()</b>
sets the validated chain used by <i>ctx</i> to be
<i>chain</i>. Ownership of the chain is transferred to
<i>ctx</i>, and so it should not be free'd by the
caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set_default()</b>
looks up and sets the default verification method. This uses
the function <b>X509_VERIFY_PARAM_lookup()</b> to find the
set of parameters associated with the given verification
method <i>name</i>. Among others, the parameters determine
the trust model and verification purpose. More detail,
including the list of currently predefined methods, is
described for the <b>−verify_name</b>
command−line option in "Verification
Options" in
<b>openssl−verification−options</b>(1).</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set_verify()</b>
provides the capability for overriding the default verify
function. This function is responsible for verifying chain
signatures and expiration times.</p>
<p style="margin-left:9%; margin-top: 1em">A verify
function is defined as an X509_STORE_CTX_verify type which
has the following signature:</p>
<p style="margin-left:9%; margin-top: 1em">int
(*verify)(X509_STORE_CTX *);</p>
<p style="margin-left:9%; margin-top: 1em">This function
should receive the current X509_STORE_CTX as a parameter and
return 1 on success or 0 on failure.</p>
<p style="margin-left:9%; margin-top: 1em">X509
certificates may contain information about what purposes
keys contained within them can be used for. For example
"TLS WWW Server Authentication" or "Email
Protection". This "key usage" information is
held internally to the certificate itself. In addition the
trust store containing trusted certificates can declare what
purposes we trust different certificates for. This
"trust" information is not held within the
certificate itself but is "meta" information held
alongside it. This "meta" information is
associated with the certificate after it is issued and could
be determined by a system administrator. For example a
certificate might declare that it is suitable for use for
both "TLS WWW Server Authentication" and "TLS
Client Authentication", but a system administrator
might only trust it for the former. An X.509 certificate
extension exists that can record extended key usage
information to supplement the purpose information described
above. This extended mechanism is arbitrarily extensible and
not well suited for a generic library API; applications that
need to validate extended key usage information in
certificates will need to define a custom
"purpose" (see below) or supply a nondefault
verification callback
(<b>X509_STORE_set_verify_cb_func</b>(3)).</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set_purpose()</b>
sets the purpose for the target certificate being verified
in the <i>ctx</i>. Built−in available values for the
<i>purpose</i> argument are <b>X509_PURPOSE_SSL_CLIENT</b>,
<b>X509_PURPOSE_SSL_SERVER</b>,
<b>X509_PURPOSE_NS_SSL_SERVER</b>,
<b>X509_PURPOSE_SMIME_SIGN</b>,
<b>X509_PURPOSE_SMIME_ENCRYPT</b>,
<b>X509_PURPOSE_CRL_SIGN</b>, <b>X509_PURPOSE_ANY</b>,
<b>X509_PURPOSE_OCSP_HELPER</b>,
<b>X509_PURPOSE_TIMESTAMP_SIGN</b> and
<b>X509_PURPOSE_CODE_SIGN</b>. It is also possible to create
a custom purpose value. Setting a purpose requests that the
key usage and extended key usage (EKU) extensions optionally
declared within the certificate and its chain are verified
to be consistent with that purpose. For SSL client, SSL
server, and S/MIME purposes, the EKU is checked also for the
CA certificates along the chain, including any given trust
anchor certificate. Potentially also further checks are done
(depending on the purpose given). Every purpose also has an
associated default trust value, which will also be set at
the same time. During verification, this trust setting will
be verified to check whether it is consistent with the trust
set by the system administrator for certificates in the
chain.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set_trust()</b>
sets the trust value for the target certificate being
verified in the <i>ctx</i>. Built−in available values
for the <i>trust</i> argument are <b>X509_TRUST_COMPAT</b>,
<b>X509_TRUST_SSL_CLIENT</b>, <b>X509_TRUST_SSL_SERVER</b>,
<b>X509_TRUST_EMAIL</b>, <b>X509_TRUST_OBJECT_SIGN</b>,
<b>X509_TRUST_OCSP_SIGN</b>, <b>X509_TRUST_OCSP_REQUEST</b>
and <b>X509_TRUST_TSA</b>. It is also possible to create a
custom trust value. Since
<b>X509_STORE_CTX_set_purpose()</b> also sets the trust
value it is normally sufficient to only call that function.
If both are called then <b>X509_STORE_CTX_set_trust()</b>
should be called after <b>X509_STORE_CTX_set_purpose()</b>
since the trust setting of the last call will be used.</p>
<p style="margin-left:9%; margin-top: 1em">It should not
normally be necessary for end user applications to call
<b>X509_STORE_CTX_purpose_inherit()</b> directly. Typically
applications should call <b>X509_STORE_CTX_set_purpose()</b>
or <b>X509_STORE_CTX_set_trust()</b> instead. Using this
function it is possible to set the purpose and trust values
for the <i>ctx</i> at the same time. Both <i>ctx</i> and its
internal verification parameter pointer must not be NULL.
The <i>def_purpose</i> and <i>purpose</i> arguments can have
the same purpose values as described for
<b>X509_STORE_CTX_set_purpose()</b> above. The <i>trust</i>
argument can have the same trust values as described in
<b>X509_STORE_CTX_set_trust()</b> above. Any of the
<i>def_purpose</i>, <i>purpose</i> or <i>trust</i> values
may also have the value 0 to indicate that the supplied
parameter should be ignored. After calling this function the
purpose to be used for verification is set from the
<i>purpose</i> argument unless the purpose was already set
in <i>ctx</i> before, and the trust is set from the
<i>trust</i> argument unless the trust was already set in
<i>ctx</i> before. If <i>trust</i> is 0 then the trust value
will be set from the default trust value for <i>purpose</i>.
If the default trust value for the purpose is
<i>X509_TRUST_DEFAULT</i> and <i>trust</i> is 0 then the
default trust value associated with the <i>def_purpose</i>
value is used for the trust setting instead.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The certificates
and CRLs in a store are used internally and should
<b>not</b> be freed up until after the associated
<b>X509_STORE_CTX</b> is freed.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The certificates
and CRLs in a context are used internally and should
<b>not</b> be freed up until after the associated
<b>X509_STORE_CTX</b> is freed. Copies should be made or
reference counts increased instead.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_new()</b>
returns a newly allocated context or NULL if an error
occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_init()</b>
and <b>X509_STORE_CTX_init_rpk()</b> return 1 for success or
0 if an error occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_param()</b>
returns a pointer to an <b>X509_VERIFY_PARAM</b> structure
or NULL if an error occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get0_rpk()</b>
returns a pointer to an <b>EVP_PKEY</b> structure if
present, or NULL if absent.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_cleanup()</b>,
<b>X509_STORE_CTX_free()</b>,
<b>X509_STORE_CTX_set0_trusted_stack()</b>,
<b>X509_STORE_CTX_set_cert()</b>,
<b>X509_STORE_CTX_set0_crls()</b> and
<b>X509_STORE_CTX_set0_param()</b> do not return values.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_set_default()</b>
returns 1 for success or 0 if an error occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>X509_STORE_CTX_get_num_untrusted()</b>
returns the number of untrusted certificates used.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>X509_verify_cert</b>(3),
<b>X509_STORE_CTX_verify</b>(3),
<b>X509_VERIFY_PARAM_set_flags</b>(3)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>X509_STORE_CTX_set0_crls()</b> function was added in
OpenSSL 1.0.0. The <b>X509_STORE_CTX_get_num_untrusted()</b>
function was added in OpenSSL 1.1.0. The
<b>X509_STORE_CTX_new_ex()</b> function was added in OpenSSL
3.0. The <b>X509_STORE_CTX_init_rpk()</b>,
<b>X509_STORE_CTX_get0_rpk()</b>, and
<b>X509_STORE_CTX_set0_rpk()</b> functions were added in
OpenSSL 3.2.</p>
<p style="margin-left:9%; margin-top: 1em">There is no need
to call <b>X509_STORE_CTX_cleanup()</b> explicitly since
OpenSSL 3.0.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2009−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
