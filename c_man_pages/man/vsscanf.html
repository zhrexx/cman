<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:54:42 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>sscanf</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">sscanf</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Conversions">Conversions</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#ATTRIBUTES">ATTRIBUTES</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#The ’a’ assignment-allocation modifier">The ’a’ assignment-allocation modifier</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#Numeric conversion specifiers">Numeric conversion specifiers</a><br/>
<a href="#Nonstandard modifiers">Nonstandard modifiers</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">sscanf, vsscanf
− input string format conversion</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;stdio.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
sscanf(const char *restrict</b> <i>str</i><b>, <br/>
const char *restrict</b> <i>format</i><b>, ...);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;stdarg.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
vsscanf(const char *restrict</b> <i>str</i><b>, <br/>
const char *restrict</b> <i>format</i><b>, va_list</b>
<i>ap</i><b>);</b></p>
<p style="margin-left:4%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<b>feature_test_macros</b>(7)):</p>
<p style="margin-left:9%; margin-top: 1em"><b>vsscanf</b>():
<br/>
_ISOC99_SOURCE || _POSIX_C_SOURCE &gt;= 200112L</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>sscanf</b>() family of functions scans formatted input
according to <i>format</i> as described below. This format
may contain <i>conversion specifications</i>; the results
from such conversions, if any, are stored in the locations
pointed to by the <i>pointer</i> arguments that follow
<i>format</i>. Each <i>pointer</i> argument must be of a
type that is appropriate for the value returned by the
corresponding conversion specification.</p>
<p style="margin-left:9%; margin-top: 1em">If the number of
conversion specifications in <i>format</i> exceeds the
number of <i>pointer</i> arguments, the results are
undefined. If the number of <i>pointer</i> arguments exceeds
the number of conversion specifications, then the excess
<i>pointer</i> arguments are evaluated, but are otherwise
ignored.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sscanf</b>()
These functions read their input from the string pointed to
by <i>str</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>vsscanf</b>() function is analogous to
<b>vsprintf</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>format</i> string consists of a sequence of
<i>directives</i> which describe how to process the sequence
of input characters. If processing of a directive fails, no
further input is read, and <b>sscanf</b>() returns. A
"failure" can be either of the following: <i>input
failure</i>, meaning that input characters were unavailable,
or <i>matching failure</i>, meaning that the input was
inappropriate (see below).</p>
<p style="margin-left:9%; margin-top: 1em">A directive is
one of the following:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>A sequence of white-space characters (space, tab,
newline, etc.; see <b>isspace</b>(3)). This directive
matches any amount of white space, including none, in the
input.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>An ordinary character (i.e., one other than white space
or '%'). This character must exactly match the next
character of input.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>A conversion specification, which commences with a '%'
(percent) character. A sequence of characters from the input
is converted according to this specification, and the result
is placed in the corresponding <i>pointer</i> argument. If
the next item of input does not match the conversion
specification, the conversion fails—this is a
<i>matching failure</i>.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Each
<i>conversion specification</i> in <i>format</i> begins with
either the character '%' or the character sequence
"<b>%</b><i>n</i><b>$</b>" (see below for the
distinction) followed by:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="8%"></td>
<td width="82%">
<p style="margin-top: 1em">An optional '*'
assignment-suppression character: <b>sscanf</b>() reads
input as directed by the conversion specification, but
discards the input. No corresponding <i>pointer</i> argument
is required, and this specification is not included in the
count of successful assignments returned by
<b>scanf</b>().</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>For decimal conversions, an optional quote character
('). This specifies that the input number may include
thousands’ separators as defined by the
<b>LC_NUMERIC</b> category of the current locale. (See
<b>setlocale</b>(3).) The quote character may precede or
follow the '*' assignment-suppression character.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>An optional 'm' character. This is used with string
conversions (<i>%s</i>, <i>%c</i>, <i>%[</i>), and relieves
the caller of the need to allocate a corresponding buffer to
hold the input: instead, <b>sscanf</b>() allocates a buffer
of sufficient size, and assigns the address of this buffer
to the corresponding <i>pointer</i> argument, which should
be a pointer to a <i>char *</i> variable (this variable
does not need to be initialized before the call). The caller
should subsequently <b>free</b>(3) this buffer when it is no
longer required.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>An optional decimal integer which specifies the
<i>maximum field width</i>. Reading of characters stops
either when this maximum is reached or when a nonmatching
character is found, whichever happens first. Most
conversions discard initial white space characters (the
exceptions are noted below), and these discarded characters
don’t count toward the maximum field width. String
input conversions store a terminating null byte ('\0') to
mark the end of the input; the maximum field width does not
include this terminator.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>An optional <i>type modifier character</i>. For example,
the <b>l</b> type modifier is used with integer conversions
such as <b>%d</b> to specify that the corresponding
<i>pointer</i> argument refers to a <i>long</i> rather than
a pointer to an <i>int</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="8%"></td>
<td width="82%">
<p>A <i>conversion specifier</i> that specifies the type of
input conversion to be performed.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The conversion
specifications in <i>format</i> are of two forms, either
beginning with '%' or beginning with
"<b>%</b><i>n</i><b>$</b>". The two forms should
not be mixed in the same <i>format</i> string, except that a
string containing "<b>%</b><i>n</i><b>$</b>"
specifications can include <b>%%</b> and <b>%*</b>. If
<i>format</i> contains '%' specifications, then these
correspond in order with successive <i>pointer</i>
arguments. In the "<b>%</b><i>n</i><b>$</b>" form
(which is specified in POSIX.1-2001, but not C99), <i>n</i>
is a decimal integer that specifies that the converted input
should be placed in the location referred to by the
<i>n</i>-th <i>pointer</i> argument following
<i>format</i>.</p>
<h3>Conversions
<a name="Conversions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The following
<i>type modifier characters</i> can appear in a conversion
specification:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em"><b>h</b></p></td>
<td width="6%"></td>
<td width="82%">
<p style="margin-top: 1em">Indicates that the conversion
will be one of <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>,
<b>x</b>, <b>X</b>, or <b>n</b> and the next pointer is a
pointer to a <i>short</i> or <i>unsigned short</i> (rather
than <i>int</i>).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>hh</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>As for <b>h</b>, but the next pointer is a pointer to a
<i>signed char</i> or <i>unsigned char</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>j</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>As for <b>h</b>, but the next pointer is a pointer to an
<i>intmax_t</i> or a <i>uintmax_t</i>. This modifier was
introduced in C99.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>l</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>Indicates either that the conversion will be one of
<b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, <b>X</b>,
or <b>n</b> and the next pointer is a pointer to a
<i>long</i> or <i>unsigned long</i> (rather than
<i>int</i>), or that the conversion will be one of <b>e</b>,
<b>f</b>, or <b>g</b> and the next pointer is a pointer to
<i>double</i> (rather than <i>float</i>). If used with
<b>%c</b> or <b>%s</b>, the corresponding parameter is
considered as a pointer to a wide character or
wide-character string respectively.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>ll</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>(ell-ell) Indicates that the conversion will be one of
<b>b</b>, <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>,
<b>X</b>, or <b>n</b> and the next pointer is a pointer to a
<i>long long</i> or <i>unsigned long long</i> (rather than
<i>int</i>).</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>L</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>Indicates that the conversion will be either <b>e</b>,
<b>f</b>, or <b>g</b> and the next pointer is a pointer to
<i>long double</i> or (as a GNU extension) the conversion
will be <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, or <b>x</b>
and the next pointer is a pointer to <i>long long</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>q</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>equivalent to <b>L</b>. This specifier does not exist in
ANSI C.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>t</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>As for <b>h</b>, but the next pointer is a pointer to a
<i>ptrdiff_t</i>. This modifier was introduced in C99.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p><b>z</b></p></td>
<td width="6%"></td>
<td width="82%">
<p>As for <b>h</b>, but the next pointer is a pointer to a
<i>size_t</i>. This modifier was introduced in C99.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The following
<i>conversion specifiers</i> are available:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em"><b>%</b></p></td>
<td width="8%"></td>
<td width="82%">
<p style="margin-top: 1em">Matches a literal '%'. That is,
<b>%%</b> in the format string matches a single input '%'
character. No conversion is done (but initial white space
characters are discarded), and assignment does not
occur.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>d</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches an optionally signed decimal integer; the next
pointer must be a pointer to <i>int</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>i</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches an optionally signed integer; the next pointer
must be a pointer to <i>int</i>. The integer is read in base
16 if it begins with <i>0x</i> or <i>0X</i>, in base 8 if it
begins with <i>0</i>, and in base 10 otherwise. Only
characters that correspond to the base are used.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>o</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches an unsigned octal integer; the next pointer must
be a pointer to <i>unsigned int</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>u</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches an unsigned decimal integer; the next pointer
must be a pointer to <i>unsigned int</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>x</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches an unsigned hexadecimal integer (that may
optionally begin with a prefix of <i>0x</i> or <i>0X</i>,
which is discarded); the next pointer must be a pointer to
<i>unsigned int</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>X</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Equivalent to <b>x</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>f</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches an optionally signed floating-point number; the
next pointer must be a pointer to <i>float</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>e</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Equivalent to <b>f</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>g</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Equivalent to <b>f</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>E</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Equivalent to <b>f</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>a</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>(C99) Equivalent to <b>f</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>s</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches a sequence of non-white-space characters; the
next pointer must be a pointer to the initial element of a
character array that is long enough to hold the input
sequence and the terminating null byte ('\0'), which is
added automatically. The input string stops at white space
or at the maximum field width, whichever occurs first.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>c</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches a sequence of characters whose length is
specified by the <i>maximum field width</i> (default 1); the
next pointer must be a pointer to <i>char</i>, and there
must be enough room for all the characters (no terminating
null byte is added). The usual skip of leading white space
is suppressed. To skip white space first, use an explicit
space in the format.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>[</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches a nonempty sequence of characters from the
specified set of accepted characters; the next pointer must
be a pointer to <i>char</i>, and there must be enough room
for all the characters in the string, plus a terminating
null byte. The usual skip of leading white space is
suppressed. The string is to be made up of characters in (or
not in) a particular set; the set is defined by the
characters between the open bracket <b>[</b> character and a
close bracket <b>]</b> character. The set <i>excludes</i>
those characters if the first character after the open
bracket is a circumflex (<b>^</b>). To include a close
bracket in the set, make it the first character after the
open bracket or the circumflex; any other position will end
the set. The hyphen character <b>−</b> is also
special; when placed between two other characters, it adds
all intervening characters to the set. To include a hyphen,
make it the last character before the final close bracket.
For instance, <b>[^]0−9−]</b> means the set
"everything except close bracket, zero through nine,
and hyphen". The string ends with the appearance of a
character not in the (or, with a circumflex, in) set or when
the field width runs out.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>p</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Matches a pointer value (as printed by <b>%p</b> in
<b>printf</b>(3)); the next pointer must be a pointer to a
pointer to <i>void</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>n</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Nothing is expected; instead, the number of characters
consumed thus far from the input is stored through the next
pointer, which must be a pointer to <i>int</i>, or variant
whose size matches the (optionally) supplied integer length
modifier. This is <i>not</i> a conversion and does
<i>not</i> increase the count returned by the function. The
assignment can be suppressed with the <b>*</b>
assignment-suppression character, but the effect on the
return value is undefined. Therefore <b>%*n</b> conversions
should not be used.</p></td></tr>
</table>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On success,
these functions return the number of input items
successfully matched and assigned; this can be fewer than
provided for, or even zero, in the event of an early
matching failure.</p>
<p style="margin-left:9%; margin-top: 1em">The value
<b>EOF</b> is returned if the end of input is reached before
either the first successful conversion or a matching failure
occurs.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><b>EILSEQ</b></p></td>
<td width="1%"></td>
<td width="67%">
<p style="margin-top: 1em">Input byte sequence does not
form a valid character.</p></td>
<td width="15%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="67%">
<p>Not enough arguments; or <i>format</i> is NULL.</p></td>
<td width="15%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOMEM</b></p></td>
<td width="1%"></td>
<td width="67%">
<p>Out of memory.</p></td>
<td width="15%">
</td></tr>
</table>
<h2>ATTRIBUTES
<a name="ATTRIBUTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">For an
explanation of the terms used in this section, see
<b>attributes</b>(7).</p>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">C11,
POSIX.1-2008.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">C89,
POSIX.1-2001.</p>
<p style="margin-left:9%; margin-top: 1em">The <b>q</b>
specifier is the 4.4BSD notation for <i>long long</i>, while
<b>ll</b> or the usage of <b>L</b> in integer conversions is
the GNU notation.</p>
<p style="margin-left:9%; margin-top: 1em">The Linux
version of these functions is based on the <i>GNU libio</i>
library. Take a look at the <i>info</i> documentation of
<i>GNU libc (glibc-1.08)</i> for a more concise
description.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<h3>The ’a’ assignment-allocation modifier
<a name="The ’a’ assignment-allocation modifier"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Originally, the
GNU C library supported dynamic allocation for string inputs
(as a nonstandard extension) via the <b>a</b> character.
(This feature is present at least as far back as glibc 2.0.)
Thus, one could write the following to have <b>sscanf</b>()
allocate a buffer for a string, with a pointer to that
buffer being returned in <i>*buf</i>:</p>
<p style="margin-left:14%; margin-top: 1em">char *buf; <br/>
sscanf(str, "%as", &amp;buf);</p>
<p style="margin-left:9%; margin-top: 1em">The use of the
letter <b>a</b> for this purpose was problematic, since
<b>a</b> is also specified by the ISO C standard as a
synonym for <b>f</b> (floating-point input). POSIX.1-2008
instead specifies the <b>m</b> modifier for assignment
allocation (as documented in DESCRIPTION, above).</p>
<p style="margin-left:9%; margin-top: 1em">Note that the
<b>a</b> modifier is not available if the program is
compiled with <i>gcc −std=c99</i> or
<i>gcc −D_ISOC99_SOURCE</i> (unless
<b>_GNU_SOURCE</b> is also specified), in which case the
<b>a</b> is interpreted as a specifier for floating-point
numbers (see above).</p>
<p style="margin-left:9%; margin-top: 1em">Support for the
<b>m</b> modifier was added to glibc 2.7, and new programs
should use that modifier instead of <b>a</b>.</p>
<p style="margin-left:9%; margin-top: 1em">As well as being
standardized by POSIX, the <b>m</b> modifier has the
following further advantages over the use of <b>a</b>:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">It may also be applied to
<b>%c</b> conversion specifiers (e.g., <b>%3mc</b>).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>It avoids ambiguity with respect to the <b>%a</b>
floating-point conversion specifier (and is unaffected by
<i>gcc −std=c99</i> etc.).</p></td></tr>
</table>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<h3>Numeric conversion specifiers
<a name="Numeric conversion specifiers"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Use of the
numeric conversion specifiers produces Undefined Behavior
for invalid input. See
<a href="https://port70.net/%7Ensz/c/c11/n1570.html#7.21.6.2p10">C11
7.21.6.2/10</a>. This is a bug in the ISO C standard, and
not an inherent design issue with the API. However, current
implementations are not safe from that bug, so it is not
recommended to use them. Instead, programs should use
functions such as <b>strtol</b>(3) to parse numeric input.
Alternatively, mitigate it by specifying a maximum field
width.</p>
<h3>Nonstandard modifiers
<a name="Nonstandard modifiers"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">These functions
are fully C99 conformant, but provide the additional
modifiers <b>q</b> and <b>a</b> as well as an additional
behavior of the <b>L</b> and <b>ll</b> modifiers. The latter
may be considered to be a bug, as it changes the behavior of
modifiers defined in C99.</p>
<p style="margin-left:9%; margin-top: 1em">Some
combinations of the type modifiers and conversion specifiers
defined by C99 do not make sense (e.g., <b>%Ld</b>). While
they may have a well-defined behavior on Linux, this need
not to be so on other architectures. Therefore it usually is
better to use modifiers that are not defined by C99 at all,
that is, use <b>q</b> instead of <b>L</b> in combination
with <b>d</b>, <b>i</b>, <b>o</b>, <b>u</b>, <b>x</b>, and
<b>X</b> conversions or <b>ll</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The usage of
<b>q</b> is not the same as on 4.4BSD, as it may be used in
float conversions equivalently to <b>L</b>.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To use the
dynamic allocation conversion specifier, specify <b>m</b> as
a length modifier (thus <b>%ms</b> or
<b>%m[</b><i>range</i><b>]</b>). The caller must
<b>free</b>(3) the returned string, as in the following
example:</p>
<p style="margin-left:14%; margin-top: 1em">char *p; <br/>
int n; <br/>
errno = 0; <br/>
n = sscanf(str, "%m[a−z]", &amp;p); <br/>
if (n == 1) { <br/>
printf("read: %s\n", p); <br/>
free(p); <br/>
} else if (errno != 0) { <br/>
perror("sscanf"); <br/>
} else { <br/>
fprintf(stderr, "No matching characters\n"); <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">As shown in the
above example, it is necessary to call <b>free</b>(3) only
if the <b>sscanf</b>() call successfully read a string.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>getc</b>(3),
<b>printf</b>(3), <b>setlocale</b>(3), <b>strtod</b>(3),
<b>strtol</b>(3), <b>strtoul</b>(3)</p>
<hr/>
</body>
</html>
