<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:52:22 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Unicode::UCD</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Unicode::UCD</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#code point argument">code point argument</a><br/>
<a href="#charinfo()">charinfo()</a><br/>
<a href="#charprop()">charprop()</a><br/>
<a href="#charprops_all()">charprops_all()</a><br/>
<a href="#charblock()">charblock()</a><br/>
<a href="#charscript()">charscript()</a><br/>
<a href="#charblocks()">charblocks()</a><br/>
<a href="#charscripts()">charscripts()</a><br/>
<a href="#charinrange()">charinrange()</a><br/>
<a href="#general_categories()">general_categories()</a><br/>
<a href="#bidi_types()">bidi_types()</a><br/>
<a href="#compexcl()">compexcl()</a><br/>
<a href="#casefold()">casefold()</a><br/>
<a href="#all_casefolds()">all_casefolds()</a><br/>
<a href="#casespec()">casespec()</a><br/>
<a href="#namedseq()">namedseq()</a><br/>
<a href="#num()">num()</a><br/>
<a href="#prop_aliases()">prop_aliases()</a><br/>
<a href="#prop_values()">prop_values()</a><br/>
<a href="#prop_value_aliases()">prop_value_aliases()</a><br/>
<a href="#prop_invlist()">prop_invlist()</a><br/>
<a href="#prop_invmap()">prop_invmap()</a><br/>
<a href="#search_invlist()">search_invlist()</a><br/>
<a href="#Unicode::UCD::UnicodeVersion">Unicode::UCD::UnicodeVersion</a><br/>
<a href="#Blocks versus Scripts">Blocks versus Scripts</a><br/>
<a href="#Matching Scripts and Blocks">Matching Scripts and Blocks</a><br/>
<a href="#Old-style versus new-style block names">Old-style versus new-style block names</a><br/>
<a href="#Use with older Unicode versions">Use with older Unicode versions</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Unicode::UCD
− Unicode character database</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charinfo'; <br/>
my $charinfo = charinfo($codepoint); <br/>
use Unicode::UCD 'charprop'; <br/>
my $value = charprop($codepoint, $property); <br/>
use Unicode::UCD 'charprops_all'; <br/>
my $all_values_hash_ref = charprops_all($codepoint); <br/>
use Unicode::UCD 'casefold'; <br/>
my $casefold = casefold($codepoint); <br/>
use Unicode::UCD 'all_casefolds'; <br/>
my $all_casefolds_ref = all_casefolds(); <br/>
use Unicode::UCD 'casespec'; <br/>
my $casespec = casespec($codepoint); <br/>
use Unicode::UCD 'charblock'; <br/>
my $charblock = charblock($codepoint); <br/>
use Unicode::UCD 'charscript'; <br/>
my $charscript = charscript($codepoint); <br/>
use Unicode::UCD 'charblocks'; <br/>
my $charblocks = charblocks(); <br/>
use Unicode::UCD 'charscripts'; <br/>
my $charscripts = charscripts(); <br/>
use Unicode::UCD qw(charscript charinrange); <br/>
my $range = charscript($script); <br/>
print "looks like $script\n" if
charinrange($range, $codepoint); <br/>
use Unicode::UCD qw(general_categories bidi_types); <br/>
my $categories = general_categories(); <br/>
my $types = bidi_types(); <br/>
use Unicode::UCD 'prop_aliases'; <br/>
my @space_names = prop_aliases("space"); <br/>
use Unicode::UCD 'prop_value_aliases'; <br/>
my @gc_punct_names = prop_value_aliases("Gc",
"Punct"); <br/>
use Unicode::UCD 'prop_values'; <br/>
my @all_EA_short_names =
prop_values("East_Asian_Width"); <br/>
use Unicode::UCD 'prop_invlist'; <br/>
my @puncts = prop_invlist("gc=punctuation"); <br/>
use Unicode::UCD 'prop_invmap'; <br/>
my ($list_ref, $map_ref, $format, $missing) <br/>
= prop_invmap("General Category"); <br/>
use Unicode::UCD 'search_invlist'; <br/>
my $index = search_invlist(\@invlist, $code_point); <br/>
# The following function should be used only internally in
<br/>
# implementations of the Unicode Normalization Algorithm,
and there <br/>
# are better choices than it. <br/>
use Unicode::UCD 'compexcl'; <br/>
my $compexcl = compexcl($codepoint); <br/>
use Unicode::UCD 'namedseq'; <br/>
my $namedseq = namedseq($named_sequence_name); <br/>
my $unicode_version = Unicode::UCD::UnicodeVersion(); <br/>
my $convert_to_numeric = <br/>
Unicode::UCD::num("\N{RUMI DIGIT ONE}\N{RUMI DIGIT
TWO}");</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The Unicode::UCD
module offers a series of functions that provide a simple
interface to the Unicode Character Database.</p>
<h3>code point argument
<a name="code point argument"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Some of the
functions are called with a <i>code point argument</i>,
which is either a decimal or a hexadecimal scalar
designating a code point in the platform’s native
character set (extended to Unicode), or a string containing
"U+" followed by hexadecimals designating a
Unicode code point. A leading 0 will force a hexadecimal
interpretation, as will a hexadecimal digit that isn’t
a decimal digit.</p>
<p style="margin-left:9%; margin-top: 1em">Examples:</p>
<p style="margin-left:9%; margin-top: 1em">223 # Decimal
223 in native character set <br/>
0223 # Hexadecimal 223, native (= 547 decimal) <br/>
0xDF # Hexadecimal DF, native (= 223 decimal) <br/>
'0xDF' # String form of hexadecimal (= 223 decimal) <br/>
'U+DF' # Hexadecimal DF, in Unicode's character set <br/>
(= LATIN SMALL LETTER SHARP S)</p>
<p style="margin-left:9%; margin-top: 1em">Note that the
largest code point in Unicode is U+10FFFF.</p>
<h3>charinfo()
<a name="charinfo()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charinfo'; <br/>
my $charinfo = charinfo(0x41);</p>
<p style="margin-left:9%; margin-top: 1em">This returns
information about the input "code point argument"
as a reference to a hash of fields as defined by the Unicode
standard. If the "code point argument" is not
assigned in the standard (i.e., has the general category
"Cn" meaning "Unassigned") or is a
non-character (meaning it is guaranteed to never be assigned
in the standard), "undef" is returned.</p>
<p style="margin-left:9%; margin-top: 1em">Fields that
aren’t applicable to the particular code point
argument exist in the returned hash, and are empty.</p>
<p style="margin-left:9%; margin-top: 1em">For results that
are less "raw" than this function returns, or to
get the values for any property, not just the few covered by
this function, use the "<b>charprop()</b>"
function.</p>
<p style="margin-left:9%; margin-top: 1em">The keys in the
hash with the meanings of their values are: <b><br/>
code</b></p>
<p style="margin-left:14%;">the input native "code
point argument" expressed in hexadecimal, with leading
zeros added if necessary to make it contain at least four
hexdigits</p>
<p style="margin-left:9%;"><b>name</b></p>
<p style="margin-left:14%;">name of <i>code</i>, all IN
UPPER CASE. Some control-type code points do not have names.
This field will be empty for "Surrogate" and
"Private Use" code points, and for the others
without a name, it will contain a description enclosed in
angle brackets, like "&lt;control&gt;".</p>
<p style="margin-left:9%;"><b>category</b></p>
<p style="margin-left:14%;">The short name of the general
category of <i>code</i>. This will match one of the keys in
the hash returned by
"<b>general_categories()</b>".</p>
<p style="margin-left:14%; margin-top: 1em">The
"<b>prop_value_aliases()</b>" function can be used
to get all the synonyms of the category name.</p>
<p style="margin-left:9%;"><b>combining</b></p>
<p style="margin-left:14%;">the combining class number for
<i>code</i> used in the Canonical Ordering Algorithm. For
Unicode 5.1, this is described in Section 3.11
"Canonical Ordering Behavior" available at
&lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;</p>
<p style="margin-left:14%; margin-top: 1em">The
"<b>prop_value_aliases()</b>" function can be used
to get all the synonyms of the combining class number.</p>
<p style="margin-left:9%;"><b>bidi</b></p>
<p style="margin-left:14%;">bidirectional type of
<i>code</i>. This will match one of the keys in the hash
returned by "<b>bidi_types()</b>".</p>
<p style="margin-left:14%; margin-top: 1em">The
"<b>prop_value_aliases()</b>" function can be used
to get all the synonyms of the bidi type name.</p>
<p style="margin-left:9%;"><b>decomposition</b></p>
<p style="margin-left:14%;">is empty if <i>code</i> has no
decomposition; or is one or more codes (separated by spaces)
that, taken in order, represent a decomposition for
<i>code</i>. Each has at least four hexdigits. The codes may
be preceded by a word enclosed in angle brackets, then a
space, like "&lt;compat&gt; ", giving the type of
decomposition</p>
<p style="margin-left:14%; margin-top: 1em">This
decomposition may be an intermediate one whose components
are also decomposable. Use Unicode::Normalize to get the
final decomposition in one step.</p>
<p style="margin-left:9%;"><b>decimal</b></p>
<p style="margin-left:14%;">if <i>code</i> represents a
decimal digit this is its integer numeric value</p>
<p style="margin-left:9%;"><b>digit</b></p>
<p style="margin-left:14%;">if <i>code</i> represents some
other digit-like number, this is its integer numeric
value</p>
<p style="margin-left:9%;"><b>numeric</b></p>
<p style="margin-left:14%;">if <i>code</i> represents a
whole or rational number, this is its numeric value.
Rational values are expressed as a string like
"1/4".</p>
<p style="margin-left:9%;"><b>mirrored</b></p>
<p style="margin-left:14%;">"Y" or "N"
designating if <i>code</i> is mirrored in bidirectional
text</p>
<p style="margin-left:9%;"><b>unicode10</b></p>
<p style="margin-left:14%;">name of <i>code</i> in the
Unicode 1.0 standard if one existed for this code point and
is different from the current name</p>
<p style="margin-left:9%;"><b>comment</b></p>
<p style="margin-left:14%;">As of Unicode 6.0, this is
always empty.</p>
<p style="margin-left:9%;"><b>upper</b></p>
<p style="margin-left:14%;">is, if non-empty, the uppercase
mapping for <i>code</i> expressed as at least four
hexdigits. This indicates that the full uppercase mapping is
a single character, and is identical to the simple
(single-character only) mapping. When this field is empty,
it means that the simple uppercase mapping is <i>code</i>
itself; you’ll need some other means, (like
"<b>charprop()</b>" or
"<b>casespec()</b>" to get the full mapping.</p>
<p style="margin-left:9%;"><b>lower</b></p>
<p style="margin-left:14%;">is, if non-empty, the lowercase
mapping for <i>code</i> expressed as at least four
hexdigits. This indicates that the full lowercase mapping is
a single character, and is identical to the simple
(single-character only) mapping. When this field is empty,
it means that the simple lowercase mapping is <i>code</i>
itself; you’ll need some other means, (like
"<b>charprop()</b>" or
"<b>casespec()</b>" to get the full mapping.</p>
<p style="margin-left:9%;"><b>title</b></p>
<p style="margin-left:14%;">is, if non-empty, the titlecase
mapping for <i>code</i> expressed as at least four
hexdigits. This indicates that the full titlecase mapping is
a single character, and is identical to the simple
(single-character only) mapping. When this field is empty,
it means that the simple titlecase mapping is <i>code</i>
itself; you’ll need some other means, (like
"<b>charprop()</b>" or
"<b>casespec()</b>" to get the full mapping.</p>
<p style="margin-left:9%;"><b>block</b></p>
<p style="margin-left:14%;">the block <i>code</i> belongs
to (used in "\p{Blk=...}"). The
"<b>prop_value_aliases()</b>" function can be used
to get all the synonyms of the block name.</p>
<p style="margin-left:14%; margin-top: 1em">See
"Blocks versus Scripts".</p>
<p style="margin-left:9%;"><b>script</b></p>
<p style="margin-left:14%;">the script <i>code</i> belongs
to. The "<b>prop_value_aliases()</b>" function can
be used to get all the synonyms of the script name. Note
that this is the older "Script" property value,
and not the improved "Script_Extensions"
value.</p>
<p style="margin-left:14%; margin-top: 1em">See
"Blocks versus Scripts".</p>
<p style="margin-left:9%; margin-top: 1em">Note that you
cannot do (de)composition and casing based solely on the
<i>decomposition</i>, <i>combining</i>, <i>lower</i>,
<i>upper</i>, and <i>title</i> fields; you will need also
the "<b>casespec()</b>" function and the
"Composition_Exclusion" property. (Or you could
just use the <b>lc()</b>, <b>uc()</b>, and <b>ucfirst()</b>
functions, and the Unicode::Normalize module.)</p>
<h3>charprop()
<a name="charprop()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charprop'; <br/>
print charprop(0x41, "Gc"), "\n"; <br/>
print charprop(0x61, "General_Category"),
"\n"; <br/>
prints <br/>
Lu <br/>
Ll</p>
<p style="margin-left:9%; margin-top: 1em">This returns the
value of the Unicode property given by the second parameter
for the "code point argument" given by the
first.</p>
<p style="margin-left:9%; margin-top: 1em">The passed-in
property may be specified as any of the synonyms returned by
"<b>prop_aliases()</b>".</p>
<p style="margin-left:9%; margin-top: 1em">The return value
is always a scalar, either a string or a number. For
properties where there are synonyms for the values, the
synonym returned by this function is the longest, most
descriptive form, the one returned by
"<b>prop_value_aliases()</b>" when called in a
scalar context. Of course, you can call
"<b>prop_value_aliases()</b>" on the result to get
other synonyms.</p>
<p style="margin-left:9%; margin-top: 1em">The return
values are more "cooked" than the
"<b>charinfo()</b>" ones. For example, the
"uc" property value is the actual string
containing the full uppercase mapping of the input code
point. You have to go to extra trouble with
"charinfo" to get this value from its
"upper" hash element when the full mapping differs
from the simple one.</p>
<p style="margin-left:9%; margin-top: 1em">Special note
should be made of the return values for a few properties:
<br/>
Block</p>
<p style="margin-left:14%;">The value returned is the
new-style (see "Old-style versus new-style block
names").</p>
<p style="margin-left:9%;">Decomposition_Mapping</p>
<p style="margin-left:14%;">Like
"<b>charinfo()</b>", the result may be an
intermediate decomposition whose components are also
decomposable. Use Unicode::Normalize to get the final
decomposition in one step.</p>
<p style="margin-left:14%; margin-top: 1em">Unlike
"<b>charinfo()</b>", this does not include the
decomposition type. Use the "Decomposition_Type"
property to get that.</p>
<p style="margin-left:9%;">Name_Alias</p>
<p style="margin-left:14%;">If the input code point’s
name has more than one synonym, they are returned joined
into a single comma-separated string.</p>
<p style="margin-left:9%;">Numeric_Value</p>
<p style="margin-left:14%;">If the result is a fraction, it
is converted into a floating point number to the accuracy of
your platform.</p>
<p style="margin-left:9%;">Script_Extensions</p>
<p style="margin-left:14%;">If the result is multiple
script names, they are returned joined into a single
comma-separated string.</p>
<p style="margin-left:9%; margin-top: 1em">When called with
a property that is a Perl extension that isn’t
expressible in a compound form, this function currently
returns "undef", as the only two possible values
are <i>true</i> or <i>false</i> (1 or 0 I suppose). This
behavior may change in the future, so don’t write code
that relies on it. "Present_In" is a Perl
extension that is expressible in a bipartite or compound
form (for example, "\p{Present_In=4.0}"), so
"charprop" accepts it. But "Any" is a
Perl extension that isn’t expressible that way, so
"charprop" returns "undef" for it. Also
"charprop" returns "undef" for all Perl
extensions that are internal-only.</p>
<h3>charprops_all()
<a name="charprops_all()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charprops_all'; <br/>
my $%properties_of_A_hash_ref =
charprops_all("U+41");</p>
<p style="margin-left:9%; margin-top: 1em">This returns a
reference to a hash whose keys are all the distinct Unicode
(no Perl extension) properties, and whose values are the
respective values for those properties for the input
"code point argument".</p>
<p style="margin-left:9%; margin-top: 1em">Each key is the
property name in its longest, most descriptive form. The
values are what "<b>charprop()</b>" would
return.</p>
<p style="margin-left:9%; margin-top: 1em">This function is
expensive in time and memory.</p>
<h3>charblock()
<a name="charblock()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charblock'; <br/>
my $charblock = charblock(0x41); <br/>
my $charblock = charblock(1234); <br/>
my $charblock = charblock(0x263a); <br/>
my $charblock = charblock("U+263a"); <br/>
my $range = charblock('Armenian');</p>
<p style="margin-left:9%; margin-top: 1em">With a
"code point argument" charblock() returns the
<i>block</i> the code point belongs to, e.g. "Basic
Latin". The old-style block name is returned (see
"Old-style versus new-style block names"). The
"<b>prop_value_aliases()</b>" function can be used
to get all the synonyms of the block name.</p>
<p style="margin-left:9%; margin-top: 1em">If the code
point is unassigned, this returns the block it would belong
to if it were assigned. (If the Unicode version being used
is so early as to not have blocks, all code points are
considered to be in "No_Block".)</p>
<p style="margin-left:9%; margin-top: 1em">See also
"Blocks versus Scripts".</p>
<p style="margin-left:9%; margin-top: 1em">If supplied with
an argument that can’t be a code point, charblock()
tries to do the opposite and interpret the argument as an
old-style block name. On an ASCII platform, the return value
is a <i>range set</i> with one range: an anonymous array
with a single element that consists of another anonymous
array whose first element is the first code point in the
block, and whose second element is the final code point in
the block. On an EBCDIC platform, the first two Unicode
blocks are not contiguous. Their range sets are lists
containing <i>start-of-range</i>, <i>end-of-range</i> code
point pairs. You can test whether a code point is in a range
set using the "<b>charinrange()</b>" function. (To
be precise, each <i>range set</i> contains a third array
element, after the range boundary ones: the old_style block
name.)</p>
<p style="margin-left:9%; margin-top: 1em">If the argument
to charblock() is not a known block, "undef" is
returned.</p>
<h3>charscript()
<a name="charscript()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charscript'; <br/>
my $charscript = charscript(0x41); <br/>
my $charscript = charscript(1234); <br/>
my $charscript = charscript("U+263a"); <br/>
my $range = charscript('Thai');</p>
<p style="margin-left:9%; margin-top: 1em">With a
"code point argument", charscript() returns the
<i>script</i> the code point belongs to, e.g.,
"Latin", "Greek", "Han". If
the code point is unassigned or the Unicode version being
used is so early that it doesn’t have scripts, this
function returns "Unknown". The
"<b>prop_value_aliases()</b>" function can be used
to get all the synonyms of the script name.</p>
<p style="margin-left:9%; margin-top: 1em">Note that the
Script_Extensions property is an improved version of the
Script property, and you should probably be using that
instead, with the "<b>charprop()</b>"
function.</p>
<p style="margin-left:9%; margin-top: 1em">If supplied with
an argument that can’t be a code point,
<b>charscript()</b> tries to do the opposite and interpret
the argument as a script name. The return value is a
<i>range set</i>: an anonymous array of arrays that contain
<i>start-of-range</i>, <i>end-of-range</i> code point pairs.
You can test whether a code point is in a range set using
the "<b>charinrange()</b>" function. (To be
precise, each <i>range set</i> contains a third array
element, after the range boundary ones: the script
name.)</p>
<p style="margin-left:9%; margin-top: 1em">If the
charscript() argument is not a known script,
"undef" is returned.</p>
<p style="margin-left:9%; margin-top: 1em">See also
"Blocks versus Scripts".</p>
<h3>charblocks()
<a name="charblocks()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charblocks'; <br/>
my $charblocks = charblocks();</p>
<p style="margin-left:9%; margin-top: 1em">charblocks()
returns a reference to a hash with the known block names as
the keys, and the code point ranges (see
"<b>charblock()</b>") as the values.</p>
<p style="margin-left:9%; margin-top: 1em">The names are in
the old-style (see "Old-style versus new-style block
names").</p>
<p style="margin-left:9%; margin-top: 1em">prop_invmap("block")
can be used to get this same data in a different type of
data structure.</p>
<p style="margin-left:9%; margin-top: 1em">prop_values("Block")
can be used to get all the known new-style block names as a
list, without the code point ranges.</p>
<p style="margin-left:9%; margin-top: 1em">See also
"Blocks versus Scripts".</p>
<h3>charscripts()
<a name="charscripts()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'charscripts'; <br/>
my $charscripts = charscripts();</p>
<p style="margin-left:9%; margin-top: 1em">charscripts()
returns a reference to a hash with the known script names as
the keys, and the code point ranges (see
"<b>charscript()</b>") as the values.</p>
<p style="margin-left:9%; margin-top: 1em">prop_invmap("script")
can be used to get this same data in a different type of
data structure. Since the Script_Extensions property is an
improved version of the Script property, you should instead
use prop_invmap("scx").</p>
<p style="margin-left:9%; margin-top: 1em">prop_values("Script")
can be used to get all the known script names as a list,
without the code point ranges.</p>
<p style="margin-left:9%; margin-top: 1em">See also
"Blocks versus Scripts".</p>
<h3>charinrange()
<a name="charinrange()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In addition to
using the "\p{Blk=...}" and
"\P{Blk=...}" constructs, you can also test
whether a code point is in the <i>range</i> as returned by
"<b>charblock()</b>" and
"<b>charscript()</b>" or as the values of the hash
returned by "<b>charblocks()</b>" and
"<b>charscripts()</b>" by using charinrange():</p>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
qw(charscript charinrange); <br/>
$range = charscript('Hiragana'); <br/>
print "looks like hiragana\n" if
charinrange($range, $codepoint);</p>
<h3>general_categories()
<a name="general_categories()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'general_categories'; <br/>
my $categories = general_categories();</p>
<p style="margin-left:9%; margin-top: 1em">This returns a
reference to a hash which has short general category names
(such as "Lu", "Nd", "Zs",
"S") as keys and long names (such as
"UppercaseLetter", "DecimalNumber",
"SpaceSeparator", "Symbol") as values.
The hash is reversible in case you need to go from the long
names to the short names. The general category is the one
returned from "<b>charinfo()</b>" under the
"category" key.</p>
<p style="margin-left:9%; margin-top: 1em">The
"<b>prop_values()</b>" and
"<b>prop_value_aliases()</b>" functions can be
used as an alternative to this function; the first returning
a simple list of the short category names; and the second
gets all the synonyms of a given category name.</p>
<h3>bidi_types()
<a name="bidi_types()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'bidi_types'; <br/>
my $categories = bidi_types();</p>
<p style="margin-left:9%; margin-top: 1em">This returns a
reference to a hash which has the short bidi (bidirectional)
type names (such as "L", "R") as keys
and long names (such as
"Left−to−Right",
"Right−to−Left") as values. The hash
is reversible in case you need to go from the long names to
the short names. The bidi type is the one returned from
"<b>charinfo()</b>" under the "bidi"
key. For the exact meaning of the various bidi classes the
Unicode TR9 is recommended reading:
&lt;http://www.unicode.org/reports/tr9/&gt; (as of Unicode
5.0.0)</p>
<p style="margin-left:9%; margin-top: 1em">The
"<b>prop_values()</b>" and
"<b>prop_value_aliases()</b>" functions can be
used as an alternative to this function; the first returning
a simple list of the short bidi type names; and the second
gets all the synonyms of a given bidi type name.</p>
<h3>compexcl()
<a name="compexcl()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">WARNING: Unicode
discourages the use of this function or any of the
alternative mechanisms listed in this section (the
documentation of compexcl()), except internally in
implementations of the Unicode Normalization Algorithm. You
should be using Unicode::Normalize directly instead of
these. Using these will likely lead to half-baked
results.</p>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'compexcl'; <br/>
my $compexcl = compexcl(0x09dc);</p>
<p style="margin-left:9%; margin-top: 1em">This routine
returns "undef" if the Unicode version being used
is so early that it doesn’t have this property.</p>
<p style="margin-left:9%; margin-top: 1em">compexcl() is
included for backwards compatibility, but as of Perl 5.12
and more modern Unicode versions, for most purposes it is
probably more convenient to use one of the following
instead:</p>
<p style="margin-left:9%; margin-top: 1em">my $compexcl =
chr(0x09dc) =˜ /\p{Comp_Ex}; <br/>
my $compexcl = chr(0x09dc) =˜
/\p{Full_Composition_Exclusion};</p>
<p style="margin-left:9%; margin-top: 1em">or even</p>
<p style="margin-left:9%; margin-top: 1em">my $compexcl =
chr(0x09dc) =˜ /\p{CE}; <br/>
my $compexcl = chr(0x09dc) =˜
/\p{Composition_Exclusion};</p>
<p style="margin-left:9%; margin-top: 1em">The first two
forms return <b>true</b> if the "code point
argument" should not be produced by composition
normalization. For the final two forms to return
<b>true</b>, it is additionally required that this fact not
otherwise be determinable from the Unicode data base.</p>
<p style="margin-left:9%; margin-top: 1em">This routine
behaves identically to the final two forms. That is, it does
not return <b>true</b> if the code point has a decomposition
consisting of another single code point, nor if its
decomposition starts with a code point whose combining class
is non-zero. Code points that meet either of these
conditions should also not be produced by composition
normalization, which is probably why you should use the
"Full_Composition_Exclusion" property instead, as
shown above.</p>
<p style="margin-left:9%; margin-top: 1em">The routine
returns <b>false</b> otherwise.</p>
<h3>casefold()
<a name="casefold()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'casefold'; <br/>
my $casefold = casefold(0xDF); <br/>
if (defined $casefold) { <br/>
my @full_fold_hex = split / /, $casefold−&gt;{'full'};
<br/>
my $full_fold_string = <br/>
join "", map {chr(hex($_))} @full_fold_hex; <br/>
my @turkic_fold_hex = <br/>
split / /, ($casefold−&gt;{'turkic'} ne "")
<br/>
? $casefold−&gt;{'turkic'} <br/>
: $casefold−&gt;{'full'}; <br/>
my $turkic_fold_string = <br/>
join "", map {chr(hex($_))} @turkic_fold_hex; <br/>
} <br/>
if (defined $casefold &amp;&amp;
$casefold−&gt;{'simple'} ne "") { <br/>
my $simple_fold_hex = $casefold−&gt;{'simple'}; <br/>
my $simple_fold_string = chr(hex($simple_fold_hex)); <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">This returns the
(almost) locale-independent case folding of the character
specified by the "code point argument". (Starting
in Perl v5.16, the core function fc() returns the
"full" mapping (described below) faster than this
does, and for entire strings.)</p>
<p style="margin-left:9%; margin-top: 1em">If there is no
case folding for the input code point, "undef" is
returned.</p>
<p style="margin-left:9%; margin-top: 1em">If there is a
case folding for that code point, a reference to a hash with
the following fields is returned: <b><br/>
code</b></p>
<p style="margin-left:14%;">the input native "code
point argument" expressed in hexadecimal, with leading
zeros added if necessary to make it contain at least four
hexdigits</p>
<p style="margin-left:9%;"><b>full</b></p>
<p style="margin-left:14%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
case folding for <i>code</i>. Each has at least four
hexdigits.</p>
<p style="margin-left:9%;"><b>simple</b></p>
<p style="margin-left:14%;">is empty, or is exactly one
code with at least four hexdigits which can be used as an
alternative case folding when the calling program cannot
cope with the fold being a sequence of multiple code points.
If <i>full</i> is just one code point, then <i>simple</i>
equals <i>full</i>. If there is no single code point folding
defined for <i>code</i>, then <i>simple</i> is the empty
string. Otherwise, it is an inferior, but still
better-than-nothing alternative folding to <i>full</i>.</p>
<p style="margin-left:9%;"><b>mapping</b></p>
<p style="margin-left:14%;">is the same as <i>simple</i> if
<i>simple</i> is not empty, and it is the same as
<i>full</i> otherwise. It can be considered to be the
simplest possible folding for <i>code</i>. It is defined
primarily for backwards compatibility.</p>
<p style="margin-left:9%;"><b>status</b></p>
<p style="margin-left:14%;">is "C" (for
"common") if the best possible fold is a single
code point (<i>simple</i> equals <i>full</i> equals
<i>mapping</i>). It is "S" if there are distinct
folds, <i>simple</i> and <i>full</i> (<i>mapping</i> equals
<i>simple</i>). And it is "F" if there is only a
<i>full</i> fold (<i>mapping</i> equals <i>full</i>;
<i>simple</i> is empty). Note that this describes the
contents of <i>mapping</i>. It is defined primarily for
backwards compatibility.</p>
<p style="margin-left:14%; margin-top: 1em">For Unicode
versions between 3.1 and 3.1.1 inclusive, <i>status</i> can
also be "I" which is the same as "C" but
is a special case for dotted uppercase I and dotless
lowercase i: <b><br/>
*</b> If you use this "I" mapping</p>
<p style="margin-left:19%;">the result is case-insensitive,
but dotless and dotted I’s are not distinguished</p>
<p style="margin-left:14%;"><b>*</b> If you exclude this
"I" mapping</p>
<p style="margin-left:19%;">the result is not fully
case-insensitive, but dotless and dotted I’s are
distinguished</p>
<p style="margin-left:9%;"><b>turkic</b></p>
<p style="margin-left:14%;">contains any special folding
for Turkic languages. For versions of Unicode starting with
3.2, this field is empty unless <i>code</i> has a different
folding in Turkic languages, in which case it is one or more
codes (separated by spaces) that, taken in order, give the
code points for the case folding for <i>code</i> in those
languages. Each code has at least four hexdigits. Note that
this folding does not maintain canonical equivalence without
additional processing.</p>
<p style="margin-left:14%; margin-top: 1em">For Unicode
versions between 3.1 and 3.1.1 inclusive, this field is
empty unless there is a special folding for Turkic
languages, in which case <i>status</i> is "I", and
<i>mapping</i>, <i>full</i>, <i>simple</i>, and
<i>turkic</i> are all equal.</p>
<p style="margin-left:9%; margin-top: 1em">Programs that
want complete generality and the best folding results should
use the folding contained in the <i>full</i> field. But note
that the fold for some code points will be a sequence of
multiple code points.</p>
<p style="margin-left:9%; margin-top: 1em">Programs that
can’t cope with the fold mapping being multiple code
points can use the folding contained in the <i>simple</i>
field, with the loss of some generality. In Unicode 5.1,
about 7% of the defined foldings have no single code point
folding.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>mapping</i> and <i>status</i> fields are provided for
backwards compatibility for existing programs. They contain
the same values as in previous versions of this
function.</p>
<p style="margin-left:9%; margin-top: 1em">Locale is not
completely independent. The <i>turkic</i> field contains
results to use when the locale is a Turkic language.</p>
<p style="margin-left:9%; margin-top: 1em">For more
information about case mappings see
&lt;http://www.unicode.org/reports/tr21&gt;</p>
<h3>all_casefolds()
<a name="all_casefolds()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'all_casefolds'; <br/>
my $all_folds_ref = all_casefolds(); <br/>
foreach my $char_with_casefold (sort { $a &lt;=&gt; $b }
<br/>
keys %$all_folds_ref) <br/>
{ <br/>
printf "%04X:", $char_with_casefold; <br/>
my $casefold =
$all_folds_ref−&gt;{$char_with_casefold}; <br/>
# Get folds for $char_with_casefold <br/>
my @full_fold_hex = split / /, $casefold−&gt;{'full'};
<br/>
my $full_fold_string = <br/>
join "", map {chr(hex($_))} @full_fold_hex; <br/>
print " full=", join " ",
@full_fold_hex; <br/>
my @turkic_fold_hex = <br/>
split / /, ($casefold−&gt;{'turkic'} ne "")
<br/>
? $casefold−&gt;{'turkic'} <br/>
: $casefold−&gt;{'full'}; <br/>
my $turkic_fold_string = <br/>
join "", map {chr(hex($_))} @turkic_fold_hex; <br/>
print "; turkic=", join " ",
@turkic_fold_hex; <br/>
if (defined $casefold &amp;&amp;
$casefold−&gt;{'simple'} ne "") { <br/>
my $simple_fold_hex = $casefold−&gt;{'simple'}; <br/>
my $simple_fold_string = chr(hex($simple_fold_hex)); <br/>
print "; simple=$simple_fold_hex"; <br/>
} <br/>
print "\n"; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">This returns all
the case foldings in the current version of Unicode in the
form of a reference to a hash. Each key to the hash is the
decimal representation of a Unicode character that has a
casefold to other than itself. The casefold of a semi-colon
is itself, so it isn’t in the hash; likewise for a
lowercase "a", but there is an entry for a capital
"A". The hash value for each key is another hash,
identical to what is returned by
"<b>casefold()</b>" if called with that code point
as its argument. So the value
"all_casefolds()−&gt;{ord("A")}'"
is equivalent to
"casefold(ord("A"))";</p>
<h3>casespec()
<a name="casespec()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'casespec'; <br/>
my $casespec = casespec(0xFB00);</p>
<p style="margin-left:9%; margin-top: 1em">This returns the
potentially locale-dependent case mappings of the "code
point argument". The mappings may be longer than a
single code point (which the basic Unicode case mappings as
returned by "<b>charinfo()</b>" never are).</p>
<p style="margin-left:9%; margin-top: 1em">If there are no
case mappings for the "code point argument", or if
all three possible mappings (<i>lower</i>, <i>title</i> and
<i>upper</i>) result in single code points and are locale
independent and unconditional, "undef" is returned
(which means that the case mappings, if any, for the code
point are those returned by
"<b>charinfo()</b>").</p>
<p style="margin-left:9%; margin-top: 1em">Otherwise, a
reference to a hash giving the mappings (or a reference to a
hash of such hashes, explained below) is returned with the
following keys and their meanings:</p>
<p style="margin-left:9%; margin-top: 1em">The keys in the
bottom layer hash with the meanings of their values are:
<b><br/>
code</b></p>
<p style="margin-left:14%;">the input native "code
point argument" expressed in hexadecimal, with leading
zeros added if necessary to make it contain at least four
hexdigits</p>
<p style="margin-left:9%;"><b>lower</b></p>
<p style="margin-left:14%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
lower case of <i>code</i>. Each has at least four
hexdigits.</p>
<p style="margin-left:9%;"><b>title</b></p>
<p style="margin-left:14%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
title case of <i>code</i>. Each has at least four
hexdigits.</p>
<p style="margin-left:9%;"><b>upper</b></p>
<p style="margin-left:14%;">one or more codes (separated by
spaces) that, taken in order, give the code points for the
upper case of <i>code</i>. Each has at least four
hexdigits.</p>
<p style="margin-left:9%;"><b>condition</b></p>
<p style="margin-left:14%;">the conditions for the mappings
to be valid. If "undef", the mappings are always
valid. When defined, this field is a list of conditions, all
of which must be true for the mappings to be valid. The list
consists of one or more <i>locales</i> (see below) and/or
<i>contexts</i> (explained in the next paragraph), separated
by spaces. (Other than as used to separate elements, spaces
are to be ignored.) Case distinctions in the condition list
are not significant. Conditions preceded by "NON_"
represent the negation of the condition.</p>
<p style="margin-left:14%; margin-top: 1em">A
<i>context</i> is one of those defined in the Unicode
standard. For Unicode 5.1, they are defined in Section 3.13
"Default Case Operations" available at
&lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;. These
are for context-sensitive casing.</p>
<p style="margin-left:9%; margin-top: 1em">The hash
described above is returned for locale-independent casing,
where at least one of the mappings has length longer than
one. If "undef" is returned, the code point may
have mappings, but if so, all are length one, and are
returned by "<b>charinfo()</b>". Note that when
this function does return a value, it will be for the
complete set of mappings for a code point, even those whose
length is one.</p>
<p style="margin-left:9%; margin-top: 1em">If there are
additional casing rules that apply only in certain locales,
an additional key for each will be defined in the returned
hash. Each such key will be its locale name, defined as a
2−letter ISO 3166 country code, possibly followed by a
"_" and a 2−letter ISO language code
(possibly followed by a "_" and a variant code).
You can find the lists of all possible locales, see
Locale::Country and Locale::Language. (In Unicode 6.0, the
only locales returned by this function are "lt",
"tr", and "az".)</p>
<p style="margin-left:9%; margin-top: 1em">Each locale key
is a reference to a hash that has the form above, and gives
the casing rules for that particular locale, which take
precedence over the locale-independent ones when in that
locale.</p>
<p style="margin-left:9%; margin-top: 1em">If the only
casing for a code point is locale-dependent, then the
returned hash will not have any of the base keys, like
"code", "upper", etc., but will contain
only locale keys.</p>
<p style="margin-left:9%; margin-top: 1em">For more
information about case mappings see
&lt;http://www.unicode.org/reports/tr21/&gt;</p>
<h3>namedseq()
<a name="namedseq()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'namedseq'; <br/>
my $namedseq = namedseq("KATAKANA LETTER AINU P");
<br/>
my @namedseq = namedseq("KATAKANA LETTER AINU P");
<br/>
my %namedseq = namedseq();</p>
<p style="margin-left:9%; margin-top: 1em">If used with a
single argument in a scalar context, returns the string
consisting of the code points of the named sequence, or
"undef" if no named sequence by that name exists.
If used with a single argument in a list context, it returns
the list of the ordinals of the code points.</p>
<p style="margin-left:9%; margin-top: 1em">If used with no
arguments in a list context, it returns a hash with the
names of all the named sequences as the keys and their
sequences as strings as the values. Otherwise, it returns
"undef" or an empty list depending on the
context.</p>
<p style="margin-left:9%; margin-top: 1em">This function
only operates on officially approved (not provisional) named
sequences.</p>
<p style="margin-left:9%; margin-top: 1em">Note that as of
Perl 5.14, "\N{KATAKANA LETTER AINU P}" will
insert the named sequence into double-quoted strings, and
"charnames::string_vianame("KATAKANA LETTER AINU
P")" will return the same string this function
does, but will also operate on character names that
aren’t named sequences, without you having to know
which are which. See charnames.</p>
<h3>num()
<a name="num()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'num'; <br/>
my $val = num("123"); <br/>
my $one_quarter = num("\N{VULGAR FRACTION ONE
QUARTER}"); <br/>
my $val = num("12a", \$valid_length); #
$valid_length contains 2</p>
<p style="margin-left:9%; margin-top: 1em">num() returns
the numeric value of the input Unicode string; or
"undef" if it doesn’t think the entire
string has a completely valid, safe numeric value. If called
with an optional second parameter, a reference to a scalar,
num() will set the scalar to the length of any valid initial
substring; or to 0 if none.</p>
<p style="margin-left:9%; margin-top: 1em">If the string is
just one character in length, the Unicode numeric value is
returned if it has one, or "undef" otherwise. If
the optional scalar ref is passed, it would be set to 1 if
the return is valid; or 0 if the return is
"undef". Note that the numeric value returned need
not be a whole number. "num("\N{TIBETAN DIGIT HALF
ZERO}")", for example returns −0.5.</p>
<p style="margin-left:9%; margin-top: 1em">If the string is
more than one character, "undef" is returned
unless all its characters are decimal digits (that is, they
would match "\d+"), from the same script. For
example if you have an ASCII ’0’ and a Bengali
’3’, mixed together, they aren’t
considered a valid number, and "undef" is
returned. A further restriction is that the digits all have
to be of the same form. A half-width digit mixed with a
full-width one will return "undef". The Arabic
script has two sets of digits; "num" will return
"undef" unless all the digits in the string come
from the same set. In all cases, the optional scalar ref
parameter is set to how long any valid initial substring of
digits is; hence it will be set to the entire string length
if the main return value is not "undef".</p>
<p style="margin-left:9%; margin-top: 1em">"num"
errs on the side of safety, and there may be valid strings
of decimal digits that it doesn’t recognize. Note that
Unicode defines a number of "digit" characters
that aren’t "decimal digit" characters.
"Decimal digits" have the property that they have
a positional value, i.e., there is a units position, a
10’s position, a 100’s, etc, AND they are
arranged in Unicode in blocks of 10 contiguous code points.
The Chinese digits, for example, are not in such a
contiguous block, and so Unicode doesn’t view them as
decimal digits, but merely digits, and so "\d"
will not match them. A single-character string containing
one of these digits will have its decimal value returned by
"num", but any longer string containing only these
digits will return "undef".</p>
<p style="margin-left:9%; margin-top: 1em">Strings of
multiple sub− and superscripts are not recognized as
numbers. You can use either of the compatibility
decompositions in Unicode::Normalize to change these into
digits, and then call "num" on the result.</p>
<h3>prop_aliases()
<a name="prop_aliases()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'prop_aliases'; <br/>
my ($short_name, $full_name, @other_names) =
prop_aliases("space"); <br/>
my $same_full_name = prop_aliases("Space"); #
Scalar context <br/>
my ($same_short_name) = prop_aliases("Space"); #
gets 0th element <br/>
print "The full name is $full_name\n"; <br/>
print "The short name is $short_name\n"; <br/>
print "The other aliases are: ", join(",
", @other_names), "\n"; <br/>
prints: <br/>
The full name is White_Space <br/>
The short name is WSpace <br/>
The other aliases are: Space</p>
<p style="margin-left:9%; margin-top: 1em">Most Unicode
properties have several synonymous names. Typically, there
is at least a short name, convenient to type, and a long
name that more fully describes the property, and hence is
more easily understood.</p>
<p style="margin-left:9%; margin-top: 1em">If you know one
name for a Unicode property, you can use
"prop_aliases" to find either the long name (when
called in scalar context), or a list of all of the names,
somewhat ordered so that the short name is in the 0th
element, the long name in the next element, and any other
synonyms are in the remaining elements, in no particular
order.</p>
<p style="margin-left:9%; margin-top: 1em">The long name is
returned in a form nicely capitalized, suitable for
printing.</p>
<p style="margin-left:9%; margin-top: 1em">The input
parameter name is loosely matched, which means that white
space, hyphens, and underscores are ignored (except for the
trailing underscore in the old_form grandfathered-in
"L_", which is better written as "LC",
and both of which mean "General_Category=Cased
Letter").</p>
<p style="margin-left:9%; margin-top: 1em">If the name is
unknown, "undef" is returned (or an empty list in
list context). Note that Perl typically recognizes property
names in regular expressions with an optional
""Is_"" (with or without the underscore)
prefixed to them, such as "\p{isgc=punct}". This
function does not recognize those in the input, returning
"undef". Nor are they included in the output as
possible synonyms.</p>
<p style="margin-left:9%; margin-top: 1em">"prop_aliases"
does know about the Perl extensions to Unicode properties,
such as "Any" and "XPosixAlpha", and the
single form equivalents to Unicode properties such as
"XDigit", "Greek", "In_Greek",
and "Is_Greek". The final example demonstrates
that the "Is_" prefix is recognized for these
extensions; it is needed to resolve ambiguities. For
example, prop_aliases('lc') returns the list "(lc,
Lowercase_Mapping)", but prop_aliases('islc') returns
"(Is_LC, Cased_Letter)". This is because
"islc" is a Perl extension which is short for
"General_Category=Cased Letter". The lists
returned for the Perl extensions will not include the
"Is_" prefix (whether or not the input had it)
unless needed to resolve ambiguities, as shown in the
"islc" example, where the returned list had one
element containing "Is_", and the other
without.</p>
<p style="margin-left:9%; margin-top: 1em">It is also
possible for the reverse to happen: prop_aliases('isc')
returns the list "(isc, ISO_Comment)"; whereas
prop_aliases('c') returns "(C, Other)" (the latter
being a Perl extension meaning
"General_Category=Other". "Properties
accessible through Unicode::UCD" in perluniprops lists
the available forms, including which ones are discouraged
from use.</p>
<p style="margin-left:9%; margin-top: 1em">Those
discouraged forms are accepted as input to
"prop_aliases", but are not returned in the lists.
prop_aliases('isL&amp;') and prop_aliases('isL_'), which are
old synonyms for "Is_LC" and should not be used in
new code, are examples of this. These both return
"(Is_LC, Cased_Letter)". Thus this function allows
you to take a discouraged form, and find its acceptable
alternatives. The same goes with single-form Block property
equivalences. Only the forms that begin with "In_"
are not discouraged; if you pass "prop_aliases" a
discouraged form, you will get back the equivalent ones that
begin with "In_". It will otherwise look like a
new-style block name (see. "Old-style versus new-style
block names").</p>
<p style="margin-left:9%; margin-top: 1em">"prop_aliases"
does not know about any user-defined properties, and will
return "undef" if called with one of those.
Likewise for Perl internal properties, with the exception of
"Perl_Decimal_Digit" which it does know about (and
which is documented below in
"<b>prop_invmap()</b>").</p>
<h3>prop_values()
<a name="prop_values()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'prop_values'; <br/>
print "AHex values are: ", join(", ",
prop_values("AHex")), <br/>
"\n"; <br/>
prints: <br/>
AHex values are: N, Y</p>
<p style="margin-left:9%; margin-top: 1em">Some Unicode
properties have a restricted set of legal values. For
example, all binary properties are restricted to just
"true" or "false"; and there are only a
few dozen possible General Categories. Use
"prop_values" to find out if a given property is
one such, and if so, to get a list of the values:</p>
<p style="margin-left:9%; margin-top: 1em">print join
", ", prop_values("NFC_Quick_Check");
<br/>
prints: <br/>
M, N, Y</p>
<p style="margin-left:9%; margin-top: 1em">If the property
doesn’t have such a restricted set, "undef"
is returned.</p>
<p style="margin-left:9%; margin-top: 1em">There are
usually several synonyms for each possible value. Use
"<b>prop_value_aliases()</b>" to access those.</p>
<p style="margin-left:9%; margin-top: 1em">Case, white
space, hyphens, and underscores are ignored in the input
property name (except for the trailing underscore in the
old-form grandfathered-in general category property value
"L_", which is better written as
"LC").</p>
<p style="margin-left:9%; margin-top: 1em">If the property
name is unknown, "undef" is returned. Note that
Perl typically recognizes property names in regular
expressions with an optional ""Is_""
(with or without the underscore) prefixed to them, such as
"\p{isgc=punct}". This function does not recognize
those in the property parameter, returning
"undef".</p>
<p style="margin-left:9%; margin-top: 1em">For the block
property, new-style block names are returned (see
"Old-style versus new-style block names").</p>
<p style="margin-left:9%; margin-top: 1em">"prop_values"
does not know about any user-defined properties, and will
return "undef" if called with one of those.</p>
<h3>prop_value_aliases()
<a name="prop_value_aliases()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'prop_value_aliases'; <br/>
my ($short_name, $full_name, @other_names) <br/>
= prop_value_aliases("Gc", "Punct");
<br/>
my $same_full_name = prop_value_aliases("Gc",
"P"); # Scalar cntxt <br/>
my ($same_short_name) = prop_value_aliases("Gc",
"P"); # gets 0th <br/>
# element <br/>
print "The full name is $full_name\n"; <br/>
print "The short name is $short_name\n"; <br/>
print "The other aliases are: ", join(",
", @other_names), "\n"; <br/>
prints: <br/>
The full name is Punctuation <br/>
The short name is P <br/>
The other aliases are: Punct</p>
<p style="margin-left:9%; margin-top: 1em">Some Unicode
properties have a restricted set of legal values. For
example, all binary properties are restricted to just
"true" or "false"; and there are only a
few dozen possible General Categories.</p>
<p style="margin-left:9%; margin-top: 1em">You can use
"<b>prop_values()</b>" to find out if a given
property is one which has a restricted set of values, and if
so, what those values are. But usually each value actually
has several synonyms. For example, in Unicode binary
properties, <i>truth</i> can be represented by any of the
strings "Y", "Yes", "T", or
"True"; and the General Category
"Punctuation" by that string, or
"Punct", or simply "P".</p>
<p style="margin-left:9%; margin-top: 1em">Like property
names, there is typically at least a short name for each
such property-value, and a long name. If you know any name
of the property-value (which you can get by
"<b>prop_values()</b>", you can use
"prop_value_aliases"() to get the long name (when
called in scalar context), or a list of all the names, with
the short name in the 0th element, the long name in the next
element, and any other synonyms in the remaining elements,
in no particular order, except that any all-numeric synonyms
will be last.</p>
<p style="margin-left:9%; margin-top: 1em">The long name is
returned in a form nicely capitalized, suitable for
printing.</p>
<p style="margin-left:9%; margin-top: 1em">Case, white
space, hyphens, and underscores are ignored in the input
parameters (except for the trailing underscore in the
old-form grandfathered-in general category property value
"L_", which is better written as
"LC").</p>
<p style="margin-left:9%; margin-top: 1em">If either name
is unknown, "undef" is returned. Note that Perl
typically recognizes property names in regular expressions
with an optional ""Is_"" (with or
without the underscore) prefixed to them, such as
"\p{isgc=punct}". This function does not recognize
those in the property parameter, returning
"undef".</p>
<p style="margin-left:9%; margin-top: 1em">If called with a
property that doesn’t have synonyms for its values, it
returns the input value, possibly normalized with
capitalization and underscores, but not necessarily checking
that the input value is valid.</p>
<p style="margin-left:9%; margin-top: 1em">For the block
property, new-style block names are returned (see
"Old-style versus new-style block names").</p>
<p style="margin-left:9%; margin-top: 1em">To find the
synonyms for single-forms, such as "\p{Any}", use
"<b>prop_aliases()</b>" instead.</p>
<p style="margin-left:9%; margin-top: 1em">"prop_value_aliases"
does not know about any user-defined properties, and will
return "undef" if called with one of those.</p>
<h3>prop_invlist()
<a name="prop_invlist()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"prop_invlist"
returns an inversion list (described below) that defines all
the code points for the binary Unicode property (or
"property=value" pair) given by the input
parameter string:</p>
<p style="margin-left:9%; margin-top: 1em">use feature
'say'; <br/>
use Unicode::UCD 'prop_invlist'; <br/>
say join ", ", prop_invlist("Any"); <br/>
prints: <br/>
0, 1114112</p>
<p style="margin-left:9%; margin-top: 1em">If the input is
unknown "undef" is returned in scalar context; an
empty-list in list context. If the input is known, the
number of elements in the list is returned if called in
scalar context.</p>
<p style="margin-left:9%; margin-top: 1em">perluniprops
gives the list of properties that this function accepts, as
well as all the possible forms for them (including with the
optional "Is_" prefixes). (Except this function
doesn’t accept any Perl-internal properties, some of
which are listed there.) This function uses the same loose
or tighter matching rules for resolving the input
property’s name as is done for regular expressions.
These are also specified in perluniprops. Examples of using
the "property=value" form are:</p>
<p style="margin-left:9%; margin-top: 1em">say join ",
", prop_invlist("Script_Extensions=Shavian");
<br/>
prints: <br/>
66640, 66688 <br/>
say join ", ",
prop_invlist("ASCII_Hex_Digit=No"); <br/>
prints: <br/>
0, 48, 58, 65, 71, 97, 103 <br/>
say join ", ",
prop_invlist("ASCII_Hex_Digit=Yes"); <br/>
prints: <br/>
48, 58, 65, 71, 97, 103</p>
<p style="margin-left:9%; margin-top: 1em">Inversion lists
are a compact way of specifying Unicode property-value
definitions. The 0th item in the list is the lowest code
point that has the property-value. The next item (item [1])
is the lowest code point beyond that one that does NOT have
the property-value. And the next item beyond that ([2]) is
the lowest code point beyond that one that does have the
property-value, and so on. Put another way, each element in
the list gives the beginning of a range that has the
property-value (for even numbered elements), or
doesn’t have the property-value (for odd numbered
elements). The name for this data structure stems from the
fact that each element in the list toggles (or inverts)
whether the corresponding range is or isn’t on the
list.</p>
<p style="margin-left:9%; margin-top: 1em">In the final
example above, the first ASCII Hex digit is code point 48,
the character "0", and all code points from it
through 57 (a "9") are ASCII hex digits. Code
points 58 through 64 aren’t, but 65 (an "A")
through 70 (an "F") are, as are 97 ("a")
through 102 ("f"). 103 starts a range of code
points that aren’t ASCII hex digits. That range
extends to infinity, which on your computer can be found in
the variable $Unicode::UCD::MAX_CP. (This variable is as
close to infinity as Perl can get on your platform, and may
be too high for some operations to work; you may wish to use
a smaller number for your purposes.)</p>
<p style="margin-left:9%; margin-top: 1em">Note that the
inversion lists returned by this function can possibly
include non-Unicode code points, that is anything above
0x10FFFF. Unicode properties are not defined on such code
points. You might wish to change the output to not include
these. Simply add 0x110000 at the end of the non-empty
returned list if it isn’t already that value; and pop
that value if it is; like:</p>
<p style="margin-left:9%; margin-top: 1em">my @list =
prop_invlist("foo"); <br/>
if (@list) { <br/>
if ($list[−1] == 0x110000) { <br/>
pop @list; # Defeat the turning on for above Unicode <br/>
} <br/>
else { <br/>
push @list, 0x110000; # Turn off for above Unicode <br/>
} <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">It is a simple
matter to expand out an inversion list to a full list of all
code points that have the property-value:</p>
<p style="margin-left:9%; margin-top: 1em">my @invlist =
prop_invlist($property_name); <br/>
die "empty" unless @invlist; <br/>
my @full_list; <br/>
for (my $i = 0; $i &lt; @invlist; $i += 2) { <br/>
my $upper = ($i + 1) &lt; @invlist <br/>
? $invlist[$i+1] − 1 # In range <br/>
: $Unicode::UCD::MAX_CP; # To infinity. <br/>
for my $j ($invlist[$i] .. $upper) { <br/>
push @full_list, $j; <br/>
} <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">"prop_invlist"
does not know about any user-defined nor Perl internal-only
properties, and will return "undef" if called with
one of those.</p>
<p style="margin-left:9%; margin-top: 1em">The
"<b>search_invlist()</b>" function is provided for
finding a code point within an inversion list.</p>
<h3>prop_invmap()
<a name="prop_invmap()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
'prop_invmap'; <br/>
my ($list_ref, $map_ref, $format, $default) <br/>
= prop_invmap("General Category");</p>
<p style="margin-left:9%; margin-top: 1em">"prop_invmap"
is used to get the complete mapping definition for a
property, in the form of an inversion map. An inversion map
consists of two parallel arrays. One is an ordered list of
code points that mark range beginnings, and the other gives
the value (or mapping) that all code points in the
corresponding range have.</p>
<p style="margin-left:9%; margin-top: 1em">"prop_invmap"
is called with the name of the desired property. The name is
loosely matched, meaning that differences in case,
white-space, hyphens, and underscores are not meaningful
(except for the trailing underscore in the old-form
grandfathered-in property "L_", which is better
written as "LC", or even better,
"Gc=LC").</p>
<p style="margin-left:9%; margin-top: 1em">Many Unicode
properties have more than one name (or alias).
"prop_invmap" understands all of these, including
Perl extensions to them. Ambiguities are resolved as
described above for "<b>prop_aliases()</b>"
(except if a property has both a complete mapping, and a
binary "Y"/"N" mapping, then specifying
the property name prefixed by "is" causes the
binary one to be returned). The Perl internal property
"Perl_Decimal_Digit, described below, is also accepted.
An empty list is returned if the property name is unknown.
See "Properties accessible through Unicode::UCD"
in perluniprops for the properties acceptable as inputs to
this function.</p>
<p style="margin-left:9%; margin-top: 1em">It is a fatal
error to call this function except in list context.</p>
<p style="margin-left:9%; margin-top: 1em">In addition to
the two arrays that form the inversion map,
"prop_invmap" returns two other values; one is a
scalar that gives some details as to the format of the
entries of the map array; the other is a default value,
useful in maps whose format name begins with the letter
"a", as described below in its subsection; and for
specialized purposes, such as converting to another data
structure, described at the end of this main section.</p>
<p style="margin-left:9%; margin-top: 1em">This means that
"prop_invmap" returns a 4 element list. For
example,</p>
<p style="margin-left:9%; margin-top: 1em">my
($blocks_ranges_ref, $blocks_maps_ref, $format, $default)
<br/>
= prop_invmap("Block");</p>
<p style="margin-left:9%; margin-top: 1em">In this call,
the two arrays will be populated as shown below (for Unicode
6.0):</p>
<p style="margin-left:9%; margin-top: 1em">Index
@blocks_ranges @blocks_maps <br/>
0 0x0000 Basic Latin <br/>
1 0x0080 Latin−1 Supplement <br/>
2 0x0100 Latin Extended−A <br/>
3 0x0180 Latin Extended−B <br/>
4 0x0250 IPA Extensions <br/>
5 0x02B0 Spacing Modifier Letters <br/>
6 0x0300 Combining Diacritical Marks <br/>
7 0x0370 Greek and Coptic <br/>
8 0x0400 Cyrillic <br/>
... <br/>
233 0x2B820 No_Block <br/>
234 0x2F800 CJK Compatibility Ideographs Supplement <br/>
235 0x2FA20 No_Block <br/>
236 0xE0000 Tags <br/>
237 0xE0080 No_Block <br/>
238 0xE0100 Variation Selectors Supplement <br/>
239 0xE01F0 No_Block <br/>
240 0xF0000 Supplementary Private Use Area−A <br/>
241 0x100000 Supplementary Private Use Area−B <br/>
242 0x110000 No_Block</p>
<p style="margin-left:9%; margin-top: 1em">The first line
(with Index [0]) means that the value for code point 0 is
"Basic Latin". The entry "0x0080" in the
@blocks_ranges column in the second line means that the
value from the first line, "Basic Latin", extends
to all code points in the range from 0 up to but not
including 0x0080, that is, through 127. In other words, the
code points from 0 to 127 are all in the "Basic
Latin" block. Similarly, all code points in the range
from 0x0080 up to (but not including) 0x0100 are in the
block named "Latin−1 Supplement", etc.
(Notice that the return is the old-style block names; see
"Old-style versus new-style block names").</p>
<p style="margin-left:9%; margin-top: 1em">The final line
(with Index [242]) means that the value for all code points
above the legal Unicode maximum code point have the value
"No_Block", which is the term Unicode uses for a
non-existing block.</p>
<p style="margin-left:9%; margin-top: 1em">The arrays
completely specify the mappings for all possible code
points. The final element in an inversion map returned by
this function will always be for the range that consists of
all the code points that aren’t legal Unicode, but
that are expressible on the platform. (That is, it starts
with code point 0x110000, the first code point above the
legal Unicode maximum, and extends to infinity.) The value
for that range will be the same that any typical unassigned
code point has for the specified property. (Certain
unassigned code points are not "typical"; for
example the non-character code points, or those in blocks
that are to be written right-to-left. The above-Unicode
range’s value is not based on these atypical code
points.) It could be argued that, instead of treating these
as unassigned Unicode code points, the value for this range
should be "undef". If you wish, you can change the
returned arrays accordingly.</p>
<p style="margin-left:9%; margin-top: 1em">The maps for
almost all properties are simple scalars that should be
interpreted as-is. These values are those given in the
Unicode-supplied data files, which may be inconsistent as to
capitalization and as to which synonym for a property-value
is given. The results may be normalized by using the
"<b>prop_value_aliases()</b>" function.</p>
<p style="margin-left:9%; margin-top: 1em">There are
exceptions to the simple scalar maps. Some properties have
some elements in their map list that are themselves lists of
scalars; and some special strings are returned that are not
to be interpreted as-is. Element [2] (placed into $format in
the example above) of the returned four element list tells
you if the map has any of these special elements or not, as
follows:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p><b>"s"</b></p></td>
<td width="1%"></td>
<td width="86%">
<p>means all the elements of the map array are simple
scalars, with no special elements. Almost all properties are
like this, like the "block" example above.</p></td></tr>
</table>
<p style="margin-left:9%;"><b>"sl"</b></p>
<p style="margin-left:14%;">means that some of the map
array elements have the form given by "s", and the
rest are lists of scalars. For example, here is a portion of
the output of calling "prop_invmap"() with the
"Script Extensions" property:</p>
<p style="margin-left:14%; margin-top: 1em">@scripts_ranges
@scripts_maps <br/>
... <br/>
0x0953 Devanagari <br/>
0x0964 [ Bengali, Devanagari, Gurumukhi, Oriya ] <br/>
0x0966 Devanagari <br/>
0x0970 Common</p>
<p style="margin-left:14%; margin-top: 1em">Here, the code
points 0x964 and 0x965 are both used in Bengali, Devanagari,
Gurmukhi, and Oriya, but no other scripts.</p>
<p style="margin-left:14%; margin-top: 1em">The Name_Alias
property is also of this form. But each scalar consists of
two components: 1) the name, and 2) the type of alias this
is. They are separated by a colon and a space. In Unicode
6.1, there are several alias types: <br/>
"correction"</p>
<p style="margin-left:19%;">indicates that the name is a
corrected form for the original name (which remains valid)
for the same code point.</p>
<p style="margin-left:14%;">"control"</p>
<p style="margin-left:19%;">adds a new name for a control
character.</p>
<p style="margin-left:14%;">"alternate"</p>
<p style="margin-left:19%;">is an alternate name for a
character</p>
<p style="margin-left:14%;">"figment"</p>
<p style="margin-left:19%;">is a name for a character that
has been documented but was never in any actual
standard.</p>
<p style="margin-left:14%;">"abbreviation"</p>
<p style="margin-left:19%;">is a common abbreviation for a
character</p>
<p style="margin-left:14%; margin-top: 1em">The lists are
ordered (roughly) so the most preferred names come before
less preferred ones.</p>
<p style="margin-left:14%; margin-top: 1em">For
example,</p>
<p style="margin-left:14%; margin-top: 1em">@aliases_ranges
@alias_maps <br/>
... <br/>
0x009E [ 'PRIVACY MESSAGE: control', 'PM: abbreviation' ]
<br/>
0x009F [ 'APPLICATION PROGRAM COMMAND: control', <br/>
'APC: abbreviation' <br/>
] <br/>
0x00A0 'NBSP: abbreviation' <br/>
0x00A1 "" <br/>
0x00AD 'SHY: abbreviation' <br/>
0x00AE "" <br/>
0x01A2 'LATIN CAPITAL LETTER GHA: correction' <br/>
0x01A3 'LATIN SMALL LETTER GHA: correction' <br/>
0x01A4 "" <br/>
...</p>
<p style="margin-left:14%; margin-top: 1em">A map to the
empty string means that there is no alias defined for the
code point.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p><b>"a"</b></p></td>
<td width="1%"></td>
<td width="86%">
<p>is like "s" in that all the map array elements
are scalars, but here they are restricted to all being
integers, and some have to be adjusted (hence the name
"a") to get the correct result. For example,
in:</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">my
($uppers_ranges_ref, $uppers_maps_ref, $format, $default)
<br/>
= prop_invmap("Simple_Uppercase_Mapping");</p>
<p style="margin-left:14%; margin-top: 1em">the returned
arrays look like this:</p>
<p style="margin-left:14%; margin-top: 1em">@$uppers_ranges_ref
@$uppers_maps_ref Note <br/>
0 0 <br/>
97 65 'a' maps to 'A', b =&gt; B ... <br/>
123 0 <br/>
181 924 MICRO SIGN =&gt; Greek Cap MU <br/>
182 0 <br/>
...</p>
<p style="margin-left:14%; margin-top: 1em">and $default is
0.</p>
<p style="margin-left:14%; margin-top: 1em">Let’s
start with the second line. It says that the uppercase of
code point 97 is 65; or uc("a") == "A".
But the line is for the entire range of code points 97
through 122. To get the mapping for any code point in this
range, you take the offset it has from the beginning code
point of the range, and add that to the mapping for that
first code point. So, the mapping for 122 ("z") is
derived by taking the offset of 122 from 97 (=25) and adding
that to 65, yielding 90 ("Z"). Likewise for
everything in between.</p>
<p style="margin-left:14%; margin-top: 1em">Requiring this
simple adjustment allows the returned arrays to be
significantly smaller than otherwise, up to a factor of 10,
speeding up searching through them.</p>
<p style="margin-left:14%; margin-top: 1em">Ranges that map
to $default, "0", behave somewhat differently. For
these, each code point maps to itself. So, in the first line
in the example, "ord(uc(chr(0)))" is 0,
"ord(uc(chr(1)))" is 1, ..
"ord(uc(chr(96)))" is 96.</p>
<p style="margin-left:9%;"><b>"al"</b></p>
<p style="margin-left:14%;">means that some of the map
array elements have the form given by "a", and the
rest are ordered lists of code points. For example, in:</p>
<p style="margin-left:14%; margin-top: 1em">my
($uppers_ranges_ref, $uppers_maps_ref, $format, $default)
<br/>
= prop_invmap("Uppercase_Mapping");</p>
<p style="margin-left:14%; margin-top: 1em">the returned
arrays look like this:</p>
<p style="margin-left:14%; margin-top: 1em">@$uppers_ranges_ref
@$uppers_maps_ref <br/>
0 0 <br/>
97 65 <br/>
123 0 <br/>
181 924 <br/>
182 0 <br/>
... <br/>
0x0149 [ 0x02BC 0x004E ] <br/>
0x014A 0 <br/>
0x014B 330 <br/>
...</p>
<p style="margin-left:14%; margin-top: 1em">This is the
full Uppercase_Mapping property (as opposed to the
Simple_Uppercase_Mapping given in the example for format
"a"). The only difference between the two in the
ranges shown is that the code point at 0x0149 (LATIN SMALL
LETTER N PRECEDED BY APOSTROPHE) maps to a string of two
characters, 0x02BC (MODIFIER LETTER APOSTROPHE) followed by
0x004E (LATIN CAPITAL LETTER N).</p>
<p style="margin-left:14%; margin-top: 1em">No adjustments
are needed to entries that are references to arrays; each
such entry will have exactly one element in its range, so
the offset is always 0.</p>
<p style="margin-left:14%; margin-top: 1em">The fourth
(index [3]) element ($default) in the list returned for this
format is 0.</p>
<p style="margin-left:9%;"><b>"ae"</b></p>
<p style="margin-left:14%;">This is like "a", but
some elements are the empty string, and should not be
adjusted. The one internal Perl property accessible by
"prop_invmap" is of this type:
"Perl_Decimal_Digit" returns an inversion map
which gives the numeric values that are represented by the
Unicode decimal digit characters. Characters that
don’t represent decimal digits map to the empty
string, like so:</p>
<p style="margin-left:14%; margin-top: 1em">@digits @values
<br/>
0x0000 "" <br/>
0x0030 0 <br/>
0x003A: "" <br/>
0x0660: 0 <br/>
0x066A: "" <br/>
0x06F0: 0 <br/>
0x06FA: "" <br/>
0x07C0: 0 <br/>
0x07CA: "" <br/>
0x0966: 0 <br/>
...</p>
<p style="margin-left:14%; margin-top: 1em">This means that
the code points from 0 to 0x2F do not represent decimal
digits; the code point 0x30 (DIGIT ZERO) represents 0; code
point 0x31, (DIGIT ONE), represents 0+1−0 = 1; ...
code point 0x39, (DIGIT NINE), represents 0+9−0 = 9;
... code points 0x3A through 0x65F do not represent decimal
digits; 0x660 (ARABIC-INDIC DIGIT ZERO), represents 0; ...
0x07C1 (NKO DIGIT ONE), represents 0+1−0 = 1 ...</p>
<p style="margin-left:14%; margin-top: 1em">The fourth
(index [3]) element ($default) in the list returned for this
format is the empty string.</p>
<p style="margin-left:9%;"><b>"ale"</b></p>
<p style="margin-left:14%;">is a combination of the
"al" type and the "ae" type. Some of the
map array elements have the forms given by "al",
and the rest are the empty string. The property
"NFKC_Casefold" has this form. An example slice
is:</p>
<p style="margin-left:14%; margin-top: 1em">@$ranges_ref
@$maps_ref Note <br/>
... <br/>
0x00AA 97 FEMININE ORDINAL INDICATOR =&gt; 'a' <br/>
0x00AB 0 <br/>
0x00AD SOFT HYPHEN =&gt; "" <br/>
0x00AE 0 <br/>
0x00AF [ 0x0020, 0x0304 ] MACRON =&gt; SPACE . COMBINING
MACRON <br/>
0x00B0 0 <br/>
...</p>
<p style="margin-left:14%; margin-top: 1em">The fourth
(index [3]) element ($default) in the list returned for this
format is 0.</p>
<p style="margin-left:9%;"><b>"ar"</b></p>
<p style="margin-left:14%;">means that all the elements of
the map array are either rational numbers or the string
"NaN", meaning "Not a Number". A
rational number is either an integer, or two integers
separated by a solidus ("/"). The second integer
represents the denominator of the division implied by the
solidus, and is actually always positive, so it is
guaranteed not to be 0 and to not be signed. When the
element is a plain integer (without the solidus), it may
need to be adjusted to get the correct value by adding the
offset, just as other "a" properties. No
adjustment is needed for fractions, as the range is
guaranteed to have just a single element, and so the offset
is always 0.</p>
<p style="margin-left:14%; margin-top: 1em">If you want to
convert the returned map to entirely scalar numbers, you can
use something like this:</p>
<p style="margin-left:14%; margin-top: 1em">my
($invlist_ref, $invmap_ref, $format) =
prop_invmap($property); <br/>
if ($format &amp;&amp; $format eq "ar") { <br/>
map { $_ = eval $_ if $_ ne 'NaN' } @$map_ref; <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">Here’s
some entries from the output of the property "Nv",
which has format "ar".</p>
<p style="margin-left:14%; margin-top: 1em">@numerics_ranges
@numerics_maps Note <br/>
0x00 "NaN" <br/>
0x30 0 DIGIT 0 .. DIGIT 9 <br/>
0x3A "NaN" <br/>
0xB2 2 SUPERSCRIPTs 2 and 3 <br/>
0xB4 "NaN" <br/>
0xB9 1 SUPERSCRIPT 1 <br/>
0xBA "NaN" <br/>
0xBC 1/4 VULGAR FRACTION 1/4 <br/>
0xBD 1/2 VULGAR FRACTION 1/2 <br/>
0xBE 3/4 VULGAR FRACTION 3/4 <br/>
0xBF "NaN" <br/>
0x660 0 ARABIC−INDIC DIGIT ZERO .. NINE <br/>
0x66A "NaN"</p>
<p style="margin-left:14%; margin-top: 1em">The fourth
(index [3]) element ($default) in the list returned for this
format is "NaN".</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p><b>"n"</b></p></td>
<td width="1%"></td>
<td width="86%">
<p>means the Name property. All the elements of the map
array are simple scalars, but some of them contain special
strings that require more work to get the actual name.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Entries such
as:</p>
<p style="margin-left:14%; margin-top: 1em">CJK UNIFIED
IDEOGRAPH−&lt;code point&gt;</p>
<p style="margin-left:14%; margin-top: 1em">mean that the
name for the code point is "CJK UNIFIED
IDEOGRAPH−" with the code point (expressed in
hexadecimal) appended to it, like "CJK UNIFIED
IDEOGRAPH−3403" (similarly for
"CJK COMPATIBILITY IDEOGRAPH−&lt;code point&gt;").</p>
<p style="margin-left:14%; margin-top: 1em">Also, entries
like</p>
<p style="margin-left:14%; margin-top: 1em">&lt;hangul
syllable&gt;</p>
<p style="margin-left:14%; margin-top: 1em">means that the
name is algorithmically calculated. This is easily done by
the function "charnames::viacode(code)" in
charnames.</p>
<p style="margin-left:14%; margin-top: 1em">Note that for
control characters ("Gc=cc"), Unicode’s data
files have the string
""&lt;control&gt;"", but the real name
of each of these characters is the empty string. This
function returns that real name, the empty string. (There
are names for these characters, but they are considered
aliases, not the Name property name, and are contained in
the "Name_Alias" property.)</p>
<p style="margin-left:9%;"><b>"ad"</b></p>
<p style="margin-left:14%;">means the Decomposition_Mapping
property. This property is like "al" properties,
except that one of the scalar elements is of the form:</p>
<p style="margin-left:14%; margin-top: 1em">&lt;hangul
syllable&gt;</p>
<p style="margin-left:14%; margin-top: 1em">This signifies
that this entry should be replaced by the decompositions for
all the code points whose decomposition is algorithmically
calculated. (All of them are currently in one range and no
others outside the range are likely to ever be added to
Unicode; the "n" format has this same entry.)
These can be generated via the function
<b>Unicode::Normalize::NFD()</b>.</p>
<p style="margin-left:14%; margin-top: 1em">Note that the
mapping is the one that is specified in the Unicode data
files, and to get the final decomposition, it may need to be
applied recursively. Unicode in fact discourages use of this
property except internally in implementations of the Unicode
Normalization Algorithm.</p>
<p style="margin-left:14%; margin-top: 1em">The fourth
(index [3]) element ($default) in the list returned for this
format is 0.</p>
<p style="margin-left:9%; margin-top: 1em">Note that a
format begins with the letter "a" if and only the
property it is for requires adjustments by adding the
offsets in multi-element ranges. For all these properties,
an entry should be adjusted only if the map is a scalar
which is an integer. That is, it must match the regular
expression:</p>
<p style="margin-left:9%; margin-top: 1em">/ ˆ
−? \d+ $ /xa</p>
<p style="margin-left:9%; margin-top: 1em">Further, the
first element in a range never needs adjustment, as the
adjustment would be just adding 0.</p>
<p style="margin-left:9%; margin-top: 1em">A binary search
such as that provided by
"<b>search_invlist()</b>", can be used to quickly
find a code point in the inversion list, and hence its
corresponding mapping.</p>
<p style="margin-left:9%; margin-top: 1em">The final,
fourth element (index [3], assigned to $default in the
"block" example) in the four element list returned
by this function is used with the "a" format
types; it may also be useful for applications that wish to
convert the returned inversion map data structure into some
other, such as a hash. It gives the mapping that most code
points map to under the property. If you establish the
convention that any code point not explicitly listed in your
data structure maps to this value, you can potentially make
your data structure much smaller. As you construct your data
structure from the one returned by this function, simply
ignore those ranges that map to this value. For example, to
convert to the data structure searchable by
"<b>charinrange()</b>", you can follow this recipe
for properties that don’t require adjustments:</p>
<p style="margin-left:9%; margin-top: 1em">my ($list_ref,
$map_ref, $format, $default) = prop_invmap($property); <br/>
my @range_list; <br/>
# Look at each element in the list, but the −2 is
needed because we <br/>
# look at $i+1 in the loop, and the final element is
guaranteed to map <br/>
# to $default by prop_invmap(), so we would skip it anyway.
<br/>
for my $i (0 .. @$list_ref − 2) { <br/>
next if $map_ref−&gt;[$i] eq $default; <br/>
push @range_list, [ $list_ref−&gt;[$i], <br/>
$list_ref−&gt;[$i+1], <br/>
$map_ref−&gt;[$i] <br/>
]; <br/>
} <br/>
print charinrange(\@range_list, $code_point),
"\n";</p>
<p style="margin-left:9%; margin-top: 1em">With this,
charinrange() will return "undef" if its input
code point maps to $default. You can avoid this by omitting
the "next" statement, and adding a line after the
loop to handle the final element of the inversion map.</p>
<p style="margin-left:9%; margin-top: 1em">Similarly, this
recipe can be used for properties that do require
adjustments:</p>
<p style="margin-left:9%; margin-top: 1em">for my $i (0 ..
@$list_ref − 2) { <br/>
next if $map_ref−&gt;[$i] eq $default; <br/>
# prop_invmap() guarantees that if the mapping is to an
array, the <br/>
# range has just one element, so no need to worry about
adjustments. <br/>
if (ref $map_ref−&gt;[$i]) { <br/>
push @range_list, <br/>
[ $list_ref−&gt;[$i], $list_ref−&gt;[$i],
$map_ref−&gt;[$i] ]; <br/>
} <br/>
else { # Otherwise each element is actually mapped to a
separate <br/>
# value, so the range has to be split into single code point
<br/>
# ranges. <br/>
my $adjustment = 0; <br/>
# For each code point that gets mapped to something... <br/>
for my $j ($list_ref−&gt;[$i] ..
$list_ref−&gt;[$i+1] −1 ) { <br/>
# ... add a range consisting of just it mapping to the <br/>
# original plus the adjustment, which is incremented for the
<br/>
# next time through the loop, as the offset increases by 1
<br/>
# for each element in the range <br/>
push @range_list, <br/>
[ $j, $j, $map_ref−&gt;[$i] + $adjustment++ ]; <br/>
} <br/>
} <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Note that the
inversion maps returned for the "Case_Folding" and
"Simple_Case_Folding" properties do not include
the Turkic-locale mappings. Use
"<b>casefold()</b>" for these.</p>
<p style="margin-left:9%; margin-top: 1em">"prop_invmap"
does not know about any user-defined properties, and will
return "undef" if called with one of those.</p>
<p style="margin-left:9%; margin-top: 1em">The returned
values for the Perl extension properties, such as
"Any" and "Greek" are somewhat
misleading. The values are either "Y" or
""N"". All Unicode properties are
bipartite, so you can actually use the "Y" or
""N"" in a Perl regular expression for
these, like "qr/\p{ID_Start=Y/}" or
"qr/\p{Upper=N/}". But the Perl extensions
aren’t specified this way, only like
"/qr/\p{Any}", <i>etc</i>. You can’t
actually use the "Y" and ""N""
in them.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Getting every
available name</i></p>
<p style="margin-left:9%; margin-top: 1em">Instead of
reading the Unicode Database directly from files, as you
were able to do for a long time, you are encouraged to use
the supplied functions. So, instead of reading
"Name.pl" directly, which changed formats in 5.32,
and may do so again without notice in the future or even
disappear, you ought to use "<b>prop_invmap()</b>"
like this:</p>
<p style="margin-left:9%; margin-top: 1em">my (%name, %cp,
%cps, $n); <br/>
# All codepoints <br/>
foreach my $cat (qw( Name Name_Alias )) { <br/>
my ($codepoints, $names, $format, $default) =
prop_invmap($cat); <br/>
# $format =&gt; "n", $default =&gt; ""
<br/>
foreach my $i (0 .. @$codepoints − 2) { <br/>
my ($cp, $n) = ($codepoints−&gt;[$i],
$names−&gt;[$i]); <br/>
# If $n is a ref, the same codepoint has multiple names <br/>
foreach my $name (ref $n ? @$n : $n) { <br/>
$name{$cp} //= $name; <br/>
$cp{$name} //= $cp; <br/>
} <br/>
} <br/>
} <br/>
# Named sequences <br/>
{ my %ns = namedseq(); <br/>
foreach my $name (sort { $ns{$a} cmp $ns{$b} } keys %ns) {
<br/>
$cp{$name} //= [ map { ord } split "" =&gt;
$ns{$name} ]; <br/>
} <br/>
}</p>
<h3>search_invlist()
<a name="search_invlist()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Unicode::UCD
qw(prop_invmap prop_invlist); <br/>
use Unicode::UCD 'search_invlist'; <br/>
my @invlist = prop_invlist($property_name); <br/>
print $code_point, ((search_invlist(\@invlist, $code_point)
// −1) % 2) <br/>
? " isn't" <br/>
: " is", <br/>
" in $property_name\n"; <br/>
my ($blocks_ranges_ref, $blocks_map_ref) =
prop_invmap("Block"); <br/>
my $index = search_invlist($blocks_ranges_ref, $code_point);
<br/>
print "$code_point is in block ",
$blocks_map_ref−&gt;[$index], "\n";</p>
<p style="margin-left:9%; margin-top: 1em">"search_invlist"
is used to search an inversion list returned by
"prop_invlist" or "prop_invmap" for a
particular "code point argument".
"undef" is returned if the code point is not found
in the inversion list (this happens only when it is not a
legal "code point argument", or is less than the
list’s first element). A warning is raised in the
first instance.</p>
<p style="margin-left:9%; margin-top: 1em">Otherwise, it
returns the index into the list of the range that contains
the code point.; that is, find "i" such that</p>
<p style="margin-left:9%; margin-top: 1em">list[i]&lt;=
code_point &lt; list[i+1].</p>
<p style="margin-left:9%; margin-top: 1em">As explained in
"<b>prop_invlist()</b>", whether a code point is
in the list or not depends on if the index is even (in) or
odd (not in). And as explained in
"<b>prop_invmap()</b>", the index is used with the
returned parallel array to find the mapping.</p>
<h3>Unicode::UCD::UnicodeVersion
<a name="Unicode::UCD::UnicodeVersion"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This returns the
version of the Unicode Character Database, in other words,
the version of the Unicode standard the database implements.
The version is a string of numbers delimited by dots
('.').</p>
<h3>Blocks versus Scripts
<a name="Blocks versus Scripts"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The difference
between a block and a script is that scripts are closer to
the linguistic notion of a set of code points required to
represent languages, while block is more of an artifact of
the Unicode code point numbering and separation into blocks
of consecutive code points (so far the size of a block is
some multiple of 16, like 128 or 256).</p>
<p style="margin-left:9%; margin-top: 1em">For example the
Latin <b>script</b> is spread over several <b>blocks</b>,
such as "Basic Latin", "Latin 1
Supplement", "Latin Extended−A", and
"Latin Extended−B". On the other hand, the
Latin script does not contain all the characters of the
"Basic Latin" block (also known as ASCII): it
includes only the letters, and not, for example, the digits
nor the punctuation.</p>
<p style="margin-left:9%; margin-top: 1em">For blocks see
&lt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&gt;</p>
<p style="margin-left:9%; margin-top: 1em">For scripts see
UTR #24: &lt;http://www.unicode.org/reports/tr24/&gt;</p>
<h3>Matching Scripts and Blocks
<a name="Matching Scripts and Blocks"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Scripts are
matched with the regular-expression construct
"\p{...}" (e.g. "\p{Tibetan}" matches
characters of the Tibetan script), while
"\p{Blk=...}" is used for blocks (e.g.
"\p{Blk=Tibetan}" matches any of the 256 code
points in the Tibetan block).</p>
<h3>Old-style versus new-style block names
<a name="Old-style versus new-style block names"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Unicode
publishes the names of blocks in two different styles,
though the two are equivalent under Unicode’s loose
matching rules.</p>
<p style="margin-left:9%; margin-top: 1em">The original
style uses blanks and hyphens in the block names (except for
"No_Block"), like so:</p>
<p style="margin-left:9%; margin-top: 1em">Miscellaneous
Mathematical Symbols−B</p>
<p style="margin-left:9%; margin-top: 1em">The newer style
replaces these with underscores, like this:</p>
<p style="margin-left:9%; margin-top: 1em">Miscellaneous_Mathematical_Symbols_B</p>
<p style="margin-left:9%; margin-top: 1em">This newer style
is consistent with the values of other Unicode properties.
To preserve backward compatibility, all the functions in
Unicode::UCD that return block names (except as noted)
return the old-style ones.
"<b>prop_value_aliases()</b>" returns the
new-style and can be used to convert from old-style to
new-style:</p>
<p style="margin-left:9%; margin-top: 1em">my $new_style =
prop_values_aliases("block", $old_style);</p>
<p style="margin-left:9%; margin-top: 1em">Perl also has
single-form extensions that refer to blocks,
"In_Cyrillic", meaning "Block=Cyrillic".
These have always been written in the new style.</p>
<p style="margin-left:9%; margin-top: 1em">To convert from
new-style to old-style, follow this recipe:</p>
<p style="margin-left:9%; margin-top: 1em">$old_style =
charblock((prop_invlist("block=$new_style"))[0]);</p>
<p style="margin-left:9%; margin-top: 1em">(which finds the
range of code points in the block using
"prop_invlist", gets the lower end of the range
(0th element) and then looks up the old name for its block
using "charblock").</p>
<p style="margin-left:9%; margin-top: 1em">Note that
starting in Unicode 6.1, many of the block names have
shorter synonyms. These are always given in the new
style.</p>
<h3>Use with older Unicode versions
<a name="Use with older Unicode versions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The functions in
this module work as well as can be expected when used on
earlier Unicode versions. But, obviously, they use the
available data from that Unicode version. For example, if
the Unicode version predates the definition of the script
property (Unicode 3.1), then any function that deals with
scripts is going to return "undef" for the script
portion of the return value.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Jarkko
Hietaniemi. Now maintained by perl5 porters.</p>
<hr/>
</body>
</html>
