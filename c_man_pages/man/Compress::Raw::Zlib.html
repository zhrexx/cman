<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:40:17 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Compress::Raw::Zlib</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Compress::Raw::Zlib</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Compress::Raw::Zlib::Deflate">Compress::Raw::Zlib::Deflate</a><br/>
<a href="#($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] )">($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] )</a><br/>
<a href="#$status = $d−&gt;deflate($input, $output)">$status = $d−&gt;deflate($input, $output)</a><br/>
<a href="#$status = $d−&gt;flush($output [, $flush_type])">$status = $d−&gt;flush($output [, $flush_type])</a><br/>
<a href="#$status = $d−&gt;deflateReset()">$status = $d−&gt;deflateReset()</a><br/>
<a href="#$status = $d−&gt;deflateParams([OPT])">$status = $d−&gt;deflateParams([OPT])</a><br/>
<a href="#$status = $d−&gt;deflateTune($good_length, $max_lazy, $nice_length,$max_chain)">$status = $d−&gt;deflateTune($good_length, $max_lazy, $nice_length,$max_chain)</a><br/>
<a href="#$d−&gt;dict_adler()">$d−&gt;dict_adler()</a><br/>
<a href="#$d−&gt;crc32()">$d−&gt;crc32()</a><br/>
<a href="#$d−&gt;adler32()">$d−&gt;adler32()</a><br/>
<a href="#$d−&gt;msg()">$d−&gt;msg()</a><br/>
<a href="#$d−&gt;total_in()">$d−&gt;total_in()</a><br/>
<a href="#$d−&gt;total_out()">$d−&gt;total_out()</a><br/>
<a href="#$d−&gt;get_Strategy()">$d−&gt;get_Strategy()</a><br/>
<a href="#$d−&gt;get_Level()">$d−&gt;get_Level()</a><br/>
<a href="#$d−&gt;get_BufSize()">$d−&gt;get_BufSize()</a><br/>
<a href="#Example">Example</a><br/>
<a href="#Compress::Raw::Zlib::Inflate">Compress::Raw::Zlib::Inflate</a><br/>
<a href="#($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] )">($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] )</a><br/>
<a href="#$status = $i−&gt;inflate($input, $output [,$eof])">$status = $i−&gt;inflate($input, $output [,$eof])</a><br/>
<a href="#$status = $i−&gt;inflateSync($input)">$status = $i−&gt;inflateSync($input)</a><br/>
<a href="#$status = $i−&gt;inflateReset()">$status = $i−&gt;inflateReset()</a><br/>
<a href="#$i−&gt;dict_adler()">$i−&gt;dict_adler()</a><br/>
<a href="#$i−&gt;crc32()">$i−&gt;crc32()</a><br/>
<a href="#$i−&gt;adler32()">$i−&gt;adler32()</a><br/>
<a href="#$i−&gt;msg()">$i−&gt;msg()</a><br/>
<a href="#$i−&gt;total_in()">$i−&gt;total_in()</a><br/>
<a href="#$i−&gt;total_out()">$i−&gt;total_out()</a><br/>
<a href="#$d−&gt;get_BufSize()">$d−&gt;get_BufSize()</a><br/>
<a href="#Examples">Examples</a><br/>
<a href="#CHECKSUM FUNCTIONS">CHECKSUM FUNCTIONS</a><br/>
<a href="#Misc">Misc</a><br/>
<a href="#my $version = Compress::Raw::Zlib::zlib_version();">my $version = Compress::Raw::Zlib::zlib_version();</a><br/>
<a href="#my $version = Compress::Raw::Zlib::zlibng_version();">my $version = Compress::Raw::Zlib::zlibng_version();</a><br/>
<a href="#my $flags = Compress::Raw::Zlib::zlibCompileFlags();">my $flags = Compress::Raw::Zlib::zlibCompileFlags();</a><br/>
<a href="#is_zlib_native(); =head2 is_zlibng_native(); =head2 is_zlibng_compat();=head2 is_zlibng();">is_zlib_native(); =head2 is_zlibng_native(); =head2 is_zlibng_compat();=head2 is_zlibng();</a><br/>
<a href="#The LimitOutput option.">The LimitOutput option.</a><br/>
<a href="#ACCESSING ZIP FILES">ACCESSING ZIP FILES</a><br/>
<a href="#FAQ">FAQ</a><br/>
<a href="#Compatibility with Unix compress/uncompress.">Compatibility with Unix compress/uncompress.</a><br/>
<a href="#Accessing .tar.Z files">Accessing .tar.Z files</a><br/>
<a href="#Zlib Library Version Support">Zlib Library Version Support</a><br/>
<a href="#CONSTANTS">CONSTANTS</a><br/>
<a href="#SUPPORT">SUPPORT</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#MODIFICATION HISTORY">MODIFICATION HISTORY</a><br/>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Compress::Raw::Zlib
− Low−Level Interface to zlib or zlib−ng
compression library</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use
Compress::Raw::Zlib ; <br/>
($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;
<br/>
$status = $d−&gt;deflate($input, $output) ; <br/>
$status = $d−&gt;flush($output [, $flush_type]) ; <br/>
$d−&gt;deflateReset() ; <br/>
$d−&gt;deflateParams(OPTS) ; <br/>
$d−&gt;deflateTune(OPTS) ; <br/>
$d−&gt;dict_adler() ; <br/>
$d−&gt;crc32() ; <br/>
$d−&gt;adler32() ; <br/>
$d−&gt;total_in() ; <br/>
$d−&gt;total_out() ; <br/>
$d−&gt;msg() ; <br/>
$d−&gt;get_Strategy(); <br/>
$d−&gt;get_Level(); <br/>
$d−&gt;get_BufSize(); <br/>
($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;
<br/>
$status = $i−&gt;inflate($input, $output [, $eof]) ;
<br/>
$status = $i−&gt;inflateSync($input) ; <br/>
$i−&gt;inflateReset() ; <br/>
$i−&gt;dict_adler() ; <br/>
$d−&gt;crc32() ; <br/>
$d−&gt;adler32() ; <br/>
$i−&gt;total_in() ; <br/>
$i−&gt;total_out() ; <br/>
$i−&gt;msg() ; <br/>
$d−&gt;get_BufSize(); <br/>
$crc = adler32($buffer [,$crc]) ; <br/>
$crc = crc32($buffer [,$crc]) ; <br/>
$crc = crc32_combine($crc1, $crc2, $len2); <br/>
$adler = adler32_combine($adler1, $adler2, $len2); <br/>
my $version = Compress::Raw::Zlib::zlib_version(); <br/>
my $flags = Compress::Raw::Zlib::zlibCompileFlags(); <br/>
is_zlib_native(); <br/>
is_zlibng_native(); <br/>
is_zlibng_compat(); <br/>
is_zlibng();</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<i>Compress::Raw::Zlib</i> module provides a Perl interface
to the <i>zlib</i> or <i>zlib−ng</i> compression
libraries (see "SEE ALSO" for details about where
to get <i>zlib</i> or <i>zlib−ng</i>).</p>
<p style="margin-left:9%; margin-top: 1em">In the text
below all references to <i>zlib</i> are also applicable to
<i>zlib−ng</i> unless otherwise stated.</p>
<h2>Compress::Raw::Zlib::Deflate
<a name="Compress::Raw::Zlib::Deflate"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This section
defines an interface that allows in−memory compression
using the <i>deflate</i> interface provided by zlib.</p>
<p style="margin-left:9%; margin-top: 1em">Here is a
definition of the interface available:</p>
<h3>($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] )
<a name="($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] )"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Initialises a
deflation object.</p>
<p style="margin-left:9%; margin-top: 1em">If you are
familiar with the <i>zlib</i> library, it combines the
features of the <i>zlib</i> functions
"deflateInit", "deflateInit2" and
"deflateSetDictionary".</p>
<p style="margin-left:9%; margin-top: 1em">If successful,
it will return the initialised deflation object, $d and a
$status of "Z_OK" in a list context. In scalar
context it returns the deflation object, $d, only.</p>
<p style="margin-left:9%; margin-top: 1em">If not
successful, the returned deflation object, $d, will be
<i>undef</i> and $status will hold the a <i>zlib</i> error
code.</p>
<p style="margin-left:9%; margin-top: 1em">The function
optionally takes a number of named options specified as
"Name =&gt; value" pairs. This allows individual
options to be tailored without having to specify them all in
the parameter list.</p>
<p style="margin-left:9%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the name=&gt;value
pairs.</p>
<p style="margin-left:9%; margin-top: 1em">Below is a list
of the valid options: <b><br/>
−Level</b></p>
<p style="margin-left:15%;">Defines the compression level.
Valid values are 0 through 9, "Z_NO_COMPRESSION",
"Z_BEST_SPEED", "Z_BEST_COMPRESSION",
and "Z_DEFAULT_COMPRESSION".</p>
<p style="margin-left:15%; margin-top: 1em">The default is
"Z_DEFAULT_COMPRESSION".</p>
<p style="margin-left:9%;"><b>−Method</b></p>
<p style="margin-left:15%;">Defines the compression method.
The only valid value at present (and the default) is
"Z_DEFLATED".</p>
<p style="margin-left:9%;"><b>−WindowBits</b></p>
<p style="margin-left:15%;">To compress an RFC 1950 data
stream, set "WindowBits" to a positive number
between 8 and 15.</p>
<p style="margin-left:15%; margin-top: 1em">To compress an
RFC 1951 data stream, set "WindowBits" to
"−MAX_WBITS".</p>
<p style="margin-left:15%; margin-top: 1em">To compress an
RFC 1952 data stream (i.e. gzip), set "WindowBits"
to "WANT_GZIP".</p>
<p style="margin-left:15%; margin-top: 1em">For a
definition of the meaning and valid values for
"WindowBits" refer to the <i>zlib</i>
documentation for <i>deflateInit2</i>.</p>
<p style="margin-left:15%; margin-top: 1em">Defaults to
"MAX_WBITS".</p>
<p style="margin-left:9%;"><b>−MemLevel</b></p>
<p style="margin-left:15%;">For a definition of the meaning
and valid values for "MemLevel" refer to the
<i>zlib</i> documentation for <i>deflateInit2</i>.</p>
<p style="margin-left:15%; margin-top: 1em">Defaults to
MAX_MEM_LEVEL.</p>
<p style="margin-left:9%;"><b>−Strategy</b></p>
<p style="margin-left:15%;">Defines the strategy used to
tune the compression. The valid values are
"Z_DEFAULT_STRATEGY", "Z_FILTERED",
"Z_RLE", "Z_FIXED" and
"Z_HUFFMAN_ONLY".</p>
<p style="margin-left:15%; margin-top: 1em">The default is
"Z_DEFAULT_STRATEGY".</p>
<p style="margin-left:9%;"><b>−Dictionary</b></p>
<p style="margin-left:15%;">When a dictionary is specified
<i>Compress::Raw::Zlib</i> will automatically call
"deflateSetDictionary" directly after calling
"deflateInit". The Adler32 value for the
dictionary can be obtained by calling the method
"$d−&gt;dict_adler()".</p>
<p style="margin-left:15%; margin-top: 1em">The default is
no dictionary.</p>
<p style="margin-left:9%;"><b>−Bufsize</b></p>
<p style="margin-left:15%;">Sets the initial size for the
output buffer used by the "$d−&gt;deflate"
and "$d−&gt;flush" methods. If the buffer
has to be reallocated to increase the size, it will grow in
increments of "Bufsize".</p>
<p style="margin-left:15%; margin-top: 1em">The default
buffer size is 4096.</p>
<p style="margin-left:9%;"><b>−AppendOutput</b></p>
<p style="margin-left:15%;">This option controls how data
is written to the output buffer by the
"$d−&gt;deflate" and
"$d−&gt;flush" methods.</p>
<p style="margin-left:15%; margin-top: 1em">If the
"AppendOutput" option is set to false, the output
buffers in the "$d−&gt;deflate" and
"$d−&gt;flush" methods will be truncated
before uncompressed data is written to them.</p>
<p style="margin-left:15%; margin-top: 1em">If the option
is set to true, uncompressed data will be appended to the
output buffer in the "$d−&gt;deflate" and
"$d−&gt;flush" methods.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:9%;"><b>−CRC32</b></p>
<p style="margin-left:15%;">If set to true, a crc32
checksum of the uncompressed data will be calculated. Use
the "$d−&gt;crc32" method to retrieve this
value.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:9%;"><b>−ADLER32</b></p>
<p style="margin-left:15%;">If set to true, an adler32
checksum of the uncompressed data will be calculated. Use
the "$d−&gt;adler32" method to retrieve this
value.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:9%; margin-top: 1em">Here is an
example of using the
"Compress::Raw::Zlib::Deflate" optional parameter
list to override the default buffer size and compression
level. All other options will take their default values.</p>
<p style="margin-left:9%; margin-top: 1em">my $d = new
Compress::Raw::Zlib::Deflate ( −Bufsize =&gt; 300,
<br/>
−Level =&gt; Z_BEST_SPEED ) ;</p>
<h3>$status = $d−&gt;deflate($input, $output)
<a name="$status = $d−&gt;deflate($input, $output)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Deflates the
contents of $input and writes the compressed data to
$output.</p>
<p style="margin-left:9%; margin-top: 1em">The $input and
$output parameters can be either scalars or scalar
references.</p>
<p style="margin-left:9%; margin-top: 1em">When finished,
$input will be completely processed (assuming there were no
errors). If the deflation was successful it writes the
deflated data to $output and returns a status value of
"Z_OK".</p>
<p style="margin-left:9%; margin-top: 1em">On error, it
returns a <i>zlib</i> error code.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"AppendOutput" option is set to true in the
constructor for the $d object, the compressed data will be
appended to $output. If it is false, $output will be
truncated before any compressed data is written to it.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b>:
This method will not necessarily write compressed data to
$output every time it is called. So do not assume that there
has been an error if the contents of $output is empty on
returning from this method. As long as the return code from
the method is "Z_OK", the deflate has
succeeded.</p>
<h3>$status = $d−&gt;flush($output [, $flush_type])
<a name="$status = $d−&gt;flush($output [, $flush_type])"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Typically used
to finish the deflation. Any pending output will be written
to $output.</p>
<p style="margin-left:9%; margin-top: 1em">Returns
"Z_OK" if successful.</p>
<p style="margin-left:9%; margin-top: 1em">Note that
flushing can seriously degrade the compression ratio, so it
should only be used to terminate a decompression (using
"Z_FINISH") or when you want to create a <i>full
flush point</i> (using "Z_FULL_FLUSH").</p>
<p style="margin-left:9%; margin-top: 1em">By default the
"flush_type" used is "Z_FINISH". Other
valid values for "flush_type" are
"Z_NO_FLUSH", "Z_PARTIAL_FLUSH",
"Z_SYNC_FLUSH" and "Z_FULL_FLUSH". It is
strongly recommended that you only set the
"flush_type" parameter if you fully understand the
implications of what it does. See the "zlib"
documentation for details.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"AppendOutput" option is set to true in the
constructor for the $d object, the compressed data will be
appended to $output. If it is false, $output will be
truncated before any compressed data is written to it.</p>
<h3>$status = $d−&gt;deflateReset()
<a name="$status = $d−&gt;deflateReset()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This method will
reset the deflation object $d. It can be used when you are
compressing multiple data streams and want to use the same
object to compress each of them. It should only be used once
the previous data stream has been flushed successfully, i.e.
a call to "$d−&gt;flush(Z_FINISH)" has
returned "Z_OK".</p>
<p style="margin-left:9%; margin-top: 1em">Returns
"Z_OK" if successful.</p>
<h3>$status = $d−&gt;deflateParams([OPT])
<a name="$status = $d−&gt;deflateParams([OPT])"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Change settings
for the deflate object $d.</p>
<p style="margin-left:9%; margin-top: 1em">The list of the
valid options is shown below. Options not specified will
remain unchanged. <b><br/>
−Level</b></p>
<p style="margin-left:15%;">Defines the compression level.
Valid values are 0 through 9, "Z_NO_COMPRESSION",
"Z_BEST_SPEED", "Z_BEST_COMPRESSION",
and "Z_DEFAULT_COMPRESSION".</p>
<p style="margin-left:9%;"><b>−Strategy</b></p>
<p style="margin-left:15%;">Defines the strategy used to
tune the compression. The valid values are
"Z_DEFAULT_STRATEGY", "Z_FILTERED" and
"Z_HUFFMAN_ONLY".</p>
<p style="margin-left:9%;"><b>−BufSize</b></p>
<p style="margin-left:15%;">Sets the initial size for the
output buffer used by the "$d−&gt;deflate"
and "$d−&gt;flush" methods. If the buffer
has to be reallocated to increase the size, it will grow in
increments of "Bufsize".</p>
<h3>$status = $d−&gt;deflateTune($good_length, $max_lazy, $nice_length,$max_chain)
<a name="$status = $d−&gt;deflateTune($good_length, $max_lazy, $nice_length,$max_chain)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Tune the
internal settings for the deflate object $d. This option is
only available if you are running zlib 1.2.2.3 or
better.</p>
<p style="margin-left:9%; margin-top: 1em">Refer to the
documentation in zlib.h for instructions on how to fly
"deflateTune".</p>
<h3>$d−&gt;dict_adler()
<a name="$d−&gt;dict_adler()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
adler32 value for the dictionary.</p>
<h3>$d−&gt;crc32()
<a name="$d−&gt;crc32()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
crc32 value for the uncompressed data to date.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"CRC32" option is not enabled in the constructor
for this object, this method will always return 0;</p>
<h3>$d−&gt;adler32()
<a name="$d−&gt;adler32()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
adler32 value for the uncompressed data to date.</p>
<h3>$d−&gt;msg()
<a name="$d−&gt;msg()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the last
error message generated by zlib.</p>
<h3>$d−&gt;total_in()
<a name="$d−&gt;total_in()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
total number of bytes uncompressed bytes input to
deflate.</p>
<h3>$d−&gt;total_out()
<a name="$d−&gt;total_out()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
total number of compressed bytes output from deflate.</p>
<h3>$d−&gt;get_Strategy()
<a name="$d−&gt;get_Strategy()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
deflation strategy currently used. Valid values are
"Z_DEFAULT_STRATEGY", "Z_FILTERED" and
"Z_HUFFMAN_ONLY".</p>
<h3>$d−&gt;get_Level()
<a name="$d−&gt;get_Level()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
compression level being used.</p>
<h3>$d−&gt;get_BufSize()
<a name="$d−&gt;get_BufSize()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
buffer size used to carry out the compression.</p>
<h3>Example
<a name="Example"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Here is a
trivial example of using "deflate". It simply
reads standard input, deflates it and writes it to standard
output.</p>
<p style="margin-left:9%; margin-top: 1em">use strict ;
<br/>
use warnings ; <br/>
use Compress::Raw::Zlib ; <br/>
binmode STDIN; <br/>
binmode STDOUT; <br/>
my $x = new Compress::Raw::Zlib::Deflate <br/>
or die "Cannot create a deflation stream\n" ; <br/>
my ($output, $status) ; <br/>
while (&lt;&gt;) <br/>
{ <br/>
$status = $x−&gt;deflate($_, $output) ; <br/>
$status == Z_OK <br/>
or die "deflation failed\n" ; <br/>
print $output ; <br/>
} <br/>
$status = $x−&gt;flush($output) ; <br/>
$status == Z_OK <br/>
or die "deflation failed\n" ; <br/>
print $output ;</p>
<h2>Compress::Raw::Zlib::Inflate
<a name="Compress::Raw::Zlib::Inflate"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This section
defines an interface that allows in−memory
uncompression using the <i>inflate</i> interface provided by
zlib.</p>
<p style="margin-left:9%; margin-top: 1em">Here is a
definition of the interface:</p>
<h3>($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] )
<a name="($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] )"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Initialises an
inflation object.</p>
<p style="margin-left:9%; margin-top: 1em">In a list
context it returns the inflation object, $i, and the
<i>zlib</i> status code ($status). In a scalar context it
returns the inflation object only.</p>
<p style="margin-left:9%; margin-top: 1em">If successful,
$i will hold the inflation object and $status will be
"Z_OK".</p>
<p style="margin-left:9%; margin-top: 1em">If not
successful, $i will be <i>undef</i> and $status will hold
the <i>zlib</i> error code.</p>
<p style="margin-left:9%; margin-top: 1em">The function
optionally takes a number of named options specified as
"−Name =&gt; value" pairs. This allows
individual options to be tailored without having to specify
them all in the parameter list.</p>
<p style="margin-left:9%; margin-top: 1em">For backward
compatibility, it is also possible to pass the parameters as
a reference to a hash containing the
"name=&gt;value" pairs.</p>
<p style="margin-left:9%; margin-top: 1em">Here is a list
of the valid options: <b><br/>
−WindowBits</b></p>
<p style="margin-left:15%;">To uncompress an RFC 1950 data
stream, set "WindowBits" to a positive number
between 8 and 15.</p>
<p style="margin-left:15%; margin-top: 1em">To uncompress
an RFC 1951 data stream, set "WindowBits" to
"−MAX_WBITS".</p>
<p style="margin-left:15%; margin-top: 1em">To uncompress
an RFC 1952 data stream (i.e. gzip), set
"WindowBits" to "WANT_GZIP".</p>
<p style="margin-left:15%; margin-top: 1em">To
auto−detect and uncompress an RFC 1950 or RFC 1952
data stream (i.e. gzip), set "WindowBits" to
"WANT_GZIP_OR_ZLIB".</p>
<p style="margin-left:15%; margin-top: 1em">For a full
definition of the meaning and valid values for
"WindowBits" refer to the <i>zlib</i>
documentation for <i>inflateInit2</i>.</p>
<p style="margin-left:15%; margin-top: 1em">Defaults to
"MAX_WBITS".</p>
<p style="margin-left:9%;"><b>−Bufsize</b></p>
<p style="margin-left:15%;">Sets the initial size for the
output buffer used by the "$i−&gt;inflate"
method. If the output buffer in this method has to be
reallocated to increase the size, it will grow in increments
of "Bufsize".</p>
<p style="margin-left:15%; margin-top: 1em">Default is
4096.</p>
<p style="margin-left:9%;"><b>−Dictionary</b></p>
<p style="margin-left:15%;">The default is no
dictionary.</p>
<p style="margin-left:9%;"><b>−AppendOutput</b></p>
<p style="margin-left:15%;">This option controls how data
is written to the output buffer by the
"$i−&gt;inflate" method.</p>
<p style="margin-left:15%; margin-top: 1em">If the option
is set to false, the output buffer in the
"$i−&gt;inflate" method will be truncated
before uncompressed data is written to it.</p>
<p style="margin-left:15%; margin-top: 1em">If the option
is set to true, uncompressed data will be appended to the
output buffer by the "$i−&gt;inflate"
method.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:9%;"><b>−CRC32</b></p>
<p style="margin-left:15%;">If set to true, a crc32
checksum of the uncompressed data will be calculated. Use
the "$i−&gt;crc32" method to retrieve this
value.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:9%;"><b>−ADLER32</b></p>
<p style="margin-left:15%;">If set to true, an adler32
checksum of the uncompressed data will be calculated. Use
the "$i−&gt;adler32" method to retrieve this
value.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:9%;"><b>−ConsumeInput</b></p>
<p style="margin-left:15%;">If set to true, this option
will remove compressed data from the input buffer of the
"$i−&gt;inflate" method as the inflate
progresses.</p>
<p style="margin-left:15%; margin-top: 1em">This option can
be useful when you are processing compressed data that is
embedded in another file/buffer. In this case the data that
immediately follows the compressed stream will be left in
the input buffer.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to true.</p>
<p style="margin-left:9%;"><b>−LimitOutput</b></p>
<p style="margin-left:15%;">The "LimitOutput"
option changes the behavior of the
"$i−&gt;inflate" method so that the amount
of memory used by the output buffer can be limited.</p>
<p style="margin-left:15%; margin-top: 1em">When
"LimitOutput" is used the size of the output
buffer used will either be the value of the
"Bufsize" option or the amount of memory already
allocated to $output, whichever is larger. Predicting the
output size available is tricky, so don't rely on getting an
exact output buffer size.</p>
<p style="margin-left:15%; margin-top: 1em">When
"LimitOutout" is not specified
"$i−&gt;inflate" will use as much memory as
it takes to write all the uncompressed data it creates by
uncompressing the input buffer.</p>
<p style="margin-left:15%; margin-top: 1em">If
"LimitOutput" is enabled, the
"ConsumeInput" option will also be enabled.</p>
<p style="margin-left:15%; margin-top: 1em">This option
defaults to false.</p>
<p style="margin-left:15%; margin-top: 1em">See "The
LimitOutput option" for a discussion on why
"LimitOutput" is needed and how to use it.</p>
<p style="margin-left:9%; margin-top: 1em">Here is an
example of using an optional parameter to override the
default buffer size.</p>
<p style="margin-left:9%; margin-top: 1em">my ($i, $status)
= new Compress::Raw::Zlib::Inflate( −Bufsize =&gt; 300
) ;</p>
<h3>$status = $i−&gt;inflate($input, $output [,$eof])
<a name="$status = $i−&gt;inflate($input, $output [,$eof])"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Inflates the
complete contents of $input and writes the uncompressed data
to $output. The $input and $output parameters can either be
scalars or scalar references.</p>
<p style="margin-left:9%; margin-top: 1em">Returns
"Z_OK" if successful and "Z_STREAM_END"
if the end of the compressed data has been successfully
reached.</p>
<p style="margin-left:9%; margin-top: 1em">If not
successful $status will hold the <i>zlib</i> error code.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"ConsumeInput" option has been set to true when
the "Compress::Raw::Zlib::Inflate" object is
created, the $input parameter is modified by
"inflate". On completion it will contain what
remains of the input buffer after inflation. In practice,
this means that when the return status is "Z_OK"
the $input parameter will contain an empty string, and when
the return status is "Z_STREAM_END" the $input
parameter will contains what (if anything) was stored in the
input buffer after the deflated data stream.</p>
<p style="margin-left:9%; margin-top: 1em">This feature is
useful when processing a file format that encapsulates a
compressed data stream (e.g. gzip, zip) and there is useful
data immediately after the deflation stream.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"AppendOutput" option is set to true in the
constructor for this object, the uncompressed data will be
appended to $output. If it is false, $output will be
truncated before any uncompressed data is written to it.</p>
<p style="margin-left:9%; margin-top: 1em">The $eof
parameter needs a bit of explanation.</p>
<p style="margin-left:9%; margin-top: 1em">Prior to version
1.2.0, zlib assumed that there was at least one trailing
byte immediately after the compressed data stream when it
was carrying out decompression. This normally isn't a
problem because the majority of zlib applications guarantee
that there will be data directly after the compressed data
stream. For example, both gzip (RFC 1950) and zip both
define trailing data that follows the compressed data
stream.</p>
<p style="margin-left:9%; margin-top: 1em">The $eof
parameter only needs to be used if <b>all</b> of the
following conditions apply</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="84%">
<p>You are either using a copy of zlib that is older than
version 1.2.0 or you want your application code to be able
to run with as many different versions of zlib as
possible.</p> </td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="3%"></td>
<td width="84%">
<p>You have set the "WindowBits" parameter to
"−MAX_WBITS" in the constructor for this
object, i.e. you are uncompressing a raw deflated data
stream (RFC 1951).</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>3.</p></td>
<td width="3%"></td>
<td width="84%">
<p>There is no data immediately after the compressed data
stream.</p> </td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">If <b>all</b> of
these are the case, then you need to set the $eof parameter
to true on the final call (and only the final call) to
"$i−&gt;inflate".</p>
<p style="margin-left:9%; margin-top: 1em">If you have
built this module with zlib &gt;= 1.2.0, the $eof parameter
is ignored. You can still set it if you want, but it won't
be used behind the scenes.</p>
<h3>$status = $i−&gt;inflateSync($input)
<a name="$status = $i−&gt;inflateSync($input)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This method can
be used to attempt to recover good data from a compressed
data stream that is partially corrupt. It scans $input until
it reaches either a <i>full flush point</i> or the end of
the buffer.</p>
<p style="margin-left:9%; margin-top: 1em">If a <i>full
flush point</i> is found, "Z_OK" is returned and
$input will be have all data up to the flush point removed.
This data can then be passed to the
"$i−&gt;inflate" method to be
uncompressed.</p>
<p style="margin-left:9%; margin-top: 1em">Any other return
code means that a flush point was not found. If more data is
available, "inflateSync" can be called repeatedly
with more compressed data until the flush point is
found.</p>
<p style="margin-left:9%; margin-top: 1em">Note <i>full
flush points</i> are not present by default in compressed
data streams. They must have been added explicitly when the
data stream was created by calling
"Compress::Deflate::flush" with
"Z_FULL_FLUSH".</p>
<h3>$status = $i−&gt;inflateReset()
<a name="$status = $i−&gt;inflateReset()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This method will
reset the inflation object $i. It can be used when you are
uncompressing multiple data streams and want to use the same
object to uncompress each of them.</p>
<p style="margin-left:9%; margin-top: 1em">Returns
"Z_OK" if successful.</p>
<h3>$i−&gt;dict_adler()
<a name="$i−&gt;dict_adler()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
adler32 value for the dictionary.</p>
<h3>$i−&gt;crc32()
<a name="$i−&gt;crc32()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
crc32 value for the uncompressed data to date.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"CRC32" option is not enabled in the constructor
for this object, this method will always return 0;</p>
<h3>$i−&gt;adler32()
<a name="$i−&gt;adler32()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
adler32 value for the uncompressed data to date.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"ADLER32" option is not enabled in the constructor
for this object, this method will always return 0;</p>
<h3>$i−&gt;msg()
<a name="$i−&gt;msg()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the last
error message generated by zlib.</p>
<h3>$i−&gt;total_in()
<a name="$i−&gt;total_in()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
total number of bytes compressed bytes input to inflate.</p>
<h3>$i−&gt;total_out()
<a name="$i−&gt;total_out()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
total number of uncompressed bytes output from inflate.</p>
<h3>$d−&gt;get_BufSize()
<a name="$d−&gt;get_BufSize()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
buffer size used to carry out the decompression.</p>
<h3>Examples
<a name="Examples"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Here is an
example of using "inflate".</p>
<p style="margin-left:9%; margin-top: 1em">use strict ;
<br/>
use warnings ; <br/>
use Compress::Raw::Zlib; <br/>
my $x = new Compress::Raw::Zlib::Inflate() <br/>
or die "Cannot create a inflation stream\n" ; <br/>
my $input = '' ; <br/>
binmode STDIN; <br/>
binmode STDOUT; <br/>
my ($output, $status) ; <br/>
while (read(STDIN, $input, 4096)) <br/>
{ <br/>
$status = $x−&gt;inflate($input, $output) ; <br/>
print $output ; <br/>
last if $status != Z_OK ; <br/>
} <br/>
die "inflation failed\n" <br/>
unless $status == Z_STREAM_END ;</p>
<p style="margin-left:9%; margin-top: 1em">The next example
show how to use the "LimitOutput" option. Notice
the use of two nested loops in this case. The outer loop
reads the data from the input source − STDIN and the
inner loop repeatedly calls "inflate" until $input
is exhausted, we get an error, or the end of the stream is
reached. One point worth remembering is by using the
"LimitOutput" option you also get
"ConsumeInput" set as well − this makes the
code below much simpler.</p>
<p style="margin-left:9%; margin-top: 1em">use strict ;
<br/>
use warnings ; <br/>
use Compress::Raw::Zlib; <br/>
my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt;
1) <br/>
or die "Cannot create a inflation stream\n" ; <br/>
my $input = '' ; <br/>
binmode STDIN; <br/>
binmode STDOUT; <br/>
my ($output, $status) ; <br/>
OUTER: <br/>
while (read(STDIN, $input, 4096)) <br/>
{ <br/>
do <br/>
{ <br/>
$status = $x−&gt;inflate($input, $output) ; <br/>
print $output ; <br/>
last OUTER <br/>
unless $status == Z_OK || $status == Z_BUF_ERROR ; <br/>
} <br/>
while length $input; <br/>
} <br/>
die "inflation failed\n" <br/>
unless $status == Z_STREAM_END ;</p>
<h2>CHECKSUM FUNCTIONS
<a name="CHECKSUM FUNCTIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Two functions
are provided by <i>zlib</i> to calculate checksums. For the
Perl interface, the order of the two parameters in both
functions has been reversed. This allows both running
checksums and one off calculations to be done.</p>
<p style="margin-left:9%; margin-top: 1em">$crc =
adler32($buffer [,$crc]) ; <br/>
$crc = crc32($buffer [,$crc]) ;</p>
<p style="margin-left:9%; margin-top: 1em">The buffer
parameters can either be a scalar or a scalar reference.</p>
<p style="margin-left:9%; margin-top: 1em">If the $crc
parameters is "undef", the crc value will be
reset.</p>
<p style="margin-left:9%; margin-top: 1em">If you have
built this module with zlib 1.2.3 or better, two more
CRC−related functions are available.</p>
<p style="margin-left:9%; margin-top: 1em">$crc =
crc32_combine($crc1, $crc2, $len2); <br/>
$adler = adler32_combine($adler1, $adler2, $len2);</p>
<p style="margin-left:9%; margin-top: 1em">These functions
allow checksums to be merged. Refer to the <i>zlib</i>
documentation for more details.</p>
<h2>Misc
<a name="Misc"></a>
</h2>
<h3>my $version = Compress::Raw::Zlib::zlib_version();
<a name="my $version = Compress::Raw::Zlib::zlib_version();"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
version of the <i>zlib</i> library if this module has been
built with the <i>zlib</i> library. If this module has been
built with <i>zlib−ng</i> in native mode, this
function will return a empty string. If this module has been
built with <i>zlib−ng</i> in compat mode, this
function will return the Izlib&gt; API verion that
<i>zlib−ng</i> is supporting.</p>
<h3>my $version = Compress::Raw::Zlib::zlibng_version();
<a name="my $version = Compress::Raw::Zlib::zlibng_version();"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
version of the zlib−ng library if this module has been
built with the <i>zlib−ng</i> library. If this module
has been built with <i>zlib</i>, this function will return a
empty string.</p>
<h3>my $flags = Compress::Raw::Zlib::zlibCompileFlags();
<a name="my $flags = Compress::Raw::Zlib::zlibCompileFlags();"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Returns the
flags indicating compile−time options that were used
to build the zlib or zlib−ng library. See the zlib
documentation for a description of the flags returned by
"zlibCompileFlags".</p>
<p style="margin-left:9%; margin-top: 1em">Note that when
the zlib sources are built along with this module the
"sprintf" flags (bits 24, 25 and 26) should be
ignored.</p>
<p style="margin-left:9%; margin-top: 1em">If you are using
zlib 1.2.0 or older, "zlibCompileFlags" will
return 0.</p>
<h3>is_zlib_native(); =head2 is_zlibng_native(); =head2 is_zlibng_compat();=head2 is_zlibng();
<a name="is_zlib_native(); =head2 is_zlibng_native(); =head2 is_zlibng_compat();=head2 is_zlibng();"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">These function
can use used to check if "Compress::Raw::Zlib" was
been built with <i>zlib</i> or <i>zlib−ng</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The function
"is_zlib_native" returns true if
"Compress::Raw::Zlib" was built with <i>zlib</i>.
The function "is_zlibng" returns true if
"Compress::Raw::Zlib" was built with
<i>zlib−ng</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>zlib−ng</i> library has an option to build with a
zlib−compataible API. The c&lt;is_zlibng_compat&gt;
function retuens true if zlib−ng has ben built with
this API.</p>
<p style="margin-left:9%; margin-top: 1em">Finally,
"is_zlibng_native" returns true if
<i>zlib−ng</i> was built with its native API.</p>
<h2>The LimitOutput option.
<a name="The LimitOutput option."></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">By default
"$i−&gt;inflate($input, $output)" will
uncompress <i>all</i> data in $input and write <i>all</i> of
the uncompressed data it has generated to $output. This
makes the interface to "inflate" much simpler
− if the method has uncompressed $input successfully
<i>all</i> compressed data in $input will have been dealt
with. So if you are reading from an input source and
uncompressing as you go the code will look something like
this</p>
<p style="margin-left:9%; margin-top: 1em">use strict ;
<br/>
use warnings ; <br/>
use Compress::Raw::Zlib; <br/>
my $x = new Compress::Raw::Zlib::Inflate() <br/>
or die "Cannot create a inflation stream\n" ; <br/>
my $input = '' ; <br/>
my ($output, $status) ; <br/>
while (read(STDIN, $input, 4096)) <br/>
{ <br/>
$status = $x−&gt;inflate($input, $output) ; <br/>
print $output ; <br/>
last if $status != Z_OK ; <br/>
} <br/>
die "inflation failed\n" <br/>
unless $status == Z_STREAM_END ;</p>
<p style="margin-left:9%; margin-top: 1em">The points to
note are</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="85%">
<p style="margin-top: 1em">The main processing loop in the
code handles reading of compressed data from STDIN.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="5%"></td>
<td width="85%">
<p>The status code returned from "inflate" will
only trigger termination of the main processing loop if it
isn't "Z_OK". When "LimitOutput" has not
been used the "Z_OK" status means that the end of
the compressed data stream has been reached or there has
been an error in uncompression.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="5%"></td>
<td width="85%">
<p>After the call to "inflate" <i>all</i> of the
uncompressed data in $input will have been processed. This
means the subsequent call to "read" can overwrite
it's contents without any problem.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">For most
use−cases the behavior described above is acceptable
(this module and it's predecessor,
"Compress::Zlib", have used it for over 10 years
without an issue), but in a few very specific
use−cases the amount of memory required for $output
can prohibitively large. For example, if the compressed data
stream contains the same pattern repeated thousands of
times, a relatively small compressed data stream can
uncompress into hundreds of megabytes. Remember
"inflate" will keep allocating memory until
<i>all</i> the uncompressed data has been written to the
output buffer − the size of $output is unbounded.</p>
<p style="margin-left:9%; margin-top: 1em">The
"LimitOutput" option is designed to help with this
use−case.</p>
<p style="margin-left:9%; margin-top: 1em">The main
difference in your code when using "LimitOutput"
is having to deal with cases where the $input parameter
still contains some uncompressed data that
"inflate" hasn't processed yet. The status code
returned from "inflate" will be "Z_OK"
if uncompression took place and "Z_BUF_ERROR" if
the output buffer is full.</p>
<p style="margin-left:9%; margin-top: 1em">Below is typical
code that shows how to use "LimitOutput".</p>
<p style="margin-left:9%; margin-top: 1em">use strict ;
<br/>
use warnings ; <br/>
use Compress::Raw::Zlib; <br/>
my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt;
1) <br/>
or die "Cannot create a inflation stream\n" ; <br/>
my $input = '' ; <br/>
binmode STDIN; <br/>
binmode STDOUT; <br/>
my ($output, $status) ; <br/>
OUTER: <br/>
while (read(STDIN, $input, 4096)) <br/>
{ <br/>
do <br/>
{ <br/>
$status = $x−&gt;inflate($input, $output) ; <br/>
print $output ; <br/>
last OUTER <br/>
unless $status == Z_OK || $status == Z_BUF_ERROR ; <br/>
} <br/>
while length $input; <br/>
} <br/>
die "inflation failed\n" <br/>
unless $status == Z_STREAM_END ;</p>
<p style="margin-left:9%; margin-top: 1em">Points to note
this time:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="82%">
<p style="margin-top: 1em">There are now two nested loops
in the code: the outer loop for reading the compressed data
from STDIN, as before; and the inner loop to carry out the
uncompression.</p> </td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="5%"></td>
<td width="82%">
<p>There are two exit points from the inner uncompression
loop.</p> </td>
<td width="3%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">Firstly when
"inflate" has returned a status other than
"Z_OK" or "Z_BUF_ERROR". This means that
either the end of the compressed data stream has been
reached ("Z_STREAM_END") or there is an error in
the compressed data. In either of these cases there is no
point in continuing with reading the compressed data, so
both loops are terminated.</p>
<p style="margin-left:15%; margin-top: 1em">The second exit
point tests if there is any data left in the input buffer,
$input − remember that the "ConsumeInput"
option is automatically enabled when "LimitOutput"
is used. When the input buffer has been exhausted, the outer
loop can run again and overwrite a now empty $input.</p>
<h2>ACCESSING ZIP FILES
<a name="ACCESSING ZIP FILES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Although it is
possible (with some effort on your part) to use this module
to access .zip files, there are other perl modules available
that will do all the hard work for you. Check out
"Archive::Zip",
"Archive::Zip::SimpleZip",
"IO::Compress::Zip" and
"IO::Uncompress::Unzip".</p>
<h2>FAQ
<a name="FAQ"></a>
</h2>
<h3>Compatibility with Unix compress/uncompress.
<a name="Compatibility with Unix compress/uncompress."></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This module is
not compatible with Unix "compress".</p>
<p style="margin-left:9%; margin-top: 1em">If you have the
"uncompress" program available, you can use this
to read compressed files</p>
<p style="margin-left:9%; margin-top: 1em">open F,
"uncompress −c $filename |"; <br/>
while (&lt;F&gt;) <br/>
{ <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">Alternatively,
if you have the "gunzip" program available, you
can use this to read compressed files</p>
<p style="margin-left:9%; margin-top: 1em">open F,
"gunzip −c $filename |"; <br/>
while (&lt;F&gt;) <br/>
{ <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">and this to
write compress files, if you have the "compress"
program available</p>
<p style="margin-left:9%; margin-top: 1em">open F, "|
compress −c $filename "; <br/>
print F "data"; <br/>
... <br/>
close F ;</p>
<h3>Accessing .tar.Z files
<a name="Accessing .tar.Z files"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">See previous FAQ
item.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"Archive::Tar" module is installed and either the
"uncompress" or "gunzip" programs are
available, you can use one of these workarounds to read
".tar.Z" files.</p>
<p style="margin-left:9%; margin-top: 1em">Firstly with
"uncompress"</p>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use Archive::Tar; <br/>
open F, "uncompress −c $filename |"; <br/>
my $tar = Archive::Tar−&gt;new(*F); <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">and this with
"gunzip"</p>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use Archive::Tar; <br/>
open F, "gunzip −c $filename |"; <br/>
my $tar = Archive::Tar−&gt;new(*F); <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">Similarly, if
the "compress" program is available, you can use
this to write a ".tar.Z" file</p>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use Archive::Tar; <br/>
use IO::File; <br/>
my $fh = new IO::File "| compress −c
&gt;$filename"; <br/>
my $tar = Archive::Tar−&gt;new(); <br/>
... <br/>
$tar−&gt;write($fh); <br/>
$fh−&gt;close ;</p>
<h3>Zlib Library Version Support
<a name="Zlib Library Version Support"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">By default
"Compress::Raw::Zlib" will build with a private
copy of version 1.2.5 of the zlib library. (See the
<i>README</i> file for details of how to override this
behaviour)</p>
<p style="margin-left:9%; margin-top: 1em">If you decide to
use a different version of the zlib library, you need to be
aware of the following issues</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="85%">
<p style="margin-top: 1em">First off, you must have zlib
1.0.5 or better.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="5%"></td>
<td width="85%">
<p>You need to have zlib 1.2.1 or better if you want to use
the "−Merge" option with
"IO::Compress::Gzip",
"IO::Compress::Deflate" and
"IO::Compress::RawDeflate".</p> </td></tr>
</table>
<h2>CONSTANTS
<a name="CONSTANTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All the
<i>zlib</i> constants are automatically imported when you
make use of <i>Compress::Raw::Zlib</i>.</p>
<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">General
feedback/questions/bug reports should be sent to
&lt;https://github.com/pmqs/Compress−Raw−Zlib/issues&gt;
(preferred) or
&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Compress−Raw−Zlib&gt;.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Compress::Zlib,
IO::Compress::Gzip, IO::Uncompress::Gunzip,
IO::Compress::Deflate, IO::Uncompress::Inflate,
IO::Compress::RawDeflate, IO::Uncompress::RawInflate,
IO::Compress::Bzip2, IO::Uncompress::Bunzip2,
IO::Compress::Lzma, IO::Uncompress::UnLzma,
IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzip,
IO::Uncompress::UnLzip, IO::Compress::Lzop,
IO::Uncompress::UnLzop, IO::Compress::Lzf,
IO::Uncompress::UnLzf, IO::Compress::Zstd,
IO::Uncompress::UnZstd, IO::Uncompress::AnyInflate,
IO::Uncompress::AnyUncompress</p>
<p style="margin-left:9%; margin-top: 1em">IO::Compress::FAQ</p>
<p style="margin-left:9%; margin-top: 1em">File::GlobMapper,
Archive::Zip, Archive::Tar, IO::Zlib</p>
<p style="margin-left:9%; margin-top: 1em">For RFC 1950,
1951 and 1952 see
&lt;https://datatracker.ietf.org/doc/html/rfc1950&gt;,
&lt;https://datatracker.ietf.org/doc/html/rfc1951&gt; and
&lt;https://datatracker.ietf.org/doc/html/rfc1952&gt;</p>
<p style="margin-left:9%; margin-top: 1em">The <i>zlib</i>
compression library was written by Jean−loup Gailly
"gzip@prep.ai.mit.edu" and Mark Adler
"madler@alumni.caltech.edu".</p>
<p style="margin-left:9%; margin-top: 1em">The primary site
for the <i>zlib</i> compression library is
&lt;http://www.zlib.org&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">The primary site
for the <i>zlib−ng</i> compression library is
&lt;https://github.com/zlib−ng/zlib−ng&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">The primary site
for gzip is &lt;http://www.gzip.org&gt;.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module was
written by Paul Marquess, "pmqs@cpan.org".</p>
<h2>MODIFICATION HISTORY
<a name="MODIFICATION HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See the Changes
file.</p>
<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright (c)
2005−2024 Paul Marquess. All rights reserved.</p>
<p style="margin-left:9%; margin-top: 1em">This program is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr/>
</body>
</html>
