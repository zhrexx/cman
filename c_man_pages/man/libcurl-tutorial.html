<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:45:59 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>libcurl-tutorial</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">libcurl-tutorial</h1>
<a href="#NAME">NAME</a><br/>
<a href="#Objective">Objective</a><br/>
<a href="#Building">Building</a><br/>
<a href="#Portable Code in a Portable World">Portable Code in a Portable World</a><br/>
<a href="#Global Preparation">Global Preparation</a><br/>
<a href="#Features libcurl Provides">Features libcurl Provides</a><br/>
<a href="#Two Interfaces">Two Interfaces</a><br/>
<a href="#Handle the Easy libcurl">Handle the Easy libcurl</a><br/>
<a href="#Multi-threading Issues">Multi-threading Issues</a><br/>
<a href="#When It does not Work">When It does not Work</a><br/>
<a href="#Upload Data to a Remote Site">Upload Data to a Remote Site</a><br/>
<a href="#Passwords">Passwords</a><br/>
<a href="#HTTP Authentication">HTTP Authentication</a><br/>
<a href="#HTTP POSTing">HTTP POSTing</a><br/>
<a href="#Converting from deprecated form API to MIME API">Converting from deprecated form API to MIME API</a><br/>
<a href="#Showing Progress">Showing Progress</a><br/>
<a href="#libcurl with C++">libcurl with C++</a><br/>
<a href="#Proxies">Proxies</a><br/>
<a href="#Persistence Is The Way to Happiness">Persistence Is The Way to Happiness</a><br/>
<a href="#HTTP Headers Used by libcurl">HTTP Headers Used by libcurl</a><br/>
<a href="#Customizing Operations">Customizing Operations</a><br/>
<a href="#Cookies Without Chocolate Chips">Cookies Without Chocolate Chips</a><br/>
<a href="#FTP Peculiarities We Need">FTP Peculiarities We Need</a><br/>
<a href="#MIME API revisited for SMTP and IMAP">MIME API revisited for SMTP and IMAP</a><br/>
<a href="#Headers Equal Fun">Headers Equal Fun</a><br/>
<a href="#Post Transfer Information">Post Transfer Information</a><br/>
<a href="#The multi Interface">The multi Interface</a><br/>
<a href="#SSL, Certificates and Other Tricks">SSL, Certificates and Other Tricks</a><br/>
<a href="#Sharing Data Between Easy Handles">Sharing Data Between Easy Handles</a><br/>
<a href="#Footnotes">Footnotes</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">libcurl−tutorial
− libcurl programming tutorial</p>
<h2>Objective
<a name="Objective"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This document
attempts to describe the general principles and some basic
approaches to consider when programming with libcurl. The
text focuses on the C interface but should apply fairly well
on other language bindings as well as they usually follow
the C API pretty closely.</p>
<p style="margin-left:9%; margin-top: 1em">This document
refers to 'the user' as the person writing the source code
that uses libcurl. That would probably be you or someone in
your position. What is generally referred to as 'the
program' is the collected source code that you write that is
using libcurl for transfers. The program is outside libcurl
and libcurl is outside of the program.</p>
<p style="margin-left:9%; margin-top: 1em">To get more
details on all options and functions described herein,
please refer to their respective man pages.</p>
<h2>Building
<a name="Building"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">There are many
different ways to build C programs. This chapter assumes a
Unix style build process. If you use a different build
system, you can still read this to get general information
that may apply to your environment as well. <br/>
Compiling the Program</p>
<p style="margin-left:18%;">Your compiler needs to know
where the libcurl headers are located. Therefore you must
set your compiler's include path to point to the directory
where you installed them. The 'curl−config'[3] tool
can be used to get this information: <br/>
$ curl-config --cflags</p>
<p style="margin-left:9%;">Linking the Program with
libcurl</p>
<p style="margin-left:18%;">When having compiled the
program, you need to link your object files to create a
single executable. For that to succeed, you need to link
with libcurl and possibly also with other libraries that
libcurl itself depends on. Like the OpenSSL libraries, but
even some standard OS libraries may be needed on the command
line. To figure out which flags to use, once again the
'curl−config' tool comes to the rescue: <br/>
$ curl-config --libs</p>
<p style="margin-left:9%;">SSL or Not</p>
<p style="margin-left:18%;">libcurl can be built and
customized in many ways. One of the things that varies from
different libraries and builds is the support for
SSL−based transfers, like HTTPS and FTPS. If a
supported SSL library was detected properly at
build−time, libcurl is built with SSL support. To
figure out if an installed libcurl has been built with SSL
support enabled, use <i>curl−config</i> like this:</p>
<p style="margin-left:18%; margin-top: 1em">$ curl-config
--feature</p>
<p style="margin-left:18%; margin-top: 1em">If SSL is
supported, the keyword <i>SSL</i> is written to stdout,
possibly together with a other features that could be either
on or off on for different libcurls.</p>
<p style="margin-left:18%; margin-top: 1em">See also the
"Features libcurl Provides" further down.</p>
<p style="margin-left:9%;">autoconf macro</p>
<p style="margin-left:18%;">When you write your configure
script to detect libcurl and setup variables accordingly, we
offer a macro that probably does everything you need in this
area. See docs/libcurl/libcurl.m4 file − it includes
docs on how to use it.</p>
<h2>Portable Code in a Portable World
<a name="Portable Code in a Portable World"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The people
behind libcurl have put a considerable effort to make
libcurl work on a large amount of different operating
systems and environments.</p>
<p style="margin-left:9%; margin-top: 1em">You program
libcurl the same way on all platforms that libcurl runs on.
There are only a few minor details that differ. If you just
make sure to write your code portable enough, you can create
a portable program. libcurl should not stop you from
that.</p>
<h2>Global Preparation
<a name="Global Preparation"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The program must
initialize some of the libcurl functionality globally. That
means it should be done exactly once, no matter how many
times you intend to use the library. Once for your program's
entire life time. This is done using <br/>
curl_global_init() <br/>
and it takes one parameter which is a bit pattern that tells
libcurl what to initialize. Using <i>CURL_GLOBAL_ALL</i>
makes it initialize all known internal sub modules, and
might be a good default option. The current two bits that
are specified are: <br/>
CURL_GLOBAL_WIN32</p>
<p style="margin-left:18%;">which only does anything on
Windows machines. When used on a Windows machine, it makes
libcurl initialize the win32 socket stuff. Without having
that initialized properly, your program cannot use sockets
properly. You should only do this once for each application,
so if your program already does this or of another library
in use does it, you should not tell libcurl to do this as
well.</p>
<p style="margin-left:9%;">CURL_GLOBAL_SSL</p>
<p style="margin-left:18%;">which only does anything on
libcurls compiled and built SSL−enabled. On these
systems, this makes libcurl initialize the SSL library
properly for this application. This only needs to be done
once for each application so if your program or another
library already does this, this bit should not be
needed.</p>
<p style="margin-left:18%; margin-top: 1em">libcurl has a
default protection mechanism that detects if
<i>curl_global_init(3)</i> has not been called by the time
<i>curl_easy_perform(3)</i> is called and if that is the
case, libcurl runs the function itself with a guessed bit
pattern. Please note that depending solely on this is not
considered nice nor good.</p>
<p style="margin-left:18%; margin-top: 1em">When the
program no longer uses libcurl, it should call
<i>curl_global_cleanup(3)</i>, which is the opposite of the
init call. It performs the reversed operations to cleanup
the resources the <i>curl_global_init(3)</i> call
initialized.</p>
<p style="margin-left:18%; margin-top: 1em">Repeated calls
to <i>curl_global_init(3)</i> and
<i>curl_global_cleanup(3)</i> should be avoided. They should
only be called once each.</p>
<h2>Features libcurl Provides
<a name="Features libcurl Provides"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">It is considered
best−practice to determine libcurl features at runtime
rather than at build−time (if possible of course). By
calling <i>curl_version_info(3)</i> and checking out the
details of the returned struct, your program can figure out
exactly what the currently running libcurl supports.</p>
<h2>Two Interfaces
<a name="Two Interfaces"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">libcurl first
introduced the so called easy interface. All operations in
the easy interface are prefixed with 'curl_easy'. The easy
interface lets you do single transfers with a synchronous
and blocking function call.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl also
offers another interface that allows multiple simultaneous
transfers in a single thread, the so called multi interface.
More about that interface is detailed in a separate chapter
further down. You still need to understand the easy
interface first, so please continue reading for better
understanding.</p>
<h2>Handle the Easy libcurl
<a name="Handle the Easy libcurl"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To use the easy
interface, you must first create yourself an easy handle.
You need one handle for each easy session you want to
perform. Basically, you should use one handle for every
thread you plan to use for transferring. You must never
share the same handle in multiple threads.</p>
<p style="margin-left:9%; margin-top: 1em">Get an easy
handle with <br/>
handle = curl_easy_init(); <br/>
It returns an easy handle. Using that you proceed to the
next step: setting up your preferred actions. A handle is
just a logic entity for the upcoming transfer or series of
transfers.</p>
<p style="margin-left:9%; margin-top: 1em">You set
properties and options for this handle using
<i>curl_easy_setopt(3)</i>. They control how the subsequent
transfer or transfers using this handle are made. Options
remain set in the handle until set again to something
different. They are sticky. Multiple requests using the same
handle use the same options.</p>
<p style="margin-left:9%; margin-top: 1em">If you at any
point would like to blank all previously set options for a
single easy handle, you can call <i>curl_easy_reset(3)</i>
and you can also make a clone of an easy handle (with all
its set options) using <i>curl_easy_duphandle(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Many of the
options you set in libcurl are "strings", pointers
to data terminated with a zero byte. When you set strings
with <i>curl_easy_setopt(3)</i>, libcurl makes its own copy
so that they do not need to be kept around in your
application after being set[4].</p>
<p style="margin-left:9%; margin-top: 1em">One of the most
basic properties to set in the handle is the URL. You set
your preferred URL to transfer with <i>CURLOPT_URL(3)</i> in
a manner similar to:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_URL, "http://domain.com/");</p>
<p style="margin-left:9%; margin-top: 1em">Let's assume for
a while that you want to receive data as the URL identifies
a remote resource you want to get here. Since you write a
sort of application that needs this transfer, I assume that
you would like to get the data passed to you directly
instead of simply getting it passed to stdout. So, you write
your own function that matches this prototype: <br/>
size_t write_data(void *buffer, size_t size, size_t nmemb,
void *userp); <br/>
You tell libcurl to pass all data to this function by
issuing a function similar to this: <br/>
curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_data);
<br/>
You can control what data your callback function gets in the
fourth argument by setting another property: <br/>
curl_easy_setopt(handle, CURLOPT_WRITEDATA,
&amp;internal_struct); <br/>
Using that property, you can easily pass local data between
your application and the function that gets invoked by
libcurl. libcurl itself does not touch the data you pass
with <i>CURLOPT_WRITEDATA(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl offers
its own default internal callback that takes care of the
data if you do not set the callback with
<i>CURLOPT_WRITEFUNCTION(3)</i>. It simply outputs the
received data to stdout. You can have the default callback
write the data to a different file handle by passing a 'FILE
*' to a file opened for writing with the
<i>CURLOPT_WRITEDATA(3)</i> option.</p>
<p style="margin-left:9%; margin-top: 1em">Now, we need to
take a step back and take a deep breath. Here is one of
those rare platform−dependent nitpicks. Did you spot
it? On some platforms[2], libcurl is not able to operate on
file handles opened by the program. Therefore, if you use
the default callback and pass in an open file handle with
<i>CURLOPT_WRITEDATA(3)</i>, libcurl crashes. You should
avoid this to make your program run fine virtually
everywhere.</p>
<p style="margin-left:9%; margin-top: 1em">(<i>CURLOPT_WRITEDATA(3)</i>
was formerly known as <i>CURLOPT_FILE</i>. Both names still
work and do the same thing).</p>
<p style="margin-left:9%; margin-top: 1em">If you are using
libcurl as a win32 DLL, you MUST use the
<i>CURLOPT_WRITEFUNCTION(3)</i> if you set
<i>CURLOPT_WRITEDATA(3)</i> − or experience
crashes.</p>
<p style="margin-left:9%; margin-top: 1em">There are of
course many more options you can set, and we get back to a
few of them later. Let's instead continue to the actual
transfer:</p>
<p style="margin-left:9%; margin-top: 1em">success =
curl_easy_perform(handle);</p>
<p style="margin-left:9%; margin-top: 1em"><i>curl_easy_perform(3)</i>
connects to the remote site, does the necessary commands and
performs the transfer. Whenever it receives data, it calls
the callback function we previously set. The function may
get one byte at a time, or it may get many kilobytes at
once. libcurl delivers as much as possible as often as
possible. Your callback function should return the number of
bytes it "took care of". If that is not the same
amount of bytes that was passed to it, libcurl aborts the
operation and returns with an error code.</p>
<p style="margin-left:9%; margin-top: 1em">When the
transfer is complete, the function returns a return code
that informs you if it succeeded in its mission or not. If a
return code is not enough for you, you can use the
<i>CURLOPT_ERRORBUFFER(3)</i> to point libcurl to a buffer
of yours where it stores a human readable error message as
well.</p>
<p style="margin-left:9%; margin-top: 1em">If you then want
to transfer another file, the handle is ready to be used
again. It is even preferred and encouraged that you reuse an
existing handle if you intend to make another transfer.
libcurl then attempts to reuse a previous connection.</p>
<p style="margin-left:9%; margin-top: 1em">For some
protocols, downloading a file can involve a complicated
process of logging in, setting the transfer mode, changing
the current directory and finally transferring the file
data. libcurl takes care of all that complication for you.
Given simply the URL to a file, libcurl takes care of all
the details needed to get the file moved from one machine to
another.</p>
<h2>Multi-threading Issues
<a name="Multi-threading Issues"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">libcurl is
thread safe but there are a few exceptions. Refer to
<i>libcurl−thread(3)</i> for more information.</p>
<h2>When It does not Work
<a name="When It does not Work"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">There are times
when the transfer fails for some reason. You might have set
the wrong libcurl option or misunderstood what the libcurl
option actually does, or the remote server might return
non−standard replies that confuse the library which
then confuses your program.</p>
<p style="margin-left:9%; margin-top: 1em">There is one
golden rule when these things occur: set the
<i>CURLOPT_VERBOSE(3)</i> option to 1. it causes the library
to spew out the entire protocol details it sends, some
internal info and some received protocol data as well
(especially when using FTP). If you are using HTTP, adding
the headers in the received output to study is also a clever
way to get a better understanding why the server behaves the
way it does. Include headers in the normal body output with
<i>CURLOPT_HEADER(3)</i> set 1.</p>
<p style="margin-left:9%; margin-top: 1em">Of course, there
are bugs left. We need to know about them to be able to fix
them, so we are quite dependent on your bug reports. When
you do report suspected bugs in libcurl, please include as
many details as you possibly can: a protocol dump that
<i>CURLOPT_VERBOSE(3)</i> produces, library version, as much
as possible of your code that uses libcurl, operating system
name and version, compiler name and version etc.</p>
<p style="margin-left:9%; margin-top: 1em">If
<i>CURLOPT_VERBOSE(3)</i> is not enough, you increase the
level of debug data your application receive by using the
<i>CURLOPT_DEBUGFUNCTION(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Getting some
in−depth knowledge about the protocols involved is
never wrong, and if you are trying to do funny things, you
might understand libcurl and how to use it better if you
study the appropriate RFC documents at least briefly.</p>
<h2>Upload Data to a Remote Site
<a name="Upload Data to a Remote Site"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">libcurl tries to
keep a protocol independent approach to most transfers, thus
uploading to a remote FTP site is similar to uploading data
to an HTTP server with a PUT request.</p>
<p style="margin-left:9%; margin-top: 1em">Of course, first
you either create an easy handle or you reuse one existing
one. Then you set the URL to operate on just like before.
This is the remote URL, that we now upload.</p>
<p style="margin-left:9%; margin-top: 1em">Since we write
an application, we most likely want libcurl to get the
upload data by asking us for it. To make it do that, we set
the read callback and the custom pointer libcurl passes to
our read callback. The read callback should have a prototype
similar to: <br/>
size_t function(char *bufptr, size_t size, size_t nitems,
void *userp); <br/>
Where <i>bufptr</i> is the pointer to a buffer we fill in
with data to upload and <i>size</i>nitems* is the size of
the buffer and therefore also the maximum amount of data we
can return to libcurl in this call. The <i>userp</i> pointer
is the custom pointer we set to point to a struct of ours to
pass private data between the application and the callback.
<br/>
curl_easy_setopt(handle, CURLOPT_READFUNCTION,
read_function);</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_READDATA, &amp;filedata); <br/>
Tell libcurl that we want to upload: <br/>
curl_easy_setopt(handle, CURLOPT_UPLOAD, 1L); <br/>
A few protocols do not behave properly when uploads are done
without any prior knowledge of the expected file size. So,
set the upload file size using the
<i>CURLOPT_INFILESIZE_LARGE(3)</i> for all known file sizes
like this[1]:</p>
<p style="margin-left:9%; margin-top: 1em">/* in this
example, file_size must be an curl_off_t variable */ <br/>
curl_easy_setopt(handle, CURLOPT_INFILESIZE_LARGE,
file_size);</p>
<p style="margin-left:9%; margin-top: 1em">When you call
<i>curl_easy_perform(3)</i> this time, it performs all the
necessary operations and when it has invoked the upload it
calls your supplied callback to get the data to upload. The
program should return as much data as possible in every
invoke, as that is likely to make the upload perform as fast
as possible. The callback should return the number of bytes
it wrote in the buffer. Returning 0 signals the end of the
upload.</p>
<h2>Passwords
<a name="Passwords"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Many protocols
use or even require that username and password are provided
to be able to download or upload the data of your choice.
libcurl offers several ways to specify them.</p>
<p style="margin-left:9%; margin-top: 1em">Most protocols
support that you specify the name and password in the URL
itself. libcurl detects this and use them accordingly. This
is written like this: <br/>
protocol://user:password@example.com/path/ <br/>
If you need any odd letters in your username or password,
you should enter them URL encoded, as %XX where XX is a
two−digit hexadecimal number.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl also
provides options to set various passwords. The username and
password as shown embedded in the URL can instead get set
with the <i>CURLOPT_USERPWD(3)</i> option. The argument
passed to libcurl should be a char * to a string in the
format "user:password". In a manner like this:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_USERPWD, "myname:thesecret");</p>
<p style="margin-left:9%; margin-top: 1em">Another case
where name and password might be needed at times, is for
those users who need to authenticate themselves to a proxy
they use. libcurl offers another option for this, the
<i>CURLOPT_PROXYUSERPWD(3)</i>. It is used quite similar to
the <i>CURLOPT_USERPWD(3)</i> option like this:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_PROXYUSERPWD, "myname:thesecret");</p>
<p style="margin-left:9%; margin-top: 1em">There is a long
time Unix "standard" way of storing FTP usernames
and passwords, namely in the $HOME/.netrc file (on Windows,
libcurl also checks the <i>%USERPROFILE% environment</i>
variable if <i>%HOME%</i> is unset, and tries
"_netrc" as name). The file should be made private
so that only the user may read it (see also the
"Security Considerations" chapter), as it might
contain the password in plain text. libcurl has the ability
to use this file to figure out what set of username and
password to use for a particular host. As an extension to
the normal functionality, libcurl also supports this file
for non−FTP protocols such as HTTP. To make curl use
this file, use the <i>CURLOPT_NETRC(3)</i> option:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_NETRC, 1L);</p>
<p style="margin-left:9%; margin-top: 1em">A basic example
of how such a .netrc file may look like:</p>
<p style="margin-left:9%; margin-top: 1em">machine
myhost.mydomain.com <br/>
login userlogin <br/>
password secretword</p>
<p style="margin-left:9%; margin-top: 1em">All these
examples have been cases where the password has been
optional, or at least you could leave it out and have
libcurl attempt to do its job without it. There are times
when the password is not optional, like when you are using
an SSL private key for secure transfers.</p>
<p style="margin-left:9%; margin-top: 1em">To pass the
known private key password to libcurl: <br/>
curl_easy_setopt(handle, CURLOPT_KEYPASSWD,
"keypassword");</p>
<h2>HTTP Authentication
<a name="HTTP Authentication"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The previous
chapter showed how to set username and password for getting
URLs that require authentication. When using the HTTP
protocol, there are many different ways a client can provide
those credentials to the server and you can control which
way libcurl uses them. The default HTTP authentication
method is called 'Basic', which is sending the name and
password in clear−text in the HTTP request,
base64−encoded. This is insecure.</p>
<p style="margin-left:9%; margin-top: 1em">At the time of
this writing, libcurl can be built to use: Basic, Digest,
NTLM, Negotiate (SPNEGO). You can tell libcurl which one to
use with <i>CURLOPT_HTTPAUTH(3)</i> as in:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);</p>
<p style="margin-left:9%; margin-top: 1em">When you send
authentication to a proxy, you can also set authentication
type the same way but instead with
<i>CURLOPT_PROXYAUTH(3)</i>:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_PROXYAUTH, CURLAUTH_NTLM);</p>
<p style="margin-left:9%; margin-top: 1em">Both these
options allow you to set multiple types (by ORing them
together), to make libcurl pick the most secure one out of
the types the server/proxy claims to support. This method
does however add a round−trip since libcurl must first
ask the server what it supports:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_HTTPAUTH, CURLAUTH_DIGEST|CURLAUTH_BASIC);</p>
<p style="margin-left:9%; margin-top: 1em">For convenience,
you can use the <i>CURLAUTH_ANY</i> define (instead of a
list with specific types) which allows libcurl to use
whatever method it wants.</p>
<p style="margin-left:9%; margin-top: 1em">When asking for
multiple types, libcurl picks the available one it considers
"best" in its own internal order of
preference.</p>
<h2>HTTP POSTing
<a name="HTTP POSTing"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">We get many
questions regarding how to issue HTTP POSTs with libcurl the
proper way. This chapter thus includes examples using both
different versions of HTTP POST that libcurl supports.</p>
<p style="margin-left:9%; margin-top: 1em">The first
version is the simple POST, the most common version, that
most HTML pages using the &lt;form&gt; tag uses. We provide
a pointer to the data and tell libcurl to post it all to the
remote site:</p>
<p style="margin-left:9%; margin-top: 1em">char
*data="name=daniel&amp;project=curl"; <br/>
curl_easy_setopt(handle, CURLOPT_POSTFIELDS, data); <br/>
curl_easy_setopt(handle, CURLOPT_URL,
"http://posthere.com/");</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_perform(handle);
/* post away! */</p>
<p style="margin-left:9%; margin-top: 1em">Simple enough,
huh? Since you set the POST options with the
<i>CURLOPT_POSTFIELDS(3)</i>, this automatically switches
the handle to use POST in the upcoming request.</p>
<p style="margin-left:9%; margin-top: 1em">What if you want
to post binary data that also requires you to set the
Content−Type: header of the post? Well, binary posts
prevent libcurl from being able to do strlen() on the data
to figure out the size, so therefore we must tell libcurl
the size of the post data. Setting headers in libcurl
requests are done in a generic way, by building a list of
our own headers and then passing that list to libcurl.</p>
<p style="margin-left:9%; margin-top: 1em">struct
curl_slist *headers=NULL; <br/>
headers = curl_slist_append(headers, "Content-Type:
text/xml");</p>
<p style="margin-left:9%; margin-top: 1em">/* post binary
data */ <br/>
curl_easy_setopt(handle, CURLOPT_POSTFIELDS, binaryptr);</p>
<p style="margin-left:9%; margin-top: 1em">/* set the size
of the postfields data */ <br/>
curl_easy_setopt(handle, CURLOPT_POSTFIELDSIZE, 23L);</p>
<p style="margin-left:9%; margin-top: 1em">/* pass our list
of custom made headers */ <br/>
curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers);</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_perform(handle);
/* post away! */</p>
<p style="margin-left:9%; margin-top: 1em">curl_slist_free_all(headers);
/* free the header list */</p>
<p style="margin-left:9%; margin-top: 1em">While the simple
examples above cover the majority of all cases where HTTP
POST operations are required, they do not do
multi−part formposts. Multi−part formposts were
introduced as a better way to post (possibly large) binary
data and were first documented in the RFC 1867 (updated in
RFC 2388). They are called multi−part because they are
built by a chain of parts, each part being a single unit of
data. Each part has its own name and contents. You can in
fact create and post a multi−part formpost with the
regular libcurl POST support described above, but that would
require that you build a formpost yourself and provide to
libcurl.</p>
<p style="margin-left:9%; margin-top: 1em">To make that
easier, libcurl provides a MIME API consisting in several
functions: using those, you can create and fill a
multi−part form. Function <i>curl_mime_init(3)</i>
creates a multi−part body; you can then append new
parts to a multi−part body using
<i>curl_mime_addpart(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">There are three
possible data sources for a part: memory using
<i>curl_mime_data(3)</i>, file using
<i>curl_mime_filedata(3)</i> and user−defined data
read callback using <i>curl_mime_data_cb(3)</i>.
<i>curl_mime_name(3)</i> sets a part's (i.e.: form field)
name, while <i>curl_mime_filename(3)</i> fills in the remote
filename. With <i>curl_mime_type(3)</i>, you can tell the
MIME type of a part, <i>curl_mime_headers(3)</i> allows
defining the part's headers. When a multi−part body is
no longer needed, you can destroy it using
<i>curl_mime_free(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The following
example sets two simple text parts with plain textual
contents, and then a file with binary contents and uploads
the whole thing.</p>
<p style="margin-left:9%; margin-top: 1em">curl_mime
*multipart = curl_mime_init(handle); <br/>
curl_mimepart *part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "name"); <br/>
curl_mime_data(part, "daniel",
CURL_ZERO_TERMINATED); <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "project"); <br/>
curl_mime_data(part, "curl",
CURL_ZERO_TERMINATED); <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "logotype-image"); <br/>
curl_mime_filedata(part, "curl.png");</p>
<p style="margin-left:9%; margin-top: 1em">/* Set the form
info */ <br/>
curl_easy_setopt(handle, CURLOPT_MIMEPOST, multipart);</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_perform(handle);
/* post away! */</p>
<p style="margin-left:9%; margin-top: 1em">/* free the post
data again */ <br/>
curl_mime_free(multipart);</p>
<p style="margin-left:9%; margin-top: 1em">To post multiple
files for a single form field, you must supply each file in
a separate part, all with the same field name. Although
function <i>curl_mime_subparts(3)</i> implements nested
multi−parts, this way of multiple files posting is
deprecated by RFC 7578, chapter 4.3.</p>
<p style="margin-left:9%; margin-top: 1em">To set the data
source from an already opened FILE pointer, use:</p>
<p style="margin-left:9%; margin-top: 1em">curl_mime_data_cb(part,
filesize, (curl_read_callback) fread, <br/>
(curl_seek_callback) fseek, NULL, filepointer);</p>
<p style="margin-left:9%; margin-top: 1em">A deprecated
<i>curl_formadd(3)</i> function is still supported in
libcurl. It should however not be used anymore for new
designs and programs using it ought to be converted to the
MIME API. It is however described here as an aid to
conversion.</p>
<p style="margin-left:9%; margin-top: 1em">Using
<i>curl_formadd</i>, you add parts to the form. When you are
done adding parts, you post the whole form.</p>
<p style="margin-left:9%; margin-top: 1em">The MIME API
example above is expressed as follows using this
function:</p>
<p style="margin-left:9%; margin-top: 1em">struct
curl_httppost *post=NULL; <br/>
struct curl_httppost *last=NULL; <br/>
curl_formadd(&amp;post, &amp;last, <br/>
CURLFORM_COPYNAME, "name", <br/>
CURLFORM_COPYCONTENTS, "daniel", CURLFORM_END);
<br/>
curl_formadd(&amp;post, &amp;last, <br/>
CURLFORM_COPYNAME, "project", <br/>
CURLFORM_COPYCONTENTS, "curl", CURLFORM_END); <br/>
curl_formadd(&amp;post, &amp;last, <br/>
CURLFORM_COPYNAME, "logotype-image", <br/>
CURLFORM_FILECONTENT, "curl.png",
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">/* Set the form
info */ <br/>
curl_easy_setopt(handle, CURLOPT_HTTPPOST, post);</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_perform(handle);
/* post away! */</p>
<p style="margin-left:9%; margin-top: 1em">/* free the post
data again */ <br/>
curl_formfree(post);</p>
<p style="margin-left:9%; margin-top: 1em">Multipart
formposts are chains of parts using MIME−style
separators and headers. It means that each one of these
separate parts get a few headers set that describe the
individual content−type, size etc. To enable your
application to handicraft this formpost even more, libcurl
allows you to supply your own set of custom headers to such
an individual form part. You can of course supply headers to
as many parts as you like, but this little example shows how
you set headers to one specific part when you add that to
the post handle:</p>
<p style="margin-left:9%; margin-top: 1em">struct
curl_slist *headers=NULL; <br/>
headers = curl_slist_append(headers, "Content-Type:
text/xml");</p>
<p style="margin-left:9%; margin-top: 1em">curl_formadd(&amp;post,
&amp;last, <br/>
CURLFORM_COPYNAME, "logotype-image", <br/>
CURLFORM_FILECONTENT, "curl.xml", <br/>
CURLFORM_CONTENTHEADER, headers, <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_perform(handle);
/* post away! */</p>
<p style="margin-left:9%; margin-top: 1em">curl_formfree(post);
/* free post */ <br/>
curl_slist_free_all(headers); /* free custom header list
*/</p>
<p style="margin-left:9%; margin-top: 1em">Since all
options on an easy handle are "sticky", they
remain the same until changed even if you do call
<i>curl_easy_perform(3)</i>, you may need to tell curl to go
back to a plain GET request if you intend to do one as your
next request. You force an easy handle to go back to GET by
using the <i>CURLOPT_HTTPGET(3)</i> option: <br/>
curl_easy_setopt(handle, CURLOPT_HTTPGET, 1L); <br/>
Just setting <i>CURLOPT_POSTFIELDS(3)</i> to "" or
NULL does <i>not</i> stop libcurl from doing a POST. It just
makes it POST without any data to send!</p>
<h2>Converting from deprecated form API to MIME API
<a name="Converting from deprecated form API to MIME API"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Four rules have
to be respected in building the multi−part:</p>
<p style="margin-left:9%; margin-top: 1em">- The easy
handle must be created before building the
multi−part.</p>
<p style="margin-left:9%; margin-top: 1em">- The
multi−part is always created by a call to
curl_mime_init(handle).</p>
<p style="margin-left:9%; margin-top: 1em">- Each part is
created by a call to curl_mime_addpart(multipart).</p>
<p style="margin-left:9%; margin-top: 1em">- When complete,
the multi−part must be bound to the easy handle using
<i>CURLOPT_MIMEPOST(3)</i> instead of
<i>CURLOPT_HTTPPOST(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Here are some
example of <i>curl_formadd</i> calls to MIME API
sequences:</p>
<p style="margin-left:9%; margin-top: 1em">curl_formadd(&amp;post,
&amp;last, <br/>
CURLFORM_COPYNAME, "id", <br/>
CURLFORM_COPYCONTENTS, "daniel", CURLFORM_END);
<br/>
CURLFORM_CONTENTHEADER, headers, <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">becomes: <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "id"); <br/>
curl_mime_data(part, "daniel",
CURL_ZERO_TERMINATED); <br/>
curl_mime_headers(part, headers, FALSE);</p>
<p style="margin-left:9%; margin-top: 1em">Setting the last
<i>curl_mime_headers(3)</i> argument to TRUE would have
caused the headers to be automatically released upon
destroyed the multi−part, thus saving a clean−up
call to <i>curl_slist_free_all(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">curl_formadd(&amp;post,
&amp;last, <br/>
CURLFORM_PTRNAME, "logotype-image", <br/>
CURLFORM_FILECONTENT, "-", <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">becomes: <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "logotype-image"); <br/>
curl_mime_data_cb(part, (curl_off_t) -1, fread, fseek, NULL,
stdin);</p>
<p style="margin-left:9%; margin-top: 1em"><i>curl_mime_name(3)</i>
always copies the field name. The special filename
"−" is not supported by
<i>curl_mime_filename(3)</i>: to read an open file, use a
callback source using fread(). The transfer is be
chunk−encoded since the data size is unknown.</p>
<p style="margin-left:9%; margin-top: 1em">curl_formadd(&amp;post,
&amp;last, <br/>
CURLFORM_COPYNAME, "datafile[]", <br/>
CURLFORM_FILE, "file1", <br/>
CURLFORM_FILE, "file2", <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">becomes: <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "datafile[]"); <br/>
curl_mime_filedata(part, "file1"); <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "datafile[]"); <br/>
curl_mime_filedata(part, "file2");</p>
<p style="margin-left:9%; margin-top: 1em">The deprecated
multipart/mixed implementation of multiple files field is
translated to two distinct parts with the same name.</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_READFUNCTION, myreadfunc); <br/>
curl_formadd(&amp;post, &amp;last, <br/>
CURLFORM_COPYNAME, "stream", <br/>
CURLFORM_STREAM, arg, <br/>
CURLFORM_CONTENTLEN, (curl_off_t) datasize, <br/>
CURLFORM_FILENAME, "archive.zip", <br/>
CURLFORM_CONTENTTYPE, "application/zip", <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">becomes: <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "stream"); <br/>
curl_mime_data_cb(part, (curl_off_t) datasize, <br/>
myreadfunc, NULL, NULL, arg); <br/>
curl_mime_filename(part, "archive.zip"); <br/>
curl_mime_type(part, "application/zip");</p>
<p style="margin-left:9%; margin-top: 1em"><i>CURLOPT_READFUNCTION(3)</i>
callback is not used: it is replace by directly setting the
part source data from the callback read function.</p>
<p style="margin-left:9%; margin-top: 1em">curl_formadd(&amp;post,
&amp;last, <br/>
CURLFORM_COPYNAME, "memfile", <br/>
CURLFORM_BUFFER, "memfile.bin", <br/>
CURLFORM_BUFFERPTR, databuffer, <br/>
CURLFORM_BUFFERLENGTH, (long) sizeof databuffer, <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">becomes: <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "memfile"); <br/>
curl_mime_data(part, databuffer, (curl_off_t) sizeof
databuffer); <br/>
curl_mime_filename(part, "memfile.bin");</p>
<p style="margin-left:9%; margin-top: 1em"><i>curl_mime_data(3)</i>
always copies the initial data: data buffer is thus free for
immediate reuse.</p>
<p style="margin-left:9%; margin-top: 1em">curl_formadd(&amp;post,
&amp;last, <br/>
CURLFORM_COPYNAME, "message", <br/>
CURLFORM_FILECONTENT, "msg.txt", <br/>
CURLFORM_END);</p>
<p style="margin-left:9%; margin-top: 1em">becomes: <br/>
part = curl_mime_addpart(multipart); <br/>
curl_mime_name(part, "message"); <br/>
curl_mime_filedata(part, "msg.txt"); <br/>
curl_mime_filename(part, NULL);</p>
<p style="margin-left:9%; margin-top: 1em">Use of
<i>curl_mime_filedata(3)</i> sets the remote filename as a
side effect: it is therefore necessary to clear it for
<i>CURLFORM_FILECONTENT</i> emulation.</p>
<h2>Showing Progress
<a name="Showing Progress"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">For historical
and traditional reasons, libcurl has a built−in
progress meter that can be switched on and then makes it
present a progress meter in your terminal.</p>
<p style="margin-left:9%; margin-top: 1em">Switch on the
progress meter by, oddly enough, setting
<i>CURLOPT_NOPROGRESS(3)</i> to zero. This option is set to
1 by default.</p>
<p style="margin-left:9%; margin-top: 1em">For most
applications however, the built−in progress meter is
useless and what instead is interesting is the ability to
specify a progress callback. The function pointer you pass
to libcurl is then called on irregular intervals with
information about the current transfer.</p>
<p style="margin-left:9%; margin-top: 1em">Set the progress
callback by using <i>CURLOPT_PROGRESSFUNCTION(3)</i>. Pass a
pointer to a function that matches this prototype:</p>
<p style="margin-left:9%; margin-top: 1em">int
progress_callback(void *clientp, <br/>
double dltotal, <br/>
double dlnow, <br/>
double ultotal, <br/>
double ulnow);</p>
<p style="margin-left:9%; margin-top: 1em">If any of the
input arguments is unknown, a 0 is provided. The first
argument, the 'clientp' is the pointer you pass to libcurl
with <i>CURLOPT_PROGRESSDATA(3)</i>. libcurl does not touch
it.</p>
<h2>libcurl with C++
<a name="libcurl with C++"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">There is
basically only one thing to keep in mind when using C++
instead of C when interfacing libcurl:</p>
<p style="margin-left:9%; margin-top: 1em">The callbacks
CANNOT be non−static class member functions</p>
<p style="margin-left:9%; margin-top: 1em">Example C++
code:</p>
<p style="margin-left:9%; margin-top: 1em">class AClass {
<br/>
static size_t write_data(void *ptr, size_t size, size_t
nmemb, <br/>
void *ourpointer) <br/>
{ <br/>
/* do what you want with the data */ <br/>
} <br/>
}</p>
<h2>Proxies
<a name="Proxies"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">What
"proxy" means according to Merriam−Webster:
"a person authorized to act for another" but also
"the agency, function, or office of a deputy who acts
as a substitute for another".</p>
<p style="margin-left:9%; margin-top: 1em">Proxies are
exceedingly common these days. Companies often only offer
Internet access to employees through their proxies. Network
clients or user−agents ask the proxy for documents,
the proxy does the actual request and then it returns
them.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl supports
SOCKS and HTTP proxies. When a given URL is wanted, libcurl
asks the proxy for it instead of trying to connect to the
actual remote host identified in the URL.</p>
<p style="margin-left:9%; margin-top: 1em">If you are using
a SOCKS proxy, you may find that libcurl does not quite
support all operations through it.</p>
<p style="margin-left:9%; margin-top: 1em">For HTTP
proxies: the fact that the proxy is an HTTP proxy puts
certain restrictions on what can actually happen. A
requested URL that might not be a HTTP URL is passed to the
HTTP proxy to deliver back to libcurl. This happens
transparently, and an application may not need to know. I
say "may", because at times it is important to
understand that all operations over an HTTP proxy use the
HTTP protocol. For example, you cannot invoke your own
custom FTP commands or even proper FTP directory listings.
<br/>
Proxy Options</p>
<p style="margin-left:18%;">To tell libcurl to use a proxy
at a given port number: <br/>
curl_easy_setopt(handle, CURLOPT_PROXY,
"proxy-host.com:8080"); <br/>
Some proxies require user authentication before allowing a
request, and you pass that information similar to this: <br/>
curl_easy_setopt(handle, CURLOPT_PROXYUSERPWD,
"user:password"); <br/>
If you want to, you can specify the hostname only in the
<i>CURLOPT_PROXY(3)</i> option, and set the port number
separately with <i>CURLOPT_PROXYPORT(3)</i>.</p>
<p style="margin-left:18%; margin-top: 1em">Tell libcurl
what kind of proxy it is with <i>CURLOPT_PROXYTYPE(3)</i>
(if not, it defaults to assuming an HTTP proxy): <br/>
curl_easy_setopt(handle, CURLOPT_PROXYTYPE,
CURLPROXY_SOCKS4);</p>
<p style="margin-left:9%;">Environment Variables</p>
<p style="margin-left:18%;">libcurl automatically checks
and uses a set of environment variables to know what proxies
to use for certain protocols. The names of the variables are
following an old tradition and are built up as
"[protocol]_proxy" (note the lower casing). Which
makes the variable 'http_proxy' checked for a name of a
proxy to use when the input URL is HTTP. Following the same
rule, the variable named 'ftp_proxy' is checked for FTP
URLs. Again, the proxies are always HTTP proxies, the
different names of the variables simply allows different
HTTP proxies to be used.</p>
<p style="margin-left:18%; margin-top: 1em">The proxy
environment variable contents should be in the format
"[protocol://][user:password@]machine[:port]".
Where the protocol:// part specifies which type of proxy it
is, and the optional port number specifies on which port the
proxy operates. If not specified, the internal default port
number is used and that is most likely not the one you would
like it to be.</p>
<p style="margin-left:18%; margin-top: 1em">There are two
special environment variables. 'all_proxy' is what sets
proxy for any URL in case the protocol specific variable was
not set, and 'no_proxy' defines a list of hosts that should
not use a proxy even though a variable may say so. If
'no_proxy' is a plain asterisk ("*") it matches
all hosts.</p>
<p style="margin-left:18%; margin-top: 1em">To explicitly
disable libcurl's checking for and using the proxy
environment variables, set the proxy name to ""
− an empty string − with
<i>CURLOPT_PROXY(3)</i>.</p>
<p style="margin-left:9%;">SSL and Proxies</p>
<p style="margin-left:18%;">SSL is for secure
point−to−point connections. This involves strong
encryption and similar things, which effectively makes it
impossible for a proxy to operate as a "man in
between" which the proxy's task is, as previously
discussed. Instead, the only way to have SSL work over an
HTTP proxy is to ask the proxy to tunnel everything through
without being able to check or fiddle with the traffic.</p>
<p style="margin-left:18%; margin-top: 1em">Opening an SSL
connection over an HTTP proxy is therefore a matter of
asking the proxy for a straight connection to the target
host on a specified port. This is made with the HTTP request
CONNECT. ("please dear proxy, connect me to that remote
host").</p>
<p style="margin-left:18%; margin-top: 1em">Because of the
nature of this operation, where the proxy has no idea what
kind of data that is passed in and out through this tunnel,
this breaks some of the few advantages that come from using
a proxy, such as caching. Many organizations prevent this
kind of tunneling to other destination port numbers than 443
(which is the default HTTPS port number).</p>
<p style="margin-left:9%;">Tunneling Through Proxy</p>
<p style="margin-left:18%;">As explained above, tunneling
is required for SSL to work and often even restricted to the
operation intended for SSL; HTTPS.</p>
<p style="margin-left:18%; margin-top: 1em">This is however
not the only time proxy−tunneling might offer benefits
to you or your application.</p>
<p style="margin-left:18%; margin-top: 1em">As tunneling
opens a direct connection from your application to the
remote machine, it suddenly also re−introduces the
ability to do non−HTTP operations over an HTTP proxy.
You can in fact use things such as FTP upload or FTP custom
commands this way.</p>
<p style="margin-left:18%; margin-top: 1em">Again, this is
often prevented by the administrators of proxies and is
rarely allowed.</p>
<p style="margin-left:18%; margin-top: 1em">Tell libcurl to
use proxy tunneling like this: <br/>
curl_easy_setopt(handle, CURLOPT_HTTPPROXYTUNNEL, 1L); <br/>
In fact, there might even be times when you want to do plain
HTTP operations using a tunnel like this, as it then enables
you to operate on the remote server instead of asking the
proxy to do so. libcurl does not stand in the way for such
innovative actions either!</p>
<p style="margin-left:9%;">Proxy Auto-Config</p>
<p style="margin-left:18%;">Netscape first came up with
this. It is basically a webpage (usually using a .pac
extension) with a JavaScript that when executed by the
browser with the requested URL as input, returns information
to the browser on how to connect to the URL. The returned
information might be "DIRECT" (which means no
proxy should be used), "PROXY host:port" (to tell
the browser where the proxy for this particular URL is) or
"SOCKS host:port" (to direct the browser to a
SOCKS proxy).</p>
<p style="margin-left:18%; margin-top: 1em">libcurl has no
means to interpret or evaluate JavaScript and thus it does
not support this. If you get yourself in a position where
you face this nasty invention, the following advice have
been mentioned and used in the past:</p>
<p style="margin-left:18%; margin-top: 1em">- Depending on
the JavaScript complexity, write up a script that translates
it to another language and execute that.</p>
<p style="margin-left:18%; margin-top: 1em">- Read the
JavaScript code and rewrite the same logic in another
language.</p>
<p style="margin-left:18%; margin-top: 1em">- Implement a
JavaScript interpreter; people have successfully used the
Mozilla JavaScript engine in the past.</p>
<p style="margin-left:18%; margin-top: 1em">- Ask your
admins to stop this, for a static proxy setup or
similar.</p>
<h2>Persistence Is The Way to Happiness
<a name="Persistence Is The Way to Happiness"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Re−cycling
the same easy handle several times when doing multiple
requests is the way to go.</p>
<p style="margin-left:9%; margin-top: 1em">After each
single <i>curl_easy_perform(3)</i> operation, libcurl keeps
the connection alive and open. A subsequent request using
the same easy handle to the same host might just be able to
use the already open connection! This reduces network impact
a lot.</p>
<p style="margin-left:9%; margin-top: 1em">Even if the
connection is dropped, all connections involving SSL to the
same host again, benefit from libcurl's session ID cache
that drastically reduces re−connection time.</p>
<p style="margin-left:9%; margin-top: 1em">FTP connections
that are kept alive save a lot of time, as the
command− response round−trips are skipped, and
also you do not risk getting blocked without permission to
login again like on many FTP servers only allowing N persons
to be logged in at the same time.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl caches
DNS name resolving results, to make lookups of a previously
looked up name a lot faster.</p>
<p style="margin-left:9%; margin-top: 1em">Other
interesting details that improve performance for subsequent
requests may also be added in the future.</p>
<p style="margin-left:9%; margin-top: 1em">Each easy handle
attempts to keep the last few connections alive for a while
in case they are to be used again. You can set the size of
this "cache" with the
<i>CURLOPT_MAXCONNECTS(3)</i> option. Default is 5. There is
rarely any point in changing this value, and if you think of
changing this it is often just a matter of thinking
again.</p>
<p style="margin-left:9%; margin-top: 1em">To force your
upcoming request to not use an already existing connection,
you can do that by setting <i>CURLOPT_FRESH_CONNECT(3)</i>
to 1. In a similar spirit, you can also forbid the upcoming
request to be "lying" around and possibly get
reused after the request by setting
<i>CURLOPT_FORBID_REUSE(3)</i> to 1.</p>
<h2>HTTP Headers Used by libcurl
<a name="HTTP Headers Used by libcurl"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">When you use
libcurl to do HTTP requests, it passes along a series of
headers automatically. It might be good for you to know and
understand these. You can replace or remove them by using
the <i>CURLOPT_HTTPHEADER(3)</i> option.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p>Host</p></td>
<td width="1%"></td>
<td width="82%">
<p>This header is required by HTTP 1.1 and even many 1.0
servers and should be the name of the server we want to talk
to. This includes the port number if anything but
default.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p>Accept</p></td>
<td width="1%"></td>
<td width="82%">
<p>"<i>/</i>"</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p>Expect</p></td>
<td width="1%"></td>
<td width="82%">
<p>When doing POST requests, libcurl sets this header to
"100−continue" to ask the server for an
"OK" message before it proceeds with sending the
data part of the post. If the posted data amount is deemed
"small", libcurl does not use this header.</p></td></tr>
</table>
<h2>Customizing Operations
<a name="Customizing Operations"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">There is an
ongoing development today where more and more protocols are
built upon HTTP for transport. This has obvious benefits as
HTTP is a tested and reliable protocol that is widely
deployed and has excellent proxy−support.</p>
<p style="margin-left:9%; margin-top: 1em">When you use one
of these protocols, and even when doing other kinds of
programming you may need to change the traditional HTTP (or
FTP or...) manners. You may need to change words, headers or
various data.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl is your
friend here too. <br/>
CURLOPT_CUSTOMREQUEST</p>
<p style="margin-left:18%;">If just changing the actual
HTTP request keyword is what you want, like when GET, HEAD
or POST is not good enough for you,
<i>CURLOPT_CUSTOMREQUEST(3)</i> is there for you. It is
simple to use:</p>
<p style="margin-left:18%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_CUSTOMREQUEST, "MYOWNREQUEST");</p>
<p style="margin-left:18%; margin-top: 1em">When using the
custom request, you change the request keyword of the actual
request you are performing. Thus, by default you make a GET
request but you can also make a POST operation (as described
before) and then replace the POST keyword if you want to.
You are the boss.</p>
<p style="margin-left:9%;">Modify Headers</p>
<p style="margin-left:18%;">HTTP−like protocols pass
a series of headers to the server when doing the request,
and you are free to pass any amount of extra headers that
you think fit. Adding headers is this easy:</p>
<p style="margin-left:18%; margin-top: 1em">struct
curl_slist *headers=NULL; /* init to NULL is important
*/</p>
<p style="margin-left:18%; margin-top: 1em">headers =
curl_slist_append(headers, "Hey-server-hey: how are
you?"); <br/>
headers = curl_slist_append(headers, "X-silly-content:
yes");</p>
<p style="margin-left:18%; margin-top: 1em">/* pass our
list of custom made headers */ <br/>
curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers);</p>
<p style="margin-left:18%; margin-top: 1em">curl_easy_perform(handle);
/* transfer http */</p>
<p style="margin-left:18%; margin-top: 1em">curl_slist_free_all(headers);
/* free the header list */</p>
<p style="margin-left:18%; margin-top: 1em">... and if you
think some of the internally generated headers, such as
Accept: or Host: do not contain the data you want them to
contain, you can replace them by simply setting them
too:</p>
<p style="margin-left:18%; margin-top: 1em">headers =
curl_slist_append(headers, "Accept: Agent-007");
<br/>
headers = curl_slist_append(headers, "Host:
munged.host.line");</p>
<p style="margin-left:9%;">Delete Headers</p>
<p style="margin-left:18%;">If you replace an existing
header with one with no contents, you prevent the header
from being sent. For instance, if you want to completely
prevent the "Accept:" header from being sent, you
can disable it with code similar to this:</p>
<p style="margin-left:18%; margin-top: 1em">headers =
curl_slist_append(headers, "Accept:");</p>
<p style="margin-left:18%; margin-top: 1em">Both replacing
and canceling internal headers should be done with careful
consideration and you should be aware that you may violate
the HTTP protocol when doing so.</p>
<p style="margin-left:9%;">Enforcing chunked
transfer-encoding</p>
<p style="margin-left:18%;">By making sure a request uses
the custom header "Transfer−Encoding:
chunked" when doing a non−GET HTTP operation,
libcurl switches over to "chunked" upload, even
though the size of the data to upload might be known. By
default, libcurl usually switches over to chunked upload
automatically if the upload data size is unknown.</p>
<p style="margin-left:9%;">HTTP Version</p>
<p style="margin-left:18%;">All HTTP requests includes the
version number to tell the server which version we support.
libcurl speaks HTTP 1.1 by default. Some old servers do not
like getting 1.1−requests and when dealing with
stubborn old things like that, you can tell libcurl to use
1.0 instead by doing something like this:</p>
<p style="margin-left:18%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0);</p>
<p style="margin-left:9%;">FTP Custom Commands</p>
<p style="margin-left:18%;">Not all protocols are
HTTP−like, and thus the above may not help you when
you want to make, for example, your FTP transfers to behave
differently.</p>
<p style="margin-left:18%; margin-top: 1em">Sending custom
commands to an FTP server means that you need to send the
commands exactly as the FTP server expects them (RFC 959 is
a good guide here), and you can only use commands that work
on the control−connection alone. All kinds of commands
that require data interchange and thus need a
data−connection must be left to libcurl's own
judgment. Also be aware that libcurl does its best to change
directory to the target directory before doing any transfer,
so if you change directory (with CWD or similar) you might
confuse libcurl and then it might not attempt to transfer
the file in the correct remote directory.</p>
<p style="margin-left:18%; margin-top: 1em">A little
example that deletes a given file before an operation:</p>
<p style="margin-left:18%; margin-top: 1em">headers =
curl_slist_append(headers, "DELE
file-to-remove");</p>
<p style="margin-left:18%; margin-top: 1em">/* pass the
list of custom commands to the handle */ <br/>
curl_easy_setopt(handle, CURLOPT_QUOTE, headers);</p>
<p style="margin-left:18%; margin-top: 1em">curl_easy_perform(handle);
/* transfer ftp data! */</p>
<p style="margin-left:18%; margin-top: 1em">curl_slist_free_all(headers);
/* free the header list */</p>
<p style="margin-left:18%; margin-top: 1em">If you would
instead want this operation (or chain of operations) to
happen _after_ the data transfer took place the option to
<i>curl_easy_setopt(3)</i> would instead be called
<i>CURLOPT_POSTQUOTE(3)</i> and used the exact same way.</p>
<p style="margin-left:18%; margin-top: 1em">The custom FTP
commands are issued to the server in the same order they are
added to the list, and if a command gets an error code
returned back from the server, no more commands are issued
and libcurl bails out with an error code
(CURLE_QUOTE_ERROR). Note that if you use
<i>CURLOPT_QUOTE(3)</i> to send commands before a transfer,
no transfer actually takes place when a quote command has
failed.</p>
<p style="margin-left:18%; margin-top: 1em">If you set the
<i>CURLOPT_HEADER(3)</i> to 1, you tell libcurl to get
information about the target file and output
"headers" about it. The headers are in
"HTTP−style", looking like they do in
HTTP.</p>
<p style="margin-left:18%; margin-top: 1em">The option to
enable headers or to run custom FTP commands may be useful
to combine with <i>CURLOPT_NOBODY(3)</i>. If this option is
set, no actual file content transfer is performed.</p>
<p style="margin-left:9%;">FTP Custom
CURLOPT_CUSTOMREQUEST</p>
<p style="margin-left:18%;">If you do want to list the
contents of an FTP directory using your own defined FTP
command, <i>CURLOPT_CUSTOMREQUEST(3)</i> does just that.
"NLST" is the default one for listing directories
but you are free to pass in your idea of a good
alternative.</p>
<h2>Cookies Without Chocolate Chips
<a name="Cookies Without Chocolate Chips"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">In the HTTP
sense, a cookie is a name with an associated value. A server
sends the name and value to the client, and expects it to
get sent back on every subsequent request to the server that
matches the particular conditions set. The conditions
include that the domain name and path match and that the
cookie has not become too old.</p>
<p style="margin-left:9%; margin-top: 1em">In
real−world cases, servers send new cookies to replace
existing ones to update them. Server use cookies to
"track" users and to keep
"sessions".</p>
<p style="margin-left:9%; margin-top: 1em">Cookies are sent
from server to clients with the header Set−Cookie: and
they are sent from clients to servers with the Cookie:
header.</p>
<p style="margin-left:9%; margin-top: 1em">To just send
whatever cookie you want to a server, you can use
<i>CURLOPT_COOKIE(3)</i> to set a cookie string like
this:</p>
<p style="margin-left:9%; margin-top: 1em">curl_easy_setopt(handle,
CURLOPT_COOKIE, "name1=var1; name2=var2;");</p>
<p style="margin-left:9%; margin-top: 1em">In many cases,
that is not enough. You might want to dynamically save
whatever cookies the remote server passes to you, and make
sure those cookies are then used accordingly on later
requests.</p>
<p style="margin-left:9%; margin-top: 1em">One way to do
this, is to save all headers you receive in a plain file and
when you make a request, you tell libcurl to read the
previous headers to figure out which cookies to use. Set the
header file to read cookies from with
<i>CURLOPT_COOKIEFILE(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>CURLOPT_COOKIEFILE(3)</i> option also automatically
enables the cookie parser in libcurl. Until the cookie
parser is enabled, libcurl does not parse or understand
incoming cookies and they are just be ignored. However, when
the parser is enabled the cookies are understood and the
cookies are kept in memory and used properly in subsequent
requests when the same handle is used. Many times this is
enough, and you may not have to save the cookies to disk at
all. Note that the file you specify to
<i>CURLOPT_COOKIEFILE(3)</i> does not have to exist to
enable the parser, so a common way to just enable the parser
and not read any cookies is to use the name of a file you
know does not exist.</p>
<p style="margin-left:9%; margin-top: 1em">If you would
rather use existing cookies that you have previously
received with your Netscape or Mozilla browsers, you can
make libcurl use that cookie file as input. The
<i>CURLOPT_COOKIEFILE(3)</i> is used for that too, as
libcurl automatically finds out what kind of file it is and
acts accordingly.</p>
<p style="margin-left:9%; margin-top: 1em">Perhaps the most
advanced cookie operation libcurl offers, is saving the
entire internal cookie state back into a Netscape/Mozilla
formatted cookie file. We call that the cookie−jar.
When you set a filename with <i>CURLOPT_COOKIEJAR(3)</i>,
that filename is created and all received cookies get stored
in it when <i>curl_easy_cleanup(3)</i> is called. This
enables cookies to get passed on properly between multiple
handles without any information getting lost.</p>
<h2>FTP Peculiarities We Need
<a name="FTP Peculiarities We Need"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">FTP transfers
use a second TCP/IP connection for the data transfer. This
is usually a fact you can forget and ignore but at times
this detail comes back to haunt you. libcurl offers several
different ways to customize how the second connection is
being made.</p>
<p style="margin-left:9%; margin-top: 1em">libcurl can
either connect to the server a second time or tell the
server to connect back to it. The first option is the
default and it is also what works best for all the people
behind firewalls, NATs or IP−masquerading setups.
libcurl then tells the server to open up a new port and wait
for a second connection. This is by default attempted with
EPSV first, and if that does not work it tries PASV instead.
(EPSV is an extension to the original FTP spec and does not
exist nor work on all FTP servers.)</p>
<p style="margin-left:9%; margin-top: 1em">You can prevent
libcurl from first trying the EPSV command by setting
<i>CURLOPT_FTP_USE_EPSV(3)</i> to zero.</p>
<p style="margin-left:9%; margin-top: 1em">In some cases,
you want to have the server connect back to you for the
second connection. This might be when the server is perhaps
behind a firewall or something and only allows connections
on a single port. libcurl then informs the remote server
which IP address and port number to connect to. This is made
with the <i>CURLOPT_FTPPORT(3)</i> option. If you set it to
"−", libcurl uses your system's
"default IP address". If you want to use a
particular IP, you can set the full IP address, a hostname
to resolve to an IP address or even a local network
interface name that libcurl gets the IP address from.</p>
<p style="margin-left:9%; margin-top: 1em">When doing the
"PORT" approach, libcurl attempts to use the EPRT
and the LPRT before trying PORT, as they work with more
protocols. You can disable this behavior by setting
<i>CURLOPT_FTP_USE_EPRT(3)</i> to zero.</p>
<h2>MIME API revisited for SMTP and IMAP
<a name="MIME API revisited for SMTP and IMAP"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">In addition to
support HTTP multi−part form fields, the MIME API can
be used to build structured email messages and send them via
SMTP or append such messages to IMAP directories.</p>
<p style="margin-left:9%; margin-top: 1em">A structured
email message may contain several parts: some are displayed
inline by the MUA, some are attachments. Parts can also be
structured as multi−part, for example to include
another email message or to offer several text formats
alternatives. This can be nested to any level.</p>
<p style="margin-left:9%; margin-top: 1em">To build such a
message, you prepare the nth−level multi−part
and then include it as a source to the parent
multi−part using function
<i>curl_mime_subparts(3)</i>. Once it has been bound to its
parent multi−part, a nth−level multi−part
belongs to it and should not be freed explicitly.</p>
<p style="margin-left:9%; margin-top: 1em">Email messages
data is not supposed to be non−ascii and line length
is limited: fortunately, some transfer encodings are defined
by the standards to support the transmission of such
incompatible data. Function <i>curl_mime_encoder(3)</i>
tells a part that its source data must be encoded before
being sent. It also generates the corresponding header for
that part. If the part data you want to send is already
encoded in such a scheme, do not use this function (this
would over−encode it), but explicitly set the
corresponding part header.</p>
<p style="margin-left:9%; margin-top: 1em">Upon sending
such a message, libcurl prepends it with the header list set
with <i>CURLOPT_HTTPHEADER(3)</i>, as zero level mime part
headers.</p>
<p style="margin-left:9%; margin-top: 1em">Here is an
example building an email message with an inline plain/html
text alternative and a file attachment encoded in
base64:</p>
<p style="margin-left:9%; margin-top: 1em">curl_mime
*message = curl_mime_init(handle);</p>
<p style="margin-left:9%; margin-top: 1em">/* The inline
part is an alternative proposing the html and the text <br/>
versions of the email. */ <br/>
curl_mime *alt = curl_mime_init(handle);</p>
<p style="margin-left:9%; margin-top: 1em">/* HTML message.
*/ <br/>
curl_mimepart *part = curl_mime_addpart(alt); <br/>
curl_mime_data(part,
"&lt;html&gt;&lt;body&gt;&lt;p&gt;This is
HTML&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;", <br/>
CURL_ZERO_TERMINATED); <br/>
curl_mime_type(part, "text/html");</p>
<p style="margin-left:9%; margin-top: 1em">/* Text message.
*/ <br/>
part = curl_mime_addpart(alt); <br/>
curl_mime_data(part, "This is plain text message",
<br/>
CURL_ZERO_TERMINATED);</p>
<p style="margin-left:9%; margin-top: 1em">/* Create the
inline part. */ <br/>
part = curl_mime_addpart(message); <br/>
curl_mime_subparts(part, alt); <br/>
curl_mime_type(part, "multipart/alternative");
<br/>
struct curl_slist *headers = curl_slist_append(NULL, <br/>
"Content-Disposition: inline"); <br/>
curl_mime_headers(part, headers, TRUE);</p>
<p style="margin-left:9%; margin-top: 1em">/* Add the
attachment. */ <br/>
part = curl_mime_addpart(message); <br/>
curl_mime_filedata(part, "manual.pdf"); <br/>
curl_mime_encoder(part, "base64");</p>
<p style="margin-left:9%; margin-top: 1em">/* Build the
mail headers. */ <br/>
headers = curl_slist_append(NULL, "From:
me@example.com"); <br/>
headers = curl_slist_append(headers, "To:
you@example.com");</p>
<p style="margin-left:9%; margin-top: 1em">/* Set these
into the easy handle. */ <br/>
curl_easy_setopt(handle, CURLOPT_HTTPHEADER, headers); <br/>
curl_easy_setopt(handle, CURLOPT_MIMEPOST, mime);</p>
<p style="margin-left:9%; margin-top: 1em">It should be
noted that appending a message to an IMAP directory requires
the message size to be known prior upload. It is therefore
not possible to include parts with unknown data size in this
context.</p>
<h2>Headers Equal Fun
<a name="Headers Equal Fun"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Some protocols
provide "headers", meta−data separated from
the normal data. These headers are by default not included
in the normal data stream, but you can make them appear in
the data stream by setting <i>CURLOPT_HEADER(3)</i> to
1.</p>
<p style="margin-left:9%; margin-top: 1em">What might be
even more useful, is libcurl's ability to separate the
headers from the data and thus make the callbacks differ.
You can for example set a different pointer to pass to the
ordinary write callback by setting
<i>CURLOPT_HEADERDATA(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Or, you can set
an entirely separate function to receive the headers, by
using <i>CURLOPT_HEADERFUNCTION(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The headers are
passed to the callback function one by one, and you can
depend on that fact. It makes it easier for you to add
custom header parsers etc.</p>
<p style="margin-left:9%; margin-top: 1em">"Headers"
for FTP transfers equal all the FTP server responses. They
are not actually true headers, but in this case we pretend
they are! ;−)</p>
<h2>Post Transfer Information
<a name="Post Transfer Information"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See
<i>curl_easy_getinfo(3)</i>.</p>
<h2>The multi Interface
<a name="The multi Interface"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The easy
interface as described in detail in this document is a
synchronous interface that transfers one file at a time and
does not return until it is done.</p>
<p style="margin-left:9%; margin-top: 1em">The multi
interface, on the other hand, allows your program to
transfer multiple files in both directions at the same time,
without forcing you to use multiple threads. The name might
make it seem that the multi interface is for
multi−threaded programs, but the truth is almost the
reverse. The multi interface allows a single−threaded
application to perform the same kinds of multiple,
simultaneous transfers that multi−threaded programs
can perform. It allows many of the benefits of
multi−threaded transfers without the complexity of
managing and synchronizing many threads.</p>
<p style="margin-left:9%; margin-top: 1em">To complicate
matters somewhat more, there are even two versions of the
multi interface. The event based one, also called
multi_socket and the "normal one" designed for
using with select(). See the libcurl−multi.3 man page
for details on the multi_socket event based API, this
description here is for the select() oriented one.</p>
<p style="margin-left:9%; margin-top: 1em">To use this
interface, you are better off if you first understand the
basics of how to use the easy interface. The multi interface
is simply a way to make multiple transfers at the same time
by adding up multiple easy handles into a "multi
stack".</p>
<p style="margin-left:9%; margin-top: 1em">You create the
easy handles you want, one for each concurrent transfer, and
you set all the options just like you learned above, and
then you create a multi handle with
<i>curl_multi_init(3)</i> and add all those easy handles to
that multi handle with <i>curl_multi_add_handle(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">When you have
added the handles you have for the moment (you can still add
new ones at any time), you start the transfers by calling
<i>curl_multi_perform(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><i>curl_multi_perform(3)</i>
is asynchronous. It only performs what can be done now and
then return control to your program. It is designed to never
block. You need to keep calling the function until all
transfers are completed.</p>
<p style="margin-left:9%; margin-top: 1em">The best usage
of this interface is when you do a select() on all possible
file descriptors or sockets to know when to call libcurl
again. This also makes it easy for you to wait and respond
to actions on your own application's sockets/handles. You
figure out what to select() for by using
<i>curl_multi_fdset(3)</i>, that fills in a set of
<i>fd_set</i> variables for you with the particular file
descriptors libcurl uses for the moment.</p>
<p style="margin-left:9%; margin-top: 1em">When you then
call select(), it returns when one of the file handles
signal action and you then call <i>curl_multi_perform(3)</i>
to allow libcurl to do what it wants to do. Take note that
libcurl does also feature some time−out code so we
advise you to never use long timeouts on select() before you
call <i>curl_multi_perform(3)</i> again.
<i>curl_multi_timeout(3)</i> is provided to help you get a
suitable timeout period.</p>
<p style="margin-left:9%; margin-top: 1em">Another
precaution you should use: always call
<i>curl_multi_fdset(3)</i> immediately before the select()
call since the current set of file descriptors may change in
any curl function invoke.</p>
<p style="margin-left:9%; margin-top: 1em">If you want to
stop the transfer of one of the easy handles in the stack,
you can use <i>curl_multi_remove_handle(3)</i> to remove
individual easy handles. Remember that easy handles should
be <i>curl_easy_cleanup(3)</i>ed.</p>
<p style="margin-left:9%; margin-top: 1em">When a transfer
within the multi stack has finished, the counter of running
transfers (as filled in by <i>curl_multi_perform(3)</i>)
decreases. When the number reaches zero, all transfers are
done.</p>
<p style="margin-left:9%; margin-top: 1em"><i>curl_multi_info_read(3)</i>
can be used to get information about completed transfers. It
then returns the CURLcode for each easy transfer, to allow
you to figure out success on each individual transfer.</p>
<h2>SSL, Certificates and Other Tricks
<a name="SSL, Certificates and Other Tricks"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">[ seeding,
passwords, keys, certificates, ENGINE, ca certs ]</p>
<h2>Sharing Data Between Easy Handles
<a name="Sharing Data Between Easy Handles"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">You can share
some data between easy handles when the easy interface is
used, and some data is share automatically when you use the
multi interface.</p>
<p style="margin-left:9%; margin-top: 1em">When you add
easy handles to a multi handle, these easy handles
automatically share a lot of the data that otherwise would
be kept on a per−easy handle basis when the easy
interface is used.</p>
<p style="margin-left:9%; margin-top: 1em">The DNS cache is
shared between handles within a multi handle, making
subsequent name resolving faster, and the connection pool
that is kept to better allow persistent connections and
connection reuse is also shared. If you are using the easy
interface, you can still share these between specific easy
handles by using the share interface, see
<i>libcurl−share(3)</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Some things are
never shared automatically, not within multi handles, like
for example cookies so the only way to share that is with
the share interface.</p>
<h2>Footnotes
<a name="Footnotes"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">[1]</p></td>
<td width="5%"></td>
<td width="82%">
<p style="margin-top: 1em">libcurl 7.10.3 and later have
the ability to switch over to chunked
Transfer−Encoding in cases where HTTP uploads are done
with data of an unknown size.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>[2]</p></td>
<td width="5%"></td>
<td width="82%">
<p>This happens on Windows machines when libcurl is built
and used as a DLL. However, you can still do this on Windows
if you link with a static library.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>[3]</p></td>
<td width="5%"></td>
<td width="82%">
<p>The curl−config tool is generated at
build−time (on Unix−like systems) and should be
installed with the 'make install' or similar instruction
that installs the library, header files, man pages etc.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>[4]</p></td>
<td width="5%"></td>
<td width="82%">
<p>This behavior was different in versions before 7.17.0,
where strings had to remain valid past the end of the
<i>curl_easy_setopt(3)</i> call.</p></td></tr>
</table>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>libcurl-easy</b>(3),
<b>libcurl-errors</b>(3), <b>libcurl-multi</b>(3),
<b>libcurl-url</b>(3)</p>
<hr/>
</body>
</html>
