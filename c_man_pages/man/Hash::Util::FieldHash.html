<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:47:10 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Hash::Util::FieldHash</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Hash::Util::FieldHash</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#FUNCTIONS">FUNCTIONS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#The Inside-out Technique">The Inside-out Technique</a><br/>
<a href="#Problems of Inside-out">Problems of Inside-out</a><br/>
<a href="#Solutions">Solutions</a><br/>
<a href="#More Problems">More Problems</a><br/>
<a href="#The Generic Object">The Generic Object</a><br/>
<a href="#How to use Field Hashes">How to use Field Hashes</a><br/>
<a href="#Garbage-Collected Hashes">Garbage-Collected Hashes</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#Example 1">Example 1</a><br/>
<a href="#Example 2">Example 2</a><br/>
<a href="#GUTS">GUTS</a><br/>
<a href='#The "PERL_MAGIC_uvar" interface for hashes'>The "PERL_MAGIC_uvar" interface for hashes</a><br/>
<a href="#Weakrefs call uvar magic">Weakrefs call uvar magic</a><br/>
<a href="#How field hashes work">How field hashes work</a><br/>
<a href="#Internal function Hash::Util::FieldHash::_fieldhash">Internal function Hash::Util::FieldHash::_fieldhash</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Hash::Util::FieldHash
− Support for Inside−Out Classes</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">### Create
fieldhashes <br/>
use Hash::Util qw(fieldhash fieldhashes); <br/>
# Create a single field hash <br/>
fieldhash my %foo; <br/>
# Create three at once... <br/>
fieldhashes \ my(%foo, %bar, %baz); <br/>
# ...or any number <br/>
fieldhashes @hashrefs; <br/>
### Create an idhash and register it for garbage collection
<br/>
use Hash::Util::FieldHash qw(idhash register); <br/>
idhash my %name; <br/>
my $object = \ do { my $o }; <br/>
# register the idhash for garbage collection with $object
<br/>
register($object, \ %name); <br/>
# the following entry will be deleted when $object goes out
of scope <br/>
$name{$object} = 'John Doe'; <br/>
### Register an ordinary hash for garbage collection <br/>
use Hash::Util::FieldHash qw(id register); <br/>
my %name; <br/>
my $object = \ do { my $o }; <br/>
# register the hash %name for garbage collection of
$object's id <br/>
register $object, \ %name; <br/>
# the following entry will be deleted when $object goes out
of scope <br/>
$name{id $object} = 'John Doe';</p>
<h2>FUNCTIONS
<a name="FUNCTIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">"Hash::Util::FieldHash"
offers a number of functions in support of "The
Inside-out Technique" of class construction.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>id</p></td>
<td width="88%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">id($obj)</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
reference address of a reference $obj. If $obj is not a
reference, returns $obj.</p>
<p style="margin-left:14%; margin-top: 1em">This function
is a stand-in replacement for Scalar::Util::refaddr, that
is, it returns the reference address of its argument as a
numeric value. The only difference is that refaddr() returns
"undef" when given a non-reference while id()
returns its argument unchanged.</p>
<p style="margin-left:14%; margin-top: 1em">id() also uses
a caching technique that makes it faster when the id of an
object is requested often, but slower if it is needed only
once or twice.</p>
<p style="margin-left:9%;">id_2obj</p>
<p style="margin-left:14%;">$obj = id_2obj($id)</p>
<p style="margin-left:14%; margin-top: 1em">If $id is the
id of a registered object (see "register"),
returns the object, otherwise an undefined value. For
registered objects this is the inverse function of id().</p>
<p style="margin-left:9%;">register</p>
<p style="margin-left:14%;">register($obj) <br/>
register($obj, @hashrefs)</p>
<p style="margin-left:14%; margin-top: 1em">In the first
form, registers an object to work with for the function
id_2obj(). In the second form, it additionally marks the
given hashrefs down for garbage collection. This means that
when the object goes out of scope, any entries in the given
hashes under the key of id($obj) will be deleted from the
hashes.</p>
<p style="margin-left:14%; margin-top: 1em">It is a fatal
error to register a non-reference $obj. Any non-hashrefs
among the following arguments are silently ignored.</p>
<p style="margin-left:14%; margin-top: 1em">It is
<i>not</i> an error to register the same object multiple
times with varying sets of hashrefs. Any hashrefs that are
not registered yet will be added, others ignored.</p>
<p style="margin-left:14%; margin-top: 1em">Registry also
implies thread support. When a new thread is created, all
references are replaced with new ones, including all
objects. If a hash uses the reference address of an object
as a key, that connection would be broken. With a registered
object, its id will be updated in all hashes registered with
it.</p>
<p style="margin-left:9%;">idhash</p>
<p style="margin-left:14%;">idhash my %hash</p>
<p style="margin-left:14%; margin-top: 1em">Makes an idhash
from the argument, which must be a hash.</p>
<p style="margin-left:14%; margin-top: 1em">An
<i>idhash</i> works like a normal hash, except that it
stringifies a <i>reference used as a key</i> differently. A
reference is stringified as if the id() function had been
invoked on it, that is, its reference address in decimal is
used as the key.</p>
<p style="margin-left:9%;">idhashes</p>
<p style="margin-left:14%;">idhashes \ my(%hash, %gnash,
%trash) <br/>
idhashes \ @hashrefs</p>
<p style="margin-left:14%; margin-top: 1em">Creates many
idhashes from its hashref arguments. Returns those arguments
that could be converted or their number in scalar
context.</p>
<p style="margin-left:9%;">fieldhash</p>
<p style="margin-left:14%;">fieldhash %hash;</p>
<p style="margin-left:14%; margin-top: 1em">Creates a
single fieldhash. The argument must be a hash. Returns a
reference to the given hash if successful, otherwise
nothing.</p>
<p style="margin-left:14%; margin-top: 1em">A
<i>fieldhash</i> is, in short, an idhash with auto-registry.
When an object (or, indeed, any reference) is used as a
fieldhash key, the fieldhash is automatically registered for
garbage collection with the object, as if "register
$obj, \ %fieldhash" had been called.</p>
<p style="margin-left:9%;">fieldhashes</p>
<p style="margin-left:14%;">fieldhashes @hashrefs;</p>
<p style="margin-left:14%; margin-top: 1em">Creates any
number of field hashes. Arguments must be hash references.
Returns the converted hashrefs in list context, their number
in scalar context.</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">A word on
terminology: I shall use the term <i>field</i> for a scalar
piece of data that a class associates with an object. Other
terms that have been used for this concept are "object
variable", "(object) property",
"(object) attribute" and more. Especially
"attribute" has some currency among Perl
programmer, but that clashes with the "attributes"
pragma. The term "field" also has some currency in
this sense and doesn’t seem to conflict with other
Perl terminology.</p>
<p style="margin-left:9%; margin-top: 1em">In Perl, an
object is a blessed reference. The standard way of
associating data with an object is to store the data inside
the object’s body, that is, the piece of data pointed
to by the reference.</p>
<p style="margin-left:9%; margin-top: 1em">In consequence,
if two or more classes want to access an object they
<i>must</i> agree on the type of reference and also on the
organization of data within the object body. Failure to
agree on the type results in immediate death when the wrong
method tries to access an object. Failure to agree on data
organization may lead to one class trampling over the data
of another.</p>
<p style="margin-left:9%; margin-top: 1em">This object
model leads to a tight coupling between subclasses. If one
class wants to inherit from another (and both classes access
object data), the classes must agree about implementation
details. Inheritance can only be used among classes that are
maintained together, in a single source or not.</p>
<p style="margin-left:9%; margin-top: 1em">In particular,
it is not possible to write general-purpose classes in this
technique, classes that can advertise themselves as
"Put me on your @ISA list and use my methods". If
the other class has different ideas about how the object
body is used, there is trouble.</p>
<p style="margin-left:9%; margin-top: 1em">For reference
"Name_hash" in "Example 1" shows the
standard implementation of a simple class "Name"
in the well-known hash based way. It also demonstrates the
predictable failure to construct a common subclass
"NamedFile" of "Name" and the class
"IO::File" (whose objects <i>must</i> be
globrefs).</p>
<p style="margin-left:9%; margin-top: 1em">Thus, techniques
are of interest that store object data <i>not</i> in the
object body but some other place.</p>
<h3>The Inside-out Technique
<a name="The Inside-out Technique"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">With
<i>inside-out</i> classes, each class declares a (typically
lexical) hash for each field it wants to use. The reference
address of an object is used as the hash key. By definition,
the reference address is unique to each object so this
guarantees a place for each field that is private to the
class and unique to each object. See "Name_id" in
"Example 1" for a simple example.</p>
<p style="margin-left:9%; margin-top: 1em">In comparison to
the standard implementation where the object is a hash and
the fields correspond to hash keys, here the fields
correspond to hashes, and the object determines the hash
key. Thus the hashes appear to be turned <i>inside
out</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The body of an
object is never examined by an inside-out class, only its
reference address is used. This allows for the body of an
actual object to be <i>anything at all</i> while the object
methods of the class still work as designed. This is a key
feature of inside-out classes.</p>
<h3>Problems of Inside-out
<a name="Problems of Inside-out"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Inside-out
classes give us freedom of inheritance, but as usual there
is a price.</p>
<p style="margin-left:9%; margin-top: 1em">Most obviously,
there is the necessity of retrieving the reference address
of an object for each data access. It’s a minor
inconvenience, but it does clutter the code.</p>
<p style="margin-left:9%; margin-top: 1em">More important
(and less obvious) is the necessity of garbage collection.
When a normal object dies, anything stored in the object
body is garbage-collected by perl. With inside-out objects,
Perl knows nothing about the data stored in field hashes by
a class, but these must be deleted when the object goes out
of scope. Thus the class must provide a "DESTROY"
method to take care of that.</p>
<p style="margin-left:9%; margin-top: 1em">In the presence
of multiple classes it can be non-trivial to make sure that
every relevant destructor is called for every object. Perl
calls the first one it finds on the inheritance tree (if
any) and that’s it.</p>
<p style="margin-left:9%; margin-top: 1em">A related issue
is thread-safety. When a new thread is created, the Perl
interpreter is cloned, which implies that all reference
addresses in use will be replaced with new ones. Thus, if a
class tries to access a field of a cloned object its
(cloned) data will still be stored under the now invalid
reference address of the original in the parent thread. A
general "CLONE" method must be provided to
re-establish the association.</p>
<h3>Solutions
<a name="Solutions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"Hash::Util::FieldHash"
addresses these issues on several levels.</p>
<p style="margin-left:9%; margin-top: 1em">The id()
function is provided in addition to the existing
Scalar::Util::refaddr(). Besides its short name it can be a
little faster under some circumstances (and a bit slower
under others). Benchmark if it matters. The working of id()
also allows the use of the class name as a <i>generic
object</i> as described further down.</p>
<p style="margin-left:9%; margin-top: 1em">The id()
function is incorporated in <i>id hashes</i> in the sense
that it is called automatically on every key that is used
with the hash. No explicit call is necessary.</p>
<p style="margin-left:9%; margin-top: 1em">The problems of
garbage collection and thread safety are both addressed by
the function register(). It registers an object together
with any number of hashes. Registry means that when the
object dies, an entry in any of the hashes under the
reference address of this object will be deleted. This
guarantees garbage collection in these hashes. It also means
that on thread cloning the object’s entries in
registered hashes will be replaced with updated entries
whose key is the cloned object’s reference address.
Thus the object-data association becomes thread-safe.</p>
<p style="margin-left:9%; margin-top: 1em">Object registry
is best done when the object is initialized for use with a
class. That way, garbage collection and thread safety are
established for every object and every field that is
initialized.</p>
<p style="margin-left:9%; margin-top: 1em">Finally,
<i>field hashes</i> incorporate all these functions in one
package. Besides automatically calling the id() function on
every object used as a key, the object is registered with
the field hash on first use. Classes based on field hashes
are fully garbage-collected and thread safe without further
measures.</p>
<h3>More Problems
<a name="More Problems"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Another problem
that occurs with inside-out classes is serialization. Since
the object data is not in its usual place, standard routines
like Storable::freeze(), Storable::thaw() and
Data::Dumper::Dumper() can’t deal with it on their
own. Both "Data::Dumper" and "Storable"
provide the necessary hooks to make things work, but the
functions or methods used by the hooks must be provided by
each inside-out class.</p>
<p style="margin-left:9%; margin-top: 1em">A general
solution to the serialization problem would require another
level of registry, one that associates <i>classes</i> and
fields. So far, the functions of
"Hash::Util::FieldHash" are unaware of any
classes, which I consider a feature. Therefore
"Hash::Util::FieldHash" doesn’t address the
serialization problems.</p>
<h3>The Generic Object
<a name="The Generic Object"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Classes based on
the id() function (and hence classes based on idhash() and
fieldhash()) show a peculiar behavior in that the class name
can be used like an object. Specifically, methods that set
or read data associated with an object continue to work as
class methods, just as if the class name were an object,
distinct from all other objects, with its own data. This
object may be called the <i>generic object</i> of the
class.</p>
<p style="margin-left:9%; margin-top: 1em">This works
because field hashes respond to keys that are not references
like a normal hash would and use the string offered as the
hash key. Thus, if a method is called as a class method, the
field hash is presented with the class name instead of an
object and blithely uses it as a key. Since the keys of real
objects are decimal numbers, there is no conflict and the
slot in the field hash can be used like any other. The id()
function behaves correspondingly with respect to
non-reference arguments.</p>
<p style="margin-left:9%; margin-top: 1em">Two possible
uses (besides ignoring the property) come to mind. A
singleton class could be implemented this using the generic
object. If necessary, an init() method could die or ignore
calls with actual objects (references), so only the generic
object will ever exist.</p>
<p style="margin-left:9%; margin-top: 1em">Another use of
the generic object would be as a template. It is a
convenient place to store class-specific defaults for
various fields to be used in actual object
initialization.</p>
<p style="margin-left:9%; margin-top: 1em">Usually, the
feature can be entirely ignored. Calling <i>object
methods</i> as <i>class methods</i> normally leads to an
error and isn’t used routinely anywhere. It may be a
problem that this error isn’t indicated by a class
with a generic object.</p>
<h3>How to use Field Hashes
<a name="How to use Field Hashes"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Traditionally,
the definition of an inside-out class contains a bare block
inside which a number of lexical hashes are declared and the
basic accessor methods defined, usually through
"Scalar::Util::refaddr". Further methods may be
defined outside this block. There has to be a DESTROY method
and, for thread support, a CLONE method.</p>
<p style="margin-left:9%; margin-top: 1em">When field
hashes are used, the basic structure remains the same. Each
lexical hash will be made a field hash. The call to
"refaddr" can be omitted from the accessor
methods. DESTROY and CLONE methods are not necessary.</p>
<p style="margin-left:9%; margin-top: 1em">If you have an
existing inside-out class, simply making all hashes field
hashes with no other change should make no difference.
Through the calls to "refaddr" or equivalent, the
field hashes never get to see a reference and work like
normal hashes. Your DESTROY (and CLONE) methods are still
needed.</p>
<p style="margin-left:9%; margin-top: 1em">To make the
field hashes kick in, it is easiest to redefine
"refaddr" as</p>
<p style="margin-left:9%; margin-top: 1em">sub refaddr {
shift }</p>
<p style="margin-left:9%; margin-top: 1em">instead of
importing it from "Scalar::Util". It should now be
possible to disable DESTROY and CLONE. Note that while it
isn’t disabled, DESTROY will be called before the
garbage collection of field hashes, so it will be invoked
with a functional object and will continue to function.</p>
<p style="margin-left:9%; margin-top: 1em">It is not
desirable to import the functions "fieldhash"
and/or "fieldhashes" into every class that is
going to use them. They are only used once to set up the
class. When the class is up and running, these functions
serve no more purpose.</p>
<p style="margin-left:9%; margin-top: 1em">If there are
only a few field hashes to declare, it is simplest to</p>
<p style="margin-left:9%; margin-top: 1em">use
Hash::Util::FieldHash;</p>
<p style="margin-left:9%; margin-top: 1em">early and call
the functions qualified:</p>
<p style="margin-left:9%; margin-top: 1em">Hash::Util::FieldHash::fieldhash
my %foo;</p>
<p style="margin-left:9%; margin-top: 1em">Otherwise,
import the functions into a convenient package like
"HUF" or, more general, "Aux"</p>
<p style="margin-left:9%; margin-top: 1em">{ <br/>
package Aux; <br/>
use Hash::Util::FieldHash ':all'; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">and call</p>
<p style="margin-left:9%; margin-top: 1em">Aux::fieldhash
my %foo;</p>
<p style="margin-left:9%; margin-top: 1em">as needed.</p>
<h3>Garbage-Collected Hashes
<a name="Garbage-Collected Hashes"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Garbage
collection in a field hash means that entries will
"spontaneously" disappear when the object that
created them disappears. That must be borne in mind,
especially when looping over a field hash. If anything you
do inside the loop could cause an object to go out of scope,
a random key may be deleted from the hash you are looping
over. That can throw the loop iterator, so it’s best
to cache a consistent snapshot of the keys and/or values and
loop over that. You will still have to check that a cached
entry still exists when you get to it.</p>
<p style="margin-left:9%; margin-top: 1em">Garbage
collection can be confusing when keys are created in a field
hash from normal scalars as well as references. Once a
reference is <i>used</i> with a field hash, the entry will
be collected, even if it was later overwritten with a plain
scalar key (every positive integer is a candidate). This is
true even if the original entry was deleted in the meantime.
In fact, deletion from a field hash, and also a test for
existence constitute <i>use</i> in this sense and create a
liability to delete the entry when the reference goes out of
scope. If you happen to create an entry with an identical
key from a string or integer, that will be collected
instead. Thus, mixed use of references and plain scalars as
field hash keys is not entirely supported.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The examples
show a very simple class that implements a <i>name</i>,
consisting of a first and last name (no middle initial). The
name class has four methods:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="8%">
<p>init()</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">An object
method that initializes the first and last name to its two
arguments. If called as a class method, init() creates an
object in the given class and initializes that.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="9%">
<p style="margin-top: 1em">first()</p></td>
<td width="77%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Retrieve the
first name</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="8%">
<p style="margin-top: 1em">last()</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Retrieve the
last name</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="8%">
<p style="margin-top: 1em">name()</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Retrieve the
full name, the first and last name joined by a blank.</p>
<p style="margin-left:9%; margin-top: 1em">The examples
show this class implemented with different levels of support
by "Hash::Util::FieldHash". All supported
combinations are shown. The difference between
implementations is often quite small. The implementations
are:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="14%">
<p style="margin-top: 1em">"Name_hash"</p></td>
<td width="72%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">A conventional
(not inside-out) implementation where an object is a hash
that stores the field values, without support by
"Hash::Util::FieldHash". This implementation
doesn’t allow arbitrary inheritance.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="12%">
<p style="margin-top: 1em">"Name_id"</p></td>
<td width="74%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Inside-out
implementation based on the id() function. It needs a
"DESTROY" method. For thread support a
"CLONE" method (not shown) would also be needed.
Instead of Hash::Util::FieldHash::id() the function
"Scalar::Util::refaddr" could be used with very
little functional difference. This is the basic pattern of
an inside-out class.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="17%">
<p style="margin-top: 1em">"Name_idhash"</p></td>
<td width="69%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Idhash-based
inside-out implementation. Like "Name_id" it needs
a "DESTROY" method and would need
"CLONE" for thread support.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="17%">
<p style="margin-top: 1em">"Name_id_reg"</p></td>
<td width="69%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Inside-out
implementation based on the id() function with explicit
object registry. No destructor is needed and objects are
thread safe.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="22%">
<p style="margin-top: 1em">"Name_idhash_reg"</p></td>
<td width="64%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Idhash-based
inside-out implementation with explicit object registry. No
destructor is needed and objects are thread safe.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="21%">
<p style="margin-top: 1em">"Name_fieldhash"</p></td>
<td width="65%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">FieldHash-based
inside-out implementation. Object registry happens
automatically. No destructor is needed and objects are
thread safe.</p>
<p style="margin-left:9%; margin-top: 1em">These examples
are realized in the code below, which could be copied to a
file <i>Example.pm</i>.</p>
<h3>Example 1
<a name="Example 1"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use strict; use
warnings; <br/>
{ <br/>
package Name_hash; # standard implementation: the <br/>
# object is a hash <br/>
sub init { <br/>
my $obj = shift; <br/>
my ($first, $last) = @_; <br/>
# create an object if called as class method <br/>
$obj = bless {}, $obj unless ref $obj; <br/>
$obj−&gt;{ first} = $first; <br/>
$obj−&gt;{ last} = $last; <br/>
$obj; <br/>
} <br/>
sub first { shift()−&gt;{ first} } <br/>
sub last { shift()−&gt;{ last} } <br/>
sub name { <br/>
my $n = shift; <br/>
join ' ' =&gt; $n−&gt;first, $n−&gt;last; <br/>
} <br/>
} <br/>
{ <br/>
package Name_id; <br/>
use Hash::Util::FieldHash qw(id); <br/>
my (%first, %last); <br/>
sub init { <br/>
my $obj = shift; <br/>
my ($first, $last) = @_; <br/>
# create an object if called as class method <br/>
$obj = bless \ my $o, $obj unless ref $obj; <br/>
$first{ id $obj} = $first; <br/>
$last{ id $obj} = $last; <br/>
$obj; <br/>
} <br/>
sub first { $first{ id shift()} } <br/>
sub last { $last{ id shift()} } <br/>
sub name { <br/>
my $n = shift; <br/>
join ' ' =&gt; $n−&gt;first, $n−&gt;last; <br/>
} <br/>
sub DESTROY { <br/>
my $id = id shift; <br/>
delete $first{ $id}; <br/>
delete $last{ $id}; <br/>
} <br/>
} <br/>
{ <br/>
package Name_idhash; <br/>
use Hash::Util::FieldHash; <br/>
Hash::Util::FieldHash::idhashes( \ my (%first, %last) );
<br/>
sub init { <br/>
my $obj = shift; <br/>
my ($first, $last) = @_; <br/>
# create an object if called as class method <br/>
$obj = bless \ my $o, $obj unless ref $obj; <br/>
$first{ $obj} = $first; <br/>
$last{ $obj} = $last; <br/>
$obj; <br/>
} <br/>
sub first { $first{ shift()} } <br/>
sub last { $last{ shift()} } <br/>
sub name { <br/>
my $n = shift; <br/>
join ' ' =&gt; $n−&gt;first, $n−&gt;last; <br/>
} <br/>
sub DESTROY { <br/>
my $n = shift; <br/>
delete $first{ $n}; <br/>
delete $last{ $n}; <br/>
} <br/>
} <br/>
{ <br/>
package Name_id_reg; <br/>
use Hash::Util::FieldHash qw(id register); <br/>
my (%first, %last); <br/>
sub init { <br/>
my $obj = shift; <br/>
my ($first, $last) = @_; <br/>
# create an object if called as class method <br/>
$obj = bless \ my $o, $obj unless ref $obj; <br/>
register( $obj, \ (%first, %last) ); <br/>
$first{ id $obj} = $first; <br/>
$last{ id $obj} = $last; <br/>
$obj; <br/>
} <br/>
sub first { $first{ id shift()} } <br/>
sub last { $last{ id shift()} } <br/>
sub name { <br/>
my $n = shift; <br/>
join ' ' =&gt; $n−&gt;first, $n−&gt;last; <br/>
} <br/>
} <br/>
{ <br/>
package Name_idhash_reg; <br/>
use Hash::Util::FieldHash qw(register); <br/>
Hash::Util::FieldHash::idhashes \ my (%first, %last); <br/>
sub init { <br/>
my $obj = shift; <br/>
my ($first, $last) = @_; <br/>
# create an object if called as class method <br/>
$obj = bless \ my $o, $obj unless ref $obj; <br/>
register( $obj, \ (%first, %last) ); <br/>
$first{ $obj} = $first; <br/>
$last{ $obj} = $last; <br/>
$obj; <br/>
} <br/>
sub first { $first{ shift()} } <br/>
sub last { $last{ shift()} } <br/>
sub name { <br/>
my $n = shift; <br/>
join ' ' =&gt; $n−&gt;first, $n−&gt;last; <br/>
} <br/>
} <br/>
{ <br/>
package Name_fieldhash; <br/>
use Hash::Util::FieldHash; <br/>
Hash::Util::FieldHash::fieldhashes \ my (%first, %last);
<br/>
sub init { <br/>
my $obj = shift; <br/>
my ($first, $last) = @_; <br/>
# create an object if called as class method <br/>
$obj = bless \ my $o, $obj unless ref $obj; <br/>
$first{ $obj} = $first; <br/>
$last{ $obj} = $last; <br/>
$obj; <br/>
} <br/>
sub first { $first{ shift()} } <br/>
sub last { $last{ shift()} } <br/>
sub name { <br/>
my $n = shift; <br/>
join ' ' =&gt; $n−&gt;first, $n−&gt;last; <br/>
} <br/>
} <br/>
1;</p>
<p style="margin-left:9%; margin-top: 1em">To exercise the
various implementations the script below can be used.</p>
<p style="margin-left:9%; margin-top: 1em">It sets up a
class "Name" that is a mirror of one of the
implementation classes "Name_hash",
"Name_id", ..., "Name_fieldhash". That
determines which implementation is run.</p>
<p style="margin-left:9%; margin-top: 1em">The script first
verifies the function of the "Name" class.</p>
<p style="margin-left:9%; margin-top: 1em">In the second
step, the free inheritability of the implementation (or lack
thereof) is demonstrated. For this purpose it constructs a
class called "NamedFile" which is a common
subclass of "Name" and the standard class
"IO::File". This puts inheritability to the test
because objects of "IO::File" <i>must</i> be
globrefs. Objects of "NamedFile" should behave
like a file opened for reading and also support the name()
method. This class juncture works with exception of the
"Name_hash" implementation, where object
initialization fails because of the incompatibility of
object bodies.</p>
<h3>Example 2
<a name="Example 2"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use strict; use
warnings; $| = 1; <br/>
use Example; <br/>
{ <br/>
package Name; <br/>
use parent 'Name_id'; # define here which implementation to
run <br/>
} <br/>
# Verify that the base package works <br/>
my $n = Name−&gt;init(qw(Albert Einstein)); <br/>
print $n−&gt;name, "\n"; <br/>
print "\n"; <br/>
# Create a named file handle (See definition below) <br/>
my $nf = NamedFile−&gt;init(qw(/tmp/x Filomena File));
<br/>
# use as a file handle... <br/>
for ( 1 .. 3 ) { <br/>
my $l = &lt;$nf&gt;; <br/>
print "line $_: $l"; <br/>
} <br/>
# ...and as a Name object <br/>
print "...brought to you by ", $nf−&gt;name,
"\n"; <br/>
exit; <br/>
# Definition of NamedFile <br/>
package NamedFile; <br/>
use parent 'Name'; <br/>
use parent 'IO::File'; <br/>
sub init { <br/>
my $obj = shift; <br/>
my ($file, $first, $last) = @_; <br/>
$obj = $obj−&gt;IO::File::new() unless ref $obj; <br/>
$obj−&gt;open($file) or die "Can't read '$file':
$!"; <br/>
$obj−&gt;Name::init($first, $last); <br/>
} <br/>
__END__</p>
<h2>GUTS
<a name="GUTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To make
"Hash::Util::FieldHash" work, there were two
changes to <i>perl</i> itself. "PERL_MAGIC_uvar"
was made available for hashes, and weak references now call
uvar "get" magic after a weakref has been cleared.
The first feature is used to make field hashes intercept
their keys upon access. The second one triggers garbage
collection.</p>
<h3>The "PERL_MAGIC_uvar" interface for hashes
<a name='The "PERL_MAGIC_uvar" interface for hashes'></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"PERL_MAGIC_uvar"
<i>get</i> magic is called from "hv_fetch_common"
and "hv_delete_common" through the function
"hv_magic_uvar_xkey", which defines the interface.
The call happens for hashes with "uvar" magic if
the "ufuncs" structure has equal values in the
"uf_val" and "uf_set" fields. Hashes are
unaffected if (and as long as) these fields hold different
values.</p>
<p style="margin-left:9%; margin-top: 1em">Upon the call,
the "mg_obj" field will hold the hash key to be
accessed. Upon return, the "SV*" value in
"mg_obj" will be used in place of the original key
in the hash access. The integer index value in the first
parameter will be the "action" value from
"hv_fetch_common", or −1 if the call is from
"hv_delete_common".</p>
<p style="margin-left:9%; margin-top: 1em">This is a
template for a function suitable for the "uf_val"
field in a "ufuncs" structure for this call. The
"uf_set" and "uf_index" fields are
irrelevant.</p>
<p style="margin-left:9%; margin-top: 1em">IV
watch_key(pTHX_ IV action, SV* field) { <br/>
MAGIC* mg = mg_find(field, PERL_MAGIC_uvar); <br/>
SV* keysv = mg−&gt;mg_obj; <br/>
/* Do whatever you need to. If you decide to <br/>
supply a different key newkey, return it like this <br/>
*/ <br/>
sv_2mortal(newkey); <br/>
mg−&gt;mg_obj = newkey; <br/>
return 0; <br/>
}</p>
<h3>Weakrefs call uvar magic
<a name="Weakrefs call uvar magic"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When a weak
reference is stored in an "SV" that has
"uvar" magic, "set" magic is called
after the reference has gone stale. This hook can be used to
trigger further garbage-collection activities associated
with the referenced object.</p>
<h3>How field hashes work
<a name="How field hashes work"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The three
features of key hashes, <i>key replacement</i>, <i>thread
support</i>, and <i>garbage collection</i> are supported by
a data structure called the <i>object registry</i>. This is
a private hash where every object is stored. An
"object" in this sense is any reference (blessed
or unblessed) that has been used as a field hash key.</p>
<p style="margin-left:9%; margin-top: 1em">The object
registry keeps track of references that have been used as
field hash keys. The keys are generated from the reference
address like in a field hash (though the registry
isn’t a field hash). Each value is a weak copy of the
original reference, stored in an "SV" that is
itself magical ("PERL_MAGIC_uvar" again). The
magical structure holds a list (another hash, really) of
field hashes that the reference has been used with. When the
weakref becomes stale, the magic is activated and uses the
list to delete the reference from all field hashes it has
been used with. After that, the entry is removed from the
object registry itself. Implicitly, that frees the magic
structure and the storage it has been using.</p>
<p style="margin-left:9%; margin-top: 1em">Whenever a
reference is used as a field hash key, the object registry
is checked and a new entry is made if necessary. The field
hash is then added to the list of fields this reference has
used.</p>
<p style="margin-left:9%; margin-top: 1em">The object
registry is also used to repair a field hash after thread
cloning. Here, the entire object registry is processed. For
every reference found there, the field hashes it has used
are visited and the entry is updated.</p>
<h3>Internal function Hash::Util::FieldHash::_fieldhash
<a name="Internal function Hash::Util::FieldHash::_fieldhash"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"># test if %hash
is a field hash <br/>
my $result = _fieldhash \ %hash, 0; <br/>
# make %hash a field hash <br/>
my $result = _fieldhash \ %hash, 1;</p>
<p style="margin-left:9%; margin-top: 1em">"_fieldhash"
is the internal function used to create field hashes. It
takes two arguments, a hashref and a mode. If the mode is
boolean false, the hash is not changed but tested if it is a
field hash. If the hash isn’t a field hash the return
value is boolean false. If it is, the return value indicates
the mode of field hash. When called with a boolean true
mode, it turns the given hash into a field hash of this
mode, returning the mode of the created field hash.
"_fieldhash" does not erase the given hash.</p>
<p style="margin-left:9%; margin-top: 1em">Currently there
is only one type of field hash, and only the boolean value
of the mode makes a difference, but that may change.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Anno Siegel
(ANNO) wrote the xs code and the changes in perl proper
Jerry Hedden (JDHEDDEN) made it faster</p>
<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright (C)
2006−2007 by (Anno Siegel)</p>
<p style="margin-left:9%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself, either Perl version
5.8.7 or, at your option, any later version of Perl 5 you
may have available.</p>
<hr/>
</body>
</html>
