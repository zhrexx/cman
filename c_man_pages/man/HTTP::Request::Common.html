<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:47:13 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>HTTP::Request::Common</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">HTTP::Request::Common</h1>
<a href="#NAME">NAME</a><br/>
<a href="#VERSION">VERSION</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">HTTP::Request::Common
− Construct common HTTP::Request objects</p>
<h2>VERSION
<a name="VERSION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">version 6.46</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use
HTTP::Request::Common; <br/>
$ua = LWP::UserAgent−&gt;new; <br/>
$ua−&gt;request(GET 'http://www.sn.no/'); <br/>
$ua−&gt;request(POST 'http://somewhere/foo', foo =&gt;
bar, bar =&gt; foo); <br/>
$ua−&gt;request(PATCH 'http://somewhere/foo', foo
=&gt; bar, bar =&gt; foo); <br/>
$ua−&gt;request(PUT 'http://somewhere/foo', foo =&gt;
bar, bar =&gt; foo); <br/>
$ua−&gt;request(OPTIONS 'http://somewhere/foo', foo
=&gt; bar, bar =&gt; foo);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module
provides functions that return newly created
"HTTP::Request" objects. These functions are
usually more convenient to use than the standard
"HTTP::Request" constructor for the most common
requests.</p>
<p style="margin-left:9%; margin-top: 1em">Note that
LWP::UserAgent has several convenience methods, including
"get", "head", "delete",
"post" and "put".</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions are provided: <br/>
GET $url <br/>
GET $url, Header =&gt; Value,...</p>
<p style="margin-left:14%;">The "GET" function
returns an HTTP::Request object initialized with the
"GET" method and the specified URL. It is roughly
equivalent to the following call</p>
<p style="margin-left:14%; margin-top: 1em">HTTP::Request−&gt;new(
<br/>
GET =&gt; $url, <br/>
HTTP::Headers−&gt;new(Header =&gt; Value,...), <br/>
)</p>
<p style="margin-left:14%; margin-top: 1em">but is less
cluttered. What is different is that a header named
"Content" will initialize the content part of the
request instead of setting a header field. Note that GET
requests should normally not have a content, so this hack
makes more sense for the "PUT", "PATCH"
<br/>
and "POST" functions described below.</p>
<p style="margin-left:14%; margin-top: 1em">The get(...)
method of LWP::UserAgent exists as a shortcut for
"$ua−&gt;request(GET ...)".</p>
<p style="margin-left:9%;">HEAD $url <br/>
HEAD $url, Header =&gt; Value,...</p>
<p style="margin-left:14%;">Like <b>GET()</b> but the
method in the request is "HEAD".</p>
<p style="margin-left:14%; margin-top: 1em">The head(...)
method of LWP::UserAgent exists as a shortcut for
"$ua−&gt;request(HEAD ...)".</p>
<p style="margin-left:9%;">DELETE $url <br/>
DELETE $url, Header =&gt; Value,...</p>
<p style="margin-left:14%;">Like "GET" but the
method in the request is "DELETE". This function
is not exported by default.</p>
<p style="margin-left:9%;">PATCH $url <br/>
PATCH $url, Header =&gt; Value,... <br/>
PATCH $url, $form_ref, Header =&gt; Value,... <br/>
PATCH $url, Header =&gt; Value,..., Content =&gt; $form_ref
<br/>
PATCH $url, Header =&gt; Value,..., Content =&gt;
$content</p>
<p style="margin-left:14%;">The same as "POST"
below, but the method in the request is
"PATCH".</p>
<p style="margin-left:9%;">PUT $url <br/>
PUT $url, Header =&gt; Value,... <br/>
PUT $url, $form_ref, Header =&gt; Value,... <br/>
PUT $url, Header =&gt; Value,..., Content =&gt; $form_ref
<br/>
PUT $url, Header =&gt; Value,..., Content =&gt; $content</p>
<p style="margin-left:14%;">The same as "POST"
below, but the method in the request is "PUT"</p>
<p style="margin-left:9%;">OPTIONS $url <br/>
OPTIONS $url, Header =&gt; Value,... <br/>
OPTIONS $url, $form_ref, Header =&gt; Value,... <br/>
OPTIONS $url, Header =&gt; Value,..., Content =&gt;
$form_ref <br/>
OPTIONS $url, Header =&gt; Value,..., Content =&gt;
$content</p>
<p style="margin-left:14%;">The same as "POST"
below, but the method in the request is
"OPTIONS"</p>
<p style="margin-left:14%; margin-top: 1em">This was added
in version 6.21, so you should require that in your
code:</p>
<p style="margin-left:14%; margin-top: 1em">use
HTTP::Request::Common 6.21;</p>
<p style="margin-left:9%;">POST $url <br/>
POST $url, Header =&gt; Value,... <br/>
POST $url, $form_ref, Header =&gt; Value,... <br/>
POST $url, Header =&gt; Value,..., Content =&gt; $form_ref
<br/>
POST $url, Header =&gt; Value,..., Content =&gt;
$content</p>
<p style="margin-left:14%;">"POST",
"PATCH" and "PUT" all work with the same
parameters.</p>
<p style="margin-left:14%; margin-top: 1em">%data = ( title
=&gt; 'something', body =&gt; something else' ); <br/>
$ua = LWP::UserAgent−&gt;new(); <br/>
$request = HTTP::Request::Common::POST( $url, [ %data ] );
<br/>
$response = $ua−&gt;request($request);</p>
<p style="margin-left:14%; margin-top: 1em">They take a
second optional array or hash reference parameter $form_ref.
The content can also be specified directly using the
"Content" pseudo−header, and you may also
provide the $form_ref this way.</p>
<p style="margin-left:14%; margin-top: 1em">The
"Content" pseudo−header steals a bit of the
header field namespace as there is no way to directly
specify a header that is actually called
"Content". If you really need this you must update
the request returned in a separate statement.</p>
<p style="margin-left:14%; margin-top: 1em">The $form_ref
argument can be used to pass key/value pairs for the form
content. By default we will initialize a request using the
"application/x−www−form−urlencoded"
content type. This means that you can emulate an HTML
&lt;form&gt; POSTing like this:</p>
<p style="margin-left:14%; margin-top: 1em">POST
'http://www.perl.org/survey.cgi', <br/>
[ name =&gt; 'Gisle Aas', <br/>
email =&gt; 'gisle@aas.no', <br/>
gender =&gt; 'M', <br/>
born =&gt; '1964', <br/>
perc =&gt; '3%', <br/>
];</p>
<p style="margin-left:14%; margin-top: 1em">This will
create an HTTP::Request object that looks like this:</p>
<p style="margin-left:14%; margin-top: 1em">POST
http://www.perl.org/survey.cgi <br/>
Content−Length: 66 <br/>
Content−Type:
application/x−www−form−urlencoded <br/>

name=Gisle%20Aas&amp;email=gisle%40aas.no&amp;gender=M&amp;born=1964&amp;perc=3%25</p>
<p style="margin-left:14%; margin-top: 1em">Multivalued
form fields can be specified by either repeating the field
name or by passing the value as an array reference.</p>
<p style="margin-left:14%; margin-top: 1em">The POST method
also supports the "multipart/form−data"
content used for <i>Form−based File Upload</i> as
specified in RFC 1867. You trigger this content format by
specifying a content type of 'form−data' as one of the
request headers. If one of the values in the $form_ref is an
array reference, then it is treated as a file part
specification with the following interpretation:</p>
<p style="margin-left:14%; margin-top: 1em">[ $file,
$filename, Header =&gt; Value... ] <br/>
[ undef, $filename, Header =&gt; Value,..., Content =&gt;
$content ]</p>
<p style="margin-left:14%; margin-top: 1em">The first value
in the array ($file) is the name of a file to open. This
file will be read and its content placed in the request. The
routine will croak if the file can't be opened. Use an
"undef" as $file value if you want to specify the
content directly with a "Content" header. The
$filename is the filename to report in the request. If this
value is undefined, then the basename of the $file will be
used. You can specify an empty string as $filename if you
want to suppress sending the filename when you provide a
$file value.</p>
<p style="margin-left:14%; margin-top: 1em">If a $file is
provided by no "Content−Type" header, then
"Content−Type" and
"Content−Encoding" will be filled in
automatically with the values returned by
LWP::MediaTypes::guess_media_type()</p>
<p style="margin-left:14%; margin-top: 1em">Sending my
<i>˜/.profile</i> to the survey used as example above
can be achieved by this:</p>
<p style="margin-left:14%; margin-top: 1em">POST
'http://www.perl.org/survey.cgi', <br/>
Content_Type =&gt; 'form−data', <br/>
Content =&gt; [ name =&gt; 'Gisle Aas', <br/>
email =&gt; 'gisle@aas.no', <br/>
gender =&gt; 'M', <br/>
born =&gt; '1964', <br/>
init =&gt; ["$ENV{HOME}/.profile"], <br/>
]</p>
<p style="margin-left:14%; margin-top: 1em">This will
create an HTTP::Request object that almost looks this (the
boundary and the content of your <i>˜/.profile</i> is
likely to be different):</p>
<p style="margin-left:14%; margin-top: 1em">POST
http://www.perl.org/survey.cgi <br/>
Content−Length: 388 <br/>
Content−Type: multipart/form−data;
boundary="6G+f" <br/>
−−6G+f <br/>
Content−Disposition: form−data;
name="name" <br/>
Gisle Aas <br/>
−−6G+f <br/>
Content−Disposition: form−data;
name="email" <br/>
gisle@aas.no <br/>
−−6G+f <br/>
Content−Disposition: form−data;
name="gender" <br/>
M <br/>
−−6G+f <br/>
Content−Disposition: form−data;
name="born" <br/>
1964 <br/>
−−6G+f <br/>
Content−Disposition: form−data;
name="init"; filename=".profile" <br/>
Content−Type: text/plain <br/>
PATH=/local/perl/bin:$PATH <br/>
export PATH <br/>
−−6G+f−−</p>
<p style="margin-left:14%; margin-top: 1em">If you set the
$DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
value, then you get back a request object with a subroutine
closure as the content attribute. This subroutine will read
the content of any files on demand and return it in suitable
chunks. This allow you to upload arbitrary big files without
using lots of memory. You can even upload infinite files
like <i>/dev/audio</i> if you wish; however, if the file is
not a plain file, there will be no
"Content−Length" header defined for the
request. Not all servers (or server applications) like this.
Also, if the file(s) change in size between the time the
"Content−Length" is calculated and the time
that the last chunk is delivered, the subroutine will
"Croak".</p>
<p style="margin-left:14%; margin-top: 1em">The post(...)
method of LWP::UserAgent exists as a shortcut for
"$ua−&gt;request(POST ...)".</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">HTTP::Request,
LWP::UserAgent</p>
<p style="margin-left:9%; margin-top: 1em">Also, there are
some examples in "EXAMPLES" in HTTP::Request that
you might find useful. For example, batch requests are
explained there.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Gisle Aas
&lt;gisle@activestate.com&gt;</p>
<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This software is
copyright (c) 1994 by Gisle Aas.</p>
<p style="margin-left:9%; margin-top: 1em">This is free
software; you can redistribute it and/or modify it under the
same terms as the Perl 5 programming language system
itself.</p>
<hr/>
</body>
</html>
