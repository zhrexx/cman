<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:48:55 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OSSL_CMP_EXEC_CERTREQ</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">OSSL_CMP_EXEC_CERTREQ</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">OSSL_CMP_exec_certreq,
OSSL_CMP_exec_IR_ses, OSSL_CMP_exec_CR_ses,
OSSL_CMP_exec_P10CR_ses, OSSL_CMP_exec_KUR_ses, OSSL_CMP_IR,
OSSL_CMP_CR, OSSL_CMP_P10CR, OSSL_CMP_KUR,
OSSL_CMP_try_certreq, OSSL_CMP_exec_RR_ses,
OSSL_CMP_exec_GENM_ses, OSSL_CMP_get1_caCerts,
OSSL_CMP_get1_rootCaKeyUpdate − functions implementing
CMP client transactions</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/cmp.h&gt; <br/>
X509 *OSSL_CMP_exec_certreq(OSSL_CMP_CTX *ctx, int req_type,
<br/>
const OSSL_CRMF_MSG *crm); <br/>
X509 *OSSL_CMP_exec_IR_ses(OSSL_CMP_CTX *ctx); <br/>
X509 *OSSL_CMP_exec_CR_ses(OSSL_CMP_CTX *ctx); <br/>
X509 *OSSL_CMP_exec_P10CR_ses(OSSL_CMP_CTX *ctx); <br/>
X509 *OSSL_CMP_exec_KUR_ses(OSSL_CMP_CTX *ctx); <br/>
#define OSSL_CMP_IR <br/>
#define OSSL_CMP_CR <br/>
#define OSSL_CMP_P10CR <br/>
#define OSSL_CMP_KUR <br/>
int OSSL_CMP_try_certreq(OSSL_CMP_CTX *ctx, int req_type,
<br/>
const OSSL_CRMF_MSG *crm, int *checkAfter); <br/>
int OSSL_CMP_exec_RR_ses(OSSL_CMP_CTX *ctx); <br/>
STACK_OF(OSSL_CMP_ITAV) *OSSL_CMP_exec_GENM_ses(OSSL_CMP_CTX
*ctx); <br/>
int OSSL_CMP_get1_caCerts(OSSL_CMP_CTX *ctx, STACK_OF(X509)
**out); <br/>
int OSSL_CMP_get1_rootCaKeyUpdate(OSSL_CMP_CTX *ctx, <br/>
const X509 *oldWithOld, X509 **newWithNew, <br/>
X509 **newWithOld, X509 **oldWithNew);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This is the
OpenSSL API for doing CMP (Certificate Management Protocol)
client−server transactions, i.e., sequences of CMP
requests and responses.</p>
<p style="margin-left:9%; margin-top: 1em">All functions
take a populated OSSL_CMP_CTX structure as their first
argument. Usually the server name, port, and path ("CMP
alias") need to be set, as well as credentials the
client can use for authenticating itself to the server. In
order to authenticate the server the client typically needs
a trust store. The functions return their respective main
results directly, while there are also accessor functions
for retrieving various results and status information from
the <i>ctx</i>. See <b>OSSL_CMP_CTX_new</b>(3) etc. for
details.</p>
<p style="margin-left:9%; margin-top: 1em">The default
conveying protocol is HTTP. Timeout values may be given per
request−response pair and per transaction. See
<b>OSSL_CMP_MSG_http_perform</b>(3) for details.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_IR_ses()</b>
requests an initial certificate from the given PKI.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_CR_ses()</b>
requests an additional certificate.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_P10CR_ses()</b>
conveys a legacy PKCS#10 CSR requesting a certificate.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_KUR_ses()</b>
obtains an updated certificate.</p>
<p style="margin-left:9%; margin-top: 1em">These four types
of certificate enrollment are implemented as macros calling
<b>OSSL_CMP_exec_certreq()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_certreq()</b>
performs a certificate request of the type specified by the
<i>req_type</i> parameter, which may be IR, CR, P10CR, or
KUR. For IR, CR, and KUR, the certificate template to be
used in the request may be supplied via the <i>crm</i>
parameter pointing to a CRMF structure. Typically <i>crm</i>
is NULL, then the template ingredients are taken from
<i>ctx</i> and need to be filled in using
<b>OSSL_CMP_CTX_set1_subjectName</b>(3),
<b>OSSL_CMP_CTX_set0_newPkey</b>(3),
<b>OSSL_CMP_CTX_set1_oldCert</b>(3), etc. For P10CR,
<b>OSSL_CMP_CTX_set1_p10CSR</b>(3) needs to be used instead.
The enrollment session may be blocked by sleeping until the
addressed CA (or an intermediate PKI component) can fully
process and answer the request.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_try_certreq()</b>
is an alternative to the above functions that is more
flexible regarding what to do after receiving a checkAfter
value. When called for the first time (with no certificate
request in progress for the given <i>ctx</i>) it starts a
new transaction by sending a certificate request constructed
as stated above using the <i>req_type</i> and optional
<i>crm</i> parameter. Otherwise (when according to
<i>ctx</i> a 'waiting' status has been received before) it
continues polling for the pending request unless the
<i>req_type</i> argument is &lt; 0, which aborts the
request. If the requested certificate is available the
function returns 1 and the caller can use
<b>OSSL_CMP_CTX_get0_newCert</b>(3) to retrieve the new
certificate. If no error occurred but no certificate is
available yet then <b>OSSL_CMP_try_certreq()</b> remembers
in the CMP context that it should be retried and returns
−1 after assigning the received checkAfter value via
the output pointer argument (unless it is NULL). The
checkAfter value indicates the number of seconds the caller
should let pass before trying again. The caller is free to
sleep for the given number of seconds or for some other time
and/or to do anything else before retrying by calling
<b>OSSL_CMP_try_certreq()</b> again with the same parameter
values as before. <b>OSSL_CMP_try_certreq()</b> then polls
to see whether meanwhile the requested certificate is
available. If the caller decides to abort the pending
certificate request and provides a negative value as the
<i>req_type</i> argument then <b>OSSL_CMP_try_certreq()</b>
aborts the CMP transaction by sending an error message to
the server.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_RR_ses()</b>
requests the revocation of the certificate specified in the
<i>ctx</i> using the issuer DN and serial number set by
<b>OSSL_CMP_CTX_set1_issuer</b>(3) and
<b>OSSL_CMP_CTX_set1_serialNumber</b>(3), respectively,
otherwise the issuer DN and serial number of the certificate
set by <b>OSSL_CMP_CTX_set1_oldCert</b>(3), otherwise the
subject DN and public key of the certificate signing request
set by <b>OSSL_CMP_CTX_set1_p10CSR</b>(3). RFC 4210 is vague
in which PKIStatus should be returned by the server. We take
"accepted" and "grantedWithMods" as
clear success and handle "revocationWarning" and
"revocationNotification" just as warnings because
CAs typically return them as an indication that the
certificate was already revoked. "rejection" is a
clear error. The values "waiting" and
"keyUpdateWarning" make no sense for revocation
and thus are treated as an error as well.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_GENM_ses()</b>
sends a genm general message containing the sequence of
infoType and infoValue pairs (InfoTypeAndValue; short:
<b>ITAV</b>) optionally provided in the <i>ctx</i> using
<b>OSSL_CMP_CTX_push0_genm_ITAV</b>(3). On success it
records in <i>ctx</i> the status
<b>OSSL_CMP_PKISTATUS_accepted</b> and returns the list of
<b>ITAV</b>s received in a genp response message. This can
be used, for instance, with infoType
"signKeyPairTypes" to obtain the set of signature
algorithm identifiers that the CA will certify for subject
public keys. See RFC 4210 section 5.3.19 and appendix E.5
for details. Functions implementing more specific genm/genp
exchanges are described next.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_get1_caCerts()</b>
uses a genm/genp message exchange with infoType caCerts to
obtain a list of CA certificates from the CMP server
referenced by <i>ctx</i>. On success it assigns to
<i>*out</i> the list of certificates received, which must be
freed by the caller. NULL output means that no CA
certificates were provided by the server.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_get1_rootCaKeyUpdate()</b>
uses a genm request message with infoType rootCaCert to
obtain from the CMP server referenced by <i>ctx</i> in a
genp response message with infoType rootCaKeyUpdate any
update of the given root CA certificate <i>oldWithOld</i>
and verifies it as far as possible. See RFC 4210 section 4.4
for details. On success it assigns to <i>*newWithNew</i> the
root certificate received. When the <i>newWithOld</i> and
<i>oldWithNew</i> output parameters are not NULL, it assigns
to them the corresponding transition certificates. NULL
means that the respective certificate was not provided by
the server. All certificates obtained this way must be freed
by the caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>WARNING:</b>
The <i>newWithNew</i> certificate is meant to be a
certificate that will be trusted. The trust placed in it
cannot be stronger than the trust placed in the
<i>oldwithold</i> certificate if present, otherwise it
cannot be stronger than the weakest trust in any of the
certificates in the trust store of <i>ctx</i>.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">CMP is defined
in RFC 4210 (and CRMF in RFC 4211).</p>
<p style="margin-left:9%; margin-top: 1em">The CMP client
implementation is limited to one request per CMP message
(and consequently to at most one response component per CMP
message).</p>
<p style="margin-left:9%; margin-top: 1em">When a client
obtains from a CMP server CA certificates that it is going
to trust, for instance via the caPubs field of a certificate
response or using functions like
<b>OSSL_CMP_get1_caCerts()</b> and
<b>OSSL_CMP_get1_rootCaKeyUpdate()</b>, authentication of
the CMP server is particularly critical. So special care
must be taken setting up server authentication in <i>ctx</i>
using functions such as <b>OSSL_CMP_CTX_set0_trusted</b>(3)
(for certificate−based authentication) or
<b>OSSL_CMP_CTX_set1_secretValue</b>(3) (for MAC−based
protection). If authentication is certificate−based,
<b>OSSL_CMP_CTX_get0_validatedSrvCert</b>(3) should be used
to obtain the server validated certificate and perform an
authorization check based on it.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_certreq()</b>,
<b>OSSL_CMP_exec_IR_ses()</b>,
<b>OSSL_CMP_exec_CR_ses()</b>,
<b>OSSL_CMP_exec_P10CR_ses()</b>, and
<b>OSSL_CMP_exec_KUR_ses()</b> return a pointer to the newly
obtained X509 certificate on success, NULL on error. This
pointer will be freed implicitly by
<b>OSSL_CMP_CTX_free()</b> or
<b>CSSL_CMP_CTX_reinit()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_try_certreq()</b>
returns 1 if the requested certificate is available via
<b>OSSL_CMP_CTX_get0_newCert</b>(3) or on successfully
aborting a pending certificate request, 0 on error, and
−1 in case a 'waiting' status has been received and
checkAfter value is available. In the latter case
<b>OSSL_CMP_CTX_get0_newCert</b>(3) yields NULL and the
output parameter <i>checkAfter</i> has been used to assign
the received value unless <i>checkAfter</i> is NULL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_RR_ses()</b>,
<b>OSSL_CMP_get1_caCerts()</b>, and
<b>OSSL_CMP_get1_rootCaKeyUpdate()</b> return 1 on success,
0 on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_exec_GENM_ses()</b>
returns NULL on error, otherwise a pointer to the sequence
of <b>ITAV</b> received, which may be empty. This pointer
must be freed by the caller.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See OSSL_CMP_CTX
for examples on how to prepare the context for these
functions.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_CTX_new</b>(3),
<b>OSSL_CMP_CTX_free</b>(3),
<b>OSSL_CMP_CTX_set1_subjectName</b>(3),
<b>OSSL_CMP_CTX_set0_newPkey</b>(3),
<b>OSSL_CMP_CTX_set1_p10CSR</b>(3),
<b>OSSL_CMP_CTX_set1_oldCert</b>(3),
<b>OSSL_CMP_CTX_get0_newCert</b>(3),
<b>OSSL_CMP_CTX_push0_genm_ITAV</b>(3),
<b>OSSL_CMP_MSG_http_perform</b>(3)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The OpenSSL CMP
support was added in OpenSSL 3.0.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_CMP_get1_caCerts()</b>
and <b>OSSL_CMP_get1_rootCaKeyUpdate()</b> were added in
OpenSSL 3.2.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2007−2023 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
