<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:49:18 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OSSL_HTTP_REQ_CTX</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">OSSL_HTTP_REQ_CTX</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#WARNINGS">WARNINGS</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">OSSL_HTTP_REQ_CTX,
OSSL_HTTP_REQ_CTX_new, OSSL_HTTP_REQ_CTX_free,
OSSL_HTTP_REQ_CTX_set_request_line,
OSSL_HTTP_REQ_CTX_add1_header,
OSSL_HTTP_REQ_CTX_set_expected, OSSL_HTTP_REQ_CTX_set1_req,
OSSL_HTTP_REQ_CTX_nbio, OSSL_HTTP_REQ_CTX_nbio_d2i,
OSSL_HTTP_REQ_CTX_exchange, OSSL_HTTP_REQ_CTX_get0_mem_bio,
OSSL_HTTP_REQ_CTX_get_resp_len,
OSSL_HTTP_REQ_CTX_set_max_response_length,
OSSL_HTTP_is_alive − HTTP client low−level
functions</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/http.h&gt; <br/>
typedef struct ossl_http_req_ctx_st OSSL_HTTP_REQ_CTX; <br/>
OSSL_HTTP_REQ_CTX *OSSL_HTTP_REQ_CTX_new(BIO *wbio, BIO
*rbio, int buf_size); <br/>
void OSSL_HTTP_REQ_CTX_free(OSSL_HTTP_REQ_CTX *rctx); <br/>
int OSSL_HTTP_REQ_CTX_set_request_line(OSSL_HTTP_REQ_CTX
*rctx, int method_POST, <br/>
const char *server, const char *port, <br/>
const char *path); <br/>
int OSSL_HTTP_REQ_CTX_add1_header(OSSL_HTTP_REQ_CTX *rctx,
<br/>
const char *name, const char *value); <br/>
int OSSL_HTTP_REQ_CTX_set_expected(OSSL_HTTP_REQ_CTX *rctx,
<br/>
const char *content_type, int asn1, <br/>
int timeout, int keep_alive); <br/>
int OSSL_HTTP_REQ_CTX_set1_req(OSSL_HTTP_REQ_CTX *rctx,
const char *content_type, <br/>
const ASN1_ITEM *it, const ASN1_VALUE *req); <br/>
int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx); <br/>
int OSSL_HTTP_REQ_CTX_nbio_d2i(OSSL_HTTP_REQ_CTX *rctx, <br/>
ASN1_VALUE **pval, const ASN1_ITEM *it); <br/>
BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx);
<br/>
BIO *OSSL_HTTP_REQ_CTX_get0_mem_bio(const OSSL_HTTP_REQ_CTX
*rctx); <br/>
size_t OSSL_HTTP_REQ_CTX_get_resp_len(const
OSSL_HTTP_REQ_CTX *rctx); <br/>
void
OSSL_HTTP_REQ_CTX_set_max_response_length(OSSL_HTTP_REQ_CTX
*rctx, <br/>
unsigned long len); <br/>
int OSSL_HTTP_is_alive(const OSSL_HTTP_REQ_CTX *rctx);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX</b>
is a context structure for an HTTP request and response,
used to collect all the necessary data to perform that
request.</p>
<p style="margin-left:9%; margin-top: 1em">This file
documents low−level HTTP functions rarely used
directly. High−level HTTP client functions like
<b>OSSL_HTTP_get</b>(3) and <b>OSSL_HTTP_transfer</b>(3)
should be preferred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_new()</b>
allocates a new HTTP request context structure, which gets
populated with the <b>BIO</b> to write/send the request to
(<i>wbio</i>), the <b>BIO</b> to read/receive the response
from (<i>rbio</i>, which may be equal to <i>wbio</i>), and
the maximum expected response header line length
<i>buf_size</i>. A value &lt;= 0 indicates that the
<b>OSSL_HTTP_DEFAULT_MAX_LINE_LEN</b> of 4KiB should be
used. <i>buf_size</i> is also used as the number of content
bytes that are read at a time. The allocated context
structure includes an internal memory <b>BIO</b>, which
collects the HTTP request header lines.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_free()</b>
frees up the HTTP request context <i>rctx</i>. The
<i>rbio</i> is not free'd, <i>wbio</i> will be free'd if
<i>free_wbio</i> is set. If the argument is NULL, nothing is
done.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_set_request_line()</b>
adds the 1st HTTP request line to <i>rctx</i>. The HTTP
method is determined by <i>method_POST</i>, which should be
1 to indicate "POST" or 0 to indicate
"GET". <i>server</i> and <i>port</i> may be set to
give the server and the optional port that an HTTP proxy
shall forward the request to, otherwise they must be left
NULL. <i>path</i> provides the HTTP request path; if left
NULL, "/" is used. For backward compatibility,
<i>path</i> may begin with "http://" and thus
convey an absoluteURI. In this case it indicates HTTP proxy
use and provides also the server (and optionally the port)
that the proxy shall forward the request to. In this case
the <i>server</i> and <i>port</i> arguments must be
NULL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_add1_header()</b>
adds header <i>name</i> with value <i>value</i> to the
context <i>rctx</i>. It can be called more than once to add
multiple header lines. For example, to add a
"Host" header for "example.com" you
would call:</p>
<p style="margin-left:9%; margin-top: 1em">OSSL_HTTP_REQ_CTX_add1_header(ctx,
"Host", "example.com");</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_set_expected()</b>
optionally sets in <i>rctx</i> some expectations of the HTTP
client on the response. Due to the structure of an HTTP
request, if the <i>keep_alive</i> argument is nonzero the
function must be used before calling
<b>OSSL_HTTP_REQ_CTX_set1_req()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">If the
<i>content_type</i> argument is not NULL, the client will
check that the specified content−type string is
included in the HTTP header of the response and return an
error if not. In the content−type header line the
specified string should be present either as a whole, or in
case the specified string does not include a ";"
character, it is sufficient that the specified string
appears as a prefix in the header line, followed by a
";" character and any further text. For instance,
if the <i>content_type</i> argument specifies
"text/html", this is matched by
"text/html", "text/html;
charset=UTF−8", etc.</p>
<p style="margin-left:9%; margin-top: 1em">If the
<i>asn1</i> parameter is nonzero a structure in ASN.1
encoding will be expected as the response content and input
streaming is disabled. This means that an ASN.1 sequence
header is required, its length field is checked, and
<b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> should be used to
get the buffered response. Otherwise (by default) any input
format is allowed without length checks. In this case the
BIO given as <i>rbio</i> argument to
<b>OSSL_HTTP_REQ_CTX_new()</b> should be used directly to
read the response contents, which may support streaming. If
the <i>timeout</i> parameter is &gt; 0 this indicates the
maximum number of seconds the subsequent HTTP transfer
(sending the request and receiving a response) is allowed to
take. <i>timeout</i> == 0 enables waiting indefinitely,
i.e., no timeout can occur. This is the default.
<i>timeout</i> &lt; 0 takes over any value set via the
<i>overall_timeout</i> argument of <b>OSSL_HTTP_open</b>(3)
with the default being 0, which means no timeout. If the
<i>keep_alive</i> parameter is 0, which is the default, the
connection is not kept open after receiving a response. This
is the default behavior for HTTP 1.0. If the value is 1 or 2
then a persistent connection is requested. If the value is 2
then a persistent connection is required, i.e., an error
occurs in case the server does not grant it.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_set1_req()</b>
finalizes the HTTP request context. It is needed if the
<i>method_POST</i> parameter in the
<b>OSSL_HTTP_REQ_CTX_set_request_line()</b> call was 1 and
an ASN.1−encoded request should be sent. It must also
be used when requesting "keep−alive", even
if a GET request is going to be sent, in which case
<i>req</i> must be NULL. Unless <i>req</i> is NULL, the
function adds the DER encoding of <i>req</i> using the ASN.1
template <i>it</i> to do the encoding (which does not
support streaming). The HTTP header
"Content−Length" is filled out with the
length of the request. <i>content_type</i> must be NULL if
<i>req</i> is NULL. If <i>content_type</i> isn't NULL, the
HTTP header "Content−Type" is also added
with the given string value. The header lines are added to
the internal memory <b>BIO</b> for the request header.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_nbio()</b>
attempts to send the request prepared in <i>rctx</i> and to
gather the response via HTTP, using the <i>wbio</i> and
<i>rbio</i> that were given when calling
<b>OSSL_HTTP_REQ_CTX_new()</b>. The function may need to be
called again if its result is −1, which indicates
<b>BIO_should_retry</b>(3). In such a case it is advisable
to sleep a little in between, using <b>BIO_wait</b>(3) on
the read BIO to prevent a busy loop.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_nbio_d2i()</b>
is like <b>OSSL_HTTP_REQ_CTX_nbio()</b> but on success in
addition parses the response, which must be a
DER−encoded ASN.1 structure, using the ASN.1 template
<i>it</i> and places the result in <i>*pval</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_exchange()</b>
calls <b>OSSL_HTTP_REQ_CTX_nbio()</b> as often as needed in
order to exchange a request and response or until a timeout
is reached. On success it returns a pointer to the BIO that
can be used to read the result. If an ASN.1−encoded
response was expected, this is the BIO returned by
<b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> when called after
the exchange. This memory BIO does not support streaming.
Otherwise the returned BIO is the <i>rbio</i> given to
<b>OSSL_HTTP_REQ_CTX_new()</b>, which may support streaming.
When this BIO is returned, it has been read past the end of
the response header, such that the actual response body can
be read from it. The returned BIO pointer MUST NOT be freed
by the caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b>
returns the internal memory <b>BIO</b>. Before the HTTP
request is sent, this could be used to adapt its header
lines. <i>Use with caution!</i> After receiving a response
via HTTP, the BIO represents the current state of reading
the response header. If the response was expected to be
ASN.1 encoded, its contents can be read via this BIO, which
does not support streaming. The returned BIO pointer must
not be freed by the caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_get_resp_len()</b>
returns the size of the response contents in <i>rctx</i> if
provided by the server as &lt;Content−Length&gt;
header field, else 0.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_set_max_response_length()</b>
sets the maximum allowed response content length for
<i>rctx</i> to <i>len</i>. If not set or <i>len</i> is 0
then the <b>OSSL_HTTP_DEFAULT_MAX_RESP_LEN</b> is used,
which currently is 100 KiB. If the
"Content−Length" header is present and
exceeds this value or the content is an ASN.1 encoded
structure with a length exceeding this value or both length
indications are present but disagree then an error
occurs.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_is_alive()</b>
can be used to query if the HTTP connection given by
<i>rctx</i> is still alive, i.e., has not been closed. It
returns 0 if <i>rctx</i> is NULL.</p>
<p style="margin-left:9%; margin-top: 1em">If the client
application requested or required a persistent connection
and this was granted by the server, it can keep <i>rctx</i>
as long as it wants to send further requests and
<b>OSSL_HTTP_is_alive()</b> returns nonzero, else it should
call <i>OSSL_HTTP_REQ_CTX_free(rctx)</i> or
<b>OSSL_HTTP_close</b>(3). In case the client application
keeps <i>rctx</i> but the connection then dies for any
reason at the server side, it will notice this obtaining an
I/O error when trying to send the next request via
<i>rctx</i>.</p>
<h2>WARNINGS
<a name="WARNINGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The server's
response may be unexpected if the hostname that was used to
create the <i>wbio</i>, any "Host" header, and the
host specified in the request URL do not match.</p>
<p style="margin-left:9%; margin-top: 1em">Many of these
functions must be called in a certain order.</p>
<p style="margin-left:9%; margin-top: 1em">First, the HTTP
request context must be allocated:
<b>OSSL_HTTP_REQ_CTX_new()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Then, the HTTP
request must be prepared with request data:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="2%"></td>
<td width="85%">
<p>Calling <b>OSSL_HTTP_REQ_CTX_set_request_line()</b>.</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="85%">
<p>Adding extra header lines with
<b>OSSL_HTTP_REQ_CTX_add1_header()</b>. This is optional and
may be done multiple times with different names.</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>3.</p></td>
<td width="2%"></td>
<td width="85%">
<p>Finalize the request using
<b>OSSL_HTTP_REQ_CTX_set1_req()</b>. This may be omitted if
the GET method is used and "keep−alive" is
not requested.</p></td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">When the request
context is fully prepared, the HTTP exchange may be
performed with <b>OSSL_HTTP_REQ_CTX_nbio()</b> or
<b>OSSL_HTTP_REQ_CTX_exchange()</b>.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">When built with
tracing enabled, <b>OSSL_HTTP_REQ_CTX_nbio()</b> and all
functions using it, such as
<b>OSSL_HTTP_REQ_CTX_exchange()</b> and
<b>OSSL_HTTP_transfer</b>(3), may be traced using
<b>OSSL_TRACE_CATEGORY_HTTP</b>. See also
<b>OSSL_trace_enabled</b>(3) and
<b>openssl−env</b>(7).</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_new()</b>
returns a pointer to a <b>OSSL_HTTP_REQ_CTX</b>, or NULL on
error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_free()</b>
and <b>OSSL_HTTP_REQ_CTX_set_max_response_length()</b> do
not return values.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_set_request_line()</b>,
<b>OSSL_HTTP_REQ_CTX_add1_header()</b>,
<b>OSSL_HTTP_REQ_CTX_set1_req()</b>, and
<b>OSSL_HTTP_REQ_CTX_set_expected()</b> return 1 for success
and 0 for failure.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_nbio()</b>
and <b>OSSL_HTTP_REQ_CTX_nbio_d2i()</b> return 1 for
success, 0 on error or redirection, −1 if retry is
needed.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_exchange()</b>
and <b>OSSL_HTTP_REQ_CTX_get0_mem_bio()</b> return a pointer
to a <b>BIO</b> on success as described above or NULL on
failure. The returned BIO must not be freed by the
caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_REQ_CTX_get_resp_len()</b>
returns the size of the response contents or 0 if not
available or an error occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HTTP_is_alive()</b>
returns 1 if its argument is non−NULL and the client
requested a persistent connection and the server did not
disagree on keeping the connection open, else 0.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>BIO_should_retry</b>(3),
<b>BIO_wait</b>(3), <b>ASN1_item_d2i_bio</b>(3),
<b>ASN1_item_i2d_mem_bio</b>(3), <b>OSSL_HTTP_open</b>(3),
<b>OSSL_HTTP_get</b>(3), <b>OSSL_HTTP_transfer</b>(3),
<b>OSSL_HTTP_close</b>(3), <b>OSSL_trace_enabled</b>(3), and
<b>openssl−env</b>(7).</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The functions
described here were added in OpenSSL 3.0.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2015−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
