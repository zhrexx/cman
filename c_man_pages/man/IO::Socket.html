<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:45:41 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>IO::Socket</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">IO::Socket</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#CONSTRUCTOR ARGUMENTS">CONSTRUCTOR ARGUMENTS</a><br/>
<a href="#Blocking">Blocking</a><br/>
<a href="#Domain">Domain</a><br/>
<a href="#Listen">Listen</a><br/>
<a href="#Timeout">Timeout</a><br/>
<a href="#Type">Type</a><br/>
<a href="#CONSTRUCTORS">CONSTRUCTORS</a><br/>
<a href="#new">new</a><br/>
<a href="#METHODS">METHODS</a><br/>
<a href="#accept">accept</a><br/>
<a href="#atmark">atmark</a><br/>
<a href="#autoflush">autoflush</a><br/>
<a href="#bind">bind</a><br/>
<a href="#connected">connected</a><br/>
<a href="#getsockopt">getsockopt</a><br/>
<a href="#listen">listen</a><br/>
<a href="#peername">peername</a><br/>
<a href="#protocol">protocol</a><br/>
<a href="#recv">recv</a><br/>
<a href="#send">send</a><br/>
<a href="#setsockopt">setsockopt</a><br/>
<a href="#shutdown">shutdown</a><br/>
<a href="#sockdomain">sockdomain</a><br/>
<a href="#socket">socket</a><br/>
<a href="#socketpair">socketpair</a><br/>
<a href="#sockname">sockname</a><br/>
<a href="#sockopt">sockopt</a><br/>
<a href="#socktype">socktype</a><br/>
<a href="#timeout">timeout</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#LIMITATIONS">LIMITATIONS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">IO::Socket
− Object interface to socket communications</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use IO::Socket qw(AF_INET AF_UNIX); <br/>
# create a new AF_INET socket <br/>
my $sock = IO::Socket−&gt;new(Domain =&gt; AF_INET);
<br/>
# which is the same as <br/>
$sock = IO::Socket::INET−&gt;new(); <br/>
# create a new AF_UNIX socket <br/>
$sock = IO::Socket−&gt;new(Domain =&gt; AF_UNIX); <br/>
# which is the same as <br/>
$sock = IO::Socket::UNIX−&gt;new();</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">"IO::Socket"
provides an object-oriented, IO::Handle−based
interface to creating and using sockets via Socket, which
provides a near one-to-one interface to the C socket
library.</p>
<p style="margin-left:9%; margin-top: 1em">"IO::Socket"
is a base class that really only defines methods for those
operations which are common to all types of sockets.
Operations which are specific to a particular socket domain
have methods defined in subclasses of
"IO::Socket". See IO::Socket::INET,
IO::Socket::UNIX, and IO::Socket::IP for examples of such a
subclass.</p>
<p style="margin-left:9%; margin-top: 1em">"IO::Socket"
will export all functions (and constants) defined by
Socket.</p>
<h2>CONSTRUCTOR ARGUMENTS
<a name="CONSTRUCTOR ARGUMENTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Given that
"IO::Socket" doesn’t have attributes in the
traditional sense, the following arguments, rather than
attributes, can be passed into the constructor.</p>
<p style="margin-left:9%; margin-top: 1em">Constructor
arguments should be passed in "Key =&gt; 'Value'"
pairs.</p>
<p style="margin-left:9%; margin-top: 1em">The only
required argument is "Domain" in IO::Socket.</p>
<h3>Blocking
<a name="Blocking"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(..., Blocking =&gt; 1); <br/>
$sock = IO::Socket−&gt;new(..., Blocking =&gt; 0);</p>
<p style="margin-left:9%; margin-top: 1em">If defined but
false, the socket will be set to non-blocking mode. If not
specified it defaults to 1 (blocking mode).</p>
<h3>Domain
<a name="Domain"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(Domain =&gt; IO::Socket::AF_INET);
<br/>
$sock = IO::Socket−&gt;new(Domain =&gt;
IO::Socket::AF_UNIX);</p>
<p style="margin-left:9%; margin-top: 1em">The socket
domain will define which subclass of "IO::Socket"
to use. The two options available along with this
distribution are "AF_INET" and
"AF_UNIX".</p>
<p style="margin-left:9%; margin-top: 1em">"AF_INET"
is for the internet address family of sockets and is handled
via IO::Socket::INET. "AF_INET" sockets are bound
to an internet address and port.</p>
<p style="margin-left:9%; margin-top: 1em">"AF_UNIX"
is for the unix domain socket and is handled via
IO::Socket::UNIX. "AF_UNIX" sockets are bound to
the file system as their address name space.</p>
<p style="margin-left:9%; margin-top: 1em">This argument is
<b>required</b>. All other arguments are optional.</p>
<h3>Listen
<a name="Listen"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(..., Listen =&gt; 5);</p>
<p style="margin-left:9%; margin-top: 1em">Listen should be
an integer value or left unset.</p>
<p style="margin-left:9%; margin-top: 1em">If provided,
this argument will place the socket into listening mode. New
connections can then be accepted using the
"accept" in IO::Socket method. The value given is
used as the listen(2) queue size.</p>
<p style="margin-left:9%; margin-top: 1em">If the
"Listen" argument is given, but false, the queue
size will be set to 5.</p>
<h3>Timeout
<a name="Timeout"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(..., Timeout =&gt; 5);</p>
<p style="margin-left:9%; margin-top: 1em">The timeout
value, in seconds, for this socket connection. How exactly
this value is utilized is defined in the socket domain
subclasses that make use of the value.</p>
<h3>Type
<a name="Type"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(..., Type =&gt;
IO::Socket::SOCK_STREAM);</p>
<p style="margin-left:9%; margin-top: 1em">The socket type
that will be used. These are usually
"SOCK_STREAM", "SOCK_DGRAM", or
"SOCK_RAW". If this argument is left undefined an
attempt will be made to infer the type from the service
name.</p>
<p style="margin-left:9%; margin-top: 1em">For example,
you’ll usually use "SOCK_STREAM" with a
"tcp" connection and "SOCK_DGRAM" with a
"udp" connection.</p>
<h2>CONSTRUCTORS
<a name="CONSTRUCTORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">"IO::Socket"
extends the IO::Handle constructor.</p>
<h3>new
<a name="new"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(); <br/>
# get a new IO::Socket::INET instance <br/>
$sock = IO::Socket−&gt;new(Domain =&gt;
IO::Socket::AF_INET); <br/>
# get a new IO::Socket::UNIX instance <br/>
$sock = IO::Socket−&gt;new(Domain =&gt;
IO::Socket::AF_UNIX); <br/>
# Domain is the only required argument <br/>
$sock = IO::Socket−&gt;new( <br/>
Domain =&gt; IO::Socket::AF_INET, # AF_INET, AF_UNIX <br/>
Type =&gt; IO::Socket::SOCK_STREAM, # SOCK_STREAM,
SOCK_DGRAM, ... <br/>
Proto =&gt; 'tcp', # 'tcp', 'udp', IPPROTO_TCP, IPPROTO_UDP
<br/>
# and so on... <br/>
);</p>
<p style="margin-left:9%; margin-top: 1em">Creates an
"IO::Socket", which is a reference to a newly
created symbol (see the Symbol package). "new"
optionally takes arguments, these arguments are defined in
"CONSTRUCTOR ARGUMENTS" in IO::Socket.</p>
<p style="margin-left:9%; margin-top: 1em">Any of the
"CONSTRUCTOR ARGUMENTS" in IO::Socket may be
passed to the constructor, but if any arguments are
provided, then one of them must be the "Domain" in
IO::Socket argument. The "Domain" in IO::Socket
argument can, by default, be either "AF_INET" or
"AF_UNIX". Other domains can be used if a proper
subclass for the domain family is registered. All other
arguments will be passed to the "configuration"
method of the package for that domain.</p>
<p style="margin-left:9%; margin-top: 1em">If the
constructor fails it will return "undef" and set
the $errstr package variable to contain an error
message.</p>
<p style="margin-left:9%; margin-top: 1em">$sock =
IO::Socket−&gt;new(...) <br/>
or die "Cannot create socket −
$IO::Socket::errstr\n";</p>
<p style="margin-left:9%; margin-top: 1em">For legacy
reasons the error message is also set into the global $@
variable, and you may still find older code which looks here
instead.</p>
<p style="margin-left:9%; margin-top: 1em">$sock =
IO::Socket−&gt;new(...) <br/>
or die "Cannot create socket − $@\n";</p>
<h2>METHODS
<a name="METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">"IO::Socket"
inherits all methods from IO::Handle and implements the
following new ones.</p>
<h3>accept
<a name="accept"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $client_sock
= $sock−&gt;accept(); <br/>
my $inet_sock =
$sock−&gt;accept('IO::Socket::INET');</p>
<p style="margin-left:9%; margin-top: 1em">The accept
method will perform the system call "accept" on
the socket and return a new object. The new object will be
created in the same class as the listen socket, unless a
specific package name is specified. This object can be used
to communicate with the client that was trying to
connect.</p>
<p style="margin-left:9%; margin-top: 1em">This differs
slightly from the "accept" function in
perlfunc.</p>
<p style="margin-left:9%; margin-top: 1em">In a scalar
context the new socket is returned, or "undef"
upon failure. In a list context a two-element array is
returned containing the new socket and the peer address; the
list will be empty upon failure.</p>
<h3>atmark
<a name="atmark"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $integer =
$sock−&gt;atmark(); <br/>
# read in some data on a given socket <br/>
my $data; <br/>
$sock−&gt;read($data, 1024) until
$sock−&gt;atmark; <br/>
# or, export the function to use: <br/>
use IO::Socket 'sockatmark'; <br/>
$sock−&gt;read($data, 1024) until
sockatmark($sock);</p>
<p style="margin-left:9%; margin-top: 1em">True if the
socket is currently positioned at the urgent data mark,
false otherwise. If your system doesn’t yet implement
"sockatmark" this will throw an exception.</p>
<p style="margin-left:9%; margin-top: 1em">If your system
does not support "sockatmark", the "use"
declaration will fail at compile time.</p>
<h3>autoflush
<a name="autoflush"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"># by default,
autoflush will be turned on when referenced <br/>
$sock−&gt;autoflush(); # turns on autoflush <br/>
# turn off autoflush <br/>
$sock−&gt;autoflush(0); <br/>
# turn on autoflush <br/>
$sock−&gt;autoflush(1);</p>
<p style="margin-left:9%; margin-top: 1em">This attribute
isn’t overridden from IO::Handle’s
implementation. However, since we turn it on by default,
it’s worth mentioning here.</p>
<h3>bind
<a name="bind"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">use Socket
qw(pack_sockaddr_in); <br/>
my $port = 3000; <br/>
my $ip_address = '0.0.0.0'; <br/>
my $packed_addr = pack_sockaddr_in($port, $ip_address); <br/>
$sock−&gt;bind($packed_addr);</p>
<p style="margin-left:9%; margin-top: 1em">Binds a network
address to a socket, just as bind(2) does. Returns true if
it succeeded, false otherwise. You should provide a packed
address of the appropriate type for the socket.</p>
<h3>connected
<a name="connected"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $peer_addr =
$sock−&gt;connected(); <br/>
if ($peer_addr) { <br/>
say "We're connected to $peer_addr"; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">If the socket is
in a connected state, the peer address is returned. If the
socket is not in a connected state, "undef" is
returned.</p>
<p style="margin-left:9%; margin-top: 1em">Note that this
method considers a half-open TCP socket to be "in a
connected state". Specifically, it does not distinguish
between the <b>ESTABLISHED</b> and <b>CLOSE-WAIT</b> TCP
states; it returns the peer address, rather than
"undef", in either case. Thus, in general, it
cannot be used to reliably learn whether the peer has
initiated a graceful shutdown because in most cases (see
below) the local TCP state machine remains in
<b>CLOSE-WAIT</b> until the local application calls
"shutdown" in IO::Socket or "close".
Only at that point does this function return
"undef".</p>
<p style="margin-left:9%; margin-top: 1em">The "in
most cases" hedge is because local TCP state machine
behavior may depend on the peer’s socket options. In
particular, if the peer socket has "SO_LINGER"
enabled with a zero timeout, then the peer’s
"close" will generate a "RST" segment.
Upon receipt of that segment, the local TCP transitions
immediately to <b>CLOSED</b>, and in that state, this method
<i>will</i> return "undef".</p>
<h3>getsockopt
<a name="getsockopt"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $value =
$sock−&gt;getsockopt(SOL_SOCKET, SO_REUSEADDR); <br/>
my $buf = $socket−&gt;getsockopt(SOL_SOCKET,
SO_RCVBUF); <br/>
say "Receive buffer is $buf bytes";</p>
<p style="margin-left:9%; margin-top: 1em">Get an option
associated with the socket. Levels other than
"SOL_SOCKET" may be specified here. As a
convenience, this method will unpack a byte buffer of the
correct size back into a number.</p>
<h3>listen
<a name="listen"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$sock−&gt;listen(5);</p>
<p style="margin-left:9%; margin-top: 1em">Does the same
thing that the listen(2) system call does. Returns true if
it succeeded, false otherwise. Listens to a socket with a
given queue size.</p>
<h3>peername
<a name="peername"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sockaddr_in
= $sock−&gt;peername();</p>
<p style="margin-left:9%; margin-top: 1em">Returns the
packed "sockaddr" address of the other end of the
socket connection. It calls "getpeername".</p>
<h3>protocol
<a name="protocol"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $proto =
$sock−&gt;protocol();</p>
<p style="margin-left:9%; margin-top: 1em">Returns the
number for the protocol being used on the socket, if known.
If the protocol is unknown, as with an "AF_UNIX"
socket, zero is returned.</p>
<h3>recv
<a name="recv"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $buffer =
""; <br/>
my $length = 1024; <br/>
my $flags = 0; # default. optional <br/>
$sock−&gt;recv($buffer, $length); <br/>
$sock−&gt;recv($buffer, $length, $flags);</p>
<p style="margin-left:9%; margin-top: 1em">Similar in
functionality to "recv" in perlfunc.</p>
<p style="margin-left:9%; margin-top: 1em">Receives a
message on a socket. Attempts to receive $length characters
of data into $buffer from the specified socket. $buffer will
be grown or shrunk to the length actually read. Takes the
same flags as the system call of the same name. Returns the
address of the sender if socket’s protocol supports
this; returns an empty string otherwise. If there’s an
error, returns "undef". This call is actually
implemented in terms of the recvfrom(2) system call.</p>
<p style="margin-left:9%; margin-top: 1em">Flags are ORed
together values, such as "MSG_BCAST",
"MSG_OOB", "MSG_TRUNC". The default
value for the flags is 0.</p>
<p style="margin-left:9%; margin-top: 1em">The cached value
of "peername" in IO::Socket is updated with the
result of "recv".</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b> In
Perl v5.30 and newer, if the socket has been marked as
":utf8", "recv" will throw an exception.
The :encoding(...) layer implicitly introduces the
":utf8" layer. See "binmode" in
perlfunc.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b> In
Perl versions older than v5.30, depending on the status of
the socket, either (8−bit) bytes or characters are
received. By default all sockets operate on bytes, but for
example if the socket has been changed using
"binmode" in perlfunc to operate with the
:encoding(UTF−8) I/O layer (see the "open"
in perlfunc pragma), the I/O will operate on
UTF8−encoded Unicode characters, not bytes. Similarly
for the ":encoding" layer: in that case pretty
much any characters can be read.</p>
<h3>send
<a name="send"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $message =
"Hello, world!"; <br/>
my $flags = 0; # defaults to zero <br/>
my $to = '0.0.0.0'; # optional destination <br/>
my $sent = $sock−&gt;send($message); <br/>
$sent = $sock−&gt;send($message, $flags); <br/>
$sent = $sock−&gt;send($message, $flags, $to);</p>
<p style="margin-left:9%; margin-top: 1em">Similar in
functionality to "send" in perlfunc.</p>
<p style="margin-left:9%; margin-top: 1em">Sends a message
on a socket. Attempts to send the scalar message to the
socket. Takes the same flags as the system call of the same
name. On unconnected sockets, you must specify a destination
to send to, in which case it does a sendto(2) syscall.
Returns the number of characters sent, or "undef"
on error. The sendmsg(2) syscall is currently
unimplemented.</p>
<p style="margin-left:9%; margin-top: 1em">The
"flags" option is optional and defaults to 0.</p>
<p style="margin-left:9%; margin-top: 1em">After a
successful send with $to, further calls to "send"
on an unconnected socket without $to will send to the same
address, and $to will be used as the result of
"peername" in IO::Socket.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b> In
Perl v5.30 and newer, if the socket has been marked as
":utf8", "send" will throw an exception.
The :encoding(...) layer implicitly introduces the
":utf8" layer. See "binmode" in
perlfunc.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b> In
Perl versions older than v5.30, depending on the status of
the socket, either (8−bit) bytes or characters are
sent. By default all sockets operate on bytes, but for
example if the socket has been changed using
"binmode" in perlfunc to operate with the
:encoding(UTF−8) I/O layer (see the "open"
in perlfunc pragma), the I/O will operate on
UTF8−encoded Unicode characters, not bytes. Similarly
for the ":encoding" layer: in that case pretty
much any characters can be sent.</p>
<h3>setsockopt
<a name="setsockopt"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$sock−&gt;setsockopt(SOL_SOCKET,
SO_REUSEADDR, 1); <br/>
$sock−&gt;setsockopt(SOL_SOCKET, SO_RCVBUF,
64*1024);</p>
<p style="margin-left:9%; margin-top: 1em">Set option
associated with the socket. Levels other than
"SOL_SOCKET" may be specified here. As a
convenience, this method will convert a number into a packed
byte buffer.</p>
<h3>shutdown
<a name="shutdown"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$sock−&gt;shutdown(SHUT_RD);
# we stopped reading data <br/>
$sock−&gt;shutdown(SHUT_WR); # we stopped writing data
<br/>
$sock−&gt;shutdown(SHUT_RDWR); # we stopped using this
socket</p>
<p style="margin-left:9%; margin-top: 1em">Shuts down a
socket connection in the manner indicated by the value
passed in, which has the same interpretation as in the
syscall of the same name.</p>
<p style="margin-left:9%; margin-top: 1em">This is useful
with sockets when you want to tell the other side
you’re done writing but not done reading, or vice
versa. It’s also a more insistent form of
"close" because it also disables the file
descriptor in any forked copies in other processes.</p>
<p style="margin-left:9%; margin-top: 1em">Returns 1 for
success; on error, returns "undef" if the socket
is not a valid filehandle, or returns 0 and sets $! for any
other failure.</p>
<h3>sockdomain
<a name="sockdomain"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $domain =
$sock−&gt;sockdomain();</p>
<p style="margin-left:9%; margin-top: 1em">Returns the
number for the socket domain type. For example, for an
"AF_INET" socket the value of &amp;AF_INET will be
returned.</p>
<h3>socket
<a name="socket"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $sock =
IO::Socket−&gt;new(); # no values given <br/>
# now let's actually get a socket with the socket method
<br/>
# domain, type, and protocol are required <br/>
$sock = $sock−&gt;socket(AF_INET, SOCK_STREAM,
'tcp');</p>
<p style="margin-left:9%; margin-top: 1em">Opens a socket
of the specified kind and returns it. Domain, type, and
protocol are specified the same as for the syscall of the
same name.</p>
<h3>socketpair
<a name="socketpair"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my ($r, $w) =
$sock−&gt;socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
<br/>
($r, $w) = IO::Socket::UNIX <br/>
−&gt;socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);</p>
<p style="margin-left:9%; margin-top: 1em">Will return a
list of two sockets created (read and write), or an empty
list on failure.</p>
<p style="margin-left:9%; margin-top: 1em">Differs slightly
from "socketpair" in perlfunc in that the argument
list is a bit simpler.</p>
<h3>sockname
<a name="sockname"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $packed_addr
= $sock−&gt;sockname();</p>
<p style="margin-left:9%; margin-top: 1em">Returns the
packed "sockaddr" address of this end of the
connection. It’s the same as getsockname(2).</p>
<h3>sockopt
<a name="sockopt"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $value =
$sock−&gt;sockopt(SO_REUSEADDR); <br/>
$sock−&gt;sockopt(SO_REUSEADDR, 1);</p>
<p style="margin-left:9%; margin-top: 1em">Unified method
to both set and get options in the "SOL_SOCKET"
level. If called with one argument then
"getsockopt" in IO::Socket is called, otherwise
"setsockopt" in IO::Socket is called.</p>
<h3>socktype
<a name="socktype"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $type =
$sock−&gt;socktype();</p>
<p style="margin-left:9%; margin-top: 1em">Returns the
number for the socket type. For example, for a
"SOCK_STREAM" socket the value of &amp;SOCK_STREAM
will be returned.</p>
<h3>timeout
<a name="timeout"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $seconds =
$sock−&gt;timeout(); <br/>
my $old_val = $sock−&gt;timeout(5); # set new and
return old value</p>
<p style="margin-left:9%; margin-top: 1em">Set or get the
timeout value (in seconds) associated with this socket. If
called without any arguments then the current setting is
returned. If called with an argument the current setting is
changed and the previous value returned.</p>
<p style="margin-left:9%; margin-top: 1em">This method is
available to all "IO::Socket" implementations but
may or may not be used by the individual domain
subclasses.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Let’s
create a TCP server on "localhost:3333".</p>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use feature 'say'; <br/>
use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR); <br/>
my $server = IO::Socket−&gt;new( <br/>
Domain =&gt; AF_INET, <br/>
Type =&gt; SOCK_STREAM, <br/>
Proto =&gt; 'tcp', <br/>
LocalHost =&gt; '0.0.0.0', <br/>
LocalPort =&gt; 3333, <br/>
ReusePort =&gt; 1, <br/>
Listen =&gt; 5, <br/>
) || die "Can't open socket: $IO::Socket::errstr";
<br/>
say "Waiting on 3333"; <br/>
while (1) { <br/>
# waiting for a new client connection <br/>
my $client = $server−&gt;accept(); <br/>
# get information about a newly connected client <br/>
my $client_address = $client−&gt;peerhost(); <br/>
my $client_port = $client−&gt;peerport(); <br/>
say "Connection from
$client_address:$client_port"; <br/>
# read up to 1024 characters from the connected client <br/>
my $data = ""; <br/>
$client−&gt;recv($data, 1024); <br/>
say "received data: $data"; <br/>
# write response data to the connected client <br/>
$data = "ok"; <br/>
$client−&gt;send($data); <br/>
# notify client that response has been sent <br/>
$client−&gt;shutdown(SHUT_WR); <br/>
} <br/>
$server−&gt;close();</p>
<p style="margin-left:9%; margin-top: 1em">A client for
such a server could be</p>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use feature 'say'; <br/>
use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR); <br/>
my $client = IO::Socket−&gt;new( <br/>
Domain =&gt; AF_INET, <br/>
Type =&gt; SOCK_STREAM, <br/>
proto =&gt; 'tcp', <br/>
PeerPort =&gt; 3333, <br/>
PeerHost =&gt; '0.0.0.0', <br/>
) || die "Can't open socket: $IO::Socket::errstr";
<br/>
say "Sending Hello World!"; <br/>
my $size = $client−&gt;send("Hello World!");
<br/>
say "Sent data of length: $size"; <br/>
$client−&gt;shutdown(SHUT_WR); <br/>
my $buffer; <br/>
$client−&gt;recv($buffer, 1024); <br/>
say "Got back $buffer"; <br/>
$client−&gt;close();</p>
<h2>LIMITATIONS
<a name="LIMITATIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On some systems,
for an IO::Socket object created with
"new_from_fd", or created with "accept"
in IO::Socket from such an object, the "protocol"
in IO::Socket, "sockdomain" in IO::Socket and
"socktype" in IO::Socket methods may return
"undef".</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Socket,
IO::Handle, IO::Socket::INET, IO::Socket::UNIX,
IO::Socket::IP</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Graham Barr.
<b>atmark()</b> by Lincoln Stein. Currently maintained by
the Perl 5 Porters. Please report all bugs at
&lt;https://github.com/Perl/perl5/issues&gt;.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright (c)
1997−8 Graham Barr &lt;gbarr@pobox.com&gt;. All rights
reserved. This program is free software; you can
redistribute it and/or modify it under the same terms as
Perl itself.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>atmark()</b> implementation: Copyright 2001, Lincoln
Stein &lt;lstein@cshl.org&gt;. This module is distributed
under the same terms as Perl itself. Feel free to use,
modify and redistribute it as long as you retain the correct
attribution.</p>
<hr/>
</body>
</html>
