<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:52:21 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Normalize</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Normalize</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Normalization Forms">Normalization Forms</a><br/>
<a href="#Decomposition and Composition">Decomposition and Composition</a><br/>
<a href="#Quick Check">Quick Check</a><br/>
<a href="#Character Data">Character Data</a><br/>
<a href="#EXPORT">EXPORT</a><br/>
<a href="#CAVEATS">CAVEATS</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#LICENSE">LICENSE</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Unicode::Normalize
− Unicode Normalization Forms</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">(1) using
function names exported by default:</p>
<p style="margin-left:9%; margin-top: 1em">use
Unicode::Normalize; <br/>
$NFD_string = NFD($string); # Normalization Form D <br/>
$NFC_string = NFC($string); # Normalization Form C <br/>
$NFKD_string = NFKD($string); # Normalization Form KD <br/>
$NFKC_string = NFKC($string); # Normalization Form KC</p>
<p style="margin-left:9%; margin-top: 1em">(2) using
function names exported on request:</p>
<p style="margin-left:9%; margin-top: 1em">use
Unicode::Normalize 'normalize'; <br/>
$NFD_string = normalize('D', $string); # Normalization Form
D <br/>
$NFC_string = normalize('C', $string); # Normalization Form
C <br/>
$NFKD_string = normalize('KD', $string); # Normalization
Form KD <br/>
$NFKC_string = normalize('KC', $string); # Normalization
Form KC</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Parameters:</p>
<p style="margin-left:9%; margin-top: 1em">$string is used
as a string under character semantics (see perlunicode).</p>
<p style="margin-left:9%; margin-top: 1em">$code_point
should be an unsigned integer representing a Unicode code
point.</p>
<p style="margin-left:9%; margin-top: 1em">Note: Between
XSUB and pure Perl, there is an incompatibility about the
interpretation of $code_point as a decimal number. XSUB
converts $code_point to an unsigned integer, but pure Perl
does not. Do not use a floating point nor a negative sign in
$code_point.</p>
<h3>Normalization Forms
<a name="Normalization Forms"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"$NFD_string
= NFD($string)"</p>
<p style="margin-left:14%;">It returns the Normalization
Form D (formed by canonical decomposition).</p>
<p style="margin-left:9%;">"$NFC_string =
NFC($string)"</p>
<p style="margin-left:14%;">It returns the Normalization
Form C (formed by canonical decomposition followed by
canonical composition).</p>
<p style="margin-left:9%;">"$NFKD_string =
NFKD($string)"</p>
<p style="margin-left:14%;">It returns the Normalization
Form KD (formed by compatibility decomposition).</p>
<p style="margin-left:9%;">"$NFKC_string =
NFKC($string)"</p>
<p style="margin-left:14%;">It returns the Normalization
Form KC (formed by compatibility decomposition followed by
<b>canonical</b> composition).</p>
<p style="margin-left:9%;">"$FCD_string =
FCD($string)"</p>
<p style="margin-left:14%;">If the given string is in FCD
("Fast C or D" form; cf. UTN #5), it returns the
string without modification; otherwise it returns an FCD
string.</p>
<p style="margin-left:14%; margin-top: 1em">Note: FCD is
not always unique, then plural forms may be equivalent each
other. FCD() will return one of these equivalent forms.</p>
<p style="margin-left:9%;">"$FCC_string =
FCC($string)"</p>
<p style="margin-left:14%;">It returns the FCC form
("Fast C Contiguous"; cf. UTN #5).</p>
<p style="margin-left:14%; margin-top: 1em">Note: FCC is
unique, as well as four normalization forms (NF*).</p>
<p style="margin-left:9%;">"$normalized_string =
normalize($form_name, $string)"</p>
<p style="margin-left:14%;">It returns the normalization
form of $form_name.</p>
<p style="margin-left:14%; margin-top: 1em">As $form_name,
one of the following names must be given.</p>
<p style="margin-left:14%; margin-top: 1em">'C' or 'NFC'
for Normalization Form C (UAX #15) <br/>
'D' or 'NFD' for Normalization Form D (UAX #15) <br/>
'KC' or 'NFKC' for Normalization Form KC (UAX #15) <br/>
'KD' or 'NFKD' for Normalization Form KD (UAX #15) <br/>
'FCD' for "Fast C or D" Form (UTN #5) <br/>
'FCC' for "Fast C Contiguous" (UTN #5)</p>
<h3>Decomposition and Composition
<a name="Decomposition and Composition"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"$decomposed_string
= decompose($string [, $useCompatMapping])"</p>
<p style="margin-left:14%;">It returns the concatenation of
the decomposition of each character in the string.</p>
<p style="margin-left:14%; margin-top: 1em">If the second
parameter (a boolean) is omitted or false, the decomposition
is canonical decomposition; if the second parameter (a
boolean) is true, the decomposition is compatibility
decomposition.</p>
<p style="margin-left:14%; margin-top: 1em">The string
returned is not always in NFD/NFKD. Reordering may be
required.</p>
<p style="margin-left:14%; margin-top: 1em">$NFD_string =
reorder(decompose($string)); # eq. to NFD() <br/>
$NFKD_string = reorder(decompose($string, TRUE)); # eq. to
NFKD()</p>
<p style="margin-left:9%;">"$reordered_string =
reorder($string)"</p>
<p style="margin-left:14%;">It returns the result of
reordering the combining characters according to Canonical
Ordering Behavior.</p>
<p style="margin-left:14%; margin-top: 1em">For example,
when you have a list of NFD/NFKD strings, you can get the
concatenated NFD/NFKD string from them, by saying</p>
<p style="margin-left:14%; margin-top: 1em">$concat_NFD =
reorder(join '', @NFD_strings); <br/>
$concat_NFKD = reorder(join '', @NFKD_strings);</p>
<p style="margin-left:9%;">"$composed_string =
compose($string)"</p>
<p style="margin-left:14%;">It returns the result of
canonical composition without applying any
decomposition.</p>
<p style="margin-left:14%; margin-top: 1em">For example,
when you have a NFD/NFKD string, you can get its NFC/NFKC
string, by saying</p>
<p style="margin-left:14%; margin-top: 1em">$NFC_string =
compose($NFD_string); <br/>
$NFKC_string = compose($NFKD_string);</p>
<p style="margin-left:9%;">"($processed, $unprocessed)
= splitOnLastStarter($normalized)"</p>
<p style="margin-left:14%;">It returns two strings: the
first one, $processed, is a part before the last starter,
and the second one, $unprocessed is another part after the
first part. A starter is a character having a combining
class of zero (see UAX #15).</p>
<p style="margin-left:14%; margin-top: 1em">Note that
$processed may be empty (when $normalized contains no
starter or starts with the last starter), and then
$unprocessed should be equal to the entire $normalized.</p>
<p style="margin-left:14%; margin-top: 1em">When you have a
$normalized string and an $unnormalized string following it,
a simple concatenation is wrong:</p>
<p style="margin-left:14%; margin-top: 1em">$concat =
$normalized . normalize($form, $unnormalized); # wrong!</p>
<p style="margin-left:14%; margin-top: 1em">Instead of it,
do like this:</p>
<p style="margin-left:14%; margin-top: 1em">($processed,
$unprocessed) = splitOnLastStarter($normalized); <br/>
$concat = $processed .
normalize($form,$unprocessed.$unnormalized);</p>
<p style="margin-left:14%; margin-top: 1em">splitOnLastStarter()
should be called with a pre−normalized parameter
$normalized, that is in the same form as $form you want.</p>
<p style="margin-left:14%; margin-top: 1em">If you have an
array of @string that should be concatenated and then
normalized, you can do like this:</p>
<p style="margin-left:14%; margin-top: 1em">my $result =
""; <br/>
my $unproc = ""; <br/>
foreach my $str (@string) { <br/>
$unproc .= $str; <br/>
my $n = normalize($form, $unproc); <br/>
my($p, $u) = splitOnLastStarter($n); <br/>
$result .= $p; <br/>
$unproc = $u; <br/>
} <br/>
$result .= $unproc; <br/>
# instead of normalize($form, join('', @string))</p>
<p style="margin-left:9%;">"$processed =
normalize_partial($form, $unprocessed)"</p>
<p style="margin-left:14%;">A wrapper for the combination
of normalize() and splitOnLastStarter(). Note that
$unprocessed will be modified as a side−effect.</p>
<p style="margin-left:14%; margin-top: 1em">If you have an
array of @string that should be concatenated and then
normalized, you can do like this:</p>
<p style="margin-left:14%; margin-top: 1em">my $result =
""; <br/>
my $unproc = ""; <br/>
foreach my $str (@string) { <br/>
$unproc .= $str; <br/>
$result .= normalize_partial($form, $unproc); <br/>
} <br/>
$result .= $unproc; <br/>
# instead of normalize($form, join('', @string))</p>
<p style="margin-left:9%;">"$processed =
NFD_partial($unprocessed)"</p>
<p style="margin-left:14%;">It does like
"normalize_partial('NFD', $unprocessed)". Note
that $unprocessed will be modified as a
side−effect.</p>
<p style="margin-left:9%;">"$processed =
NFC_partial($unprocessed)"</p>
<p style="margin-left:14%;">It does like
"normalize_partial('NFC', $unprocessed)". Note
that $unprocessed will be modified as a
side−effect.</p>
<p style="margin-left:9%;">"$processed =
NFKD_partial($unprocessed)"</p>
<p style="margin-left:14%;">It does like
"normalize_partial('NFKD', $unprocessed)". Note
that $unprocessed will be modified as a
side−effect.</p>
<p style="margin-left:9%;">"$processed =
NFKC_partial($unprocessed)"</p>
<p style="margin-left:14%;">It does like
"normalize_partial('NFKC', $unprocessed)". Note
that $unprocessed will be modified as a
side−effect.</p>
<h3>Quick Check
<a name="Quick Check"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">(see Annex 8,
UAX #15; and
<i>lib/unicore/DerivedNormalizationProps.txt</i>)</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions check whether the string is in that normalization
form.</p>
<p style="margin-left:9%; margin-top: 1em">The result
returned will be one of the following:</p>
<p style="margin-left:9%; margin-top: 1em">YES The string
is in that normalization form. <br/>
NO The string is not in that normalization form. <br/>
MAYBE Dubious. Maybe yes, maybe no. <br/>
"$result = checkNFD($string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO".</p>
<p style="margin-left:9%;">"$result =
checkNFC($string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO"; "undef" if "MAYBE".</p>
<p style="margin-left:9%;">"$result =
checkNFKD($string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO".</p>
<p style="margin-left:9%;">"$result =
checkNFKC($string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO"; "undef" if "MAYBE".</p>
<p style="margin-left:9%;">"$result =
checkFCD($string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO".</p>
<p style="margin-left:9%;">"$result =
checkFCC($string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO"; "undef" if "MAYBE".</p>
<p style="margin-left:14%; margin-top: 1em">Note: If a
string is not in FCD, it must not be in FCC. So
checkFCC($not_FCD_string) should return "NO".</p>
<p style="margin-left:9%;">"$result =
check($form_name, $string)"</p>
<p style="margin-left:14%;">It returns true (1) if
"YES"; false ("empty string") if
"NO"; "undef" if "MAYBE".</p>
<p style="margin-left:14%; margin-top: 1em">As $form_name,
one of the following names must be given.</p>
<p style="margin-left:14%; margin-top: 1em">'C' or 'NFC'
for Normalization Form C (UAX #15) <br/>
'D' or 'NFD' for Normalization Form D (UAX #15) <br/>
'KC' or 'NFKC' for Normalization Form KC (UAX #15) <br/>
'KD' or 'NFKD' for Normalization Form KD (UAX #15) <br/>
'FCD' for "Fast C or D" Form (UTN #5) <br/>
'FCC' for "Fast C Contiguous" (UTN #5)</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:9%; margin-top: 1em">In the cases of
NFD, NFKD, and FCD, the answer must be either
"YES" or "NO". The answer
"MAYBE" may be returned in the cases of NFC, NFKC,
and FCC.</p>
<p style="margin-left:9%; margin-top: 1em">A
"MAYBE" string should contain at least one
combining character or the like. For example,
"COMBINING ACUTE ACCENT" has the
MAYBE_NFC/MAYBE_NFKC property.</p>
<p style="margin-left:9%; margin-top: 1em">Both
"checkNFC("A\N{COMBINING ACUTE
ACCENT}")" and "checkNFC("B\N{COMBINING
ACUTE ACCENT}")" will return "MAYBE".
"A\N{COMBINING ACUTE ACCENT}" is not in NFC (its
NFC is "\N{LATIN CAPITAL LETTER A WITH ACUTE}"),
while "B\N{COMBINING ACUTE ACCENT}" is in NFC.</p>
<p style="margin-left:9%; margin-top: 1em">If you want to
check exactly, compare the string with its NFC/NFKC/FCC.</p>
<p style="margin-left:9%; margin-top: 1em">if ($string eq
NFC($string)) { <br/>
# $string is exactly normalized in NFC; <br/>
} else { <br/>
# $string is not normalized in NFC; <br/>
} <br/>
if ($string eq NFKC($string)) { <br/>
# $string is exactly normalized in NFKC; <br/>
} else { <br/>
# $string is not normalized in NFKC; <br/>
}</p>
<h3>Character Data
<a name="Character Data"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">These functions
are interface of character data used internally. If you want
only to get Unicode normalization forms, you don't need call
them yourself. <br/>
"$canonical_decomposition =
getCanon($code_point)"</p>
<p style="margin-left:14%;">If the character is canonically
decomposable (including Hangul Syllables), it returns the
(full) canonical decomposition as a string. Otherwise it
returns "undef".</p>
<p style="margin-left:14%; margin-top: 1em"><b>Note:</b>
According to the Unicode standard, the canonical
decomposition of the character that is not canonically
decomposable is same as the character itself.</p>
<p style="margin-left:9%;">"$compatibility_decomposition
= getCompat($code_point)"</p>
<p style="margin-left:14%;">If the character is
compatibility decomposable (including Hangul Syllables), it
returns the (full) compatibility decomposition as a string.
Otherwise it returns "undef".</p>
<p style="margin-left:14%; margin-top: 1em"><b>Note:</b>
According to the Unicode standard, the compatibility
decomposition of the character that is not compatibility
decomposable is same as the character itself.</p>
<p style="margin-left:9%;">"$code_point_composite =
getComposite($code_point_here, <br/>
$code_point_next)"</p>
<p style="margin-left:14%;">If two characters here and next
(as code points) are composable (including Hangul
Jamo/Syllables and Composition Exclusions), it returns the
code point of the composite.</p>
<p style="margin-left:14%; margin-top: 1em">If they are not
composable, it returns "undef".</p>
<p style="margin-left:9%;">"$combining_class =
getCombinClass($code_point)"</p>
<p style="margin-left:14%;">It returns the combining class
(as an integer) of the character.</p>
<p style="margin-left:9%;">"$may_be_composed_with_prev_char
= isComp2nd($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean whether
the character of the specified codepoint may be composed
with the previous one in a certain composition (including
Hangul Compositions, but excluding Composition Exclusions
and Non−Starter Decompositions).</p>
<p style="margin-left:9%;">"$is_exclusion =
isExclusion($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean whether
the code point is a composition exclusion.</p>
<p style="margin-left:9%;">"$is_singleton =
isSingleton($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean whether
the code point is a singleton</p>
<p style="margin-left:9%;">"$is_non_starter_decomposition
= isNonStDecomp($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean whether
the code point has Non−Starter Decomposition.</p>
<p style="margin-left:9%;">"$is_Full_Composition_Exclusion
= isComp_Ex($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property Comp_Ex (Full_Composition_Exclusion). This
property is generated from Composition Exclusions +
Singletons + Non−Starter Decompositions.</p>
<p style="margin-left:9%;">"$NFD_is_NO =
isNFD_NO($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property NFD_NO (NFD_Quick_Check=No).</p>
<p style="margin-left:9%;">"$NFC_is_NO =
isNFC_NO($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property NFC_NO (NFC_Quick_Check=No).</p>
<p style="margin-left:9%;">"$NFC_is_MAYBE =
isNFC_MAYBE($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</p>
<p style="margin-left:9%;">"$NFKD_is_NO =
isNFKD_NO($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property NFKD_NO (NFKD_Quick_Check=No).</p>
<p style="margin-left:9%;">"$NFKC_is_NO =
isNFKC_NO($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property NFKC_NO (NFKC_Quick_Check=No).</p>
<p style="margin-left:9%;">"$NFKC_is_MAYBE =
isNFKC_MAYBE($code_point)"</p>
<p style="margin-left:14%;">It returns a boolean of the
derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</p>
<h2>EXPORT
<a name="EXPORT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">"NFC",
"NFD", "NFKC", "NFKD": by
default.</p>
<p style="margin-left:9%; margin-top: 1em">"normalize"
and other some functions: on request.</p>
<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Perl's version
vs. Unicode version</p>
<p style="margin-left:14%;">Since this module refers to
perl core's Unicode database in the directory
<i>/lib/unicore</i> (or formerly <i>/lib/unicode</i>), the
Unicode version of normalization implemented by this module
depends on what has been compiled into your perl. The
following table lists the default Unicode version that comes
with various perl versions. (It is possible to change the
Unicode version in any perl version to be any earlier
Unicode version, so one could cause Unicode 3.2 to be used
in any perl version starting with 5.8.0. Read
<i>$Config{privlib}/unicore/README.perl</i> for details.</p>
<p style="margin-left:14%; margin-top: 1em">perl's version
implemented Unicode version <br/>
5.6.1 3.0.1 <br/>
5.7.2 3.1.0 <br/>
5.7.3 3.1.1 (normalization is same as 3.1.0) <br/>
5.8.0 3.2.0 <br/>
5.8.1−5.8.3 4.0.0 <br/>
5.8.4−5.8.6 4.0.1 (normalization is same as 4.0.0)
<br/>
5.8.7−5.8.8 4.1.0 <br/>
5.10.0 5.0.0 <br/>
5.8.9, 5.10.1 5.1.0 <br/>
5.12.x 5.2.0 <br/>
5.14.x 6.0.0 <br/>
5.16.x 6.1.0 <br/>
5.18.x 6.2.0 <br/>
5.20.x 6.3.0 <br/>
5.22.x 7.0.0</p>
<p style="margin-left:9%;">Correction of decomposition
mapping</p>
<p style="margin-left:14%;">In older Unicode versions, a
small number of characters (all of which are CJK
compatibility ideographs as far as they have been found) may
have an erroneous decomposition mapping (see
<i>lib/unicore/NormalizationCorrections.txt</i>). Anyhow,
this module will neither refer to
<i>lib/unicore/NormalizationCorrections.txt</i> nor provide
any specific version of normalization. Therefore this module
running on an older perl with an older Unicode database may
use the erroneous decomposition mapping blindly conforming
to the Unicode database.</p>
<p style="margin-left:9%;">Revised definition of canonical
composition</p>
<p style="margin-left:14%;">In Unicode 4.1.0, the
definition D2 of canonical composition (which affects NFC
and NFKC) has been changed (see Public Review Issue #29 and
recent UAX #15). This module has used the newer definition
since the version 0.07 (Oct 31, 2001). This module will not
support the normalization according to the older definition,
even if the Unicode version implemented by perl is lower
than 4.1.0.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">SADAHIRO
Tomoyuki &lt;SADAHIRO@cpan.org&gt;</p>
<p style="margin-left:9%; margin-top: 1em">Currently
maintained by &lt;perl5−porters@perl.org&gt;</p>
<p style="margin-left:9%; margin-top: 1em">Copyright(C)
2001−2012, SADAHIRO Tomoyuki. Japan. All rights
reserved.</p>
<h2>LICENSE
<a name="LICENSE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">&lt;http://www.unicode.org/reports/tr15/&gt;</p>
<p style="margin-left:14%;">Unicode Normalization Forms
− UAX #15</p>
<p style="margin-left:9%;">&lt;http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt&gt;</p>
<p style="margin-left:14%;">Composition Exclusion Table</p>
<p style="margin-left:9%;">&lt;http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt&gt;</p>
<p style="margin-left:14%;">Derived Normalization
Properties</p>
<p style="margin-left:9%;">&lt;http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt&gt;</p>
<p style="margin-left:14%;">Normalization Corrections</p>
<p style="margin-left:9%;">&lt;http://www.unicode.org/review/pr−29.html&gt;</p>
<p style="margin-left:14%;">Public Review Issue #29:
Normalization Issue</p>
<p style="margin-left:9%;">&lt;http://www.unicode.org/notes/tn5/&gt;</p>
<p style="margin-left:14%;">Canonical Equivalence in
Applications − UTN #5</p>
<hr/>
</body>
</html>
