<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:42:01 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>charnames</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">charnames</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#LOOSE MATCHES">LOOSE MATCHES</a><br/>
<a href="#ALIASES">ALIASES</a><br/>
<a href="#CUSTOM ALIASES">CUSTOM ALIASES</a><br/>
<a href="#charnames::string_vianame(name)">charnames::string_vianame(name)</a><br/>
<a href="#charnames::vianame(name)">charnames::vianame(name)</a><br/>
<a href="#charnames::viacode(code)">charnames::viacode(code)</a><br/>
<a href="#CUSTOM TRANSLATORS">CUSTOM TRANSLATORS</a><br/>
<a href="#BUGS">BUGS</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">charnames
− access to Unicode character names and named
character sequences; also define character names</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use charnames
':full'; <br/>
print "\N{GREEK SMALL LETTER SIGMA} is called
sigma.\n"; <br/>
print "\N{LATIN CAPITAL LETTER E WITH VERTICAL LINE
BELOW}", <br/>
" is an officially named sequence of two Unicode
characters\n"; <br/>
use charnames ':loose'; <br/>
print "\N{Greek small−letter sigma}", <br/>
"can be used to ignore case, underscores, most
blanks," <br/>
"and when you aren't sure if the official name has
hyphens\n"; <br/>
use charnames ':short'; <br/>
print "\N{greek:Sigma} is an upper−case
sigma.\n"; <br/>
use charnames qw(cyrillic greek); <br/>
print "\N{sigma} is Greek sigma, and \N{be} is Cyrillic
b.\n"; <br/>
use utf8; <br/>
use charnames ":full", ":alias" =&gt; {
<br/>
e_ACUTE =&gt; "LATIN SMALL LETTER E WITH ACUTE",
<br/>
mychar =&gt; 0xE8000, # Private use area <br/>
"自 転 車 に 乗 る
人 " =&gt; "BICYCLIST" <br/>
}; <br/>
print "\N{e_ACUTE} is a small letter e with an
acute.\n"; <br/>
print "\N{mychar} allows me to name private use
characters.\n"; <br/>
print "And I can create synonyms in other
languages,", <br/>
" such as \N{自 転 車 に
乗 る 人 } for "BICYCLIST
(U+1F6B4)\n"; <br/>
use charnames (); <br/>
print charnames::viacode(0x1234); # prints "ETHIOPIC
SYLLABLE SEE" <br/>
printf "%04X", charnames::vianame("GOTHIC
LETTER AHSA"); # prints <br/>
# "10330" <br/>
print charnames::vianame("LATIN CAPITAL LETTER
A"); # prints 65 on <br/>
# ASCII platforms; <br/>
# 193 on EBCDIC <br/>
print charnames::string_vianame("LATIN CAPITAL LETTER
A"); # prints "A"</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Pragma "use
charnames" is used to gain access to the names of the
Unicode characters and named character sequences, and to
allow you to define your own character and character
sequence names.</p>
<p style="margin-left:9%; margin-top: 1em">All forms of the
pragma enable use of the following 3 functions:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>"charnames::string_vianame(<i>name</i>)" for
run-time lookup of a either a character name or a named
character sequence, returning its string representation</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>"charnames::vianame(<i>name</i>)" for run-time
lookup of a character name (but not a named character
sequence) to get its ordinal value (code point)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>"charnames::viacode(<i>code</i>)" for run-time
lookup of a code point to get its Unicode name.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Starting in Perl
v5.16, any occurrence of "\N{<i>CHARNAME</i>}"
sequences in a double-quotish string automatically loads
this module with arguments ":full" and
":short" (described below) if it hasn’t
already been loaded with different arguments, in order to
compile the named Unicode character into position in the
string. Prior to v5.16, an explicit
"use charnames" was required to enable this
usage. (However, prior to v5.16, the form
"use charnames ();" did not enable
"\N{<i>CHARNAME</i>}".)</p>
<p style="margin-left:9%; margin-top: 1em">Note that
"\N{U+<i>...</i>}", where the <i>...</i> is a
hexadecimal number, also inserts a character into a string.
The character it inserts is the one whose Unicode code point
(ordinal value) is equal to the number. For example,
"\N{U+263a}" is the Unicode (white background,
black foreground) smiley face equivalent to "\N{WHITE
SMILING FACE}". Also note, "\N{<i>...</i>}"
can mean a regex quantifier instead of a character name,
when the <i>...</i> is a number (or comma separated pair of
numbers (see "QUANTIFIERS" in perlreref), and is
not related to this pragma.</p>
<p style="margin-left:9%; margin-top: 1em">The
"charnames" pragma supports arguments
":full", ":loose", ":short",
script names and customized aliases.</p>
<p style="margin-left:9%; margin-top: 1em">If
":full" is present, for expansion of
"\N{<i>CHARNAME</i>}", the string <i>CHARNAME</i>
is first looked up in the list of standard Unicode character
names.</p>
<p style="margin-left:9%; margin-top: 1em">":loose"
is a variant of ":full" which allows
<i>CHARNAME</i> to be less precisely specified. Details are
in "LOOSE MATCHES".</p>
<p style="margin-left:9%; margin-top: 1em">If
":short" is present, and <i>CHARNAME</i> has the
form "<i>SCRIPT</i>:<i>CNAME</i>", then
<i>CNAME</i> is looked up as a letter in script
<i>SCRIPT</i>, as described in the next paragraph. Or, if
"use charnames" is used with script name
arguments, then for "\N{<i>CHARNAME</i>}" the name
<i>CHARNAME</i> is looked up as a letter in the given
scripts (in the specified order). Customized aliases can
override these, and are explained in "CUSTOM
ALIASES".</p>
<p style="margin-left:9%; margin-top: 1em">For lookup of
<i>CHARNAME</i> inside a given script <i>SCRIPTNAME</i>,
this pragma looks in the table of standard Unicode names for
the names</p>
<p style="margin-left:9%; margin-top: 1em">SCRIPTNAME
CAPITAL LETTER CHARNAME <br/>
SCRIPTNAME SMALL LETTER CHARNAME <br/>
SCRIPTNAME LETTER CHARNAME</p>
<p style="margin-left:9%; margin-top: 1em">If
<i>CHARNAME</i> is all lowercase, then the
"CAPITAL" variant is ignored, otherwise the
"SMALL" variant is ignored, and both
<i>CHARNAME</i> and <i>SCRIPTNAME</i> are converted to all
uppercase for look-up. Other than that, both of them follow
loose rules if ":loose" is also specified; strict
otherwise.</p>
<p style="margin-left:9%; margin-top: 1em">Note that
"\N{...}" is compile-time; it’s a special
form of string constant used inside double-quotish strings;
this means that you cannot use variables inside the
"\N{...}". If you want similar run-time
functionality, use <b>charnames::string_vianame()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Note, starting
in Perl 5.18, the name "BELL" refers to the
Unicode character U+1F514, instead of the traditional
U+0007. For the latter, use "ALERT" or
"BEL".</p>
<p style="margin-left:9%; margin-top: 1em">It is a syntax
error to use "\N{NAME}" where "NAME" is
unknown.</p>
<p style="margin-left:9%; margin-top: 1em">For
"\N{NAME}", it is a fatal error if "use
bytes" is in effect and the input name is that of a
character that won’t fit into a byte (i.e., whose
ordinal is above 255).</p>
<p style="margin-left:9%; margin-top: 1em">Otherwise, any
string that includes a "\N{<i>charname</i>}" or
"\N{U+<i>code point</i>}" will automatically
have Unicode rules (see "Byte and Character
Semantics" in perlunicode).</p>
<h2>LOOSE MATCHES
<a name="LOOSE MATCHES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">By specifying
":loose", Unicode’s loose character name
matching
&lt;http://www.unicode.org/reports/tr44#Matching_Rules&gt;
rules are selected instead of the strict exact match used
otherwise. That means that <i>CHARNAME</i> doesn’t
have to be so precisely specified. Upper/lower case
doesn’t matter (except with scripts as mentioned
above), nor do any underscores, and the only hyphens that
matter are those at the beginning or end of a word in the
name (with one exception: the hyphen in U+1180 "HANGUL
JUNGSEONG O−E" does matter). Also, blanks not
adjacent to hyphens don’t matter. The official Unicode
names are quite variable as to where they use hyphens versus
spaces to separate word-like units, and this option allows
you to not have to care as much. The reason non-medial
hyphens matter is because of cases like U+0F60 "TIBETAN
LETTER −A" versus U+0F68 "TIBETAN LETTER
A". The hyphen here is significant, as is the space
before it, and so both must be included.</p>
<p style="margin-left:9%; margin-top: 1em">":loose"
slows down look-ups by a factor of 2 to 3 versus
":full", but the trade-off may be worth it to you.
Each individual look-up takes very little time, and the
results are cached, so the speed difference would become a
factor only in programs that do look-ups of many different
spellings, and probably only when those look-ups are through
vianame() and string_vianame(), since "\N{...}"
look-ups are done at compile time.</p>
<h2>ALIASES
<a name="ALIASES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Starting in
Unicode 6.1 and Perl v5.16, Unicode defines many
abbreviations and names that were formerly Perl extensions,
and some additional ones that Perl did not previously
accept. The list is getting too long to reproduce here, but
you can get the complete list from the Unicode web site:
&lt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Earlier versions
of Perl accepted almost all the 6.1 names. These were most
extensively documented in the v5.14 version of this pod:
&lt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&gt;.</p>
<h2>CUSTOM ALIASES
<a name="CUSTOM ALIASES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">You can add
customized aliases to standard (":full") Unicode
naming conventions. The aliases override any standard
definitions, so, if you’re twisted enough, you can
change "\N{LATIN CAPITAL LETTER A}" to mean
"B", etc.</p>
<p style="margin-left:9%; margin-top: 1em">Aliases must
begin with a character that is alphabetic. After that, each
may contain any combination of word ("\w")
characters, SPACE (U+0020), HYPHEN-MINUS (U+002D), LEFT
PARENTHESIS (U+0028), and RIGHT PARENTHESIS (U+0029). These
last two should never have been allowed in names, and are
retained for backwards compatibility only, and may be
deprecated and removed in future releases of Perl, so
don’t use them for new names. (More precisely, the
first character of a name you specify must be something that
matches all of "\p{ID_Start}",
"\p{Alphabetic}", and "\p{Gc=Letter}".
This makes sure it is what any reasonable person would view
as an alphabetic character. And, the continuation characters
that match "\w" must also match
"\p{ID_Continue}".) Starting with Perl v5.18, any
Unicode characters meeting the above criteria may be used;
prior to that only Latin1−range characters were
acceptable.</p>
<p style="margin-left:9%; margin-top: 1em">An alias can map
to either an official Unicode character name (not a loose
matched name) or to a numeric code point (ordinal). The
latter is useful for assigning names to code points in
Unicode private use areas such as U+E800 through U+F8FF. A
numeric code point must be a non-negative integer, or a
string beginning with "U+" or "0x" with
the remainder considered to be a hexadecimal integer. A
literal numeric constant must be unsigned; it will be
interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as
decimal. If it begins with "U+", it is interpreted
as the Unicode code point; otherwise it is interpreted as
native. (Only code points below 256 can differ between
Unicode and native.) Thus "U+41" is always the
Latin letter "A"; but 0x41 can be "NO-BREAK
SPACE" on EBCDIC platforms.</p>
<p style="margin-left:9%; margin-top: 1em">Aliases are
added either by the use of anonymous hashes:</p>
<p style="margin-left:9%; margin-top: 1em">use charnames
":alias" =&gt; { <br/>
e_ACUTE =&gt; "LATIN SMALL LETTER E WITH ACUTE",
<br/>
mychar1 =&gt; 0xE8000, <br/>
}; <br/>
my $str = "\N{e_ACUTE}";</p>
<p style="margin-left:9%; margin-top: 1em">or by using a
file containing aliases:</p>
<p style="margin-left:9%; margin-top: 1em">use charnames
":alias" =&gt; "pro";</p>
<p style="margin-left:9%; margin-top: 1em">This will try to
read "unicore/pro_alias.pl" from the @INC path.
This file should return a list in plain perl:</p>
<p style="margin-left:9%; margin-top: 1em">( <br/>
A_GRAVE =&gt; "LATIN CAPITAL LETTER A WITH GRAVE",
<br/>
A_CIRCUM =&gt; "LATIN CAPITAL LETTER A WITH
CIRCUMFLEX", <br/>
A_DIAERES =&gt; "LATIN CAPITAL LETTER A WITH
DIAERESIS", <br/>
A_TILDE =&gt; "LATIN CAPITAL LETTER A WITH TILDE",
<br/>
A_BREVE =&gt; "LATIN CAPITAL LETTER A WITH BREVE",
<br/>
A_RING =&gt; "LATIN CAPITAL LETTER A WITH RING
ABOVE", <br/>
A_MACRON =&gt; "LATIN CAPITAL LETTER A WITH
MACRON", <br/>
mychar2 =&gt; "U+E8001", <br/>
);</p>
<p style="margin-left:9%; margin-top: 1em">Both these
methods insert ":full" automatically as the first
argument (if no other argument is given), and you can give
the ":full" explicitly as well, like</p>
<p style="margin-left:9%; margin-top: 1em">use charnames
":full", ":alias" =&gt;
"pro";</p>
<p style="margin-left:9%; margin-top: 1em">":loose"
has no effect with these. Input names must match exactly,
using ":full" rules.</p>
<p style="margin-left:9%; margin-top: 1em">Also, both these
methods currently allow only single characters to be named.
To name a sequence of characters, use a custom translator
(described below).</p>
<h2>charnames::string_vianame(name)
<a name="charnames::string_vianame(name)"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This is a
runtime equivalent to "\N{...}". <i>name</i> can
be any expression that evaluates to a name accepted by
"\N{...}" under the ":full" option to
"charnames". In addition, any other options for
the controlling "use charnames" in the same scope
apply, like ":loose" or any script list,
":short" option, or custom aliases you may have
defined.</p>
<p style="margin-left:9%; margin-top: 1em">The only
differences are due to the fact that
"string_vianame" is run-time and "\N{}"
is compile time. You can’t interpolate inside a
"\N{}", (so "\N{$variable}"
doesn’t work); and if the input name is unknown,
"string_vianame" returns "undef" instead
of it being a syntax error.</p>
<h2>charnames::vianame(name)
<a name="charnames::vianame(name)"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This is similar
to "string_vianame". The main difference is that
under most circumstances, "vianame" returns an
ordinal code point, whereas "string_vianame"
returns a string. For example,</p>
<p style="margin-left:9%; margin-top: 1em">printf
"U+%04X", charnames::vianame("FOUR
TEARDROP−SPOKED ASTERISK");</p>
<p style="margin-left:9%; margin-top: 1em">prints
"U+2722".</p>
<p style="margin-left:9%; margin-top: 1em">This leads to
the other two differences. Since a single code point is
returned, the function can’t handle named character
sequences, as these are composed of multiple characters (it
returns "undef" for these. And, the code point can
be that of any character, even ones that aren’t legal
under the "use bytes" pragma,</p>
<p style="margin-left:9%; margin-top: 1em">See
"BUGS" for the circumstances in which the behavior
differs from that described above.</p>
<h2>charnames::viacode(code)
<a name="charnames::viacode(code)"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Returns the full
name of the character indicated by the numeric code. For
example,</p>
<p style="margin-left:9%; margin-top: 1em">print
charnames::viacode(0x2722);</p>
<p style="margin-left:9%; margin-top: 1em">prints
"FOUR TEARDROP-SPOKED ASTERISK".</p>
<p style="margin-left:9%; margin-top: 1em">The name
returned is the "best" (defined below) official
name or alias for the code point, if available; otherwise
your custom alias for it, if defined; otherwise
"undef". This means that your alias will only be
returned for code points that don’t have an official
Unicode name (nor alias) such as private use code
points.</p>
<p style="margin-left:9%; margin-top: 1em">If you define
more than one name for the code point, it is indeterminate
which one will be returned.</p>
<p style="margin-left:9%; margin-top: 1em">As mentioned,
the function returns "undef" if no name is known
for the code point. In Unicode the proper name for these is
the empty string, which "undef" stringifies to.
(If you ask for a code point past the legal Unicode maximum
of U+10FFFF that you haven’t assigned an alias to, you
get "undef" plus a warning.)</p>
<p style="margin-left:9%; margin-top: 1em">The input number
must be a non-negative integer, or a string beginning with
"U+" or "0x" with the remainder
considered to be a hexadecimal integer. A literal numeric
constant must be unsigned; it will be interpreted as hex if
it has a leading zero or contains non-decimal hex digits;
otherwise it will be interpreted as decimal. If it begins
with "U+", it is interpreted as the Unicode code
point; otherwise it is interpreted as native. (Only code
points below 256 can differ between Unicode and native.)
Thus "U+41" is always the Latin letter
"A"; but 0x41 can be "NO-BREAK SPACE" on
EBCDIC platforms.</p>
<p style="margin-left:9%; margin-top: 1em">As mentioned
above under "ALIASES", Unicode 6.1 defines extra
names (synonyms or aliases) for some code points, most of
which were already available as Perl extensions. All these
are accepted by "\N{...}" and the other functions
in this module, but "viacode" has to choose which
one name to return for a given input code point, so it
returns the "best" name. To understand how this
works, it is helpful to know more about the Unicode name
properties. All code points actually have only a single
name, which (starting in Unicode 2.0) can never change once
a character has been assigned to the code point. But
mistakes have been made in assigning names, for example
sometimes a clerical error was made during the publishing of
the Standard which caused words to be misspelled, and there
was no way to correct those. The Name_Alias property was
eventually created to handle these situations. If a name was
wrong, a corrected synonym would be published for it, using
Name_Alias. "viacode" will return that corrected
synonym as the "best" name for a code point. (It
is even possible, though it hasn’t happened yet, that
the correction itself will need to be corrected, and so
another Name_Alias can be created for that code point;
"viacode" will return the most recent
correction.)</p>
<p style="margin-left:9%; margin-top: 1em">The Unicode name
for each of the control characters (such as LINE FEED) is
the empty string. However almost all had names assigned by
other standards, such as the ASCII Standard, or were in
common use. "viacode" returns these names as the
"best" ones available. Unicode 6.1 has created
Name_Aliases for each of them, including alternate names,
like NEW LINE. "viacode" uses the original name,
"LINE FEED" in preference to the alternate.
Similarly the name returned for U+FEFF is "ZERO WIDTH
NO-BREAK SPACE", not "BYTE ORDER MARK".</p>
<p style="margin-left:9%; margin-top: 1em">Until Unicode
6.1, the 4 control characters U+0080, U+0081, U+0084, and
U+0099 did not have names nor aliases. To preserve backwards
compatibility, any alias you define for these code points
will be returned by this function, in preference to the
official name.</p>
<p style="margin-left:9%; margin-top: 1em">Some code points
also have abbreviated names, such as "LF" or
"NL". "viacode" never returns these.</p>
<p style="margin-left:9%; margin-top: 1em">Because a name
correction may be added in future Unicode releases, the name
that "viacode" returns may change as a result.
This is a rare event, but it does happen.</p>
<h2>CUSTOM TRANSLATORS
<a name="CUSTOM TRANSLATORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The mechanism of
translation of "\N{...}" escapes is general and
not hardwired into <i>charnames.pm</i>. A module can install
custom translations (inside the scope which "use"s
the module) with the following magic incantation:</p>
<p style="margin-left:9%; margin-top: 1em">sub import {
<br/>
shift; <br/>
$ˆH{charnames} = \&amp;translator; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Here
<b>translator()</b> is a subroutine which takes
<i>CHARNAME</i> as an argument, and returns text to insert
into the string instead of the
"\N{<i>CHARNAME</i>}" escape.</p>
<p style="margin-left:9%; margin-top: 1em">This is the only
way you can create a custom named sequence of code
points.</p>
<p style="margin-left:9%; margin-top: 1em">Since the text
to insert should be different in "bytes" mode and
out of it, the function should check the current state of
"bytes"−flag as in:</p>
<p style="margin-left:9%; margin-top: 1em">use bytes (); #
for $bytes::hint_bits <br/>
sub translator { <br/>
if ($ˆH &amp; $bytes::hint_bits) { <br/>
return bytes_translator(@_); <br/>
} <br/>
else { <br/>
return utf8_translator(@_); <br/>
} <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">See "CUSTOM
ALIASES" above for restrictions on <i>CHARNAME</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Of course,
"vianame", "viacode", and
"string_vianame" would need to be overridden as
well.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>vianame()</b>
normally returns an ordinal code point, but when the input
name is of the form "U+...", it returns a chr
instead. In this case, if "use bytes" is in effect
and the character won’t fit into a byte, it returns
"undef" and raises a warning.</p>
<p style="margin-left:9%; margin-top: 1em">Since evaluation
of the translation function (see "CUSTOM
TRANSLATORS") happens in the middle of compilation (of
a string literal), the translation function should not do
any "eval"s or "require"s. This
restriction should be lifted (but is low priority) in a
future version of Perl.</p>
<hr/>
</body>
</html>
