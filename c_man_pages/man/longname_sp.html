<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:46:12 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>curs_sp_funcs</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">curs_sp_funcs</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Improved Functions">Improved Functions</a><br/>
<a href="#New Functions">New Functions</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#PORTABILITY">PORTABILITY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>curs_sp_funcs</b>
− <i>curses</i> screen-pointer extension</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;curses.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
alloc_pair_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>fg</i><b>, int</b> <i>bg</i><b>); <br/>
int assume_default_colors_sp(SCREEN*</b> <i>sp</i><b>,
int</b> <i>fg</i><b>, int</b> <i>bg</i><b>); <br/>
int baudrate_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int beep_sp(SCREEN*</b> <i>sp</i><b>); <br/>
bool can_change_color_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int cbreak_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int color_content_sp(SCREEN*</b> <i>sp</i><b>, short</b>
<i>color</i><b>, short*</b> <i>r</i><b>, short*</b>
<i>g</i><b>, short*</b> <i>b</i><b>); <br/>
int curs_set_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>visibility</i><b>); <br/>
int def_prog_mode_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int def_shell_mode_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
define_key_sp(SCREEN*</b> <i>sp</i><b>, const char *</b>
<i>definition</i><b>, int</b> <i>keycode</i><b>); <br/>
int delay_output_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>ms</i><b>); <br/>
int doupdate_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int echo_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int endwin_sp(SCREEN*</b> <i>sp</i><b>); <br/>
char erasechar_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int erasewchar_sp(SCREEN*</b> <i>sp</i><b>, wchar_t
*</b><i>wc</i><b>); <br/>
int extended_color_content_sp(SCREEN *</b> <i>sp</i><b>,
int</b> <i>color</i><b>, int *</b> <i>r</i><b>, int *</b>
<i>g</i><b>, int *</b> <i>b</i><b>); <br/>
int extended_pair_content_sp(SCREEN*</b> <i>sp</i><b>,
int</b> <i>pair</i><b>, int *</b> <i>fg</i><b>, int *</b>
<i>bg</i><b>); <br/>
int extended_slk_color_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>pair</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
filter_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int find_pair_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>fg</i><b>, int</b> <i>bg</i><b>); <br/>
int flash_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int flushinp_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int free_pair_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>pair</i><b>); <br/>
int get_escdelay_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int getmouse_sp(SCREEN*</b> <i>sp</i><b>, MEVENT*</b>
<i>event</i><b>); <br/>
WINDOW* getwin_sp(SCREEN*</b> <i>sp</i><b>, FILE*</b>
<i>filep</i><b>); <br/>
int halfdelay_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>tenths</i><b>); <br/>
bool has_colors_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>bool
has_ic_sp(SCREEN*</b> <i>sp</i><b>); <br/>
bool has_il_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int has_key_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>c</i><b>); <br/>
bool has_mouse_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int init_color_sp(SCREEN*</b> <i>sp</i><b>, short</b>
<i>color</i><b>, short</b> <i>r</i><b>, short</b>
<i>g</i><b>, short</b> <i>b</i><b>); <br/>
int init_extended_color_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>color</i><b>, int</b> <i>r</i><b>, int</b> <i>g</i><b>,
int</b> <i>b</i><b>); <br/>
int init_extended_pair_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>pair</i><b>, int</b> <i>fg</i><b>, int</b> <i>bg</i><b>);
<br/>
int init_pair_sp(SCREEN*</b> <i>sp</i><b>, short</b>
<i>pair</i><b>, short</b> <i>fg</i><b>, short</b>
<i>bg</i><b>); <br/>
int intrflush_sp(SCREEN*</b> <i>sp</i><b>, WINDOW*</b>
<i>win</i><b>, bool</b> <i>bf</i><b>); <br/>
int is_cbreak_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
is_echo_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int is_nl_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int is_raw_sp(SCREEN*</b> <i>sp</i><b>); <br/>
bool is_term_resized_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>lines</i><b>, int</b> <i>columns</i><b>); <br/>
bool isendwin_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int key_defined_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>definition</i><b>); <br/>
char* keybound_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>keycode</i><b>, int</b> <i>count</i><b>); <br/>
NCURSES_CONST char* keyname_sp(SCREEN*</b> <i>sp</i><b>,
int</b> <i>c</i><b>); <br/>
int keyok_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>keycode</i><b>, bool</b> <i>enable</i><b>); <br/>
char killchar_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
killwchar_sp(SCREEN*</b> <i>sp</i><b>, wchar_t
*</b><i>wc</i><b>); <br/>
char* longname_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int mcprint_sp(SCREEN*</b> <i>sp</i><b>, char
*</b><i>data</i><b>, int</b> <i>len</i><b>); <br/>
int mouseinterval_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>erval</i><b>); <br/>
mmask_t mousemask_sp(SCREEN*</b> <i>sp</i><b>, mmask_t</b>
<i>newmask</i><b>, mmask_t *</b><i>oldmask</i><b>); <br/>
int mvcur_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>oldrow</i><b>, int</b> <i>oldcol</i><b>, int</b>
<i>newrow</i><b>, int</b> <i>newcol</i><b>); <br/>
int napms_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>ms</i><b>); <br/>
WINDOW* newpad_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>nrows</i><b>, int</b> <i>ncols</i><b>); <br/>
SCREEN* new_prescr(void); <br/>
SCREEN* newterm_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>type</i><b>, FILE *</b><i>outfd</i><b>, FILE
*</b><i>infd</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>WINDOW*
newwin_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>nlines</i><b>, int</b> <i>ncols</i><b>, int</b>
<i>begin_y</i><b>, int</b> <i>begin_x</i><b>); <br/>
int nl_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int nocbreak_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int noecho_sp(SCREEN*</b> <i>sp</i><b>); <br/>
void nofilter_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int nonl_sp(SCREEN*</b> <i>sp</i><b>); <br/>
void noqiflush_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int noraw_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int pair_content_sp(SCREEN*</b> <i>sp</i><b>, short</b>
<i>pair</i><b>, short*</b> <i>fg</i><b>, short*</b>
<i>bg</i><b>); <br/>
void qiflush_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
raw_sp(SCREEN*</b> <i>sp</i><b>); <br/>
void reset_color_pairs_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int reset_prog_mode_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int reset_shell_mode_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int resetty_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int resize_term_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>lines</i><b>, int</b> <i>columns</i><b>); <br/>
int resizeterm_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>lines</i><b>, int</b> <i>columns</i><b>); <br/>
int ripoffline_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>line</i><b>, int (*</b><i>init</i><b>)(WINDOW*</b>
<i>win</i><b>, int</b> <i>fmt</i><b>)); <br/>
int savetty_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int scr_init_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>filename</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
scr_restore_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>filename</i><b>); <br/>
int scr_set_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>filename</i><b>); <br/>
int set_escdelay_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>ms</i><b>); <br/>
int set_tabsize_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>cols</i><b>); <br/>
int slk_attrset_sp(SCREEN*</b> <i>sp</i><b>, const
chtype</b> <i>a</i><b>); <br/>
int slk_attr_set_sp(SCREEN*</b> <i>sp</i><b>, const
attr_t</b> <i>attrs</i><b>, short</b> <i>pair</i><b>,
void*</b><i>opts</i><b>); <br/>
int slk_attroff_sp(SCREEN*</b> <i>sp</i><b>, const
chtype</b> <i>a</i><b>); <br/>
int slk_attron_sp(SCREEN*</b> <i>sp</i><b>, const chtype</b>
<i>a</i><b>); <br/>
attr_t slk_attr_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int slk_clear_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
slk_color_sp(SCREEN*</b> <i>sp</i><b>, short</b>
<i>pair</i><b>); <br/>
int slk_init_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>fmt</i><b>); <br/>
char* slk_label_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>labnum</i><b>); <br/>
int slk_noutrefresh_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int slk_refresh_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int slk_restore_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int slk_set_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>labnum</i><b>, const char *</b> <i>label</i><b>, int</b>
<i>fmt</i><b>); <br/>
int slk_touch_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int start_color_sp(SCREEN*</b> <i>sp</i><b>); <br/>
attr_t term_attrs_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>chtype
termattrs_sp(SCREEN*</b> <i>sp</i><b>); <br/>
char* termname_sp(SCREEN*</b> <i>sp</i><b>); <br/>
int typeahead_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>fd</i><b>); <br/>
int unget_wch_sp(SCREEN*</b> <i>sp</i><b>, const wchar_t</b>
<i>wc</i><b>); <br/>
int ungetch_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>c</i><b>); <br/>
int ungetmouse_sp(SCREEN*</b> <i>sp</i><b>, MEVENT*</b>
<i>event</i><b>); <br/>
int use_default_colors_sp(SCREEN*</b> <i>sp</i><b>); <br/>
void use_env_sp(SCREEN*</b> <i>sp</i><b>, bool</b>
<i>bf</i><b>); <br/>
int use_legacy_coding_sp(SCREEN*</b> <i>sp</i><b>, int</b>
<i>level</i><b>); <br/>
void use_tioctl_sp(SCREEN *</b><i>sp</i><b>, bool</b>
<i>bf</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
vid_attr_sp(SCREEN*</b> <i>sp</i><b>, attr_t</b>
<i>attrs</i><b>, short</b> <i>pair</i><b>, void *</b>
<i>opts</i><b>); <br/>
int vid_puts_sp(SCREEN*</b> <i>sp</i><b>, attr_t</b>
<i>attrs</i><b>, short</b> <i>pair</i><b>, void *</b>
<i>opts</i><b>, NCURSES_SP_OUTC</b> <i>putc</i><b>); <br/>
int vidattr_sp(SCREEN*</b> <i>sp</i><b>, chtype</b>
<i>attrs</i><b>); <br/>
int vidputs_sp(SCREEN*</b> <i>sp</i><b>, chtype</b>
<i>attrs</i><b>, NCURSES_SP_OUTC</b> <i>putc</i><b>); <br/>
wchar_t* wunctrl_sp(SCREEN*</b> <i>sp</i><b>, cchar_t
*</b><i>wch</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;form.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>FORM*
new_form_sp(SCREEN*</b> <i>sp</i><b>, FIELD
**</b><i>fields</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;menu.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>MENU*
new_menu_sp(SCREEN*</b> <i>sp</i><b>, ITEM
**</b><i>items</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;panel.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>PANEL*
ceiling_panel(SCREEN*</b> <i>sp</i><b>); <br/>
PANEL* ground_panel(SCREEN*</b> <i>sp</i><b>); <br/>
void update_panels_sp(SCREEN*</b> <i>sp</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;term.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
del_curterm_sp(SCREEN*</b> <i>sp</i><b>, TERMINAL
*</b><i>oterm</i><b>); <br/>
int putp_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>str</i><b>); <br/>
int restartterm_sp(SCREEN*</b> <i>sp</i><b>, NCURSES_CONST
char*</b><i>term</i><b>, int</b> <i>filedes</i><b>, int
*</b><i>errret</i><b>); <br/>
TERMINAL* set_curterm_sp(SCREEN*</b> <i>sp</i><b>,
TERMINAL*</b><i>nterm</i><b>); <br/>
int tgetent_sp(SCREEN*</b> <i>sp</i><b>, char
*</b><i>bp</i><b>, const char *</b><i>name</i><b>); <br/>
int tgetflag_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>); <br/>
int tgetnum_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>); <br/>
char* tgetstr_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>, char **</b><i>area</i><b>); <br/>
char* tgoto_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>, int</b> <i>col</i><b>, int</b>
<i>row</i><b>); <br/>
int tigetflag_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
tigetnum_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>); <br/>
char* tigetstr_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>capname</i><b>);</b> <i><br/>
/* tparm_sp may use 9 long parameters rather than being
variadic */</i> <b><br/>
char* tparm_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>str</i><b>, ...); <br/>
int tputs_sp(SCREEN*</b> <i>sp</i><b>, const char
*</b><i>str</i><b>, int</b> <i>affcnt</i><b>,
NCURSES_SP_OUTC</b> <i>putc</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;unctrl.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>NCURSES_CONST
char* unctrl_sp(SCREEN*</b> <i>sp</i><b>, chtype</b>
<i>ch</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This
implementation can be configured to provide a set of
functions which improve the ability to manage multiple
screens. This feature can be added to any of the
configurations supported by <i>ncurses</i>; it adds new
symbols without changing the meaning of any of the existing
ones.</p>
<h3>Improved Functions
<a name="Improved Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Most of the
functions are new versions of existing functions. A
parameter is added at the front of the parameter list. It is
a <i>SCREEN</i> pointer.</p>
<p style="margin-left:9%; margin-top: 1em">The existing
functions all use the current screen, which is a static
variable. The extended functions use the specified screen,
thereby reducing the number of variables which must be
modified to update multiple screens.</p>
<h3>New Functions
<a name="New Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Here are the new
functions: <br/>
ceiling_panel</p>
<p style="margin-left:15%;">this returns a pointer to the
topmost panel in the given screen.</p>
<p style="margin-left:9%;">ground_panel</p>
<p style="margin-left:15%;">this returns a pointer to the
lowest panel in the given screen.</p>
<p style="margin-left:9%;">new_prescr</p>
<p style="margin-left:15%;">when creating a new screen, the
library uses static variables which have been preset, e.g.,
by <b>use_env</b>(3X), <b>filter</b>(3X), etc. With the
screen-pointer extension, there are situations where it must
create a current screen before the unextended library does.
The <b>new_prescr</b> function is used internally to handle
these cases. It is also provided to allow applications to
customize library initialization.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This extension
introduces some new names: <br/>
NCURSES_SP_FUNCS</p>
<p style="margin-left:15%;">This is set to the library
patch-level number. In the unextended library, this is zero
(0), to make it useful for checking if the extension is
provided.</p>
<p style="margin-left:9%;">NCURSES_SP_NAME</p>
<p style="margin-left:15%;">The new functions are named
using the macro <i>NCURSES_SP_NAME</i>, which hides the
actual implementation. Currently this adds a
“_sp” suffix to the name of the unextended
function. This manual page indexes the extensions showing
the full name. However the proper usage of these functions
uses the macro, to provide for the possibility of changing
the naming convention for specific library
configurations.</p>
<p style="margin-left:9%;">NCURSES_SP_OUTC</p>
<p style="margin-left:15%;">This is a new function-pointer
type to use in the screen-pointer functions where an
<i>NCURSES_OUTC</i> is used in the unextended library.</p>
<p style="margin-left:9%;">NCURSES_OUTC</p>
<p style="margin-left:15%;">This is a function-pointer type
used for the cases where a function passes characters to the
output stream, e.g., <b>vidputs</b>(3X).</p>
<h2>PORTABILITY
<a name="PORTABILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These routines
are specific to <i>ncurses</i>. They were not supported on
Version 7, BSD or System V implementations. It is
recommended that any code depending on <i>ncurses</i>
extensions be conditioned using <i>NCURSES_SP_FUNCS</i>.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>curses</b>(3X),
<b>curs_opaque</b>(3X), <b>curs_threads</b>(3X)</p>
<hr/>
</body>
</html>
