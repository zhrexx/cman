<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:52:40 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>wl_event_source</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">wl_event_source</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Public Types">Public Types</a><br/>
<a href="#Public Member Functions">Public Member Functions</a><br/>
<a href="#Detailed Description">Detailed Description</a><br/>
<a href="#Member Typedef Documentation">Member Typedef Documentation</a><br/>
<a href="#typedef int(* wl_event_loop_fd_func_t) (int fd, uint32_t mask, void *data)">typedef int(* wl_event_loop_fd_func_t) (int fd, uint32_t mask, void *data)</a><br/>
<a href="#typedef void(* wl_event_loop_idle_func_t) (void *data)">typedef void(* wl_event_loop_idle_func_t) (void *data)</a><br/>
<a href="#typedef int(* wl_event_loop_signal_func_t) (int signal_number, void *data)">typedef int(* wl_event_loop_signal_func_t) (int signal_number, void *data)</a><br/>
<a href="#typedef int(* wl_event_loop_timer_func_t) (void *data)">typedef int(* wl_event_loop_timer_func_t) (void *data)</a><br/>
<a href="#Member Function Documentation">Member Function Documentation</a><br/>
<a href="#struct wl_event_source * wl_event_loop_add_fd (struct wl_event_loop * loop,int fd, uint32_t mask, wl_event_loop_fd_func_t func, void * data)">struct wl_event_source * wl_event_loop_add_fd (struct wl_event_loop * loop,int fd, uint32_t mask, wl_event_loop_fd_func_t func, void * data)</a><br/>
<a href="#struct wl_event_source * wl_event_loop_add_idle (struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void * data)">struct wl_event_source * wl_event_loop_add_idle (struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void * data)</a><br/>
<a href="#struct wl_event_source * wl_event_loop_add_signal (struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void * data)">struct wl_event_source * wl_event_loop_add_signal (struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void * data)</a><br/>
<a href="#struct wl_event_source * wl_event_loop_add_timer (struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void * data)">struct wl_event_source * wl_event_loop_add_timer (struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void * data)</a><br/>
<a href="#void wl_event_source_check (struct wl_event_source * source)">void wl_event_source_check (struct wl_event_source * source)</a><br/>
<a href="#int wl_event_source_fd_update (struct wl_event_source * source, uint32_tmask)">int wl_event_source_fd_update (struct wl_event_source * source, uint32_tmask)</a><br/>
<a href="#int wl_event_source_remove (struct wl_event_source * source)">int wl_event_source_remove (struct wl_event_source * source)</a><br/>
<a href="#int wl_event_source_timer_update (struct wl_event_source * source, intms_delay)">int wl_event_source_timer_update (struct wl_event_source * source, intms_delay)</a><br/>
<a href="#Author">Author</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">wl_event_source
− An abstract event source.</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;wayland−server−core.h&gt;</p>
<h3>Public Types
<a name="Public Types"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">typedef int(*
<b>wl_event_loop_fd_func_t</b>) (int fd, uint32_t mask, void
*data) <br/>
typedef int(* <b>wl_event_loop_timer_func_t</b>) (void
*data) <br/>
typedef int(* <b>wl_event_loop_signal_func_t</b>) (int
signal_number, void *data) <br/>
typedef void(* <b>wl_event_loop_idle_func_t</b>) (void
*data)</p>
<h3>Public Member Functions
<a name="Public Member Functions"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">struct
<b>wl_event_source</b> * <b>wl_event_loop_add_fd</b> (struct
<b>wl_event_loop</b> *loop, int fd, uint32_t mask,
<b>wl_event_loop_fd_func_t</b> func, void *data) <br/>
int <b>wl_event_source_fd_update</b> (struct
<b>wl_event_source</b> *source, uint32_t mask) <br/>
struct <b>wl_event_source</b> *
<b>wl_event_loop_add_timer</b> (struct <b>wl_event_loop</b>
*loop, <b>wl_event_loop_timer_func_t</b> func, void *data)
<br/>
int <b>wl_event_source_timer_update</b> (struct
<b>wl_event_source</b> *source, int ms_delay) <br/>
struct <b>wl_event_source</b> *
<b>wl_event_loop_add_signal</b> (struct <b>wl_event_loop</b>
*loop, int signal_number, <b>wl_event_loop_signal_func_t</b>
func, void *data) <br/>
struct <b>wl_event_source</b> *
<b>wl_event_loop_add_idle</b> (struct <b>wl_event_loop</b>
*loop, <b>wl_event_loop_idle_func_t</b> func, void *data)
<br/>
void <b>wl_event_source_check</b> (struct
<b>wl_event_source</b> *source) <br/>
int <b>wl_event_source_remove</b> (struct
<b>wl_event_source</b> *source)</p>
<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">An abstract
event source.</p>
<p style="margin-left:9%; margin-top: 1em">This is the
generic type for fd, timer, signal, and idle sources.
Functions that operate on specific source types must not be
used with a different type, even if the function signature
allows it.</p>
<h2>Member Typedef Documentation
<a name="Member Typedef Documentation"></a>
</h2>
<h3>typedef int(* wl_event_loop_fd_func_t) (int fd, uint32_t mask, void *data)
<a name="typedef int(* wl_event_loop_fd_func_t) (int fd, uint32_t mask, void *data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">File descriptor
dispatch function type</p>
<p style="margin-left:9%; margin-top: 1em">Functions of
this type are used as callbacks for file descriptor
events.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>fd</i> The file descriptor
delivering the event. <i><br/>
mask</i> Describes the kind of the event as a bitwise-or of:
WL_EVENT_READABLE, WL_EVENT_WRITABLE, WL_EVENT_HANGUP,
WL_EVENT_ERROR. <i><br/>
data</i> The user data argument of the related
<b>wl_event_loop_add_fd()</b> call.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">If the event source is
registered for re-check with <b>wl_event_source_check()</b>:
0 for all done, 1 for needing a re-check. If not registered,
the return value is ignored and should be zero.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_add_fd()</b></p>
<h3>typedef void(* wl_event_loop_idle_func_t) (void *data)
<a name="typedef void(* wl_event_loop_idle_func_t) (void *data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Idle task
function type</p>
<p style="margin-left:9%; margin-top: 1em">Functions of
this type are used as callbacks before blocking in
<b>wl_event_loop_dispatch()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>data</i> The user data
argument of the related <b>wl_event_loop_add_idle()</b>
call.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_add_idle()
wl_event_loop_dispatch()</b></p>
<h3>typedef int(* wl_event_loop_signal_func_t) (int signal_number, void *data)
<a name="typedef int(* wl_event_loop_signal_func_t) (int signal_number, void *data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Signal dispatch
function type</p>
<p style="margin-left:9%; margin-top: 1em">Functions of
this type are used as callbacks for (POSIX) signals.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>signal_number <br/>
data</i> The user data argument of the related
<b>wl_event_loop_add_signal()</b> call.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">If the event source is
registered for re-check with <b>wl_event_source_check()</b>:
0 for all done, 1 for needing a re-check. If not registered,
the return value is ignored and should be zero.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_add_signal()</b></p>
<h3>typedef int(* wl_event_loop_timer_func_t) (void *data)
<a name="typedef int(* wl_event_loop_timer_func_t) (void *data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Timer dispatch
function type</p>
<p style="margin-left:9%; margin-top: 1em">Functions of
this type are used as callbacks for timer expiry.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>data</i> The user data
argument of the related <b>wl_event_loop_add_timer()</b>
call.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">If the event source is
registered for re-check with <b>wl_event_source_check()</b>:
0 for all done, 1 for needing a re-check. If not registered,
the return value is ignored and should be zero.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_add_timer()</b></p>
<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>
<h3>struct wl_event_source * wl_event_loop_add_fd (struct wl_event_loop * loop,int fd, uint32_t mask, wl_event_loop_fd_func_t func, void * data)
<a name="struct wl_event_source * wl_event_loop_add_fd (struct wl_event_loop * loop,int fd, uint32_t mask, wl_event_loop_fd_func_t func, void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a file
descriptor event source</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop that
will process the new source. <i><br/>
fd</i> The file descriptor to watch. <i><br/>
mask</i> A bitwise-or of which events to watch for:
WL_EVENT_READABLE, WL_EVENT_WRITABLE. <i><br/>
func</i> The file descriptor dispatch function. <i><br/>
data</i> User data.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new file descriptor event
source.</p>
<p style="margin-left:9%; margin-top: 1em">The given file
descriptor is initially watched for the events given in
mask. This can be changed as needed with
<b>wl_event_source_fd_update()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">If it is
possible that program execution causes the file descriptor
to be read while leaving the data in a buffer without
actually processing it, it may be necessary to register the
file descriptor source to be re-checked, see
<b>wl_event_source_check()</b>. This will ensure that the
dispatch function gets called even if the file descriptor is
not readable or writable anymore. This is especially useful
with IPC libraries that automatically buffer incoming data,
possibly as a side-effect of other operations.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_fd_func_t</b></p>
<h3>struct wl_event_source * wl_event_loop_add_idle (struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void * data)
<a name="struct wl_event_source * wl_event_loop_add_idle (struct wl_event_loop *loop, wl_event_loop_idle_func_t func, void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create an idle
task</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop that
will process the new task. <i><br/>
func</i> The idle task dispatch function. <i><br/>
data</i> User data.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new idle task (an event
source).</p>
<p style="margin-left:9%; margin-top: 1em">Idle tasks are
dispatched before <b>wl_event_loop_dispatch()</b> goes to
sleep. See <b>wl_event_loop_dispatch()</b> for more
details.</p>
<p style="margin-left:9%; margin-top: 1em">Idle tasks fire
once, and are automatically destroyed right after the
callback function has been called.</p>
<p style="margin-left:9%; margin-top: 1em">An idle task can
be cancelled before the callback has been called by
<b>wl_event_source_remove()</b>. Calling
<b>wl_event_source_remove()</b> after or from within the
callback results in undefined behaviour.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_idle_func_t</b></p>
<h3>struct wl_event_source * wl_event_loop_add_signal (struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void * data)
<a name="struct wl_event_source * wl_event_loop_add_signal (struct wl_event_loop *loop, int signal_number, wl_event_loop_signal_func_t func, void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a POSIX
signal event source</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop that
will process the new source. <i><br/>
signal_number</i> Number of the signal to watch for. <i><br/>
func</i> The signal dispatch function. <i><br/>
data</i> User data.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new signal event source.</p>
<p style="margin-left:9%; margin-top: 1em">This function
blocks the normal delivery of the given signal in the
calling thread, and creates a ’watch’ for it.
Signal delivery no longer happens asynchronously, but by
<b>wl_event_loop_dispatch()</b> calling the dispatch
callback function func.</p>
<p style="margin-left:9%; margin-top: 1em">It is the
caller’s responsibility to ensure that all other
threads have also blocked the signal.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_signal_func_t</b></p>
<h3>struct wl_event_source * wl_event_loop_add_timer (struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void * data)
<a name="struct wl_event_source * wl_event_loop_add_timer (struct wl_event_loop *loop, wl_event_loop_timer_func_t func, void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a timer
event source</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop that
will process the new source. <i><br/>
func</i> The timer dispatch function. <i><br/>
data</i> User data.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new timer event source.</p>
<p style="margin-left:9%; margin-top: 1em">The timer is
initially disarmed. It needs to be armed with a call to
<b>wl_event_source_timer_update()</b> before it can trigger
a dispatch call.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_timer_func_t</b></p>
<h3>void wl_event_source_check (struct wl_event_source * source)
<a name="void wl_event_source_check (struct wl_event_source * source)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Mark event
source to be re-checked</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>source</i> The event source
to be re-checked.</p>
<p style="margin-left:9%; margin-top: 1em">This function
permanently marks the event source to be re-checked after
the normal dispatch of sources in
<b>wl_event_loop_dispatch()</b>. Re-checking will keep
iterating over all such event sources until the dispatch
function for them all returns zero.</p>
<p style="margin-left:9%; margin-top: 1em">Re-checking is
used on sources that may become ready to dispatch as a
side-effect of dispatching themselves or other event
sources, including idle sources. Re-checking ensures all the
incoming events have been fully drained before
<b>wl_event_loop_dispatch()</b> returns.</p>
<h3>int wl_event_source_fd_update (struct wl_event_source * source, uint32_tmask)
<a name="int wl_event_source_fd_update (struct wl_event_source * source, uint32_tmask)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Update a file
descriptor source’s event mask</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>source</i> The file
descriptor event source to update. <i><br/>
mask</i> The new mask, a bitwise-or of: WL_EVENT_READABLE,
WL_EVENT_WRITABLE.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success, -1 on
failure.</p>
<p style="margin-left:9%; margin-top: 1em">This changes
which events, readable and/or writable, cause the dispatch
callback to be called on.</p>
<p style="margin-left:9%; margin-top: 1em">File descriptors
are usually writable to begin with, so they do not need to
be polled for writable until a write actually fails. When a
write fails, the event mask can be changed to poll for
readable and writable, delivering a dispatch callback when
it is possible to write more. Once all data has been
written, the mask can be changed to poll only for readable
to avoid busy-looping on dispatch.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_add_fd()</b></p>
<h3>int wl_event_source_remove (struct wl_event_source * source)
<a name="int wl_event_source_remove (struct wl_event_source * source)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Remove an event
source from its event loop</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>source</i> The event source
to be removed.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">Zero.</p>
<p style="margin-left:9%; margin-top: 1em">The event source
is removed from the event loop it was created for, and is
effectively destroyed. This invalidates source . The
dispatch function of the source will no longer be called
through this source.</p>
<h3>int wl_event_source_timer_update (struct wl_event_source * source, intms_delay)
<a name="int wl_event_source_timer_update (struct wl_event_source * source, intms_delay)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Arm or disarm a
timer</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>source</i> The timer event
source to modify. <i><br/>
ms_delay</i> The timeout in milliseconds.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success, -1 on
failure.</p>
<p style="margin-left:9%; margin-top: 1em">If the timeout
is zero, the timer is disarmed.</p>
<p style="margin-left:9%; margin-top: 1em">If the timeout
is non-zero, the timer is set to expire after the given
timeout in milliseconds. When the timer expires, the
dispatch function set with <b>wl_event_loop_add_timer()</b>
is called once from <b>wl_event_loop_dispatch()</b>. If
another dispatch is desired after another expiry,
<b>wl_event_source_timer_update()</b> needs to be called
again.</p>
<h2>Author
<a name="Author"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated
automatically by Doxygen for Wayland from the source
code.</p>
<hr/>
</body>
</html>
