<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:54:47 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Dumper</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Dumper</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#EXTENDED SYNOPSIS">EXTENDED SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#FUNCTIONS AND METHODS">FUNCTIONS AND METHODS</a><br/>
<a href="#EXPORTS">EXPORTS</a><br/>
<a href="#BUGS AND DEPENDENCIES">BUGS AND DEPENDENCIES</a><br/>
<a href="#REVISIONS AND CREDITS">REVISIONS AND CREDITS</a><br/>
<a href="#CURRENT MAINTAINER">CURRENT MAINTAINER</a><br/>
<a href="#ORIGINAL AUTHOR">ORIGINAL AUTHOR</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">XML::Dumper
− Perl module for dumping Perl objects from/to XML</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"># ===== Using an
object <br/>
use XML::Dumper; <br/>
$dump = new XML::Dumper; <br/>
$xml = $dump−&gt;pl2xml( $perl ); <br/>
$perl = $dump−&gt;xml2pl( $xml ); <br/>
$dump−&gt;pl2xml( $perl,
"my_perl_data.xml.gz" ); <br/>
# ===== Using function calls <br/>
use XML::Dumper; <br/>
$xml = pl2xml( $perl ); <br/>
$perl = xml2pl( $xml );</p>
<h2>EXTENDED SYNOPSIS
<a name="EXTENDED SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use XML::Dumper;
<br/>
my $dump = new XML::Dumper; <br/>
my $perl = ''; <br/>
my $xml = ''; <br/>
# ===== Convert Perl code to XML <br/>
$perl = [ <br/>
{ <br/>
fname =&gt; 'Fred', <br/>
lname =&gt; 'Flintstone', <br/>
residence =&gt; 'Bedrock' <br/>
}, <br/>
{ <br/>
fname =&gt; 'Barney', <br/>
lname =&gt; 'Rubble', <br/>
residence =&gt; 'Bedrock' <br/>
} <br/>
]; <br/>
$xml = $dump−&gt;pl2xml( $perl ); <br/>
# ===== Dump to a file <br/>
my $file = "dump.xml"; <br/>
$dump−&gt;pl2xml( $perl, $file ); <br/>
# ===== Convert XML to Perl code <br/>
$xml = q| <br/>
&lt;perldata&gt; <br/>
&lt;arrayref&gt; <br/>
&lt;item key="0"&gt; <br/>
&lt;hashref&gt; <br/>
&lt;item key="fname"&gt;Fred&lt;/item&gt; <br/>
&lt;item key="lname"&gt;Flintstone&lt;/item&gt;
<br/>
&lt;item key="residence"&gt;Bedrock&lt;/item&gt;
<br/>
&lt;/hashref&gt; <br/>
&lt;/item&gt; <br/>
&lt;item key="1"&gt; <br/>
&lt;hashref&gt; <br/>
&lt;item key="fname"&gt;Barney&lt;/item&gt; <br/>
&lt;item key="lname"&gt;Rubble&lt;/item&gt; <br/>
&lt;item key="residence"&gt;Bedrock&lt;/item&gt;
<br/>
&lt;/hashref&gt; <br/>
&lt;/item&gt; <br/>
&lt;/arrayref&gt; <br/>
&lt;/perldata&gt; <br/>
|; <br/>
my $perl = $dump−&gt;xml2pl( $xml ); <br/>
# ===== Convert an XML file to Perl code <br/>
my $perl = $dump−&gt;xml2pl( $file ); <br/>
# ===== And serialize Perl code to an XML file <br/>
$dump−&gt;pl2xml( $perl, $file ); <br/>
# ===== USE COMPRESSION <br/>
$dump−&gt;pl2xml( $perl, $file.".gz" ); <br/>
# ===== INCLUDE AN IN−DOCUMENT DTD <br/>
$dump−&gt;dtd; <br/>
my $xml_with_dtd = $dump−&gt;pl2xml( $perl ); <br/>
# ===== USE EXTERNAL DTD <br/>
$dump−&gt;dtd( $file, $url ); <br/>
my $xml_with_link_to_dtd = $dump−&gt;pl2xml( $perl
);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">XML::Dumper
dumps Perl data to XML format. XML::Dumper can also read XML
data that was previously dumped by the module and convert it
back to Perl. You can use the module read the XML from a
file and write the XML to a file. Perl objects are blessed
back to their original packaging; if the modules are
installed on the system where the perl objects are
reconstituted from xml, they will behave as expected.
Intuitively, if the perl objects are converted and
reconstituted in the same environment, all should be well.
And it is.</p>
<p style="margin-left:9%; margin-top: 1em">Additionally,
because XML benefits so nicely from compression, XML::Dumper
understands gzipped XML files. It does so with an optional
dependency on Compress::Zlib. So, if you dump a Perl
variable with a file that has an extension of '.xml.gz', it
will store and compress the file in gzipped format.
Likewise, if you read a file with the extension '.xml.gz',
it will uncompress the file in memory before parsing the XML
back into a Perl variable.</p>
<p style="margin-left:9%; margin-top: 1em">Another fine
challenge that this module rises to meet is that it
understands circular definitions and multiple references to
a single object. This includes doubly−linked lists,
circular references, and the so−called 'Flyweight'
pattern of Object Oriented programming. So it can take the
gnarliest of your perl data, and should do just fine.</p>
<p style="margin-left:9%; margin-top: 1em">One caveat;
XML::Dumper does not handle binary data. There have been
discussions in the expat mailing list archives discussing
the challenges associated with encoding binary data with
XML. I chose the cowardly path of making the problem a
non−issue by not addressing it. To store binary data,
one could encode the data into ASCII before encapsulating
the data as XML, and then reverse the process to restore the
data. There are several Perl modules that one can use for
this, Convert::UU, for example.</p>
<h3>FUNCTIONS AND METHODS
<a name="FUNCTIONS AND METHODS"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="41%">
<p style="margin-top: 1em"><b>new()</b> − XML::Dumper
constructor.</p> </td>
<td width="45%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Creates a lean,
mean, XML dumping machine. It's also completely at your
disposal.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="7%">
<p style="margin-top: 1em">dtd −</p></td>
<td width="79%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Generates a
Document Type Dictionary for the 'perldata' data type. The
default behaviour is to embed the DTD in the XML, thereby
creating valid XML. Given a filename, the DTD will be
written out to that file and the XML document for your Perl
data will link to the file. Given a filename and an URL, the
DTD will be written out the file and the XML document will
link to the URL. XML::Dumper doesn't try really hard to
determine where your DTD's ought to go or relative paths or
anything, so be careful with what arguments you supply this
method, or just go with the default with the embedded DTD.
Between DTD's and Schemas, the potential for more
free−form data to be imported and exported becomes
feasible.</p>
<p style="margin-left:14%; margin-top: 1em">Usage:</p>
<p style="margin-left:14%; margin-top: 1em">dtd(); # Causes
XML to include embedded DTD <br/>
dtd( $file ); # DTD saved to $file; XML will link to $file
<br/>
dtd( $file, $url ); # DTD saved to $file; XML will link to
$url <br/>
dtd( 0 ); # Prevents XML from including embedded DTD</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="35%">
<p style="margin-top: 1em">pl2xml( $xml, [ $file ] )
−</p> </td>
<td width="51%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">(Also
<b>perl2xml()</b>, for those who enjoy readability over
brevity).</p>
<p style="margin-left:14%; margin-top: 1em">Converts Perl
data to XML. If a second argument is given, then the Perl
data will be stored to disk as XML, using the second
argument as a filename.</p>
<p style="margin-left:14%; margin-top: 1em">Usage: See
Synopsis</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="55%">
<p style="margin-top: 1em">xml2pl( $xml_or_filename, [
$callback ] ) −</p></td>
<td width="31%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">(Also
<b>xml2perl()</b>, for those who enjoy readability over
brevity.)</p>
<p style="margin-left:14%; margin-top: 1em">Converts XML to
a Perl datatype. If this method is given a second argument,
XML::Dumper will use the second argument as a callback (if
possible). If the first argument isn't XML and exists as a
file, that file will be read and its contents will be used
as the input XML.</p>
<p style="margin-left:14%; margin-top: 1em">Currently, the
only supported invocation of callbacks is through soft
references. That is to say, the callback argument ought to
be a string that matches the name of a callable method for
your classes. If you have a congruent interface, this should
work like a peach. If your class interface doesn't have such
a named method, it won't be called.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="69%">
<p style="margin-top: 1em">xml_compare( $xml1, $xml2 )
− Compares xml for content</p></td>
<td width="17%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Compares two
dumped Perl data structures (that is, compares the xml) for
identity in content. Use this function rather than perl's
built−in string comparison. This function will return
true for any two perl data that are either deep clones of
each other, or identical. This method is exported by
default.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="72%">
<p style="margin-top: 1em">xml_identity( $xml1, $xml2 )
− Compares xml for identity</p></td>
<td width="14%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Compares two
dumped Perl data structures (that is, compares the xml) for
identity in instantiation. This function will return true
for any two perl data that are identical, but not for deep
clones of each other. This method is also exported by
default.</p>
<h2>EXPORTS
<a name="EXPORTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">By default, the
following methods are exported:</p>
<p style="margin-left:9%; margin-top: 1em">xml2pl, pl2xml,
xml_compare, xml_identity</p>
<h2>BUGS AND DEPENDENCIES
<a name="BUGS AND DEPENDENCIES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">XML::Dumper has
changed API since 0.4, as a response to a bug report from
PerlMonks. I felt it was necessary, as the functions simply
didn't work as advertised. That is, xml2pl really didnt
accept xml as an argument; what it wanted was an XML Parse
tree. To correct for the API change, simply don't parse the
XML before feeding it to XML::Dumper.</p>
<p style="margin-left:9%; margin-top: 1em">XML::Dumper also
has no understanding of typeglobs (references or not),
references to regular expressions, or references to Perl
subroutines. Turns out that Data::Dumper doesn't do
references to Perl subroutines, either, so at least I'm in
somewhat good company.</p>
<p style="margin-left:9%; margin-top: 1em">XML::Dumper
requires one perl module, available from CPAN</p>
<p style="margin-left:9%; margin-top: 1em">XML::Parser</p>
<p style="margin-left:9%; margin-top: 1em">XML::Parser
itself relies on Clark Cooper's Expat implementation in
Perl, which in turn requires James Clark's expat package
itself. See the documentation for XML::Parser for more
information.</p>
<h2>REVISIONS AND CREDITS
<a name="REVISIONS AND CREDITS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The list of
credits got so long that I had to move it to the Changes
file. Thanks to all those who've contributed with bug
reports and suggested features! Keep 'em coming!</p>
<p style="margin-left:9%; margin-top: 1em">I've had
ownership of the module since June of 2002, and very much
appreciate requests on how to make the module better. It has
served me well, both as a learning tool on how I can repay
my debt to the Perl Community, and as a practical module
that is useful. I'm thrilled to be able to offer this bit of
code. So, if you have suggestions, bug reports, or feature
requests, please let me know and I'll do my best to make
this a better module.</p>
<h2>CURRENT MAINTAINER
<a name="CURRENT MAINTAINER"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Mike Wong
&lt;mike_w3@pacbell.net&gt;</p>
<p style="margin-left:9%; margin-top: 1em">XML::Dumper is
free software. You can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<h2>ORIGINAL AUTHOR
<a name="ORIGINAL AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Jonathan
Eisenzopf &lt;eisen@pobox.com&gt;</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>perl</b>(1)
<b>Compress::Zlib</b>(3) <b>XML::Parser</b>(3)
<b>Data::DumpXML</b>(3)</p>
<hr/>
</body>
</html>
