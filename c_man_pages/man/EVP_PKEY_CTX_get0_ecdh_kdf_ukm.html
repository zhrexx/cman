<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:42:36 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EVP_PKEY_CTX_CTRL</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">EVP_PKEY_CTX_CTRL</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RSA parameters">RSA parameters</a><br/>
<a href="#DSA parameters">DSA parameters</a><br/>
<a href="#DH parameters">DH parameters</a><br/>
<a href="#DH key derivation function parameters">DH key derivation function parameters</a><br/>
<a href="#EC parameters">EC parameters</a><br/>
<a href="#ECDH parameters">ECDH parameters</a><br/>
<a href="#ECDH key derivation function parameters">ECDH key derivation function parameters</a><br/>
<a href="#Other parameters">Other parameters</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">EVP_PKEY_CTX_ctrl,
EVP_PKEY_CTX_ctrl_str, EVP_PKEY_CTX_ctrl_uint64,
EVP_PKEY_CTX_md, EVP_PKEY_CTX_set_signature_md,
EVP_PKEY_CTX_get_signature_md, EVP_PKEY_CTX_set_mac_key,
EVP_PKEY_CTX_set_group_name, EVP_PKEY_CTX_get_group_name,
EVP_PKEY_CTX_set_rsa_padding, EVP_PKEY_CTX_get_rsa_padding,
EVP_PKEY_CTX_set_rsa_pss_saltlen,
EVP_PKEY_CTX_get_rsa_pss_saltlen,
EVP_PKEY_CTX_set_rsa_keygen_bits,
EVP_PKEY_CTX_set_rsa_keygen_pubexp,
EVP_PKEY_CTX_set1_rsa_keygen_pubexp,
EVP_PKEY_CTX_set_rsa_keygen_primes,
EVP_PKEY_CTX_set_rsa_mgf1_md_name,
EVP_PKEY_CTX_set_rsa_mgf1_md, EVP_PKEY_CTX_get_rsa_mgf1_md,
EVP_PKEY_CTX_get_rsa_mgf1_md_name,
EVP_PKEY_CTX_set_rsa_oaep_md_name,
EVP_PKEY_CTX_set_rsa_oaep_md, EVP_PKEY_CTX_get_rsa_oaep_md,
EVP_PKEY_CTX_get_rsa_oaep_md_name,
EVP_PKEY_CTX_set0_rsa_oaep_label,
EVP_PKEY_CTX_get0_rsa_oaep_label,
EVP_PKEY_CTX_set_dsa_paramgen_bits,
EVP_PKEY_CTX_set_dsa_paramgen_q_bits,
EVP_PKEY_CTX_set_dsa_paramgen_md,
EVP_PKEY_CTX_set_dsa_paramgen_md_props,
EVP_PKEY_CTX_set_dsa_paramgen_gindex,
EVP_PKEY_CTX_set_dsa_paramgen_type,
EVP_PKEY_CTX_set_dsa_paramgen_seed,
EVP_PKEY_CTX_set_dh_paramgen_prime_len,
EVP_PKEY_CTX_set_dh_paramgen_subprime_len,
EVP_PKEY_CTX_set_dh_paramgen_generator,
EVP_PKEY_CTX_set_dh_paramgen_type,
EVP_PKEY_CTX_set_dh_paramgen_gindex,
EVP_PKEY_CTX_set_dh_paramgen_seed,
EVP_PKEY_CTX_set_dh_rfc5114, EVP_PKEY_CTX_set_dhx_rfc5114,
EVP_PKEY_CTX_set_dh_pad, EVP_PKEY_CTX_set_dh_nid,
EVP_PKEY_CTX_set_dh_kdf_type, EVP_PKEY_CTX_get_dh_kdf_type,
EVP_PKEY_CTX_set0_dh_kdf_oid, EVP_PKEY_CTX_get0_dh_kdf_oid,
EVP_PKEY_CTX_set_dh_kdf_md, EVP_PKEY_CTX_get_dh_kdf_md,
EVP_PKEY_CTX_set_dh_kdf_outlen,
EVP_PKEY_CTX_get_dh_kdf_outlen,
EVP_PKEY_CTX_set0_dh_kdf_ukm, EVP_PKEY_CTX_get0_dh_kdf_ukm,
EVP_PKEY_CTX_set_ec_paramgen_curve_nid,
EVP_PKEY_CTX_set_ec_param_enc,
EVP_PKEY_CTX_set_ecdh_cofactor_mode,
EVP_PKEY_CTX_get_ecdh_cofactor_mode,
EVP_PKEY_CTX_set_ecdh_kdf_type,
EVP_PKEY_CTX_get_ecdh_kdf_type,
EVP_PKEY_CTX_set_ecdh_kdf_md, EVP_PKEY_CTX_get_ecdh_kdf_md,
EVP_PKEY_CTX_set_ecdh_kdf_outlen,
EVP_PKEY_CTX_get_ecdh_kdf_outlen,
EVP_PKEY_CTX_set0_ecdh_kdf_ukm,
EVP_PKEY_CTX_get0_ecdh_kdf_ukm, EVP_PKEY_CTX_set1_id,
EVP_PKEY_CTX_get1_id, EVP_PKEY_CTX_get1_id_len,
EVP_PKEY_CTX_set_kem_op − algorithm specific control
operations</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/evp.h&gt; <br/>
int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int
optype, <br/>
int cmd, int p1, void *p2); <br/>
int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype,
int optype, <br/>
int cmd, uint64_t value); <br/>
int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char
*type, <br/>
const char *value); <br/>
int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd,
const char *md); <br/>
int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br/>
int EVP_PKEY_CTX_get_signature_md(EVP_PKEY_CTX *ctx, const
EVP_MD **pmd); <br/>
int EVP_PKEY_CTX_set_mac_key(EVP_PKEY_CTX *ctx, const
unsigned char *key, <br/>
int len); <br/>
int EVP_PKEY_CTX_set_group_name(EVP_PKEY_CTX *ctx, const
char *name); <br/>
int EVP_PKEY_CTX_get_group_name(EVP_PKEY_CTX *ctx, char
*name, size_t namelen); <br/>
int EVP_PKEY_CTX_set_kem_op(EVP_PKEY_CTX *ctx, const char
*op); <br/>
#include &lt;openssl/rsa.h&gt; <br/>
int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int
pad); <br/>
int EVP_PKEY_CTX_get_rsa_padding(EVP_PKEY_CTX *ctx, int
*pad); <br/>
int EVP_PKEY_CTX_set_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int
saltlen); <br/>
int EVP_PKEY_CTX_get_rsa_pss_saltlen(EVP_PKEY_CTX *ctx, int
*saltlen); <br/>
int EVP_PKEY_CTX_set_rsa_keygen_bits(EVP_PKEY_CTX *ctx, int
mbits); <br/>
int EVP_PKEY_CTX_set1_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx,
BIGNUM *pubexp); <br/>
int EVP_PKEY_CTX_set_rsa_keygen_primes(EVP_PKEY_CTX *ctx,
int primes); <br/>
int EVP_PKEY_CTX_set_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx,
const char *mdname, <br/>
const char *mdprops); <br/>
int EVP_PKEY_CTX_set_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br/>
int EVP_PKEY_CTX_get_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br/>
int EVP_PKEY_CTX_get_rsa_mgf1_md_name(EVP_PKEY_CTX *ctx,
char *name, <br/>
size_t namelen); <br/>
int EVP_PKEY_CTX_set_rsa_oaep_md_name(EVP_PKEY_CTX *ctx,
const char *mdname, <br/>
const char *mdprops); <br/>
int EVP_PKEY_CTX_set_rsa_oaep_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br/>
int EVP_PKEY_CTX_get_rsa_oaep_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br/>
int EVP_PKEY_CTX_get_rsa_oaep_md_name(EVP_PKEY_CTX *ctx,
char *name, <br/>
size_t namelen); <br/>
int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx, void
*label, <br/>
int len); <br/>
int EVP_PKEY_CTX_get0_rsa_oaep_label(EVP_PKEY_CTX *ctx,
unsigned char **label); <br/>
#include &lt;openssl/dsa.h&gt; <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_bits(EVP_PKEY_CTX *ctx,
int nbits); <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_q_bits(EVP_PKEY_CTX *ctx,
int qbits); <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_md(EVP_PKEY_CTX *ctx,
const EVP_MD *md); <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_md_props(EVP_PKEY_CTX
*ctx, <br/>
const char *md_name, <br/>
const char *md_properties); <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_type(EVP_PKEY_CTX *ctx,
const char *name); <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_gindex(EVP_PKEY_CTX *ctx,
int gindex); <br/>
int EVP_PKEY_CTX_set_dsa_paramgen_seed(EVP_PKEY_CTX *ctx,
<br/>
const unsigned char *seed, <br/>
size_t seedlen); <br/>
#include &lt;openssl/dh.h&gt; <br/>
int EVP_PKEY_CTX_set_dh_paramgen_prime_len(EVP_PKEY_CTX
*ctx, int len); <br/>
int EVP_PKEY_CTX_set_dh_paramgen_subprime_len(EVP_PKEY_CTX
*ctx, int len); <br/>
int EVP_PKEY_CTX_set_dh_paramgen_generator(EVP_PKEY_CTX
*ctx, int gen); <br/>
int EVP_PKEY_CTX_set_dh_paramgen_type(EVP_PKEY_CTX *ctx, int
type); <br/>
int EVP_PKEY_CTX_set_dh_pad(EVP_PKEY_CTX *ctx, int pad);
<br/>
int EVP_PKEY_CTX_set_dh_nid(EVP_PKEY_CTX *ctx, int nid);
<br/>
int EVP_PKEY_CTX_set_dh_rfc5114(EVP_PKEY_CTX *ctx, int
rfc5114); <br/>
int EVP_PKEY_CTX_set_dhx_rfc5114(EVP_PKEY_CTX *ctx, int
rfc5114); <br/>
int EVP_PKEY_CTX_set_dh_paramgen_gindex(EVP_PKEY_CTX *ctx,
int gindex); <br/>
int EVP_PKEY_CTX_set_dh_paramgen_seed(EVP_PKEY_CTX *ctx,
<br/>
const unsigned char *seed, <br/>
size_t seedlen); <br/>
int EVP_PKEY_CTX_set_dh_kdf_type(EVP_PKEY_CTX *ctx, int
kdf); <br/>
int EVP_PKEY_CTX_get_dh_kdf_type(EVP_PKEY_CTX *ctx); <br/>
int EVP_PKEY_CTX_set0_dh_kdf_oid(EVP_PKEY_CTX *ctx,
ASN1_OBJECT *oid); <br/>
int EVP_PKEY_CTX_get0_dh_kdf_oid(EVP_PKEY_CTX *ctx,
ASN1_OBJECT **oid); <br/>
int EVP_PKEY_CTX_set_dh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br/>
int EVP_PKEY_CTX_get_dh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br/>
int EVP_PKEY_CTX_set_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int
len); <br/>
int EVP_PKEY_CTX_get_dh_kdf_outlen(EVP_PKEY_CTX *ctx, int
*len); <br/>
int EVP_PKEY_CTX_set0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned
char *ukm, int len); <br/>
#include &lt;openssl/ec.h&gt; <br/>
int EVP_PKEY_CTX_set_ec_paramgen_curve_nid(EVP_PKEY_CTX
*ctx, int nid); <br/>
int EVP_PKEY_CTX_set_ec_param_enc(EVP_PKEY_CTX *ctx, int
param_enc); <br/>
int EVP_PKEY_CTX_set_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx,
int cofactor_mode); <br/>
int EVP_PKEY_CTX_get_ecdh_cofactor_mode(EVP_PKEY_CTX *ctx);
<br/>
int EVP_PKEY_CTX_set_ecdh_kdf_type(EVP_PKEY_CTX *ctx, int
kdf); <br/>
int EVP_PKEY_CTX_get_ecdh_kdf_type(EVP_PKEY_CTX *ctx); <br/>
int EVP_PKEY_CTX_set_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD *md); <br/>
int EVP_PKEY_CTX_get_ecdh_kdf_md(EVP_PKEY_CTX *ctx, const
EVP_MD **md); <br/>
int EVP_PKEY_CTX_set_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int
len); <br/>
int EVP_PKEY_CTX_get_ecdh_kdf_outlen(EVP_PKEY_CTX *ctx, int
*len); <br/>
int EVP_PKEY_CTX_set0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx,
unsigned char *ukm, int len); <br/>
int EVP_PKEY_CTX_set1_id(EVP_PKEY_CTX *ctx, void *id, size_t
id_len); <br/>
int EVP_PKEY_CTX_get1_id(EVP_PKEY_CTX *ctx, void *id); <br/>
int EVP_PKEY_CTX_get1_id_len(EVP_PKEY_CTX *ctx, size_t
*id_len);</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining <b>OPENSSL_API_COMPAT</b> with a
suitable version value, see
<b>openssl_user_macros</b>(7):</p>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/rsa.h&gt; <br/>
int EVP_PKEY_CTX_set_rsa_keygen_pubexp(EVP_PKEY_CTX *ctx,
BIGNUM *pubexp); <br/>
#include &lt;openssl/dh.h&gt; <br/>
int EVP_PKEY_CTX_get0_dh_kdf_ukm(EVP_PKEY_CTX *ctx, unsigned
char **ukm); <br/>
#include &lt;openssl/ec.h&gt; <br/>
int EVP_PKEY_CTX_get0_ecdh_kdf_ukm(EVP_PKEY_CTX *ctx,
unsigned char **ukm);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_ctrl()</b>
sends a control operation to the context <i>ctx</i>. The key
type used must match <i>keytype</i> if it is not −1.
The parameter <i>optype</i> is a mask indicating which
operations the control can be applied to. The control
command is indicated in <i>cmd</i> and any additional
arguments in <i>p1</i> and <i>p2</i>.</p>
<p style="margin-left:9%; margin-top: 1em">For <i>cmd</i> =
<b>EVP_PKEY_CTRL_SET_MAC_KEY</b>, <i>p1</i> is the length of
the MAC key, and <i>p2</i> is the MAC key. This is used by
Poly1305, SipHash, HMAC and CMAC.</p>
<p style="margin-left:9%; margin-top: 1em">Applications
will not normally call <b>EVP_PKEY_CTX_ctrl()</b> directly
but will instead call one of the algorithm specific
functions below.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_ctrl_uint64()</b>
is a wrapper that directly passes a uint64 value as
<i>p2</i> to <b>EVP_PKEY_CTX_ctrl()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_ctrl_str()</b>
allows an application to send an algorithm specific control
operation to a context <i>ctx</i> in string form. This is
intended to be used for options specified on the command
line or in text files. The commands supported are documented
in the openssl utility command line pages for the option
<i>−pkeyopt</i> which is supported by the
<i>pkeyutl</i>, <i>genpkey</i> and <i>req</i> commands.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_md()</b>
sends a message digest control operation to the context
<i>ctx</i>. The message digest is specified by its name
<i>md</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_signature_md()</b>
sets the message digest type used in a signature. It can be
used in the RSA, DSA and ECDSA algorithms.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_signature_md()</b>gets
the message digest type used in a signature. It can be used
in the RSA, DSA and ECDSA algorithms.</p>
<p style="margin-left:9%; margin-top: 1em">Key generation
typically involves setting up parameters to be used and
generating the private and public key data. Some algorithm
implementations allow private key data to be set explicitly
using <b>EVP_PKEY_CTX_set_mac_key()</b>. In this case key
generation is simply the process of setting up the
parameters for the key and then setting the raw key data to
the value explicitly. Normally applications would call
<b>EVP_PKEY_new_raw_private_key</b>(3) or similar functions
instead.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_mac_key()</b>
can be used with any of the algorithms supported by the
<b>EVP_PKEY_new_raw_private_key</b>(3) function.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_group_name()</b>
sets the group name to <i>name</i> for parameter and key
generation. For example for EC keys this will set the curve
name and for DH keys it will set the name of the finite
field group.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_group_name()</b>
finds the group name that's currently set with <i>ctx</i>,
and writes it to the location that <i>name</i> points at, as
long as its size <i>namelen</i> is large enough to store
that name, including a terminating NUL byte.</p>
<h3>RSA parameters
<a name="RSA parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_padding()</b>
sets the RSA padding mode for <i>ctx</i>. The <i>pad</i>
parameter can take the value <b>RSA_PKCS1_PADDING</b> for
PKCS#1 padding, <b>RSA_NO_PADDING</b> for no padding,
<b>RSA_PKCS1_OAEP_PADDING</b> for OAEP padding (encrypt and
decrypt only), <b>RSA_X931_PADDING</b> for X9.31 padding
(signature operations only), <b>RSA_PKCS1_PSS_PADDING</b>
(sign and verify only) and <b>RSA_PKCS1_WITH_TLS_PADDING</b>
for TLS RSA ClientKeyExchange message padding (decryption
only).</p>
<p style="margin-left:9%; margin-top: 1em">Two RSA padding
modes behave differently if
<b>EVP_PKEY_CTX_set_signature_md()</b> is used. If this
function is called for PKCS#1 padding the plaintext buffer
is an actual digest value and is encapsulated in a
DigestInfo structure according to PKCS#1 when signing and
this structure is expected (and stripped off) when
verifying. If this control is not used with RSA and PKCS#1
padding then the supplied data is used directly and not
encapsulated. In the case of X9.31 padding for RSA the
algorithm identifier byte is added or checked and removed if
this control is called. If it is not called then the first
byte of the plaintext buffer is expected to be the algorithm
identifier byte.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_padding()</b>
gets the RSA padding mode for <i>ctx</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_pss_saltlen()</b>
sets the RSA PSS salt length to <i>saltlen</i>. As its name
implies it is only supported for PSS padding. If this
function is not called then the salt length is maximized up
to the digest length when signing and auto detection when
verifying. Four special values are supported: <b><br/>
RSA_PSS_SALTLEN_DIGEST</b></p>
<p style="margin-left:14%;">sets the salt length to the
digest length.</p>
<p style="margin-left:9%;"><b>RSA_PSS_SALTLEN_MAX</b></p>
<p style="margin-left:14%;">sets the salt length to the
maximum permissible value.</p>
<p style="margin-left:9%;"><b>RSA_PSS_SALTLEN_AUTO</b></p>
<p style="margin-left:14%;">causes the salt length to be
automatically determined based on the <b>PSS</b> block
structure when verifying. When signing, it has the same
meaning as <b>RSA_PSS_SALTLEN_MAX</b>.</p>
<p style="margin-left:9%;"><b>RSA_PSS_SALTLEN_AUTO_DIGEST_MAX</b></p>
<p style="margin-left:14%;">causes the salt length to be
automatically determined based on the <b>PSS</b> block
structure when verifying, like <b>RSA_PSS_SALTLEN_AUTO</b>.
When signing, the salt length is maximized up to a maximum
of the digest length to comply with FIPS 186−4 section
5.5.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_pss_saltlen()</b>
gets the RSA PSS salt length for <i>ctx</i>. The padding
mode must already have been set to
<b>RSA_PKCS1_PSS_PADDING</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_bits()</b>
sets the RSA key length for RSA key generation to
<i>bits</i>. If not specified 2048 bits is used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set1_rsa_keygen_pubexp()</b>
sets the public exponent value for RSA key generation to the
value stored in <i>pubexp</i>. Currently it should be an odd
integer. In accordance with the OpenSSL naming convention,
the <i>pubexp</i> pointer must be freed independently of the
EVP_PKEY_CTX (ie, it is internally copied). If not specified
65537 is used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_pubexp()</b>
does the same as
<b>EVP_PKEY_CTX_set1_rsa_keygen_pubexp()</b> except that
there is no internal copy and therefore <i>pubexp</i> should
not be modified or freed after the call.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_primes()</b>
sets the number of primes for RSA key generation to
<i>primes</i>. If not specified 2 is used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_mgf1_md_name()</b>
sets the MGF1 digest for RSA padding schemes to the digest
named <i>mdname</i>. If the RSA algorithm implementation for
the selected provider supports it then the digest will be
fetched using the properties <i>mdprops</i>. If not
explicitly set the signing digest is used. The padding mode
must have been set to <b>RSA_PKCS1_OAEP_PADDING</b> or
<b>RSA_PKCS1_PSS_PADDING</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_mgf1_md()</b>
does the same as <b>EVP_PKEY_CTX_set_rsa_mgf1_md_name()</b>
except that the name of the digest is inferred from the
supplied <i>md</i> and it is not possible to specify any
properties.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_mgf1_md_name()</b>
gets the name of the MGF1 digest algorithm for <i>ctx</i>.
If not explicitly set the signing digest is used. The
padding mode must have been set to
<b>RSA_PKCS1_OAEP_PADDING</b> or
<b>RSA_PKCS1_PSS_PADDING</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_mgf1_md()</b>
does the same as <b>EVP_PKEY_CTX_get_rsa_mgf1_md_name()</b>
except that it returns a pointer to an EVP_MD object
instead. Note that only known, built−in EVP_MD objects
will be returned. The EVP_MD object may be NULL if the
digest is not one of these (such as a digest only
implemented in a third party provider).</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_oaep_md_name()</b>
sets the message digest type used in RSA OAEP to the digest
named <i>mdname</i>. If the RSA algorithm implementation for
the selected provider supports it then the digest will be
fetched using the properties <i>mdprops</i>. The padding
mode must have been set to
<b>RSA_PKCS1_OAEP_PADDING</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_oaep_md()</b>
does the same as <b>EVP_PKEY_CTX_set_rsa_oaep_md_name()</b>
except that the name of the digest is inferred from the
supplied <i>md</i> and it is not possible to specify any
properties.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_oaep_md_name()</b>
gets the message digest algorithm name used in RSA OAEP and
stores it in the buffer <i>name</i> which is of size
<i>namelen</i>. The padding mode must have been set to
<b>RSA_PKCS1_OAEP_PADDING</b>. The buffer should be
sufficiently large for any expected digest algorithm names
or the function will fail.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_oaep_md()</b>
does the same as <b>EVP_PKEY_CTX_get_rsa_oaep_md_name()</b>
except that it returns a pointer to an EVP_MD object
instead. Note that only known, built−in EVP_MD objects
will be returned. The EVP_MD object may be NULL if the
digest is not one of these (such as a digest only
implemented in a third party provider).</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_rsa_oaep_label()</b>
sets the RSA OAEP label to binary data <i>label</i> and its
length in bytes to <i>len</i>. If <i>label</i> is NULL or
<i>len</i> is 0, the label is cleared. The library takes
ownership of the label so the caller should not free the
original memory pointed to by <i>label</i>. The padding mode
must have been set to <b>RSA_PKCS1_OAEP_PADDING</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_rsa_oaep_label()</b>
gets the RSA OAEP label to <i>label</i>. The return value is
the label length. The padding mode must have been set to
<b>RSA_PKCS1_OAEP_PADDING</b>. The resulting pointer is
owned by the library and should not be freed by the
caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>RSA_PKCS1_WITH_TLS_PADDING</b>
is used when decrypting an RSA encrypted TLS
pre−master secret in a TLS ClientKeyExchange message.
It is the same as RSA_PKCS1_PADDING except that it
additionally verifies that the result is the correct length
and the first two bytes are the protocol version initially
requested by the client. If the encrypted content is
publicly invalid then the decryption will fail. However, if
the padding checks fail then decryption will still appear to
succeed but a random TLS premaster secret will be returned
instead. This padding mode accepts two parameters which can
be set using the <b>EVP_PKEY_CTX_set_params</b>(3) function.
These are OSSL_ASYM_CIPHER_PARAM_TLS_CLIENT_VERSION and
OSSL_ASYM_CIPHER_PARAM_TLS_NEGOTIATED_VERSION, both of which
are expected to be unsigned integers. Normally only the
first of these will be set and represents the TLS protocol
version that was first requested by the client (e.g. 0x0303
for TLSv1.2, 0x0302 for TLSv1.1 etc). Historically some
buggy clients would use the negotiated protocol version
instead of the protocol version first requested. If this
behaviour should be tolerated then
OSSL_ASYM_CIPHER_PARAM_TLS_NEGOTIATED_VERSION should be set
to the actual negotiated protocol version. Otherwise it
should be left unset.</p>
<p style="margin-left:9%; margin-top: 1em">Similarly to the
<b>RSA_PKCS1_WITH_TLS_PADDING</b> above, since OpenSSL
version 3.2.0, the use of <b>RSA_PKCS1_PADDING</b> will
return a randomly generated message instead of padding
errors in case padding checks fail. Applications that want
to remain secure while using earlier versions of OpenSSL, or
a provider that doesn't implement the implicit rejection
mechanism, still need to handle both the error code from the
RSA decryption operation and the returned message in a side
channel secure manner. This protection against
Bleichenbacher attacks can be disabled by setting
<b>OSSL_ASYM_CIPHER_PARAM_IMPLICIT_REJECTION</b> (an
unsigned integer) to 0.</p>
<h3>DSA parameters
<a name="DSA parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_bits()</b>
sets the number of bits used for DSA parameter generation to
<b>nbits</b>. If not specified, 2048 is used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_q_bits()</b>
sets the number of bits in the subprime parameter <i>q</i>
for DSA parameter generation to <i>qbits</i>. If not
specified, 224 is used. If a digest function is specified
below, this parameter is ignored and instead, the number of
bits in <i>q</i> matches the size of the digest.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_md()</b>
sets the digest function used for DSA parameter generation
to <i>md</i>. If not specified, one of SHA−1,
SHA−224, or SHA−256 is selected to match the bit
length of <i>q</i> above.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_md_props()</b>
sets the digest function used for DSA parameter generation
using <i>md_name</i> and <i>md_properties</i> to retrieve
the digest from a provider. If not specified, <i>md_name</i>
will be set to one of SHA−1, SHA−224, or
SHA−256 depending on the bit length of <i>q</i> above.
<i>md_properties</i> is a property query string that has a
default value of '' if not specified.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_gindex()</b>
sets the <i>gindex</i> used by the generator G. The default
value is −1 which uses unverifiable g, otherwise a
positive value uses verifiable g. This value must be saved
if key validation of g is required, since it is not part of
a persisted key.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_seed()</b>
sets the <i>seed</i> to use for generation rather than using
a randomly generated value for the seed. This is useful for
testing purposes only and can fail if the seed does not
produce primes for both p &amp; q on its first iteration.
This value must be saved if key validation of p, q, and
verifiable g are required, since it is not part of a
persisted key.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dsa_paramgen_type()</b>
sets the generation type to use FIPS186−4 generation
if <i>name</i> is "fips186_4", or FIPS186−2
generation if <i>name</i> is "fips186_2". The
default value for the default provider is
"fips186_2". The default value for the FIPS
provider is "fips186_4".</p>
<h3>DH parameters
<a name="DH parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_prime_len()</b>
sets the length of the DH prime parameter <i>p</i> for DH
parameter generation. If this function is not called then
2048 is used. Only accepts lengths greater than or equal to
256.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_subprime_len()</b>
sets the length of the DH optional subprime parameter
<i>q</i> for DH parameter generation. The default is 256 if
the prime is at least 2048 bits long or 160 otherwise. The
DH paramgen type must have been set to
"fips186_4".</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_generator()</b>
sets DH generator to <i>gen</i> for DH parameter generation.
If not specified 2 is used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_type()</b>
sets the key type for DH parameter generation. The supported
parameters are: <b><br/>
DH_PARAMGEN_TYPE_GROUP</b></p>
<p style="margin-left:14%;">Use a named group. If only the
safe prime parameter <i>p</i> is set this can be used to
select a ffdhe safe prime group of the correct size.</p>
<p style="margin-left:9%;"><b>DH_PARAMGEN_TYPE_FIPS_186_4</b></p>
<p style="margin-left:14%;">FIPS186−4 FFC parameter
generator.</p>
<p style="margin-left:9%;"><b>DH_PARAMGEN_TYPE_FIPS_186_2</b></p>
<p style="margin-left:14%;">FIPS186−2 FFC parameter
generator (X9.42 DH).</p>
<p style="margin-left:9%;"><b>DH_PARAMGEN_TYPE_GENERATOR</b></p>
<p style="margin-left:14%;">Uses a safe prime generator g
(PKCS#3 format).</p>
<p style="margin-left:9%; margin-top: 1em">The default in
the default provider is <b>DH_PARAMGEN_TYPE_GENERATOR</b>
for the "DH" keytype, and
<b>DH_PARAMGEN_TYPE_FIPS_186_2</b> for the "DHX"
keytype. In the FIPS provider the default value is
<b>DH_PARAMGEN_TYPE_GROUP</b> for the "DH" keytype
and &lt;<b>DH_PARAMGEN_TYPE_FIPS_186_4</b> for the
"DHX" keytype.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_gindex()</b>
sets the <i>gindex</i> used by the generator G. The default
value is −1 which uses unverifiable g, otherwise a
positive value uses verifiable g. This value must be saved
if key validation of g is required, since it is not part of
a persisted key.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_paramgen_seed()</b>
sets the <i>seed</i> to use for generation rather than using
a randomly generated value for the seed. This is useful for
testing purposes only and can fail if the seed does not
produce primes for both p &amp; q on its first iteration.
This value must be saved if key validation of p, q, and
verifiable g are required, since it is not part of a
persisted key.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_pad()</b>
sets the DH padding mode. If <i>pad</i> is 1 the shared
secret is padded with zeros up to the size of the DH prime
<i>p</i>. If <i>pad</i> is zero (the default) then no
padding is performed.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_nid()</b>
sets the DH parameters to values corresponding to <i>nid</i>
as defined in RFC7919 or RFC3526. The <i>nid</i> parameter
must be <b>NID_ffdhe2048</b>, <b>NID_ffdhe3072</b>,
<b>NID_ffdhe4096</b>, <b>NID_ffdhe6144</b>,
<b>NID_ffdhe8192</b>, <b>NID_modp_1536</b>,
<b>NID_modp_2048</b>, <b>NID_modp_3072</b>,
<b>NID_modp_4096</b>, <b>NID_modp_6144</b>,
<b>NID_modp_8192</b> or <b>NID_undef</b> to clear the stored
value. This function can be called during parameter or key
generation. The nid parameter and the rfc5114 parameter are
mutually exclusive.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_rfc5114()</b>
and <b>EVP_PKEY_CTX_set_dhx_rfc5114()</b> both set the DH
parameters to the values defined in RFC5114. The
<i>rfc5114</i> parameter must be 1, 2 or 3 corresponding to
RFC5114 sections 2.1, 2.2 and 2.3. or 0 to clear the stored
value. This macro can be called during parameter generation.
The <i>ctx</i> must have a key type of <b>EVP_PKEY_DHX</b>.
The rfc5114 parameter and the nid parameter are mutually
exclusive.</p>
<h3>DH key derivation function parameters
<a name="DH key derivation function parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Note that all of
the following functions require that the <i>ctx</i>
parameter has a private key type of <b>EVP_PKEY_DHX</b>.
When using key derivation, the output of
<b>EVP_PKEY_derive()</b> is the output of the KDF instead of
the DH shared secret. The KDF output is typically used as a
Key Encryption Key (KEK) that in turn encrypts a Content
Encryption Key (CEK).</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_kdf_type()</b>
sets the key derivation function type to <i>kdf</i> for DH
key derivation. Possible values are
<b>EVP_PKEY_DH_KDF_NONE</b> and <b>EVP_PKEY_DH_KDF_X9_42</b>
which uses the key derivation specified in RFC2631 (based on
the keying algorithm described in X9.42). When using key
derivation, the <i>kdf_oid</i>, <i>kdf_md</i> and
<i>kdf_outlen</i> parameters must also be specified.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_dh_kdf_type()</b>
gets the key derivation function type for <i>ctx</i> used
for DH key derivation. Possible values are
<b>EVP_PKEY_DH_KDF_NONE</b> and
<b>EVP_PKEY_DH_KDF_X9_42</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_dh_kdf_oid()</b>
sets the key derivation function object identifier to
<i>oid</i> for DH key derivation. This OID should identify
the algorithm to be used with the Content Encryption Key.
The library takes ownership of the object identifier so the
caller should not free the original memory pointed to by
<i>oid</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_dh_kdf_oid()</b>
gets the key derivation function oid for <i>ctx</i> used for
DH key derivation. The resulting pointer is owned by the
library and should not be freed by the caller.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_kdf_md()</b>
sets the key derivation function message digest to <i>md</i>
for DH key derivation. Note that RFC2631 specifies that this
digest should be SHA1 but OpenSSL tolerates other
digests.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_dh_kdf_md()</b>
gets the key derivation function message digest for
<i>ctx</i> used for DH key derivation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_dh_kdf_outlen()</b>
sets the key derivation function output length to <i>len</i>
for DH key derivation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_dh_kdf_outlen()</b>
gets the key derivation function output length for
<i>ctx</i> used for DH key derivation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_dh_kdf_ukm()</b>
sets the user key material to <i>ukm</i> and its length to
<i>len</i> for DH key derivation. This parameter is optional
and corresponds to the partyAInfo field in RFC2631 terms.
The specification requires that it is 512 bits long but this
is not enforced by OpenSSL. The library takes ownership of
the user key material so the caller should not free the
original memory pointed to by <i>ukm</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_dh_kdf_ukm()</b>
gets the user key material for <i>ctx</i>. The return value
is the user key material length. The resulting pointer is
owned by the library and should not be freed by the
caller.</p>
<h3>EC parameters
<a name="EC parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Use
<b>EVP_PKEY_CTX_set_group_name()</b> (described above) to
set the curve name to <i>name</i> for parameter and key
generation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ec_paramgen_curve_nid()</b>
does the same as <b>EVP_PKEY_CTX_set_group_name()</b>, but
is specific to EC and uses a <i>nid</i> rather than a name
string.</p>
<p style="margin-left:9%; margin-top: 1em">For EC parameter
generation, one of <b>EVP_PKEY_CTX_set_group_name()</b> or
<b>EVP_PKEY_CTX_set_ec_paramgen_curve_nid()</b> must be
called or an error occurs because there is no default curve.
These function can also be called to set the curve
explicitly when generating an EC key.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_group_name()</b>
(described above) can be used to obtain the curve name
that's currently set with <i>ctx</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ec_param_enc()</b>
sets the EC parameter encoding to <i>param_enc</i> when
generating EC parameters or an EC key. The encoding can be
<b>OPENSSL_EC_EXPLICIT_CURVE</b> for explicit parameters
(the default in versions of OpenSSL before 1.1.0) or
<b>OPENSSL_EC_NAMED_CURVE</b> to use named curve form. For
maximum compatibility the named curve form should be used.
Note: the <b>OPENSSL_EC_NAMED_CURVE</b> value was added in
OpenSSL 1.1.0; previous versions should use 0 instead.</p>
<h3>ECDH parameters
<a name="ECDH parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ecdh_cofactor_mode()</b>
sets the cofactor mode to <i>cofactor_mode</i> for ECDH key
derivation. Possible values are 1 to enable cofactor key
derivation, 0 to disable it and −1 to clear the stored
cofactor mode and fallback to the private key cofactor
mode.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_cofactor_mode()</b>
returns the cofactor mode for <i>ctx</i> used for ECDH key
derivation. Possible values are 1 when cofactor key
derivation is enabled and 0 otherwise.</p>
<h3>ECDH key derivation function parameters
<a name="ECDH key derivation function parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ecdh_kdf_type()</b>
sets the key derivation function type to <i>kdf</i> for ECDH
key derivation. Possible values are
<b>EVP_PKEY_ECDH_KDF_NONE</b> and
<b>EVP_PKEY_ECDH_KDF_X9_63</b> which uses the key derivation
specified in X9.63. When using key derivation, the
<i>kdf_md</i> and <i>kdf_outlen</i> parameters must also be
specified.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_kdf_type()</b>
returns the key derivation function type for <i>ctx</i> used
for ECDH key derivation. Possible values are
<b>EVP_PKEY_ECDH_KDF_NONE</b> and
<b>EVP_PKEY_ECDH_KDF_X9_63</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ecdh_kdf_md()</b>
sets the key derivation function message digest to <i>md</i>
for ECDH key derivation. Note that X9.63 specifies that this
digest should be SHA1 but OpenSSL tolerates other
digests.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_kdf_md()</b>
gets the key derivation function message digest for
<i>ctx</i> used for ECDH key derivation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_ecdh_kdf_outlen()</b>
sets the key derivation function output length to <i>len</i>
for ECDH key derivation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_ecdh_kdf_outlen()</b>
gets the key derivation function output length for
<i>ctx</i> used for ECDH key derivation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set0_ecdh_kdf_ukm()</b>
sets the user key material to <i>ukm</i> for ECDH key
derivation. This parameter is optional and corresponds to
the shared info in X9.63 terms. The library takes ownership
of the user key material so the caller should not free the
original memory pointed to by <i>ukm</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get0_ecdh_kdf_ukm()</b>
gets the user key material for <i>ctx</i>. The return value
is the user key material length. The resulting pointer is
owned by the library and should not be freed by the
caller.</p>
<h3>Other parameters
<a name="Other parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set1_id()</b>,
<b>EVP_PKEY_CTX_get1_id()</b> and
<b>EVP_PKEY_CTX_get1_id_len()</b> are used to manipulate the
special identifier field for specific signature algorithms
such as SM2. The <b>EVP_PKEY_CTX_set1_id()</b> sets an ID
pointed by <i>id</i> with the length <i>id_len</i> to the
library. The library takes a copy of the id so that the
caller can safely free the original memory pointed to by
<i>id</i>. <b>EVP_PKEY_CTX_get1_id_len()</b> returns the
length of the ID set via a previous call to
<b>EVP_PKEY_CTX_set1_id()</b>. The length is usually used to
allocate adequate memory for further calls to
<b>EVP_PKEY_CTX_get1_id()</b>. <b>EVP_PKEY_CTX_get1_id()</b>
returns the previously set ID value to caller in <i>id</i>.
The caller should allocate adequate memory space for the
<i>id</i> before calling <b>EVP_PKEY_CTX_get1_id()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_kem_op()</b>
sets the KEM operation to run. This can be set after
<b>EVP_PKEY_encapsulate_init()</b> or
<b>EVP_PKEY_decapsulate_init()</b> to select the kem
operation. RSA is the only key type that supports
encapsulation currently, and as there is no default
operation for the RSA type, this function must be called
before <b>EVP_PKEY_encapsulate()</b> or
<b>EVP_PKEY_decapsulate()</b>.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All other
functions described on this page return a positive value for
success and 0 or a negative value for failure. In particular
a return value of −2 indicates the operation is not
supported by the public key algorithm.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_params</b>(3),
<b>EVP_PKEY_CTX_new</b>(3), <b>EVP_PKEY_encrypt</b>(3),
<b>EVP_PKEY_decrypt</b>(3), <b>EVP_PKEY_sign</b>(3),
<b>EVP_PKEY_verify</b>(3),
<b>EVP_PKEY_verify_recover</b>(3),
<b>EVP_PKEY_derive</b>(3), <b>EVP_PKEY_keygen</b>(3)
<b>EVP_PKEY_encapsulate</b>(3)
<b>EVP_PKEY_decapsulate</b>(3)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_get_rsa_oaep_md_name()</b>,
<b>EVP_PKEY_CTX_get_rsa_mgf1_md_name()</b>,
<b>EVP_PKEY_CTX_set_rsa_mgf1_md_name()</b>,
<b>EVP_PKEY_CTX_set_rsa_oaep_md_name()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_md_props()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_gindex()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_type()</b>,
<b>EVP_PKEY_CTX_set_dsa_paramgen_seed()</b>,
<b>EVP_PKEY_CTX_set_group_name()</b> and
<b>EVP_PKEY_CTX_get_group_name()</b> were added in OpenSSL
3.0.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>EVP_PKEY_CTX_set1_id()</b>, <b>EVP_PKEY_CTX_get1_id()</b>
and <b>EVP_PKEY_CTX_get1_id_len()</b> macros were added in
1.1.1, other functions were added in OpenSSL 1.0.0.</p>
<p style="margin-left:9%; margin-top: 1em">In OpenSSL 1.1.1
and below the functions were mostly macros. From OpenSSL 3.0
they are all functions.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_CTX_set_rsa_keygen_pubexp()</b>,
<b>EVP_PKEY_CTX_get0_dh_kdf_ukm()</b>, and
<b>EVP_PKEY_CTX_get0_ecdh_kdf_ukm()</b> were deprecated in
OpenSSL 3.0.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2006−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
