<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:46:06 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GLCOPYPIXELS</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">GLCOPYPIXELS</h1>
<a href="#NAME">NAME</a><br/>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br/>
<a href="#PARAMETERS">PARAMETERS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#ASSOCIATED GETS">ASSOCIATED GETS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glCopyPixels</b>
− copy pixels in the frame buffer</p>
<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">void
<b>glCopyPixels</b>( GLint <i>x</i>,</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="24%"></td>
<td width="76%">
<p>GLint <i>y</i>,</p></td></tr>
<tr align="left" valign="top">
<td width="24%"></td>
<td width="76%">
<p>GLsizei <i>width</i>,</p></td></tr>
<tr align="left" valign="top">
<td width="24%"></td>
<td width="76%">
<p>GLsizei <i>height</i>,</p></td></tr>
<tr align="left" valign="top">
<td width="24%"></td>
<td width="76%">
<p>GLenum <i>type</i> )</p></td></tr>
</table>
<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p style="margin-top: 1em"><i>x</i>, <i>y</i></p></td>
<td width="1%"></td>
<td width="85%">
<p style="margin-top: 1em">Specify the window coordinates
of the lower left corner of the rectangular region of pixels
to be copied.</p></td></tr>
</table>
<p style="margin-left:9%;"><i>width</i>, <i>height</i></p>
<p style="margin-left:15%;">Specify the dimensions of the
rectangular region of pixels to be copied. Both must be
nonnegative.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p><i>type</i></p></td>
<td width="1%"></td>
<td width="85%">
<p>Specifies whether color values, depth values, or stencil
values are to be copied. Symbolic constants <b>GL_COLOR</b>,
<b>GL_DEPTH</b>, and <b>GL_STENCIL</b> are accepted.</p></td></tr>
</table>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glCopyPixels</b>
copies a screen-aligned rectangle of pixels from the
specified frame buffer location to a region relative to the
current raster position. Its operation is well defined only
if the entire pixel source region is within the exposed
portion of the window. Results of copies from outside the
window, or from regions of the window that are not exposed,
are hardware dependent and undefined.</p>
<p style="margin-left:9%; margin-top: 1em"><i>x</i> and
<i>y</i> specify the window coordinates of the lower left
corner of the rectangular region to be copied. <i>width</i>
and <i>height</i> specify the dimensions of the rectangular
region to be copied. Both <i>width</i> and <i>height</i>
must not be negative.</p>
<p style="margin-left:9%; margin-top: 1em">Several
parameters control the processing of the pixel data while it
is being copied. These parameters are set with three
commands: <b>glPixelTransfer</b>, <b>glPixelMap</b>, and
<b>glPixelZoom</b>. This reference page describes the
effects on <b>glCopyPixels</b> of most, but not all, of the
parameters specified by these three commands.</p>
<p style="margin-left:9%; margin-top: 1em"><b>glCopyPixels</b>
copies values from each pixel with the lower left-hand
corner at (<i>x</i> + <i>i</i>, <i>y</i> + <i>j</i>) for 0
≤ <i>i</i> &lt; <i>width</i> and 0 ≤ <i>j</i> &lt;
<i>height</i>. This pixel is said to be the <i>i</i>th pixel
in the <i>j</i>th row. Pixels are copied in row order from
the lowest to the highest row, left to right in each
row.</p>
<p style="margin-left:9%; margin-top: 1em"><i>type</i>
specifies whether color, depth, or stencil data is to be
copied. The details of the transfer for each data type are
as follows:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="10%">
<p style="margin-top: 1em"><b>GL_COLOR</b></p></td>
<td width="9%"></td>
<td width="72%">
<p style="margin-top: 1em">Indices or RGBA colors are read
from the buffer currently specified as the read source
buffer (see <b>glReadBuffer</b>). If the GL is in color
index mode, each index that is read from this buffer is
converted to a fixed-point with an unspecified number of
bits to the right of the binary point. Each index is then
shifted left by <b>GL_INDEX_SHIFT</b> bits, and added to
<b>GL_INDEX_OFFSET</b>. If <b>GL_INDEX_SHIFT</b> is
negative, the shift is to the right. In either case, zero
bits fill otherwise unspecified bit locations in the result.
If <b>GL_MAP_COLOR</b> is true, the index is replaced with
the value that it references in lookup table
<b>GL_PIXEL_MAP_I_TO_I</b>. Whether the lookup replacement
of the index is done or not, the integer part of the index
is then ANDed with 2 <i><small><small>b</small></small></i>
−1, where <i>b</i> is the number of bits in a color
index buffer.</p></td></tr>
</table>
<p style="margin-left:28%; margin-top: 1em">If the GL is in
RGBA mode, the red, green, blue, and alpha components of
each pixel that is read are converted to an internal
floating-point with unspecified precision. The conversion
maps the largest representable component value to 1.0, and
component value 0 to 0.0. The resulting floating-point color
values are then multiplied by <b>GL_c_SCALE</b> and added to
<b>GL_c_BIAS</b>, where <i>c</i> is RED, GREEN, BLUE, and
ALPHA for the respective color components. The results are
clamped to the range [0,1]. If <b>GL_MAP_COLOR</b> is true,
each color component is scaled by the size of lookup table
<b>GL_PIXEL_MAP_c_TO_c</b>, then replaced by the value that
it references in that table. <i>c</i> is R, G, B, or A.</p>
<p style="margin-left:28%; margin-top: 1em">If the
<b>GL_ARB_imaging</b> extension is supported, the color
values may be additionally processed by color-table lookups,
color-matrix transformations, and convolution filters.</p>
<p style="margin-left:28%; margin-top: 1em">The GL then
converts the resulting indices or RGBA colors to fragments
by attaching the current raster position <i>z</i> coordinate
and texture coordinates to each pixel, then assigning window
coordinates (<i>x <small><small>r</small></small></i>
+<i>i</i>,<i>y <small><small>r</small></small></i>
+<i>j</i>), where (<i>x <small><small>r</small></small></i>
,<i>y <small><small>r</small></small></i> ) is the current
raster position, and the pixel was the <i>i</i>th pixel in
the <i>j</i>th row. These pixel fragments are then treated
just like the fragments generated by rasterizing points,
lines, or polygons. Texture mapping, fog, and all the
fragment operations are applied before the fragments are
written to the frame buffer.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="10%">
<p style="margin-top: 1em"><b>GL_DEPTH</b></p></td>
<td width="9%"></td>
<td width="72%">
<p style="margin-top: 1em">Depth values are read from the
depth buffer and converted directly to an internal
floating-point with unspecified precision. The resulting
floating-point depth value is then multiplied by
<b>GL_DEPTH_SCALE</b> and added to <b>GL_DEPTH_BIAS</b>. The
result is clamped to the range [0,1].</p></td></tr>
</table>
<p style="margin-left:28%; margin-top: 1em">The GL then
converts the resulting depth components to fragments by
attaching the current raster position color or color index
and texture coordinates to each pixel, then assigning window
coordinates (<i>x <small><small>r</small></small></i>
+<i>i</i>,<i>y <small><small>r</small></small></i>
+<i>j</i>), where (<i>x <small><small>r</small></small></i>
,<i>y <small><small>r</small></small></i> ) is the current
raster position, and the pixel was the <i>i</i>th pixel in
the <i>j</i>th row. These pixel fragments are then treated
just like the fragments generated by rasterizing points,
lines, or polygons. Texture mapping, fog, and all the
fragment operations are applied before the fragments are
written to the frame buffer.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="13%">
<p style="margin-top: 1em"><b>GL_STENCIL</b></p></td>
<td width="6%"></td>
<td width="72%">
<p style="margin-top: 1em">Stencil indices are read from
the stencil buffer and converted to an internal fixed-point
with an unspecified number of bits to the right of the
binary point. Each fixed-point index is then shifted left by
<b>GL_INDEX_SHIFT</b> bits, and added to
<b>GL_INDEX_OFFSET</b>. If <b>GL_INDEX_SHIFT</b> is
negative, the shift is to the right. In either case, zero
bits fill otherwise unspecified bit locations in the result.
If <b>GL_MAP_STENCIL</b> is true, the index is replaced with
the value that it references in lookup table
<b>GL_PIXEL_MAP_S_TO_S</b>. Whether the lookup replacement
of the index is done or not, the integer part of the index
is then ANDed with 2 <i><small><small>b</small></small></i>
−1, where <i>b</i> is the number of bits in the
stencil buffer. The resulting stencil indices are then
written to the stencil buffer such that the index read from
the <i>i</i>th location of the <i>j</i>th row is written to
location (<i>x <small><small>r</small></small></i>
+<i>i</i>,<i>y <small><small>r</small></small></i>
+<i>j</i>), where (<i>x <small><small>r</small></small></i>
,<i>y <small><small>r</small></small></i> ) is the current
raster position. Only the pixel ownership test, the scissor
test, and the stencil writemask affect these write
operations.</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The
rasterization described thus far assumes pixel zoom factors
of 1.0. If <b><br/>
glPixelZoom</b> is used to change the <i>x</i> and <i>y</i>
pixel zoom factors, pixels are converted to fragments as
follows. If (<i>x <small><small>r</small></small></i> , <i>y
<small><small>r</small></small></i> ) is the current raster
position, and a given pixel is in the <i>i</i>th location in
the <i>j</i>th row of the source pixel rectangle, then
fragments are generated for pixels whose centers are in the
rectangle with corners at</p>
<p align="center" style="margin-top: 1em">(<i>x
<small><small>r</small></small></i> +<i>zoom
<small><small>x</small></small> i</i>, <i>y
<small><small>r</small></small></i> +<i>zoom
<small><small>y</small></small> j</i>) <br/>
and <br/>
(<i>x <small><small>r</small></small></i> +<i>zoom
<small><small>x</small></small></i> (<i>i</i>+1), <i>y
<small><small>r</small></small></i> +<i>zoom
<small><small>y</small></small></i> (<i>j</i>+1))</p>
<p style="margin-top: 1em">where <i>zoom
<small><small>x</small></small></i> is the value of
<b>GL_ZOOM_X</b> and <i>zoom
<small><small>y</small></small></i> is the value of
<b>GL_ZOOM_Y</b>.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To copy the
color pixel in the lower left corner of the window to the
current raster position, use glCopyPixels(0, 0, 1, 1,
<b>GL_COLOR</b>);</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Modes specified
by <b>glPixelStore</b> have no effect on the operation of
<b>glCopyPixels</b>.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_ENUM</b>
is generated if <i>type</i> is not an accepted value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated if either <i>width</i> or <i>height</i> is
negative.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>type</i> is <b>GL_DEPTH</b> and there is
no depth buffer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <i>type</i> is <b>GL_STENCIL</b> and there
is no stencil buffer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <b>glCopyPixels</b> is executed between the
execution of <b>glBegin</b> and the corresponding execution
of <b>glEnd</b>.</p>
<h2>ASSOCIATED GETS
<a name="ASSOCIATED GETS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glGet</b>
with argument <b>GL_CURRENT_RASTER_POSITION <br/>
glGet</b> with argument
<b>GL_CURRENT_RASTER_POSITION_VALID</b></p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glColorTable(3G)</b>,
<b>glConvolutionFilter1D(3G)</b>,
<b>glConvolutionFilter2D(3G)</b>, <b>glDepthFunc(3G)</b>,
<b>glDrawBuffer(3G)</b>, <b>glDrawPixels(3G)</b>,
<b>glMatrixMode(3G)</b>, <b>glPixelMap(3G)</b>,
<b>glPixelTransfer(3G)</b>, <b>glPixelZoom(3G)</b>,
<b>glRasterPos(3G)</b>, <b>glReadBuffer(3G)</b>,
<b>glReadPixels(3G)</b>, <b>glSeparableFilter2D(3G)</b>,
<b>glStencilFunc(3G)</b></p>
<hr/>
</body>
</html>
