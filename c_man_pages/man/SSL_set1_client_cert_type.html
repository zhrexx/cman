<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:53:33 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SSL_SET1_SERVER_CERT_TYPE</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">SSL_SET1_SERVER_CERT_TYPE</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">SSL_set1_client_cert_type,
SSL_set1_server_cert_type, SSL_CTX_set1_client_cert_type,
SSL_CTX_set1_server_cert_type, SSL_get0_client_cert_type,
SSL_get0_server_cert_type, SSL_CTX_get0_client_cert_type,
SSL_CTX_get0_server_cert_type − certificate type
(RFC7250) support</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/ssl.h&gt; <br/>
int SSL_set1_client_cert_type(SSL *s, const unsigned char
*val, size_t len); <br/>
int SSL_set1_server_cert_type(SSL *s, const unsigned char
*val, size_t len); <br/>
int SSL_CTX_set1_client_cert_type(SSL_CTX *ctx, const
unsigned char *val, size_t len); <br/>
int SSL_CTX_set1_server_cert_type(SSL_CTX *ctx, const
unsigned char *val, size_t len); <br/>
int SSL_get0_client_cert_type(const SSL *s, unsigned char
**val, size_t *len); <br/>
int SSL_get0_server_cert_type(const SSL *s, unsigned char
**val, size_t *len); <br/>
int SSL_CTX_get0_client_cert_type(const SSL_CTX *ctx,
unsigned char **val, size_t *len); <br/>
int SSL_CTX_get0_server_cert_type(const SSL_CTX *s, unsigned
char **val, size_t *len);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>SSL_set1_client_cert_type()</b> and
<b>SSL_CTX_set1_client_cert_type()</b> functions set the
values for the client certificate type extension. The
<b>SSL_get0_client_cert_type()</b> and
<b>SSL_CTX_get0_client_cert_type()</b> functions retrieve
the local values to be used in the client certificate type
extension.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>SSL_set1_server_cert_type()</b> and
<b>SSL_CTX_set1_server_cert_type()</b> functions set the
values for the server certificate type extension. The
<b>SSL_get0_server_cert_type()</b> and
<b>SSL_CTX_get0_server_cert_type()</b> functions retrieve
the local values to be used in the server certificate type
extension.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The certificate
type extensions are used to negotiate the certificate type
to be used in the handshake. These extensions let each side
know what its peer is able to accept.</p>
<p style="margin-left:9%; margin-top: 1em">The client
certificate type is sent from the client to the server to
indicate what certificate types the client is able to
present. Values are configured in preference order. On the
server, this setting determines which certificate types the
server is willing to accept. The server ultimately chooses
what type to request (if any) from the values that are
mutually supported. By default (if no explicit settings are
specified), only X.509 certificates are supported.</p>
<p style="margin-left:9%; margin-top: 1em">The server
certificate type is sent from the client to the server to
indicate what certificate types the client accepts. Values
are configured in preference order. On the server, this
setting determines which certificate types the server is
willing to present. The server ultimately chooses what type
to use from the values that are mutually supported. By
default (if no explicit settings are specified), only X.509
certificates are supported.</p>
<p style="margin-left:9%; margin-top: 1em">Having RPK
specified first means that side will attempt to send (or
request) RPKs if its peer also supports RPKs, otherwise
X.509 certificate will be used if both have specified that
(or have not configured these options).</p>
<p style="margin-left:9%; margin-top: 1em">The two
supported values in the <b>val</b> array are: <br/>
TLSEXT_cert_type_x509</p>
<p style="margin-left:14%;">Which corresponds to an X.509
certificate normally used in TLS.</p>
<p style="margin-left:9%;">TLSEXT_cert_type_rpk</p>
<p style="margin-left:14%;">Which corresponds to a raw
public key.</p>
<p style="margin-left:9%; margin-top: 1em">If <b>val</b> is
set to a non−NULL value, then the extension is sent in
the handshake. If b&lt;val&gt; is set to a NULL value (and
<b>len</b> is 0), then the extension is disabled. The
default value is NULL, meaning the extension is not sent,
and X.509 certificates are used in the handshake.</p>
<p style="margin-left:9%; margin-top: 1em">Raw public keys
may be used in place of certificates when specified in the
certificate type and negotiated. Raw public keys have no
subject, issuer, validity dates or digital signature.</p>
<p style="margin-left:9%; margin-top: 1em">Use the
<b>SSL_get_negotiated_client_cert_type</b>(3) and
<b>SSL_get_negotiated_server_cert_type</b>(3) functions to
get the negotiated cert type values (at the conclusion of
the handshake, or in callbacks that happen after the TLS
ServerHello has been processed).</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All functions
return 1 on success and 0 on failure.</p>
<p style="margin-left:9%; margin-top: 1em">The memory
returned from the get0 functions must not be freed.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To use raw
public keys on the server, set up the SSL_CTX and SSL as
follows:</p>
<p style="margin-left:9%; margin-top: 1em">SSL_CTX *ctx;
<br/>
SSL *ssl; <br/>
unsigned char cert_type[] = { TLSEXT_cert_type_rpk,
TLSEXT_cert_type_x509 }; <br/>
EVP_PKEY *rpk; <br/>
/* Assign rpk to an EVP_PKEY from a file or other means */
<br/>
if ((ctx = SSL_CTX_new(TLS_server_method())) == NULL) <br/>
/* error */ <br/>
if ((ssl = SSL_new(ctx)) == NULL) <br/>
/* error */ <br/>
if (!SSL_set1_server_cert_type(ssl, cert_type,
sizeof(cert_type))) <br/>
/* error */ <br/>
/* A certificate does not need to be specified when using
raw public keys */ <br/>
if (!SSL_use_PrivateKey(ssl, rpk)) <br/>
/* error */ <br/>
/* Perform SSL_accept() operations */</p>
<p style="margin-left:9%; margin-top: 1em">To connect to
this server, set the client SSL_CTX and SSL as follows:</p>
<p style="margin-left:9%; margin-top: 1em">/* Connect
function */ <br/>
SSL_CTX *ctx; <br/>
SSL *ssl; <br/>
const char *dane_tlsa_domain = "smtp.example.com";
<br/>
unsigned char cert_type[] = { TLSEXT_cert_type_rpk,
TLSEXT_cert_type_x509 }; <br/>
EVP_PKEY *rpk; <br/>
int verify_result; <br/>
/* Assign rpk to an EVP_PKEY from a file or other means */
<br/>
if ((ctx = SSL_CTX_new(TLS_client_method())) == NULL) <br/>
/* error */ <br/>
if (SSL_CTX_dane_enable(ctx) &lt;= 0) <br/>
/* error */ <br/>
if ((ssl = SSL_new(ctx)) == NULL) <br/>
/* error */ <br/>
/* <br/>
* The `dane_tlsa_domain` arguments sets the default SNI
hostname. <br/>
* It may be set to NULL when enabling DANE on the server
side. <br/>
*/ <br/>
if (SSL_dane_enable(ssl, dane_tlsa_domain) &lt;= 0) <br/>
/* error */ <br/>
if (!SSL_set1_server_cert_type(ssl, cert_type,
sizeof(cert_type))) <br/>
/* error */ <br/>
if (!SSL_add_expected_rpk(ssl, rpk)) <br/>
/* error */ <br/>
/* Do SSL_connect() handshake and handle errors here */ <br/>
/* Optional: verify the peer RPK */ <br/>
verify_result = SSL_get_verify_result(ssl); <br/>
if (verify_result == X509_V_OK) { <br/>
/* The server's raw public key matched the TLSA record */
<br/>
} else if (verify_result == X509_V_ERR_DANE_NO_MATCH) { <br/>
/* <br/>
* The server's raw public key, or public key in certificate,
did not <br/>
* match the TLSA record <br/>
*/ <br/>
} else if (verify_result == X509_V_ERR_RPK_UNTRUSTED) { <br/>
/* <br/>
* No TLSA records of the correct type are available to
verify the <br/>
* server's raw public key. This would not happen in this
example, <br/>
* as a TLSA record is configured. <br/>
*/ <br/>
} else { <br/>
/* Some other verify error */ <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">To validate
client raw public keys, code from the client example may
need to be incorporated into the server side.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>SSL_get0_peer_rpk</b>(3),
<b>SSL_get_negotiated_client_cert_type</b>(3),
<b>SSL_get_negotiated_server_cert_type</b>(3),
<b>SSL_use_certificate</b>(3)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These functions
were added in OpenSSL 3.2.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright 2023
The OpenSSL Project Authors. All Rights Reserved.</p>
<hr/>
</body>
</html>
