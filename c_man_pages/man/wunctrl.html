<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:54:55 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>curs_util</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">curs_util</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#unctrl">unctrl</a><br/>
<a href="#keyname, key_name">keyname, key_name</a><br/>
<a href="#filter, nofilter">filter, nofilter</a><br/>
<a href="#use_env">use_env</a><br/>
<a href="#use_tioctl">use_tioctl</a><br/>
<a href="#putwin, getwin">putwin, getwin</a><br/>
<a href="#delay_output">delay_output</a><br/>
<a href="#flushinp">flushinp</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#PORTABILITY">PORTABILITY</a><br/>
<a href="#filter">filter</a><br/>
<a href="#delay_output padding">delay_output padding</a><br/>
<a href="#keyname">keyname</a><br/>
<a href="#nofilter, use_tioctl">nofilter, use_tioctl</a><br/>
<a href="#putwin/getwin file-format">putwin/getwin file-format</a><br/>
<a href="#unctrl, wunctrl">unctrl, wunctrl</a><br/>
<a href="#use_env, use_tioctl">use_env, use_tioctl</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>delay_output</b>,
<b>filter</b>, <b>flushinp</b>, <b>getwin</b>,
<b>key_name</b>, <b>keyname</b>, <b>nofilter</b>,
<b>putwin</b>, <b>unctrl</b>, <b>use_env</b>,
<b>use_tioctl</b>, <b>wunctrl</b> − miscellaneous
<i>curses</i> utility routines</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;curses.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>const char
*unctrl(chtype</b> <i>ch</i><b>); <br/>
wchar_t *wunctrl(cchar_t *</b><i>wch</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>const char
*keyname(int</b> <i>c</i><b>); <br/>
const char *key_name(wchar_t</b> <i>wc</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
filter(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
use_env(bool</b> <i>bf</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
putwin(WINDOW *</b><i>win</i><b>, FILE
*</b><i>filep</i><b>); <br/>
WINDOW *getwin(FILE *</b><i>filep</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
delay_output(int</b> <i>ms</i><b>); <br/>
int flushinp(void);</b></p>
<p style="margin-left:9%; margin-top: 1em"><i>/* extensions
*/</i> <b><br/>
void nofilter(void); <br/>
void use_tioctl(bool</b> <i>bf</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<h3>unctrl
<a name="unctrl"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>unctrl</b> routine returns a character string as a
printable representation of the character <i>ch</i>:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Printable characters are displayed as themselves, e.g.,
a one-character string containing the key.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Control characters are displayed in the
<b>ˆ</b><i>X</i> notation.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Printing characters are displayed as is.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>DEL (character 127) is displayed as <b>ˆ?</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Values above 128 are either meta characters (if the
screen has not been initialized, or if <b>meta</b>(3X) has
been called with a <b>TRUE</b> parameter), shown in the
<b>M−</b><i>X</i> notation, or are displayed as
themselves. In the latter case, the values may not be
printable; this follows the X/Open specification.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The
corresponding <b>wunctrl</b> returns a printable
representation of a complex character <i>wch</i>.</p>
<p style="margin-left:9%; margin-top: 1em">In both
<b>unctrl</b> and <b>wunctrl</b> the attributes and color
associated with the character parameter are ignored.</p>
<h3>keyname, key_name
<a name="keyname, key_name"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>keyname</b> routine returns a character string
corresponding to the key <i>c</i>. Key codes are different
from character codes.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Key codes below 256 are
characters. They are displayed using <b>unctrl</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Values above 256 may be the codes for function keys. The
function key name is displayed.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Otherwise (if there is no corresponding name and the key
is not a character) the function returns null, to denote an
error. X/Open also lists an “UNKNOWN KEY” return
value, which some implementations return rather than
null.</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The
corresponding <b>key_name</b> returns a multibyte character
string corresponding to the wide-character value <i>wc</i>.
The two functions (<b>keyname</b> and <b>key_name</b>) do
not return the same set of strings:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em"><b>keyname</b> returns null
where <b>key_name</b> would display a meta character.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p><b>key_name</b> does not return the name of a function
key.</p> </td></tr>
</table>
<h3>filter, nofilter
<a name="filter, nofilter"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>filter</b> routine, if used, must be called before
<b>initscr</b> or <b>newterm</b> are called. Calling
<b>filter</b> causes these changes in initialization:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em"><b>LINES</b> is set to 1;</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the capabilities <b>clear</b>, <b>cud1</b>, <b>cud</b>,
<b>cup</b>, <b>cuu1</b>, <b>cuu</b>, <b>vpa</b> are
disabled;</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the capability <b>ed</b> is disabled if <b>bce</b> is
set;</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>and the <b>home</b> string is set to the value of
<b>cr</b>.</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The
<b>nofilter</b> routine cancels the effect of a preceding
<b>filter</b> call. That allows the caller to initialize a
screen on a different device, using a different value of
<b>$TERM</b>. The limitation arises because the
<b>filter</b> routine modifies the in-memory copy of the
terminal information.</p>
<h3>use_env
<a name="use_env"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>use_env</b> routine, if used, should be called before
<b>initscr</b> or <b>newterm</b> are called (because those
compute the screen size). It modifies the way <i>ncurses</i>
treats environment variables when determining the screen
size.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Normally <i>ncurses</i> looks
first at the terminal database for the screen size.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">If
<b>use_env</b> was called with <b>FALSE</b> for parameter,
it stops here unless <b>use_tioctl</b> was also called with
<b>TRUE</b> for parameter.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Then it asks for the screen size
via operating system calls. If successful, it overrides the
values from the terminal database.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Finally (unless <b>use_env</b> was called with
<b>FALSE</b> parameter), <i>ncurses</i> examines the
<i>LINES</i> or <i>COLUMNS</i> environment variables, using
a value in those to override the results from the operating
system or terminal database.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em"><i>curses</i>
also updates the screen size in response to <b>SIGWINCH</b>,
unless overridden by the <i>LINES</i> or <i>COLUMNS</i>
environment variables,</p>
<h3>use_tioctl
<a name="use_tioctl"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>use_tioctl</b> routine, if used, should be called before
<b>initscr</b> or <b>newterm</b> are called (because those
compute the screen size). After <b>use_tioctl</b> is called
with <b>TRUE</b> as an argument, <i>ncurses</i> modifies the
last step in its computation of screen size as follows:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">checks if the <i>LINES</i> and
<i>COLUMNS</i> environment variables are set to a number
greater than zero.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>for each, <i>ncurses</i> updates the corresponding
environment variable with the value that it has obtained via
operating system call or from the terminal database.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p><i>ncurses</i> re-fetches the value of the environment
variables so that it is still the environment variables that
set the screen size.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The
<b>use_env</b> and <b>use_tioctl</b> routines combine as
follows.</p>
<h3>putwin, getwin
<a name="putwin, getwin"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>putwin</b> routine writes all data associated with window
(or pad) <i>win</i> into the file to which <i>filep</i>
points. This information can be later retrieved using the
<b>getwin</b> function.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>getwin</b> routine reads window related data stored in
the file by <b>putwin</b>. The routine then creates and
initializes a new window using that data. It returns a
pointer to the new window. There are a few caveats:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">the data written is a copy of
the <i>WINDOW</i> structure, and its associated character
cells. The format differs between the wide-character
(<i>ncursesw</i>) and non-wide (<i>ncurses</i>) libraries.
You can transfer data between the two, however.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the retrieved window is always created as a top-level
window (or pad), rather than a subwindow.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the window’s character cells contain the color
pair <i>value</i>, but not the actual color <i>numbers</i>.
If cells in the retrieved window use color pairs that have
not been created in the application using <b>init_pair</b>,
they will not be colored when the window is refreshed.</p></td></tr>
</table>
<h3>delay_output
<a name="delay_output"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>delay_output</b> routine inserts an <i>ms</i> millisecond
pause in output. Employ this function judiciously when
terminal output uses padding, because <i>ncurses</i>
transmits null characters (consuming CPU and I/O resources)
instead of sleeping and requesting resumption from the
operating system. Padding is used unless:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="78%">
<p style="margin-top: 1em">the terminal description has
<b>npc</b> (<b>no_pad_char</b>) capability, or</p></td>
<td width="8%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="78%">
<p>the environment variable <b>NCURSES_NO_PADDING</b> is
set.</p> </td>
<td width="8%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">If padding is
not in use, <i>ncurses</i> uses <b>napms</b> to perform the
delay. If the value of <i>ms</i> exceeds 30,000 (thirty
seconds), it is capped at that value.</p>
<h3>flushinp
<a name="flushinp"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>flushinp</b> routine throws away any typeahead that has
been typed by the user and has not yet been read by the
program.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Except for
<b>flushinp</b>, routines that return an integer return
<b>ERR</b> upon failure and <b>OK</b> (SVr4 specifies only
"an integer value other than <b>ERR</b>") upon
successful completion.</p>
<p style="margin-left:9%; margin-top: 1em">Routines that
return pointers return <b>NULL</b> on error.</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses
does not specify any error conditions. In this
implementation</p>
<p style="margin-left:13%;"><b>flushinp</b></p>
<p style="margin-left:19%;">returns <b>ERR</b> if the
terminal was not initialized.</p>
<p style="margin-left:13%;"><b>putwin</b></p>
<p style="margin-left:19%;">returns <b>ERR</b> if the
associated <i>write</i>(2) calls return <b>ERR</b>.</p>
<h2>PORTABILITY
<a name="PORTABILITY"></a>
</h2>
<h3>filter
<a name="filter"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The SVr4
documentation describes the action of <b>filter</b> only in
the vaguest terms. The description here is adapted from
X/Open Curses (which erroneously fails to describe the
disabling of <b>cuu</b>).</p>
<h3>delay_output padding
<a name="delay_output padding"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The limitation
to 30 seconds and the use of <b>napms</b> differ from other
implementations.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>SVr4 curses does not delay if no padding character is
available.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>NetBSD curses uses <b>napms</b> when no padding
character is available, but does not take timing into
account when using the padding character.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Neither limits
the delay.</p>
<h3>keyname
<a name="keyname"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>keyname</b> function may return the names of user-defined
string capabilities that are defined in the terminfo entry
via the <b>−x</b> option of <b>tic</b>. This
implementation automatically assigns at run-time key codes
to user-defined strings that begin with “k”. The
key codes start at KEY_MAX, but are not guaranteed to be the
same value for different runs because user-defined codes are
merged from all terminal descriptions that have been loaded.
The <b>use_extended_names</b>(3X) function controls whether
this data is loaded when the terminal description is read by
the library.</p>
<h3>nofilter, use_tioctl
<a name="nofilter, use_tioctl"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>nofilter</b> and <b>use_tioctl</b> routines are specific
to <i>ncurses</i>. They were not supported on Version 7, BSD
or System V implementations. It is recommended that any code
depending on <i>ncurses</i> extensions be conditioned using
<b>NCURSES_VERSION</b>.</p>
<h3>putwin/getwin file-format
<a name="putwin/getwin file-format"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>putwin</b> and <b>getwin</b> functions have several
issues with portability:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">The files written and read by
these functions use an implementation-specific format.
Although the format is an obvious target for
standardization, it has been overlooked.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Interestingly
enough, according to the copyright dates in Solaris source,
the functions (along with <b>scr_init</b>, etc.) originated
with the University of California, Berkeley (in 1982) and
were later (in 1988) incorporated into SVr4. Oddly, there
are no such functions in the 4.3BSD curses sources.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Most implementations simply dump
the binary <i>WINDOW</i> structure to the file. These
include SVr4 curses, NetBSD and PDCurses, as well as older
<i>ncurses</i> versions. This implementation (as well as the
X/Open variant of Solaris curses, dated 1995) uses textual
dumps.</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">The
implementations that use binary dumps use block-I/O
(<i>write</i>(2) and <i>read</i>(2) functions). Those that
use textual dumps use buffered-I/O. A few applications may
happen to write extra data in the file using these
functions. Doing that can run into problems mixing block-
and buffered-I/O. This implementation reduces the problem on
writes by flushing the output. However, reading from a file
written using mixed schemes may not be successful.</p>
<h3>unctrl, wunctrl
<a name="unctrl, wunctrl"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses,
Issue 4 describes these functions. It states that
<b>unctrl</b> and <b>wunctrl</b> will return a null pointer
if unsuccessful, but does not define any error conditions.
This implementation checks for three cases:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">the parameter is a 7-bit
US−ASCII code. This is the case that X/Open Curses
documented.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the parameter is in the range 128−159, i.e., a C1
control code. If <b>use_legacy_coding</b>(3X) has been
called with a <b>2</b> parameter, <b>unctrl</b> returns the
parameter, i.e., a one-character string with the parameter
as the first character. Otherwise, it returns
“˜@”, “˜A”, etc.,
analogous to “ˆ@”, “ˆA”,
C0 controls.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">X/Open Curses
does not document whether <b>unctrl</b> can be called before
initializing curses. This implementation permits that, and
returns the “˜@”, etc., values in that
case.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">parameter values outside the 0
to 255 range. <b>unctrl</b> returns a null pointer.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The strings
returned by <b>unctrl</b> in this implementation are
determined at compile time, showing C1 controls from the
upper-128 codes with a “˜” prefix rather
than “ˆ”. Other implementations have
different conventions. For example, they may show both sets
of control characters with “ˆ”, and strip
the parameter to 7 bits. Or they may ignore C1 controls and
treat all of the upper-128 codes as printable. This
implementation uses 8 bits but does not modify the string to
reflect locale. The <b>use_legacy_coding</b>(3X) function
allows the caller to change the output of <b>unctrl</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Likewise, the
<b>meta</b>(3X) function allows the caller to change the
output of <b>keyname</b>, i.e., it determines whether to use
the “M−” prefix for “meta”
keys (codes in the range 128 to 255). Both
<b>use_legacy_coding</b>(3X) and <b>meta</b>(3X) succeed
only after curses is initialized. X/Open Curses does not
document the treatment of codes 128 to 159. When treating
them as “meta” keys (or if <b>keyname</b> is
called before initializing curses), this implementation
returns strings “M−ˆ@”,
“M−ˆA”, etc.</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses
documents <b>unctrl</b> as declared in
<b>&lt;unctrl.h&gt;</b>, which <i>ncurses</i> does. However,
<i>ncurses</i>’ <b>&lt;curses.h&gt;</b> includes
<b>&lt;unctrl.h&gt;</b>, matching the behavior of SVr4
curses. Other implementations may not do that.</p>
<h3>use_env, use_tioctl
<a name="use_env, use_tioctl"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If
<i>ncurses</i> is configured to provide the sp-functions
extension, the state of <b>use_env</b> and <b>use_tioctl</b>
may be updated before creating each <i>screen</i> rather
than once only (<b>curs_sp_funcs</b>(3X)). This feature of
<b>use_env</b> is not provided by other implementations of
curses.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">4BSD (1980)
defined <i>unctrl</i> (as a macro, in <i>unctrl.h</i>).</p>
<p style="margin-left:9%; margin-top: 1em">SVr2 (1984)
introduced <i>delay_output</i>, <i>flushinp</i>, and
<i>keyname</i>.</p>
<p style="margin-left:9%; margin-top: 1em">SVr3 (1987)
added <i>filter</i>. Later that year, SVr3.1 brought
<i>getwin</i> and <i>putwin</i>, reading and writing window
dumps with <i>fread</i>(3) and <i>fwrite</i>(3),
respectively.</p>
<p style="margin-left:9%; margin-top: 1em">SVr4 (1989)
supplied <i>use_env</i>.</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses
Issue 4 (1995) specified <i>key_name</i> and
<i>wunctrl</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><i>ncurses</i>
5.6 (2006) added <i>nofilter</i>, and 6.0 (2015)
<i>use_tioctl</i>.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>curses</b>(3X),
<b>curs_initscr</b>(3X), <b>curs_inopts</b>(3X),
<b>curs_kernel</b>(3X), <b>curs_scr_dump</b>(3X),
<b>curs_sp_funcs</b>(3X), <b>curs_variables</b>(3X),
<b>legacy_coding</b>(3X)</p>
<hr/>
</body>
</html>
