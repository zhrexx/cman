<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:48:19 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Math::BigInt</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Math::BigInt</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Input">Input</a><br/>
<a href="#Output">Output</a><br/>
<a href="#METHODS">METHODS</a><br/>
<a href="#Configuration methods">Configuration methods</a><br/>
<a href="#Constructor methods">Constructor methods</a><br/>
<a href="#Boolean methods">Boolean methods</a><br/>
<a href="#Comparison methods">Comparison methods</a><br/>
<a href="#Arithmetic methods">Arithmetic methods</a><br/>
<a href="#Bitwise methods">Bitwise methods</a><br/>
<a href="#Rounding methods">Rounding methods</a><br/>
<a href="#Other mathematical methods">Other mathematical methods</a><br/>
<a href="#Object property methods">Object property methods</a><br/>
<a href="#String conversion methods">String conversion methods</a><br/>
<a href="#Other conversion methods">Other conversion methods</a><br/>
<a href="#Utility methods">Utility methods</a><br/>
<a href="#ACCURACY and PRECISION">ACCURACY and PRECISION</a><br/>
<a href="#Precision P">Precision P</a><br/>
<a href="#Accuracy A">Accuracy A</a><br/>
<a href="#Fallback F">Fallback F</a><br/>
<a href="#Rounding mode R">Rounding mode R</a><br/>
<a href="#Infinity and Not a Number">Infinity and Not a Number</a><br/>
<a href="#INTERNALS">INTERNALS</a><br/>
<a href="#MATH LIBRARY">MATH LIBRARY</a><br/>
<a href="#SIGN">SIGN</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#NUMERIC LITERALS">NUMERIC LITERALS</a><br/>
<a href="#Hexadecimal, octal, and binary floating point literals">Hexadecimal, octal, and binary floating point literals</a><br/>
<a href="#PERFORMANCE">PERFORMANCE</a><br/>
<a href="#Alternative math libraries">Alternative math libraries</a><br/>
<a href="#SUBCLASSING">SUBCLASSING</a><br/>
<a href="#Subclassing Math::BigInt">Subclassing Math::BigInt</a><br/>
<a href="#UPGRADING">UPGRADING</a><br/>
<a href="#Auto−upgrade">Auto−upgrade</a><br/>
<a href="#EXPORTS">EXPORTS</a><br/>
<a href="#CAVEATS">CAVEATS</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#SUPPORT">SUPPORT</a><br/>
<a href="#LICENSE">LICENSE</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHORS">AUTHORS</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Math::BigInt
− arbitrary size integer math package</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use
Math::BigInt; <br/>
# or make it faster with huge numbers: install (optional)
<br/>
# Math::BigInt::GMP and always use (it falls back to <br/>
# pure Perl if the GMP library is not installed): <br/>
# (See also the L&lt;MATH LIBRARY&gt; section!) <br/>
# to warn if Math::BigInt::GMP cannot be found, use <br/>
use Math::BigInt lib =&gt; 'GMP'; <br/>
# to suppress the warning if Math::BigInt::GMP cannot be
found, use <br/>
# use Math::BigInt try =&gt; 'GMP'; <br/>
# to die if Math::BigInt::GMP cannot be found, use <br/>
# use Math::BigInt only =&gt; 'GMP'; <br/>
# Configuration methods (may be used as class methods and
instance methods) <br/>
Math::BigInt−&gt;accuracy(); # get class accuracy <br/>
Math::BigInt−&gt;accuracy($n); # set class accuracy
<br/>
Math::BigInt−&gt;precision(); # get class precision
<br/>
Math::BigInt−&gt;precision($n); # set class precision
<br/>
Math::BigInt−&gt;round_mode(); # get class rounding
mode <br/>
Math::BigInt−&gt;round_mode($m); # set global round
mode, must be one of <br/>
# 'even', 'odd', '+inf', '−inf', 'zero', <br/>
# 'trunc', or 'common' <br/>
Math::BigInt−&gt;div_scale($n); # set fallback
accuracy <br/>
Math::BigInt−&gt;trap_inf($b); # trap infinities or
not <br/>
Math::BigInt−&gt;trap_nan($b); # trap NaNs or not <br/>
Math::BigInt−&gt;config(); # return hash with
configuration <br/>
# Constructor methods (when the class methods below are used
as instance <br/>
# methods, the value is assigned the invocand) <br/>
$x = Math::BigInt−&gt;new($str); # defaults to 0 <br/>
$x = Math::BigInt−&gt;new('0x123'); # from hexadecimal
<br/>
$x = Math::BigInt−&gt;new('0b101'); # from binary <br/>
$x = Math::BigInt−&gt;from_hex('cafe'); # from
hexadecimal <br/>
$x = Math::BigInt−&gt;from_oct('377'); # from octal
<br/>
$x = Math::BigInt−&gt;from_bin('1101'); # from binary
<br/>
$x = Math::BigInt−&gt;from_base('why', 36); # from any
base <br/>
$x = Math::BigInt−&gt;from_base_num([1, 0], 2); # from
any base <br/>
$x = Math::BigInt−&gt;bzero(); # create a +0 <br/>
$x = Math::BigInt−&gt;bone(); # create a +1 <br/>
$x = Math::BigInt−&gt;bone('−'); # create a
−1 <br/>
$x = Math::BigInt−&gt;binf(); # create a +inf <br/>
$x = Math::BigInt−&gt;binf('−'); # create a
−inf <br/>
$x = Math::BigInt−&gt;bnan(); # create a
Not−A−Number <br/>
$x = Math::BigInt−&gt;bpi(); # returns pi <br/>
$y = $x−&gt;copy(); # make a copy (unlike $y = $x)
<br/>
$y = $x−&gt;as_int(); # return as a Math::BigInt <br/>
$y = $x−&gt;as_float(); # return as a Math::BigFloat
<br/>
$y = $x−&gt;as_rat(); # return as a Math::BigRat <br/>
# Boolean methods (these don't modify the invocand) <br/>
$x−&gt;is_zero(); # if $x is 0 <br/>
$x−&gt;is_one(); # if $x is +1 <br/>
$x−&gt;is_one("+"); # ditto <br/>
$x−&gt;is_one("−"); # if $x is
−1 <br/>
$x−&gt;is_inf(); # if $x is +inf or −inf <br/>
$x−&gt;is_inf("+"); # if $x is +inf <br/>
$x−&gt;is_inf("−"); # if $x is
−inf <br/>
$x−&gt;is_nan(); # if $x is NaN <br/>
$x−&gt;is_positive(); # if $x &gt; 0 <br/>
$x−&gt;is_pos(); # ditto <br/>
$x−&gt;is_negative(); # if $x &lt; 0 <br/>
$x−&gt;is_neg(); # ditto <br/>
$x−&gt;is_odd(); # if $x is odd <br/>
$x−&gt;is_even(); # if $x is even <br/>
$x−&gt;is_int(); # if $x is an integer <br/>
# Comparison methods <br/>
$x−&gt;bcmp($y); # compare numbers (undef, &lt; 0, ==
0, &gt; 0) <br/>
$x−&gt;bacmp($y); # compare absolutely (undef, &lt; 0,
== 0, &gt; 0) <br/>
$x−&gt;beq($y); # true if and only if $x == $y <br/>
$x−&gt;bne($y); # true if and only if $x != $y <br/>
$x−&gt;blt($y); # true if and only if $x &lt; $y <br/>
$x−&gt;ble($y); # true if and only if $x &lt;= $y <br/>
$x−&gt;bgt($y); # true if and only if $x &gt; $y <br/>
$x−&gt;bge($y); # true if and only if $x &gt;= $y <br/>
# Arithmetic methods <br/>
$x−&gt;bneg(); # negation <br/>
$x−&gt;babs(); # absolute value <br/>
$x−&gt;bsgn(); # sign function (−1, 0, 1, or
NaN) <br/>
$x−&gt;bnorm(); # normalize (no−op) <br/>
$x−&gt;binc(); # increment $x by 1 <br/>
$x−&gt;bdec(); # decrement $x by 1 <br/>
$x−&gt;badd($y); # addition (add $y to $x) <br/>
$x−&gt;bsub($y); # subtraction (subtract $y from $x)
<br/>
$x−&gt;bmul($y); # multiplication (multiply $x by $y)
<br/>
$x−&gt;bmuladd($y,$z); # $x = $x * $y + $z <br/>
$x−&gt;bdiv($y); # division (floored), set $x to
quotient <br/>
# return (quo,rem) or quo if scalar <br/>
$x−&gt;btdiv($y); # division (truncated), set $x to
quotient <br/>
# return (quo,rem) or quo if scalar <br/>
$x−&gt;bmod($y); # modulus (x % y) <br/>
$x−&gt;btmod($y); # modulus (truncated) <br/>
$x−&gt;bmodinv($mod); # modular multiplicative inverse
<br/>
$x−&gt;bmodpow($y,$mod); # modular exponentiation (($x
** $y) % $mod) <br/>
$x−&gt;binv() # inverse (1/$x) <br/>
$x−&gt;bpow($y); # power of arguments (x ** y) <br/>
$x−&gt;blog(); # logarithm of $x to base e (Euler's
number) <br/>
$x−&gt;blog($base); # logarithm of $x to base $base
(e.g., base 2) <br/>
$x−&gt;bexp(); # calculate e ** $x where e is Euler's
number <br/>
$x−&gt;bilog2(); # log2($x) rounded down to nearest
int <br/>
$x−&gt;bilog10(); # log10($x) rounded down to nearest
int <br/>
$x−&gt;bclog2(); # log2($x) rounded up to nearest int
<br/>
$x−&gt;bclog10(); # log19($x) rounded up to nearest
int <br/>
$x−&gt;bnok($y); # x over y (binomial coefficient n
over k) <br/>
$x−&gt;buparrow($n, $y); # Knuth's up−arrow
notation <br/>
$x−&gt;backermann($y); # the Ackermann function <br/>
$x−&gt;bsin(); # sine <br/>
$x−&gt;bcos(); # cosine <br/>
$x−&gt;batan(); # inverse tangent <br/>
$x−&gt;batan2($y); # two−argument inverse
tangent <br/>
$x−&gt;bsqrt(); # calculate square root <br/>
$x−&gt;broot($y); # $y'th root of $x (e.g. $y == 3
=&gt; cubic root) <br/>
$x−&gt;bfac(); # factorial of $x (1*2*3*4*..$x) <br/>
$x−&gt;bdfac(); # double factorial of $x
($x*($x−2)*($x−4)*...) <br/>
$x−&gt;btfac(); # triple factorial of $x
($x*($x−3)*($x−6)*...) <br/>
$x−&gt;bmfac($k); # $k'th multi−factorial of $x
($x*($x−$k)*...) <br/>
$x−&gt;blsft($n); # left shift $n places in base 2
<br/>
$x−&gt;blsft($n,$b); # left shift $n places in base $b
<br/>
# returns (quo,rem) or quo (scalar context) <br/>
$x−&gt;brsft($n); # right shift $n places in base 2
<br/>
$x−&gt;brsft($n,$b); # right shift $n places in base
$b <br/>
# returns (quo,rem) or quo (scalar context) <br/>
# Bitwise methods <br/>
$x−&gt;bblsft($y); # bitwise left shift <br/>
$x−&gt;bbrsft($y); # bitwise right shift <br/>
$x−&gt;band($y); # bitwise and <br/>
$x−&gt;bior($y); # bitwise inclusive or <br/>
$x−&gt;bxor($y); # bitwise exclusive or <br/>
$x−&gt;bnot(); # bitwise not (two's complement) <br/>
# Rounding methods <br/>
$x−&gt;round($A,$P,$mode); # round to accuracy or
precision using <br/>
# rounding mode $mode <br/>
$x−&gt;bround($n); # accuracy: preserve $n digits <br/>
$x−&gt;bfround($n); # $n &gt; 0: round to $nth digit
left of dec. point <br/>
# $n &lt; 0: round to $nth digit right of dec. point <br/>
$x−&gt;bfloor(); # round towards minus infinity <br/>
$x−&gt;bceil(); # round towards plus infinity <br/>
$x−&gt;bint(); # round towards zero <br/>
# Other mathematical methods <br/>
$x−&gt;bgcd($y); # greatest common divisor <br/>
$x−&gt;blcm($y); # least common multiple <br/>
# Object property methods (do not modify the invocand) <br/>
$x−&gt;sign(); # the sign, either +, − or NaN
<br/>
$x−&gt;digit($n); # the nth digit, counting from the
right <br/>
$x−&gt;digit(−$n); # the nth digit, counting
from the left <br/>
$x−&gt;length(); # return number of digits in number
<br/>
($xl,$f) = $x−&gt;length(); # length of number and
length of fraction <br/>
# part, latter is always 0 digits long <br/>
# for Math::BigInt objects <br/>
$x−&gt;mantissa(); # return (signed) mantissa as a
Math::BigInt <br/>
$x−&gt;exponent(); # return exponent as a Math::BigInt
<br/>
$x−&gt;parts(); # return (mantissa,exponent) as a
Math::BigInt <br/>
$x−&gt;sparts(); # mantissa and exponent (as integers)
<br/>
$x−&gt;nparts(); # mantissa and exponent (normalised)
<br/>
$x−&gt;eparts(); # mantissa and exponent (engineering
notation) <br/>
$x−&gt;dparts(); # integer and fraction part <br/>
$x−&gt;fparts(); # numerator and denominator <br/>
$x−&gt;numerator(); # numerator <br/>
$x−&gt;denominator(); # denominator <br/>
# Conversion methods (do not modify the invocand) <br/>
$x−&gt;bstr(); # decimal notation, possibly zero
padded <br/>
$x−&gt;bsstr(); # string in scientific notation with
integers <br/>
$x−&gt;bnstr(); # string in normalized notation <br/>
$x−&gt;bestr(); # string in engineering notation <br/>
$x−&gt;bfstr(); # string in fractional notation <br/>
$x−&gt;to_hex(); # as signed hexadecimal string <br/>
$x−&gt;to_bin(); # as signed binary string <br/>
$x−&gt;to_oct(); # as signed octal string <br/>
$x−&gt;to_bytes(); # as byte string <br/>
$x−&gt;to_base($b); # as string in any base <br/>
$x−&gt;to_base_num($b); # as array of integers in any
base <br/>
$x−&gt;as_hex(); # as signed hexadecimal string with
prefixed 0x <br/>
$x−&gt;as_bin(); # as signed binary string with
prefixed 0b <br/>
$x−&gt;as_oct(); # as signed octal string with
prefixed 0 <br/>
# Other conversion methods <br/>
$x−&gt;numify(); # return as scalar (might overflow or
underflow)</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Math::BigInt
provides support for arbitrary precision integers.
Overloading is also provided for Perl operators.</p>
<h3>Input
<a name="Input"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Input values to
these routines may be any scalar number or string that looks
like a number and represents an integer. Anything that is
accepted by Perl as a literal numeric constant should be
accepted by this module, except that finite
non−integers return NaN.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Leading and trailing whitespace is ignored.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Leading zeros are ignored, except for floating point
numbers with a binary exponent, in which case the number is
interpreted as an octal floating point number. For example,
"01.4p+0" gives 1.5, "00.4p+0" gives
0.5, but "0.4p+0" gives a NaN. And while
"0377" gives 255, "0377p0" gives
255.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>If the string has a "0x" or "0X"
prefix, it is interpreted as a hexadecimal number.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>If the string has a "0o" or "0O"
prefix, it is interpreted as an octal number. A floating
point literal with a "0" prefix is also
interpreted as an octal number.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>If the string has a "0b" or "0B"
prefix, it is interpreted as a binary number.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Underline characters are allowed in the same way as they
are allowed in literal numerical constants.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>If the string can not be interpreted, or does not
represent a finite integer, NaN is returned.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>For hexadecimal, octal, and binary floating point
numbers, the exponent must be separated from the significand
(mantissa) by the letter "p" or "P", not
"e" or "E" as with decimal numbers.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Some examples of
valid string input</p>
<p style="margin-left:9%; margin-top: 1em">Input string
Resulting value <br/>
123 123 <br/>
1.23e2 123 <br/>
12300e−2 123 <br/>
67_538_754 67538754 <br/>
−4_5_6.7_8_9e+0_1_0 −4567890000000 <br/>
0x13a 314 <br/>
0x13ap0 314 <br/>
0x1.3ap+8 314 <br/>
0x0.00013ap+24 314 <br/>
0x13a000p−12 314 <br/>
0o472 314 <br/>
0o1.164p+8 314 <br/>
0o0.0001164p+20 314 <br/>
0o1164000p−10 314 <br/>
0472 472 Note! <br/>
01.164p+8 314 <br/>
00.0001164p+20 314 <br/>
01164000p−10 314 <br/>
0b100111010 314 <br/>
0b1.0011101p+8 314 <br/>
0b0.00010011101p+12 314 <br/>
0b100111010000p−3 314</p>
<p style="margin-left:9%; margin-top: 1em">Input given as
scalar numbers might lose precision. Quote your input to
ensure that no digits are lost:</p>
<p style="margin-left:9%; margin-top: 1em">$x =
Math::BigInt−&gt;new( 56789012345678901234 ); # bad
<br/>
$x = Math::BigInt−&gt;new('56789012345678901234'); #
good</p>
<p style="margin-left:9%; margin-top: 1em">Currently,
"Math::BigInt−"<b>new()</b>&gt; (no input
argument) and
"Math::BigInt−"new("")&gt; return
0. This might change in the future, so always use the
following explicit forms to get a zero:</p>
<p style="margin-left:9%; margin-top: 1em">$zero =
Math::BigInt−&gt;bzero();</p>
<h3>Output
<a name="Output"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Output values
are usually Math::BigInt objects.</p>
<p style="margin-left:9%; margin-top: 1em">Boolean
operators is_zero(), is_one(), is_inf(), etc. return true or
false.</p>
<p style="margin-left:9%; margin-top: 1em">Comparison
operators bcmp() and bacmp()) return −1, 0, 1, or
undef.</p>
<h2>METHODS
<a name="METHODS"></a>
</h2>
<h3>Configuration methods
<a name="Configuration methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Each of the
methods below (except <b>config()</b>, <b>accuracy()</b> and
<b>precision()</b>) accepts three additional parameters.
These arguments $A, $P and $R are "accuracy",
"precision" and "round_mode". Please see
the section about "ACCURACY and PRECISION" for
more information.</p>
<p style="margin-left:9%; margin-top: 1em">Setting a class
variable effects all object instance that are created
afterwards. <b><br/>
accuracy()</b></p>
<p style="margin-left:14%;">Math::BigInt−&gt;accuracy(5);
# set class accuracy <br/>
$x−&gt;accuracy(5); # set instance accuracy <br/>
$A = Math::BigInt−&gt;accuracy(); # get class accuracy
<br/>
$A = $x−&gt;accuracy(); # get instance accuracy</p>
<p style="margin-left:14%; margin-top: 1em">Set or get the
accuracy, i.e., the number of significant digits. The
accuracy must be an integer. If the accuracy is set to
"undef", no rounding is done.</p>
<p style="margin-left:14%; margin-top: 1em">Alternatively,
one can round the results explicitly using one of
"<b>round()</b>", "<b>bround()</b>" or
"<b>bfround()</b>" or by passing the desired
accuracy to the method as an additional parameter:</p>
<p style="margin-left:14%; margin-top: 1em">my $x =
Math::BigInt−&gt;new(30000); <br/>
my $y = Math::BigInt−&gt;new(7); <br/>
print scalar $x−&gt;copy()−&gt;bdiv($y, 2); #
prints 4300 <br/>
print scalar
$x−&gt;copy()−&gt;bdiv($y)−&gt;bround(2);
# prints 4300</p>
<p style="margin-left:14%; margin-top: 1em">Please see the
section about "ACCURACY and PRECISION" for further
details.</p>
<p style="margin-left:14%; margin-top: 1em">$y =
Math::BigInt−&gt;new(1234567); # $y is not rounded
<br/>
Math::BigInt−&gt;accuracy(4); # set class accuracy to
4 <br/>
$x = Math::BigInt−&gt;new(1234567); # $x is rounded
automatically <br/>
print "$x $y"; # prints "1235000
1234567" <br/>
print $x−&gt;accuracy(); # prints "4" <br/>
print $y−&gt;accuracy(); # also prints "4",
since <br/>
# class accuracy is 4 <br/>
Math::BigInt−&gt;accuracy(5); # set class accuracy to
5 <br/>
print $x−&gt;accuracy(); # prints "4", since
instance <br/>
# accuracy is 4 <br/>
print $y−&gt;accuracy(); # prints "5", since
no instance <br/>
# accuracy, and class accuracy is 5</p>
<p style="margin-left:14%; margin-top: 1em">Note: Each
class has it's own globals separated from Math::BigInt, but
it is possible to subclass Math::BigInt and make the globals
of the subclass aliases to the ones from Math::BigInt.</p>
<p style="margin-left:9%;"><b>precision()</b></p>
<p style="margin-left:14%;">Math::BigInt−&gt;precision(−2);
# set class precision <br/>
$x−&gt;precision(−2); # set instance precision
<br/>
$P = Math::BigInt−&gt;precision(); # get class
precision <br/>
$P = $x−&gt;precision(); # get instance precision</p>
<p style="margin-left:14%; margin-top: 1em">Set or get the
precision, i.e., the place to round relative to the decimal
point. The precision must be a integer. Setting the
precision to $P means that each number is rounded up or
down, depending on the rounding mode, to the nearest
multiple of 10**$P. If the precision is set to
"undef", no rounding is done.</p>
<p style="margin-left:14%; margin-top: 1em">You might want
to use "<b>accuracy()</b>" instead. With
"<b>accuracy()</b>" you set the number of digits
each result should have, with "<b>precision()</b>"
you set the place where to round.</p>
<p style="margin-left:14%; margin-top: 1em">Please see the
section about "ACCURACY and PRECISION" for further
details.</p>
<p style="margin-left:14%; margin-top: 1em">$y =
Math::BigInt−&gt;new(1234567); # $y is not rounded
<br/>
Math::BigInt−&gt;precision(4); # set class precision
to 4 <br/>
$x = Math::BigInt−&gt;new(1234567); # $x is rounded
automatically <br/>
print $x; # prints "1230000"</p>
<p style="margin-left:14%; margin-top: 1em">Note: Each
class has its own globals separated from Math::BigInt, but
it is possible to subclass Math::BigInt and make the globals
of the subclass aliases to the ones from Math::BigInt.</p>
<p style="margin-left:9%;"><b>div_scale()</b></p>
<p style="margin-left:14%;">Set/get the fallback accuracy.
This is the accuracy used when neither accuracy nor
precision is set explicitly. It is used when a computation
might otherwise attempt to return an infinite number of
digits.</p>
<p style="margin-left:9%;"><b>round_mode()</b></p>
<p style="margin-left:14%;">Set/get the rounding mode.</p>
<p style="margin-left:9%;"><b>trap_inf()</b></p>
<p style="margin-left:14%;">Set/get the value determining
whether infinities should cause a fatal error or not.</p>
<p style="margin-left:9%;"><b>trap_nan()</b></p>
<p style="margin-left:14%;">Set/get the value determining
whether NaNs should cause a fatal error or not.</p>
<p style="margin-left:9%;"><b>upgrade()</b></p>
<p style="margin-left:14%;">Set/get the class for
upgrading. When a computation might result in a
non−integer, the operands are upgraded to this class.
This is used for instance by bignum. The default is
"undef", i.e., no upgrading.</p>
<p style="margin-left:14%; margin-top: 1em"># with no
upgrading <br/>
$x = Math::BigInt−&gt;new(12); <br/>
$y = Math::BigInt−&gt;new(5); <br/>
print $x / $y, "\n"; # 2 as a Math::BigInt <br/>
# with upgrading to Math::BigFloat <br/>
Math::BigInt −&gt;
upgrade("Math::BigFloat"); <br/>
print $x / $y, "\n"; # 2.4 as a Math::BigFloat
<br/>
# with upgrading to Math::BigRat (after loading
Math::BigRat) <br/>
Math::BigInt −&gt; upgrade("Math::BigRat");
<br/>
print $x / $y, "\n"; # 12/5 as a Math::BigRat</p>
<p style="margin-left:9%;"><b>downgrade()</b></p>
<p style="margin-left:14%;">Set/get the class for
downgrading. The default is "undef", i.e., no
downgrading. Downgrading is not done by Math::BigInt.</p>
<p style="margin-left:9%;"><b>modify()</b></p>
<p style="margin-left:14%;">$x−&gt;modify('bpowd');</p>
<p style="margin-left:14%; margin-top: 1em">This method
returns 0 if the object can be modified with the given
operation, or 1 if not.</p>
<p style="margin-left:14%; margin-top: 1em">This is used
for instance by Math::BigInt::Constant.</p>
<p style="margin-left:9%;"><b>config()</b></p>
<p style="margin-left:14%;">Math::BigInt−&gt;config("trap_nan"
=&gt; 1); # set <br/>
$accu = Math::BigInt−&gt;config("accuracy");
# get</p>
<p style="margin-left:14%; margin-top: 1em">Set or get
class variables. Read−only parameters are marked as
RO. Read−write parameters are marked as RW. The
following parameters are supported.</p>
<p style="margin-left:14%; margin-top: 1em">Parameter RO/RW
Description <br/>
Example <br/>

============================================================
<br/>
lib RO Name of the math backend library <br/>
Math::BigInt::Calc <br/>
lib_version RO Version of the math backend library <br/>
0.30 <br/>
class RO The class of config you just called <br/>
Math::BigRat <br/>
version RO version number of the class you used <br/>
0.10 <br/>
upgrade RW To which class numbers are upgraded <br/>
undef <br/>
downgrade RW To which class numbers are downgraded <br/>
undef <br/>
precision RW Global precision <br/>
undef <br/>
accuracy RW Global accuracy <br/>
undef <br/>
round_mode RW Global round mode <br/>
even <br/>
div_scale RW Fallback accuracy for division etc. <br/>
40 <br/>
trap_nan RW Trap NaNs <br/>
undef <br/>
trap_inf RW Trap +inf/−inf <br/>
undef</p>
<h3>Constructor methods
<a name="Constructor methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>new()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;new($str,$A,$P,$R);</p>
<p style="margin-left:14%; margin-top: 1em">Creates a new
Math::BigInt object from a scalar or another Math::BigInt
object. The input is accepted as decimal, hexadecimal (with
leading '0x'), octal (with leading ('0o') or binary (with
leading '0b').</p>
<p style="margin-left:14%; margin-top: 1em">See
"Input" for more info on accepted input
formats.</p>
<p style="margin-left:9%;"><b>from_dec()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;from_dec("314159"); # input
is decimal</p>
<p style="margin-left:14%; margin-top: 1em">Interpret input
as a decimal. It is equivalent to <b>new()</b>, but does not
accept anything but strings representing finite, decimal
numbers.</p>
<p style="margin-left:9%;"><b>from_hex()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;from_hex("0xcafe"); # input
is hexadecimal</p>
<p style="margin-left:14%; margin-top: 1em">Interpret input
as a hexadecimal string. A "0x" or "x"
prefix is optional. A single underscore character may be
placed right after the prefix, if present, or between any
two digits. If the input is invalid, a NaN is returned.</p>
<p style="margin-left:9%;"><b>from_oct()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;from_oct("0775"); # input
is octal</p>
<p style="margin-left:14%; margin-top: 1em">Interpret the
input as an octal string and return the corresponding value.
A "0" (zero) prefix is optional. A single
underscore character may be placed right after the prefix,
if present, or between any two digits. If the input is
invalid, a NaN is returned.</p>
<p style="margin-left:9%;"><b>from_bin()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;from_bin("0b10011"); #
input is binary</p>
<p style="margin-left:14%; margin-top: 1em">Interpret the
input as a binary string. A "0b" or "b"
prefix is optional. A single underscore character may be
placed right after the prefix, if present, or between any
two digits. If the input is invalid, a NaN is returned.</p>
<p style="margin-left:9%;"><b>from_bytes()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;from_bytes("\xf3\x6b"); #
$x = 62315</p>
<p style="margin-left:14%; margin-top: 1em">Interpret the
input as a byte string, assuming big endian byte order. The
output is always a non−negative, finite integer.</p>
<p style="margin-left:14%; margin-top: 1em">In some special
cases, <b>from_bytes()</b> matches the conversion done by
<b>unpack()</b>:</p>
<p style="margin-left:14%; margin-top: 1em">$b =
"\x4e"; # one char byte string <br/>
$x = Math::BigInt−&gt;from_bytes($b); # = 78 <br/>
$y = unpack "C", $b; # ditto, but scalar <br/>
$b = "\xf3\x6b"; # two char byte string <br/>
$x = Math::BigInt−&gt;from_bytes($b); # = 62315 <br/>
$y = unpack "S&gt;", $b; # ditto, but scalar <br/>
$b = "\x2d\xe0\x49\xad"; # four char byte string
<br/>
$x = Math::BigInt−&gt;from_bytes($b); # = 769673645
<br/>
$y = unpack "L&gt;", $b; # ditto, but scalar <br/>
$b = "\x2d\xe0\x49\xad\x2d\xe0\x49\xad"; # eight
char byte string <br/>
$x = Math::BigInt−&gt;from_bytes($b); # =
3305723134637787565 <br/>
$y = unpack "Q&gt;", $b; # ditto, but scalar</p>
<p style="margin-left:9%;"><b>from_base()</b></p>
<p style="margin-left:14%;">Given a string, a base, and an
optional collation sequence, interpret the string as a
number in the given base. The collation sequence describes
the value of each character in the string.</p>
<p style="margin-left:14%; margin-top: 1em">If a collation
sequence is not given, a default collation sequence is used.
If the base is less than or equal to 36, the collation
sequence is the string consisting of the 36 characters
"0" to "9" and "A" to
"Z". In this case, the letter case in the input is
ignored. If the base is greater than 36, and smaller than or
equal to 62, the collation sequence is the string consisting
of the 62 characters "0" to "9",
"A" to "Z", and "a" to
"z". A base larger than 62 requires the collation
sequence to be specified explicitly.</p>
<p style="margin-left:14%; margin-top: 1em">These examples
show standard binary, octal, and hexadecimal conversion. All
cases return 250.</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;from_base("11111010", 2);
<br/>
$x = Math::BigInt−&gt;from_base("372", 8);
<br/>
$x = Math::BigInt−&gt;from_base("fa",
16);</p>
<p style="margin-left:14%; margin-top: 1em">When the base
is less than or equal to 36, and no collation sequence is
given, the letter case is ignored, so both of these also
return 250:</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;from_base("6Y", 16); <br/>
$x = Math::BigInt−&gt;from_base("6y",
16);</p>
<p style="margin-left:14%; margin-top: 1em">When the base
greater than 36, and no collation sequence is given, the
default collation sequence contains both uppercase and
lowercase letters, so the letter case in the input is not
ignored:</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;from_base("6S", 37); # $x
is 250 <br/>
$x = Math::BigInt−&gt;from_base("6s", 37); #
$x is 276 <br/>
$x = Math::BigInt−&gt;from_base("121", 3); #
$x is 16 <br/>
$x = Math::BigInt−&gt;from_base("XYZ", 36);
# $x is 44027 <br/>
$x = Math::BigInt−&gt;from_base("Why", 42);
# $x is 58314</p>
<p style="margin-left:14%; margin-top: 1em">The collation
sequence can be any set of unique characters. These two
cases are equivalent</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;from_base("100", 2,
"01"); # $x is 4 <br/>
$x =
Math::BigInt−&gt;from_base("|−−",
2, "−|"); # $x is 4</p>
<p style="margin-left:9%;"><b>from_base_num()</b></p>
<p style="margin-left:14%;">Returns a new Math::BigInt
object given an array of values and a base. This method is
equivalent to from_base(), but works on numbers in an array
rather than characters in a string. Unlike from_base(), all
input values may be arbitrarily large.</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;from_base_num([1, 1, 0, 1], 2) # $x
is 13 <br/>
$x = Math::BigInt−&gt;from_base_num([3, 125, 39], 128)
# $x is 65191</p>
<p style="margin-left:9%;"><b>bzero()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;bzero(); <br/>
$x−&gt;bzero();</p>
<p style="margin-left:14%; margin-top: 1em">Returns a new
Math::BigInt object representing zero. If used as an
instance method, assigns the value to the invocand.</p>
<p style="margin-left:9%;"><b>bone()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;bone(); # +1 <br/>
$x = Math::BigInt−&gt;bone("+"); # +1 <br/>
$x = Math::BigInt−&gt;bone("−"); #
−1 <br/>
$x−&gt;bone(); # +1 <br/>
$x−&gt;bone("+"); # +1 <br/>
$x−&gt;bone('−'); # −1</p>
<p style="margin-left:14%; margin-top: 1em">Creates a new
Math::BigInt object representing one. The optional argument
is either '−' or '+', indicating whether you want plus
one or minus one. If used as an instance method, assigns the
value to the invocand.</p>
<p style="margin-left:9%;"><b>binf()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;binf($sign);</p>
<p style="margin-left:14%; margin-top: 1em">Creates a new
Math::BigInt object representing infinity. The optional
argument is either '−' or '+', indicating whether you
want infinity or minus infinity. If used as an instance
method, assigns the value to the invocand.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;binf();
<br/>
$x−&gt;binf('−');</p>
<p style="margin-left:9%;"><b>bnan()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;bnan();</p>
<p style="margin-left:14%; margin-top: 1em">Creates a new
Math::BigInt object representing NaN (Not A Number). If used
as an instance method, assigns the value to the
invocand.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bnan();</p>
<p style="margin-left:9%;"><b>bpi()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;bpi(100); # 3 <br/>
$x−&gt;bpi(100); # 3</p>
<p style="margin-left:14%; margin-top: 1em">Creates a new
Math::BigInt object representing PI. If used as an instance
method, assigns the value to the invocand. With Math::BigInt
this always returns 3.</p>
<p style="margin-left:14%; margin-top: 1em">If upgrading is
in effect, returns PI, rounded to N digits with the current
rounding mode:</p>
<p style="margin-left:14%; margin-top: 1em">use
Math::BigFloat; <br/>
use Math::BigInt upgrade =&gt; "Math::BigFloat";
<br/>
print Math::BigInt−&gt;bpi(3), "\n"; # 3.14
<br/>
print Math::BigInt−&gt;bpi(100), "\n"; #
3.1415....</p>
<p style="margin-left:9%;"><b>copy()</b></p>
<p style="margin-left:14%;">$x−&gt;copy(); # make a
true copy of $x (unlike $y = $x)</p>
<p style="margin-left:9%;"><b>as_int() <br/>
as_number()</b></p>
<p style="margin-left:14%;">These methods are called when
Math::BigInt encounters an object it doesn't know how to
handle. For instance, assume $x is a Math::BigInt, or
subclass thereof, and $y is defined, but not a Math::BigInt,
or subclass thereof. If you do</p>
<p style="margin-left:14%; margin-top: 1em">$x −&gt;
badd($y);</p>
<p style="margin-left:14%; margin-top: 1em">$y needs to be
converted into an object that $x can deal with. This is done
by first checking if $y is something that $x might be
upgraded to. If that is the case, no further attempts are
made. The next is to see if $y supports the method as_int().
If it does, as_int() is called, but if it doesn't, the next
thing is to see if $y supports the method as_number(). If it
does, as_number() is called. The method as_int() (and
as_number()) is expected to return either an object that has
the same class as $x, a subclass thereof, or a string that
"ref($x)−&gt;new()" can parse to create an
object.</p>
<p style="margin-left:14%; margin-top: 1em">as_number() is
an alias to as_int(). "as_number" was introduced
in v1.22, while as_int() was introduced in v1.68.</p>
<p style="margin-left:14%; margin-top: 1em">In
Math::BigInt, as_int() has the same effect as copy().</p>
<p style="margin-left:9%;"><b>as_float()</b></p>
<p style="margin-left:14%;">Return the argument as a
Math::BigFloat object.</p>
<p style="margin-left:9%;"><b>as_rat()</b></p>
<p style="margin-left:14%;">Return the argument as a
Math::BigRat object.</p>
<h3>Boolean methods
<a name="Boolean methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">None of these
methods modify the invocand object. <b><br/>
is_zero()</b></p>
<p style="margin-left:14%;">$x−&gt;is_zero(); # true
if $x is 0</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is zero and false otherwise.</p>
<p style="margin-left:9%;">is_one( [ SIGN ])</p>
<p style="margin-left:14%;">$x−&gt;is_one(); # true
if $x is +1 <br/>
$x−&gt;is_one("+"); # ditto <br/>
$x−&gt;is_one("−"); # true if $x is
−1</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is one and false otherwise.</p>
<p style="margin-left:9%;"><b>is_finite()</b></p>
<p style="margin-left:14%;">$x−&gt;is_finite(); #
true if $x is not +inf, −inf or NaN</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is a finite number, i.e., it is neither +inf,
−inf, nor NaN.</p>
<p style="margin-left:9%;">is_inf( [ SIGN ] )</p>
<p style="margin-left:14%;">$x−&gt;is_inf(); # true
if $x is +inf <br/>
$x−&gt;is_inf("+"); # ditto <br/>
$x−&gt;is_inf("−"); # true if $x is
−inf</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is infinite and false otherwise.</p>
<p style="margin-left:9%;"><b>is_nan()</b></p>
<p style="margin-left:14%;">$x−&gt;is_nan(); # true
if $x is NaN</p>
<p style="margin-left:9%;"><b>is_positive() <br/>
is_pos()</b></p>
<p style="margin-left:14%;">$x−&gt;is_positive(); #
true if &gt; 0 <br/>
$x−&gt;is_pos(); # ditto</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is positive and false otherwise. A
"NaN" is neither positive nor negative.</p>
<p style="margin-left:9%;"><b>is_negative() <br/>
is_neg()</b></p>
<p style="margin-left:14%;">$x−&gt;is_negative(); #
true if &lt; 0 <br/>
$x−&gt;is_neg(); # ditto</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is negative and false otherwise. A
"NaN" is neither positive nor negative.</p>
<p style="margin-left:9%;"><b>is_non_positive()</b></p>
<p style="margin-left:14%;">$x−&gt;is_non_positive();
# true if &lt;= 0</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is negative or zero.</p>
<p style="margin-left:9%;"><b>is_non_negative()</b></p>
<p style="margin-left:14%;">$x−&gt;is_non_negative();
# true if &gt;= 0</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is positive or zero.</p>
<p style="margin-left:9%;"><b>is_odd()</b></p>
<p style="margin-left:14%;">$x−&gt;is_odd(); # true
if odd, false for even</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is odd and false otherwise. "NaN",
"+inf", and "−inf" are neither odd
nor even.</p>
<p style="margin-left:9%;"><b>is_even()</b></p>
<p style="margin-left:14%;">$x−&gt;is_even(); # true
if $x is even</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is even and false otherwise. "NaN",
"+inf", "−inf" are not integers
and are neither odd nor even.</p>
<p style="margin-left:9%;"><b>is_int()</b></p>
<p style="margin-left:14%;">$x−&gt;is_int(); # true
if $x is an integer</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
the invocand is an integer and false otherwise.
"NaN", "+inf", "−inf"
are not integers.</p>
<h3>Comparison methods
<a name="Comparison methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">None of these
methods modify the invocand object. Note that a
"NaN" is neither less than, greater than, or equal
to anything else, even a "NaN". <b><br/>
bcmp()</b></p>
<p style="margin-left:14%;">$x−&gt;bcmp($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns
−1, 0, 1 depending on whether $x is less than, equal
to, or grater than $y. Returns undef if any operand is a
NaN.</p>
<p style="margin-left:9%;"><b>bacmp()</b></p>
<p style="margin-left:14%;">$x−&gt;bacmp($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns
−1, 0, 1 depending on whether the absolute value of $x
is less than, equal to, or grater than the absolute value of
$y. Returns undef if any operand is a NaN.</p>
<p style="margin-left:9%;"><b>beq()</b></p>
<p style="margin-left:14%;">$x −&gt; beq($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
and only if $x is equal to $y, and false otherwise.</p>
<p style="margin-left:9%;"><b>bne()</b></p>
<p style="margin-left:14%;">$x −&gt; bne($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
and only if $x is not equal to $y, and false otherwise.</p>
<p style="margin-left:9%;"><b>blt()</b></p>
<p style="margin-left:14%;">$x −&gt; blt($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
and only if $x is equal to $y, and false otherwise.</p>
<p style="margin-left:9%;"><b>ble()</b></p>
<p style="margin-left:14%;">$x −&gt; ble($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
and only if $x is less than or equal to $y, and false
otherwise.</p>
<p style="margin-left:9%;"><b>bgt()</b></p>
<p style="margin-left:14%;">$x −&gt; bgt($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
and only if $x is greater than $y, and false otherwise.</p>
<p style="margin-left:9%;"><b>bge()</b></p>
<p style="margin-left:14%;">$x −&gt; bge($y);</p>
<p style="margin-left:14%; margin-top: 1em">Returns true if
and only if $x is greater than or equal to $y, and false
otherwise.</p>
<h3>Arithmetic methods
<a name="Arithmetic methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">These methods
modify the invocand object and returns it. <b><br/>
bneg()</b></p>
<p style="margin-left:14%;">$x−&gt;bneg();</p>
<p style="margin-left:14%; margin-top: 1em">Negate the
number, e.g. change the sign between '+' and '−', or
between '+inf' and '−inf', respectively. Does nothing
for NaN or zero.</p>
<p style="margin-left:9%;"><b>babs()</b></p>
<p style="margin-left:14%;">$x−&gt;babs();</p>
<p style="margin-left:14%; margin-top: 1em">Set the number
to its absolute value, e.g. change the sign from '−'
to '+' and from '−inf' to '+inf', respectively. Does
nothing for NaN or positive numbers.</p>
<p style="margin-left:9%;"><b>bsgn()</b></p>
<p style="margin-left:14%;">$x−&gt;bsgn();</p>
<p style="margin-left:14%; margin-top: 1em">Signum
function. Set the number to −1, 0, or 1, depending on
whether the number is negative, zero, or positive,
respectively. Does not modify NaNs.</p>
<p style="margin-left:9%;"><b>bnorm()</b></p>
<p style="margin-left:14%;">$x−&gt;bnorm(); #
normalize (no−op)</p>
<p style="margin-left:14%; margin-top: 1em">Normalize the
number. This is a no−op and is provided only for
backwards compatibility.</p>
<p style="margin-left:9%;"><b>binc()</b></p>
<p style="margin-left:14%;">$x−&gt;binc(); #
increment x by 1</p>
<p style="margin-left:9%;"><b>bdec()</b></p>
<p style="margin-left:14%;">$x−&gt;bdec(); #
decrement x by 1</p>
<p style="margin-left:9%;"><b>badd()</b></p>
<p style="margin-left:14%;">$x−&gt;badd($y); #
addition (add $y to $x)</p>
<p style="margin-left:9%;"><b>bsub()</b></p>
<p style="margin-left:14%;">$x−&gt;bsub($y); #
subtraction (subtract $y from $x)</p>
<p style="margin-left:9%;"><b>bmul()</b></p>
<p style="margin-left:14%;">$x−&gt;bmul($y); #
multiplication (multiply $x by $y)</p>
<p style="margin-left:9%;"><b>bmuladd()</b></p>
<p style="margin-left:14%;">$x−&gt;bmuladd($y,$z);</p>
<p style="margin-left:14%; margin-top: 1em">Multiply $x by
$y, and then add $z to the result,</p>
<p style="margin-left:14%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>
<p style="margin-left:9%;"><b>binv()</b></p>
<p style="margin-left:14%;">$x−&gt;binv();</p>
<p style="margin-left:14%; margin-top: 1em">Invert the
value of $x, i.e., compute 1/$x.</p>
<p style="margin-left:9%;"><b>bdiv()</b></p>
<p style="margin-left:14%;">$x−&gt;bdiv($y); #
divide, set $x to quotient</p>
<p style="margin-left:14%; margin-top: 1em">Divides $x by
$y by doing floored division (F−division), where the
quotient is the floored (rounded towards negative infinity)
quotient of the two operands. In list context, returns the
quotient and the remainder. The remainder is either zero or
has the same sign as the second operand. In scalar context,
only the quotient is returned.</p>
<p style="margin-left:14%; margin-top: 1em">The quotient is
always the greatest integer less than or equal to the
real−valued quotient of the two operands, and the
remainder (when it is non−zero) always has the same
sign as the second operand; so, for example,</p>
<p style="margin-left:14%; margin-top: 1em">1 / 4 =&gt; (
0, 1) <br/>
1 / −4 =&gt; (−1, −3) <br/>
−3 / 4 =&gt; (−1, 1) <br/>
−3 / −4 =&gt; ( 0, −3) <br/>
−11 / 2 =&gt; (−5, 1) <br/>
11 / −2 =&gt; (−5, −1)</p>
<p style="margin-left:14%; margin-top: 1em">The behavior of
the overloaded operator % agrees with the behavior of Perl's
built−in % operator (as documented in the perlop
manpage), and the equation</p>
<p style="margin-left:14%; margin-top: 1em">$x == ($x / $y)
* $y + ($x % $y)</p>
<p style="margin-left:14%; margin-top: 1em">holds true for
any finite $x and finite, non−zero $y.</p>
<p style="margin-left:14%; margin-top: 1em">Perl's
"use integer" might change the behaviour of % and
/ for scalars. This is because under 'use integer' Perl does
what the underlying C library thinks is right, and this
varies. However, "use integer" does not change the
way things are done with Math::BigInt objects.</p>
<p style="margin-left:9%;"><b>btdiv()</b></p>
<p style="margin-left:14%;">$x−&gt;btdiv($y); #
divide, set $x to quotient</p>
<p style="margin-left:14%; margin-top: 1em">Divides $x by
$y by doing truncated division (T−division), where
quotient is the truncated (rouneded towards zero) quotient
of the two operands. In list context, returns the quotient
and the remainder. The remainder is either zero or has the
same sign as the first operand. In scalar context, only the
quotient is returned.</p>
<p style="margin-left:9%;"><b>bmod()</b></p>
<p style="margin-left:14%;">$x−&gt;bmod($y); #
modulus (x % y)</p>
<p style="margin-left:14%; margin-top: 1em">Returns $x
modulo $y, i.e., the remainder after floored division
(F−division). This method is like Perl's % operator.
See "<b>bdiv()</b>".</p>
<p style="margin-left:9%;"><b>btmod()</b></p>
<p style="margin-left:14%;">$x−&gt;btmod($y); #
modulus</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
remainer after truncated division (T−division). See
"<b>btdiv()</b>".</p>
<p style="margin-left:9%;"><b>bmodinv()</b></p>
<p style="margin-left:14%;">$x−&gt;bmodinv($mod); #
modular multiplicative inverse</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
multiplicative inverse of $x modulo $mod. If</p>
<p style="margin-left:14%; margin-top: 1em">$y = $x
−&gt; copy() −&gt; bmodinv($mod)</p>
<p style="margin-left:14%; margin-top: 1em">then $y is the
number closest to zero, and with the same sign as $mod,
satisfying</p>
<p style="margin-left:14%; margin-top: 1em">($x * $y) %
$mod = 1 % $mod</p>
<p style="margin-left:14%; margin-top: 1em">If $x and $y
are non−zero, they must be relative primes, i.e.,
"bgcd($y, $mod)==1". '"NaN"' is returned
when no modular multiplicative inverse exists.</p>
<p style="margin-left:9%;"><b>bmodpow()</b></p>
<p style="margin-left:14%;">$num−&gt;bmodpow($exp,$mod);
# modular exponentiation <br/>
# ($num**$exp % $mod)</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
value of $num taken to the power $exp in the modulus $mod
using binary exponentiation. "bmodpow" is far
superior to writing</p>
<p style="margin-left:14%; margin-top: 1em">$num ** $exp %
$mod</p>
<p style="margin-left:14%; margin-top: 1em">because it is
much faster − it reduces internal variables into the
modulus whenever possible, so it operates on smaller
numbers.</p>
<p style="margin-left:14%; margin-top: 1em">"bmodpow"
also supports negative exponents.</p>
<p style="margin-left:14%; margin-top: 1em">bmodpow($num,
−1, $mod)</p>
<p style="margin-left:14%; margin-top: 1em">is exactly
equivalent to</p>
<p style="margin-left:14%; margin-top: 1em">bmodinv($num,
$mod)</p>
<p style="margin-left:9%;"><b>bpow()</b></p>
<p style="margin-left:14%;">$x−&gt;bpow($y); # power
of arguments (x ** y)</p>
<p style="margin-left:14%; margin-top: 1em">bpow() (and the
rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only
returned the result. This is to be consistent with badd()
etc. The first three modifies $x, the last one won't:</p>
<p style="margin-left:14%; margin-top: 1em">print
bpow($x,$i),"\n"; # modify $x <br/>
print $x−&gt;bpow($i),"\n"; # ditto <br/>
print $x **= $i,"\n"; # the same <br/>
print $x ** $i,"\n"; # leave $x alone</p>
<p style="margin-left:14%; margin-top: 1em">The form
"$x **= $y" is faster than "$x = $x **
$y;", though.</p>
<p style="margin-left:9%;"><b>blog()</b></p>
<p style="margin-left:14%;">$x−&gt;blog($base,
$accuracy); # logarithm of x to the base $base</p>
<p style="margin-left:14%; margin-top: 1em">If $base is not
defined, Euler's number (e) is used:</p>
<p style="margin-left:14%; margin-top: 1em">print
$x−&gt;blog(undef, 100); # log(x) to 100 digits</p>
<p style="margin-left:9%;"><b>bexp()</b></p>
<p style="margin-left:14%;">$x−&gt;bexp($accuracy); #
calculate e ** X</p>
<p style="margin-left:14%; margin-top: 1em">Calculates the
expression "e ** $x" where "e" is
Euler's number.</p>
<p style="margin-left:14%; margin-top: 1em">This method was
added in v1.82 of Math::BigInt (April 2007).</p>
<p style="margin-left:14%; margin-top: 1em">See also
"<b>blog()</b>".</p>
<p style="margin-left:9%;"><b>bilog2()</b></p>
<p style="margin-left:14%;">Base 2 logarithm rounded down
towards the nearest integer.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bilog2();
# int(log2(x)) = int(log(x)/log(2))</p>
<p style="margin-left:14%; margin-top: 1em">In list context
a second argument is returned. This is 1 if the result is
exact, i.e., the input is an exact power of 2, and 0
otherwise.</p>
<p style="margin-left:9%;"><b>bilog10()</b></p>
<p style="margin-left:14%;">Base 10 logarithm rounded down
towards the nearest integer.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bilog10();
# int(log10(x)) = int(log(x)/log(10))</p>
<p style="margin-left:14%; margin-top: 1em">In list context
a second argument is returned. This is 1 if the result is
exact, i.e., the input is an exact power of 10, and 0
otherwise.</p>
<p style="margin-left:9%;"><b>bclog2()</b></p>
<p style="margin-left:14%;">Base 2 logarithm rounded up
towards the nearest integer.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bclog2();
# ceil(log2(x)) = ceil(log(x)/log(2))</p>
<p style="margin-left:14%; margin-top: 1em">In list context
a second argument is returned. This is 1 if the result is
exact, i.e., the input is an exact power of 2, and 0
otherwise.</p>
<p style="margin-left:9%;"><b>bclog10()</b></p>
<p style="margin-left:14%;">Base 10 logarithm rounded up
towards the nearest integer.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bclog10();
# ceil(log10(x)) = ceil(log(x)/log(10))</p>
<p style="margin-left:14%; margin-top: 1em">In list context
a second argument is returned. This is 1 if the result is
exact, i.e., the input is an exact power of 10, and 0
otherwise.</p>
<p style="margin-left:9%;"><b>bnok()</b></p>
<p style="margin-left:14%;">$x−&gt;bnok($y); # x over
y (binomial coefficient n over k)</p>
<p style="margin-left:14%; margin-top: 1em">Calculates the
binomial coefficient n over k, also called the
"choose" function, which is</p>
<p style="margin-left:14%; margin-top: 1em">( n ) n! <br/>
| | =
−−−−−−−−
<br/>
( k ) k!(n−k)!</p>
<p style="margin-left:14%; margin-top: 1em">when n and k
are non−negative. This method implements the full
Kronenburg extension (Kronenburg, M.J. "The Binomial
Coefficient for Negative Arguments." 18 May 2011.
http://arxiv.org/abs/1105.3689/) illustrated by the
following pseudo−code:</p>
<p style="margin-left:14%; margin-top: 1em">if n &gt;= 0
and k &gt;= 0: <br/>
return binomial(n, k) <br/>
if k &gt;= 0: <br/>
return (−1)ˆk*binomial(−n+k−1, k)
<br/>
if k &lt;= n: <br/>
return
(−1)ˆ(n−k)*binomial(−k−1,
n−k) <br/>
else <br/>
return 0</p>
<p style="margin-left:14%; margin-top: 1em">The behaviour
is identical to the behaviour of the Maple and Mathematica
function for negative integers n, k.</p>
<p style="margin-left:9%;"><b>buparrow() <br/>
uparrow()</b></p>
<p style="margin-left:14%;">$a −&gt; buparrow($n,
$b); # modifies $a <br/>
$x = $a −&gt; uparrow($n, $b); # does not modify
$a</p>
<p style="margin-left:14%; margin-top: 1em">This method
implements Knuth's up−arrow notation, where $n is a
non−negative integer representing the number of
up−arrows. $n = 0 gives multiplication, $n = 1 gives
exponentiation, $n = 2 gives tetration, $n = 3 gives
hexation etc. The following illustrates the relation between
the first values of $n.</p>
<p style="margin-left:14%; margin-top: 1em">See
&lt;https://en.wikipedia.org/wiki/Knuth%27s_up−arrow_notation&gt;.</p>
<p style="margin-left:9%;"><b>backermann() <br/>
ackermann()</b></p>
<p style="margin-left:14%;">$m −&gt; backermann($n);
# modifies $a <br/>
$x = $m −&gt; ackermann($n); # does not modify $a</p>
<p style="margin-left:14%; margin-top: 1em">This method
implements the Ackermann function:</p>
<p style="margin-left:14%; margin-top: 1em">/ n + 1 if m =
0 <br/>
A(m, n) = | A(m−1, 1) if m &gt; 0 and n = 0 <br/>
\ A(m−1, A(m, n−1)) if m &gt; 0 and n &gt; 0</p>
<p style="margin-left:14%; margin-top: 1em">Its value grows
rapidly, even for small inputs. For example, A(4, 2) is an
integer of 19729 decimal digits.</p>
<p style="margin-left:14%; margin-top: 1em">See
https://en.wikipedia.org/wiki/Ackermann_function</p>
<p style="margin-left:9%;"><b>bsin()</b></p>
<p style="margin-left:14%;">my $x =
Math::BigInt−&gt;new(1); <br/>
print $x−&gt;bsin(100), "\n";</p>
<p style="margin-left:14%; margin-top: 1em">Calculate the
sine of $x, modifying $x in place.</p>
<p style="margin-left:14%; margin-top: 1em">In
Math::BigInt, unless upgrading is in effect, the result is
truncated to an integer.</p>
<p style="margin-left:14%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>
<p style="margin-left:9%;"><b>bcos()</b></p>
<p style="margin-left:14%;">my $x =
Math::BigInt−&gt;new(1); <br/>
print $x−&gt;bcos(100), "\n";</p>
<p style="margin-left:14%; margin-top: 1em">Calculate the
cosine of $x, modifying $x in place.</p>
<p style="margin-left:14%; margin-top: 1em">In
Math::BigInt, unless upgrading is in effect, the result is
truncated to an integer.</p>
<p style="margin-left:14%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>
<p style="margin-left:9%;"><b>batan()</b></p>
<p style="margin-left:14%;">my $x =
Math::BigFloat−&gt;new(0.5); <br/>
print $x−&gt;batan(100), "\n";</p>
<p style="margin-left:14%; margin-top: 1em">Calculate the
arcus tangens of $x, modifying $x in place.</p>
<p style="margin-left:14%; margin-top: 1em">In
Math::BigInt, unless upgrading is in effect, the result is
truncated to an integer.</p>
<p style="margin-left:14%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>
<p style="margin-left:9%;"><b>batan2()</b></p>
<p style="margin-left:14%;">my $x =
Math::BigInt−&gt;new(1); <br/>
my $y = Math::BigInt−&gt;new(1); <br/>
print $y−&gt;batan2($x), "\n";</p>
<p style="margin-left:14%; margin-top: 1em">Calculate the
arcus tangens of $y divided by $x, modifying $y in
place.</p>
<p style="margin-left:14%; margin-top: 1em">In
Math::BigInt, unless upgrading is in effect, the result is
truncated to an integer.</p>
<p style="margin-left:14%; margin-top: 1em">This method was
added in v1.87 of Math::BigInt (June 2007).</p>
<p style="margin-left:9%;"><b>bsqrt()</b></p>
<p style="margin-left:14%;">$x−&gt;bsqrt(); #
calculate square root</p>
<p style="margin-left:14%; margin-top: 1em">bsqrt() returns
the square root truncated to an integer.</p>
<p style="margin-left:14%; margin-top: 1em">If you want a
better approximation of the square root, then use:</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigFloat−&gt;new(12); <br/>
Math::BigFloat−&gt;precision(0); <br/>
Math::BigFloat−&gt;round_mode('even'); <br/>
print $x−&gt;copy−&gt;bsqrt(),"\n"; #
4 <br/>
Math::BigFloat−&gt;precision(2); <br/>
print $x−&gt;bsqrt(),"\n"; # 3.46 <br/>
print $x−&gt;bsqrt(3),"\n"; # 3.464</p>
<p style="margin-left:9%;"><b>broot()</b></p>
<p style="margin-left:14%;">$x−&gt;broot($N);</p>
<p style="margin-left:14%; margin-top: 1em">Calculates the
N'th root of $x.</p>
<p style="margin-left:9%;"><b>bfac()</b></p>
<p style="margin-left:14%;">$x−&gt;bfac(); #
factorial of $x</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
factorial of $x, i.e., $x*($x−1)*($x−2)*...*2*1,
the product of all positive integers up to and including $x.
$x must be &gt; −1. The factorial of N is commonly
written as N!, or N!1, when using the multifactorial
notation.</p>
<p style="margin-left:9%;"><b>bdfac()</b></p>
<p style="margin-left:14%;">$x−&gt;bdfac(); # double
factorial of $x</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
double factorial of $x, i.e.,
$x*($x−2)*($x−4)*... $x must be &gt; −2.
The double factorial of N is commonly written as N!!, or
N!2, when using the multifactorial notation.</p>
<p style="margin-left:9%;"><b>btfac()</b></p>
<p style="margin-left:14%;">$x−&gt;btfac(); # triple
factorial of $x</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
triple factorial of $x, i.e.,
$x*($x−3)*($x−6)*... $x must be &gt; −3.
The triple factorial of N is commonly written as N!!!, or
N!3, when using the multifactorial notation.</p>
<p style="margin-left:9%;"><b>bmfac()</b></p>
<p style="margin-left:14%;">$x−&gt;bmfac($k); # $k'th
multifactorial of $x</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
multi−factorial of $x, i.e.,
$x*($x−$k)*($x−2*$k)*... $x must be &gt;
−$k. The multi−factorial of N is commonly
written as N!K.</p>
<p style="margin-left:9%;"><b>bfib()</b></p>
<p style="margin-left:14%;">$F = $n−&gt;bfib(); # a
single Fibonacci number <br/>
@F = $n−&gt;bfib(); # a list of Fibonacci numbers</p>
<p style="margin-left:14%; margin-top: 1em">In scalar
context, returns a single Fibonacci number. In list context,
returns a list of Fibonacci numbers. The invocand is the
last element in the output.</p>
<p style="margin-left:14%; margin-top: 1em">The Fibonacci
sequence is defined by</p>
<p style="margin-left:14%; margin-top: 1em">F(0) = 0 <br/>
F(1) = 1 <br/>
F(n) = F(n−1) + F(n−2)</p>
<p style="margin-left:14%; margin-top: 1em">In list
context, F(0) and F(n) is the first and last number in the
output, respectively. For example, if $n is 12, then
"@F = $n−&gt;bfib()" returns the following
values, F(0) to F(12):</p>
<p style="margin-left:14%; margin-top: 1em">0, 1, 1, 2, 3,
5, 8, 13, 21, 34, 55, 89, 144</p>
<p style="margin-left:14%; margin-top: 1em">The sequence
can also be extended to negative index n using the
re−arranged recurrence relation</p>
<p style="margin-left:14%; margin-top: 1em">F(n−2) =
F(n) − F(n−1)</p>
<p style="margin-left:14%; margin-top: 1em">giving the
bidirectional sequence</p>
<p style="margin-left:14%; margin-top: 1em">n −7
−6 −5 −4 −3 −2 −1 0 1 2
3 4 5 6 7 <br/>
F(n) 13 −8 5 −3 2 −1 1 0 1 1 2 3 5 8
13</p>
<p style="margin-left:14%; margin-top: 1em">If $n is
−12, the following values, F(0) to F(12), are
returned:</p>
<p style="margin-left:14%; margin-top: 1em">0, 1, −1,
2, −3, 5, −8, 13, −21, 34, −55, 89,
−144</p>
<p style="margin-left:9%;"><b>blucas()</b></p>
<p style="margin-left:14%;">$F = $n−&gt;blucas(); # a
single Lucas number <br/>
@F = $n−&gt;blucas(); # a list of Lucas numbers</p>
<p style="margin-left:14%; margin-top: 1em">In scalar
context, returns a single Lucas number. In list context,
returns a list of Lucas numbers. The invocand is the last
element in the output.</p>
<p style="margin-left:14%; margin-top: 1em">The Lucas
sequence is defined by</p>
<p style="margin-left:14%; margin-top: 1em">L(0) = 2 <br/>
L(1) = 1 <br/>
L(n) = L(n−1) + L(n−2)</p>
<p style="margin-left:14%; margin-top: 1em">In list
context, L(0) and L(n) is the first and last number in the
output, respectively. For example, if $n is 12, then
"@L = $n−&gt;blucas()" returns the following
values, L(0) to L(12):</p>
<p style="margin-left:14%; margin-top: 1em">2, 1, 3, 4, 7,
11, 18, 29, 47, 76, 123, 199, 322</p>
<p style="margin-left:14%; margin-top: 1em">The sequence
can also be extended to negative index n using the
re−arranged recurrence relation</p>
<p style="margin-left:14%; margin-top: 1em">L(n−2) =
L(n) − L(n−1)</p>
<p style="margin-left:14%; margin-top: 1em">giving the
bidirectional sequence</p>
<p style="margin-left:14%; margin-top: 1em">n −7
−6 −5 −4 −3 −2 −1 0 1 2
3 4 5 6 7 <br/>
L(n) 29 −18 11 −7 4 −3 1 2 1 3 4 7 11 18
29</p>
<p style="margin-left:14%; margin-top: 1em">If $n is
−12, the following values, L(0) to L(−12), are
returned:</p>
<p style="margin-left:14%; margin-top: 1em">2, 1, −3,
4, −7, 11, −18, 29, −47, 76, −123,
199, −322</p>
<p style="margin-left:9%;"><b>brsft()</b></p>
<p style="margin-left:14%;">Right shift.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;brsft($n);
# right shift $n places in base 2 <br/>
$x−&gt;brsft($n, $b); # right shift $n places in base
$b</p>
<p style="margin-left:14%; margin-top: 1em">The latter is
equivalent to</p>
<p style="margin-left:14%; margin-top: 1em">$x −&gt;
bdiv($b −&gt; copy() −&gt; bpow($n));</p>
<p style="margin-left:9%;"><b>blsft()</b></p>
<p style="margin-left:14%;">Left shift.</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;blsft($n);
# left shift $n places in base 2 <br/>
$x−&gt;blsft($n, $b); # left shift $n places in base
$b</p>
<p style="margin-left:14%; margin-top: 1em">The latter is
equivalent to</p>
<p style="margin-left:14%; margin-top: 1em">$x −&gt;
bmul($b −&gt; copy() −&gt; bpow($n));</p>
<h3>Bitwise methods
<a name="Bitwise methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">For all bitwise
methods, the operands are truncated to integers, i.e.,
rounded towards zero, if necessary, before the method is
applied. The bitwise methods never upgrade, and they always
return an integer. <b><br/>
bbrsft()</b></p>
<p style="margin-left:14%;">Bitwise right shift. This is
equivalent to Perl's "&gt;&gt;" operator.</p>
<p style="margin-left:14%; margin-top: 1em">$x −&gt;
bbrsft($n); # right shift $n places in base 2</p>
<p style="margin-left:14%; margin-top: 1em">If $n is
negative, the shifting is done in the opposite direction, so
these two are equivalent for all $x and $n</p>
<p style="margin-left:14%; margin-top: 1em">$y = $x
−&gt; bbrsft($n); <br/>
$y = $x −&gt; bblsft(−$n);</p>
<p style="margin-left:14%; margin-top: 1em">and also
equivalent to</p>
<p style="margin-left:14%; margin-top: 1em">$y = $x
−&gt; bdiv(ref($x) −&gt; new(2) −&gt;
bpow($n)); # if $n &gt; 0 <br/>
$y = $x −&gt; bmul(ref($x) −&gt; new(2)
−&gt; bpow(−$n)); # if $n &lt; 0</p>
<p style="margin-left:9%;"><b>bblsft()</b></p>
<p style="margin-left:14%;">Bitwise left shift. This is
equivalent to Perl's "&lt;&lt;" operator.</p>
<p style="margin-left:14%; margin-top: 1em">$x −&gt;
bblsft($n); # left shift $n places in base 2</p>
<p style="margin-left:14%; margin-top: 1em">If $n is
negative, the shifting is done in the opposite direction, so
these two are equivalent for all $x and $n</p>
<p style="margin-left:14%; margin-top: 1em">$y = $x
−&gt; bblsft($n); <br/>
$y = $x −&gt; bbrsft(−$n);</p>
<p style="margin-left:14%; margin-top: 1em">and also
equivalent to</p>
<p style="margin-left:14%; margin-top: 1em">$y = $x
−&gt; bmul(ref($x) −&gt; new(2) −&gt;
bpow($n)); # if $n &gt; 0 <br/>
$y = $x −&gt; bdiv(ref($x) −&gt; new(2)
−&gt; bpow($n)); # if $n &lt; 0</p>
<p style="margin-left:9%;"><b>band()</b></p>
<p style="margin-left:14%;">$x−&gt;band($y); #
bitwise and</p>
<p style="margin-left:9%;"><b>bior()</b></p>
<p style="margin-left:14%;">$x−&gt;bior($y); #
bitwise inclusive or</p>
<p style="margin-left:9%;"><b>bxor()</b></p>
<p style="margin-left:14%;">$x−&gt;bxor($y); #
bitwise exclusive or</p>
<p style="margin-left:9%;"><b>bnot()</b></p>
<p style="margin-left:14%;">$x−&gt;bnot(); # bitwise
not (two's complement)</p>
<p style="margin-left:14%; margin-top: 1em">Two's
complement (bitwise not). This is equivalent to, but faster
than,</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;binc()−&gt;bneg();</p>
<h3>Rounding methods
<a name="Rounding methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>round()</b></p>
<p style="margin-left:14%;">$x−&gt;round($A,$P,$round_mode);</p>
<p style="margin-left:14%; margin-top: 1em">Round $x to
accuracy $A or precision $P using the round mode
$round_mode.</p>
<p style="margin-left:9%;"><b>bround()</b></p>
<p style="margin-left:14%;">$x−&gt;bround($N); #
accuracy: preserve $N digits</p>
<p style="margin-left:14%; margin-top: 1em">Rounds $x to an
accuracy of $N digits.</p>
<p style="margin-left:9%;"><b>bfround()</b></p>
<p style="margin-left:14%;">$x−&gt;bfround($N);</p>
<p style="margin-left:14%; margin-top: 1em">Rounds to a
multiple of 10**$N. Examples:</p>
<p style="margin-left:14%; margin-top: 1em">Input N Result
<br/>
123456.123456 3 123500 <br/>
123456.123456 2 123450 <br/>
123456.123456 −2 123456.12 <br/>
123456.123456 −3 123456.123</p>
<p style="margin-left:9%;"><b>bfloor()</b></p>
<p style="margin-left:14%;">$x−&gt;bfloor();</p>
<p style="margin-left:14%; margin-top: 1em">Round $x
towards minus infinity, i.e., set $x to the largest integer
less than or equal to $x.</p>
<p style="margin-left:9%;"><b>bceil()</b></p>
<p style="margin-left:14%;">$x−&gt;bceil();</p>
<p style="margin-left:14%; margin-top: 1em">Round $x
towards plus infinity, i.e., set $x to the smallest integer
greater than or equal to $x).</p>
<p style="margin-left:9%;"><b>bint()</b></p>
<p style="margin-left:14%;">$x−&gt;bint();</p>
<p style="margin-left:14%; margin-top: 1em">Round $x
towards zero.</p>
<h3>Other mathematical methods
<a name="Other mathematical methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>bgcd()</b></p>
<p style="margin-left:14%;">$x −&gt; bgcd($y); # GCD
of $x and $y <br/>
$x −&gt; bgcd($y, $z, ...); # GCD of $x, $y, $z,
...</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
greatest common divisor (GCD).</p>
<p style="margin-left:9%;"><b>blcm()</b></p>
<p style="margin-left:14%;">$x −&gt; blcm($y); # LCM
of $x and $y <br/>
$x −&gt; blcm($y, $z, ...); # LCM of $x, $y, $z,
...</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
least common multiple (LCM).</p>
<h3>Object property methods
<a name="Object property methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>sign()</b></p>
<p style="margin-left:14%;">$x−&gt;sign();</p>
<p style="margin-left:14%; margin-top: 1em">Return the
sign, of $x, meaning either "+",
"−", "−inf",
"+inf" or NaN.</p>
<p style="margin-left:14%; margin-top: 1em">If you want $x
to have a certain sign, use one of the following
methods:</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;babs();
# '+' <br/>
$x−&gt;babs()−&gt;bneg(); # '−' <br/>
$x−&gt;bnan(); # 'NaN' <br/>
$x−&gt;binf(); # '+inf' <br/>
$x−&gt;binf('−'); # '−inf'</p>
<p style="margin-left:9%;"><b>digit()</b></p>
<p style="margin-left:14%;">$x−&gt;digit($n); #
return the nth digit, counting from right</p>
<p style="margin-left:14%; margin-top: 1em">If $n is
negative, returns the digit counting from left.</p>
<p style="margin-left:9%;"><b>digitsum()</b></p>
<p style="margin-left:14%;">$x−&gt;digitsum();</p>
<p style="margin-left:14%; margin-top: 1em">Computes the
sum of the base 10 digits and returns it.</p>
<p style="margin-left:9%;"><b>bdigitsum()</b></p>
<p style="margin-left:14%;">$x−&gt;bdigitsum();</p>
<p style="margin-left:14%; margin-top: 1em">Computes the
sum of the base 10 digits and assigns the result to the
invocand.</p>
<p style="margin-left:9%;"><b>length()</b></p>
<p style="margin-left:14%;">$x−&gt;length(); <br/>
($xl, $fl) = $x−&gt;length();</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
number of digits in the decimal representation of the
number. In list context, returns the length of the integer
and fraction part. For Math::BigInt objects, the length of
the fraction part is always 0.</p>
<p style="margin-left:14%; margin-top: 1em">The following
probably doesn't do what you expect:</p>
<p style="margin-left:14%; margin-top: 1em">$c =
Math::BigInt−&gt;new(123); <br/>
print $c−&gt;length(),"\n"; # prints 30</p>
<p style="margin-left:14%; margin-top: 1em">It prints both
the number of digits in the number and in the fraction part
since print calls length() in list context. Use something
like:</p>
<p style="margin-left:14%; margin-top: 1em">print scalar
$c−&gt;length(),"\n"; # prints 3</p>
<p style="margin-left:9%;"><b>mantissa()</b></p>
<p style="margin-left:14%;">$x−&gt;mantissa();</p>
<p style="margin-left:14%; margin-top: 1em">Return the
signed mantissa of $x as a Math::BigInt.</p>
<p style="margin-left:9%;"><b>exponent()</b></p>
<p style="margin-left:14%;">$x−&gt;exponent();</p>
<p style="margin-left:14%; margin-top: 1em">Return the
exponent of $x as a Math::BigInt.</p>
<p style="margin-left:9%;"><b>parts()</b></p>
<p style="margin-left:14%;">$x−&gt;parts();</p>
<p style="margin-left:14%; margin-top: 1em">Returns the
significand (mantissa) and the exponent as integers. In
Math::BigFloat, both are returned as Math::BigInt
objects.</p>
<p style="margin-left:9%;"><b>sparts()</b></p>
<p style="margin-left:14%;">Returns the significand
(mantissa) and the exponent as integers. In scalar context,
only the significand is returned. The significand is the
integer with the smallest absolute value. The output of
sparts() corresponds to the output from bsstr().</p>
<p style="margin-left:14%; margin-top: 1em">In
Math::BigInt, this method is identical to parts().</p>
<p style="margin-left:9%;"><b>nparts()</b></p>
<p style="margin-left:14%;">Returns the significand
(mantissa) and exponent corresponding to normalized
notation. In scalar context, only the significand is
returned. For finite non−zero numbers, the
significand's absolute value is greater than or equal to 1
and less than 10. The output of nparts() corresponds to the
output from bnstr(). In Math::BigInt, if the significand can
not be represented as an integer, upgrading is performed or
NaN is returned.</p>
<p style="margin-left:9%;"><b>eparts()</b></p>
<p style="margin-left:14%;">Returns the significand
(mantissa) and exponent corresponding to engineering
notation. In scalar context, only the significand is
returned. For finite non−zero numbers, the
significand's absolute value is greater than or equal to 1
and less than 1000, and the exponent is a multiple of 3. The
output of eparts() corresponds to the output from bestr().
In Math::BigInt, if the significand can not be represented
as an integer, upgrading is performed or NaN is
returned.</p>
<p style="margin-left:9%;"><b>dparts()</b></p>
<p style="margin-left:14%;">Returns the integer part and
the fraction part. If the fraction part can not be
represented as an integer, upgrading is performed or NaN is
returned. The output of dparts() corresponds to the output
from bdstr().</p>
<p style="margin-left:9%;"><b>fparts()</b></p>
<p style="margin-left:14%;">Returns the smallest possible
numerator and denominator so that the numerator divided by
the denominator gives back the original value. For finite
numbers, both values are integers. Mnemonic: fraction.</p>
<p style="margin-left:9%;"><b>numerator()</b></p>
<p style="margin-left:14%;">Together with
"<b>denominator()</b>", returns the smallest
integers so that the numerator divided by the denominator
reproduces the original value. With Math::BigInt,
<b>numerator()</b> simply returns a copy of the
invocand.</p>
<p style="margin-left:9%;"><b>denominator()</b></p>
<p style="margin-left:14%;">Together with
"<b>numerator()</b>", returns the smallest
integers so that the numerator divided by the denominator
reproduces the original value. With Math::BigInt,
<b>denominator()</b> always returns either a 1 or a NaN.</p>
<h3>String conversion methods
<a name="String conversion methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>bstr()</b></p>
<p style="margin-left:14%;">Returns a string representing
the number using decimal notation. In Math::BigFloat, the
output is zero padded according to the current accuracy or
precision, if any of those are defined.</p>
<p style="margin-left:9%;"><b>bsstr()</b></p>
<p style="margin-left:14%;">Returns a string representing
the number using scientific notation where both the
significand (mantissa) and the exponent are integers. The
output corresponds to the output from sparts().</p>
<p style="margin-left:14%; margin-top: 1em">123 is returned
as "123e+0" <br/>
1230 is returned as "123e+1" <br/>
12300 is returned as "123e+2" <br/>
12000 is returned as "12e+3" <br/>
10000 is returned as "1e+4"</p>
<p style="margin-left:9%;"><b>bnstr()</b></p>
<p style="margin-left:14%;">Returns a string representing
the number using normalized notation, the most common
variant of scientific notation. For finite non−zero
numbers, the absolute value of the significand is greater
than or equal to 1 and less than 10. The output corresponds
to the output from nparts().</p>
<p style="margin-left:14%; margin-top: 1em">123 is returned
as "1.23e+2" <br/>
1230 is returned as "1.23e+3" <br/>
12300 is returned as "1.23e+4" <br/>
12000 is returned as "1.2e+4" <br/>
10000 is returned as "1e+4"</p>
<p style="margin-left:9%;"><b>bestr()</b></p>
<p style="margin-left:14%;">Returns a string representing
the number using engineering notation. For finite
non−zero numbers, the absolute value of the
significand is greater than or equal to 1 and less than
1000, and the exponent is a multiple of 3. The output
corresponds to the output from eparts().</p>
<p style="margin-left:14%; margin-top: 1em">123 is returned
as "123e+0" <br/>
1230 is returned as "1.23e+3" <br/>
12300 is returned as "12.3e+3" <br/>
12000 is returned as "12e+3" <br/>
10000 is returned as "10e+3"</p>
<p style="margin-left:9%;"><b>bdstr()</b></p>
<p style="margin-left:14%;">Returns a string representing
the number using decimal notation. The output corresponds to
the output from dparts().</p>
<p style="margin-left:14%; margin-top: 1em">123 is returned
as "123" <br/>
1230 is returned as "1230" <br/>
12300 is returned as "12300" <br/>
12000 is returned as "12000" <br/>
10000 is returned as "10000"</p>
<p style="margin-left:9%;"><b>bfstr()</b></p>
<p style="margin-left:14%;">Returns a string representing
the number using fractional notation. The output corresponds
to the output from fparts().</p>
<p style="margin-left:14%; margin-top: 1em">12.345 is
returned as "2469/200" <br/>
123.45 is returned as "2469/20" <br/>
1234.5 is returned as "2469/2" <br/>
12345 is returned as "12345" <br/>
123450 is returned as "123450"</p>
<p style="margin-left:9%;"><b>to_hex()</b></p>
<p style="margin-left:14%;">$x−&gt;to_hex();</p>
<p style="margin-left:14%; margin-top: 1em">Returns a
hexadecimal string representation of the number. See also
<b>from_hex()</b>.</p>
<p style="margin-left:9%;"><b>to_bin()</b></p>
<p style="margin-left:14%;">$x−&gt;to_bin();</p>
<p style="margin-left:14%; margin-top: 1em">Returns a
binary string representation of the number. See also
<b>from_bin()</b>.</p>
<p style="margin-left:9%;"><b>to_oct()</b></p>
<p style="margin-left:14%;">$x−&gt;to_oct();</p>
<p style="margin-left:14%; margin-top: 1em">Returns an
octal string representation of the number. See also
<b>from_oct()</b>.</p>
<p style="margin-left:9%;"><b>to_bytes()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;new("1667327589"); <br/>
$s = $x−&gt;to_bytes(); # $s = "cafe"</p>
<p style="margin-left:14%; margin-top: 1em">Returns a byte
string representation of the number using big endian byte
order. The invocand must be a non−negative, finite
integer. See also <b>from_bytes()</b>.</p>
<p style="margin-left:9%;"><b>to_base()</b></p>
<p style="margin-left:14%;">$x =
Math::BigInt−&gt;new("250"); <br/>
$x−&gt;to_base(2); # returns "11111010" <br/>
$x−&gt;to_base(8); # returns "372" <br/>
$x−&gt;to_base(16); # returns "fa"</p>
<p style="margin-left:14%; margin-top: 1em">Returns a
string representation of the number in the given base. If a
collation sequence is given, the collation sequence
determines which characters are used in the output.</p>
<p style="margin-left:14%; margin-top: 1em">Here are some
more examples</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;new("16")−&gt;to_base(3);
# returns "121" <br/>
$x =
Math::BigInt−&gt;new("44027")−&gt;to_base(36);
# returns "XYZ" <br/>
$x =
Math::BigInt−&gt;new("58314")−&gt;to_base(42);
# returns "Why" <br/>
$x =
Math::BigInt−&gt;new("4")−&gt;to_base(2,
"−|"); # returns
"|−−"</p>
<p style="margin-left:14%; margin-top: 1em">See
<b>from_base()</b> for information and examples.</p>
<p style="margin-left:9%;"><b>to_base_num()</b></p>
<p style="margin-left:14%;">Converts the given number to
the given base. This method is equivalent to _to_base(), but
returns numbers in an array rather than characters in a
string. In the output, the first element is the most
significant. Unlike _to_base(), all input values may be
arbitrarily large.</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;new(13); <br/>
$x−&gt;to_base_num(2); # returns [1, 1, 0, 1] <br/>
$x = Math::BigInt−&gt;new(65191); <br/>
$x−&gt;to_base_num(128); # returns [3, 125, 39]</p>
<p style="margin-left:9%;"><b>as_hex()</b></p>
<p style="margin-left:14%;">$x−&gt;as_hex();</p>
<p style="margin-left:14%; margin-top: 1em">As, to_hex(),
but with a "0x" prefix.</p>
<p style="margin-left:9%;"><b>as_bin()</b></p>
<p style="margin-left:14%;">$x−&gt;as_bin();</p>
<p style="margin-left:14%; margin-top: 1em">As, to_bin(),
but with a "0b" prefix.</p>
<p style="margin-left:9%;"><b>as_oct()</b></p>
<p style="margin-left:14%;">$x−&gt;as_oct();</p>
<p style="margin-left:14%; margin-top: 1em">As, to_oct(),
but with a "0" prefix.</p>
<p style="margin-left:9%;"><b>as_bytes()</b></p>
<p style="margin-left:14%;">This is just an alias for
to_bytes().</p>
<h3>Other conversion methods
<a name="Other conversion methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>numify()</b></p>
<p style="margin-left:14%;">print
$x−&gt;numify();</p>
<p style="margin-left:14%; margin-top: 1em">Returns a Perl
scalar from $x. It is used automatically whenever a scalar
is needed, for instance in array index operations.</p>
<h3>Utility methods
<a name="Utility methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">These utility
methods are made public <b><br/>
dec_str_to_dec_flt_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using decimal notation and converts it to a
string representing the same number using decimal floating
point notation. The output consists of five parts joined
together: the sign of the significand, the absolute value of
the significand as the smallest possible integer, the letter
"e", the sign of the exponent, and the absolute
value of the exponent. If the input is invalid, nothing is
returned.</p>
<p style="margin-left:14%; margin-top: 1em">$str2 = $class
−&gt; dec_str_to_dec_flt_str($str1);</p>
<p style="margin-left:14%; margin-top: 1em">Some
examples</p>
<p style="margin-left:14%; margin-top: 1em">Input Output
<br/>
31400.00e−4 +314e−2 <br/>
−0.00012300e8 −123e+2 <br/>
0 +0e+0</p>
<p style="margin-left:9%;"><b>hex_str_to_dec_flt_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using hexadecimal notation and converts it to a
string representing the same number using decimal floating
point notation. The output has the same format as that of
"<b>dec_str_to_dec_flt_str()</b>".</p>
<p style="margin-left:14%; margin-top: 1em">$str2 = $class
−&gt; hex_str_to_dec_flt_str($str1);</p>
<p style="margin-left:14%; margin-top: 1em">Some
examples</p>
<p style="margin-left:14%; margin-top: 1em">Input Output
<br/>
0xff +255e+0</p>
<p style="margin-left:14%; margin-top: 1em">Some
examples</p>
<p style="margin-left:9%;"><b>oct_str_to_dec_flt_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using octal notation and converts it to a
string representing the same number using decimal floating
point notation. The output has the same format as that of
"<b>dec_str_to_dec_flt_str()</b>".</p>
<p style="margin-left:14%; margin-top: 1em">$str2 = $class
−&gt; oct_str_to_dec_flt_str($str1);</p>
<p style="margin-left:9%;"><b>bin_str_to_dec_flt_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using binary notation and converts it to a
string representing the same number using decimal floating
point notation. The output has the same format as that of
"<b>dec_str_to_dec_flt_str()</b>".</p>
<p style="margin-left:14%; margin-top: 1em">$str2 = $class
−&gt; bin_str_to_dec_flt_str($str1);</p>
<p style="margin-left:9%;"><b>dec_str_to_dec_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using decimal notation and converts it to a
string representing the same number using decimal notation.
If the number represents an integer, the output consists of
a sign and the absolute value. If the number represents a
non−integer, the output consists of a sign, the
integer part of the number, the decimal point ".",
and the fraction part of the number without any trailing
zeros. If the input is invalid, nothing is returned.</p>
<p style="margin-left:9%;"><b>hex_str_to_dec_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using hexadecimal notation and converts it to a
string representing the same number using decimal notation.
The output has the same format as that of
"<b>dec_str_to_dec_str()</b>".</p>
<p style="margin-left:9%;"><b>oct_str_to_dec_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using octal notation and converts it to a
string representing the same number using decimal notation.
The output has the same format as that of
"<b>dec_str_to_dec_str()</b>".</p>
<p style="margin-left:9%;"><b>bin_str_to_dec_str()</b></p>
<p style="margin-left:14%;">Takes a string representing any
valid number using binary notation and converts it to a
string representing the same number using decimal notation.
The output has the same format as that of
"<b>dec_str_to_dec_str()</b>".</p>
<h2>ACCURACY and PRECISION
<a name="ACCURACY and PRECISION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Math::BigInt and
Math::BigFloat have full support for accuracy and precision
based rounding, both automatically after every operation, as
well as manually.</p>
<p style="margin-left:9%; margin-top: 1em">This section
describes the accuracy/precision handling in Math::BigInt
and Math::BigFloat as it used to be and as it is now,
complete with an explanation of all terms and
abbreviations.</p>
<p style="margin-left:9%; margin-top: 1em">Not yet
implemented things (but with correct description) are marked
with '!', things that need to be answered are marked with
'?'.</p>
<p style="margin-left:9%; margin-top: 1em">In the next
paragraph follows a short description of terms used here
(because these may differ from terms used by others people
or documentation).</p>
<p style="margin-left:9%; margin-top: 1em">During the rest
of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) are be
used.</p>
<h3>Precision P
<a name="Precision P"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Precision is a
fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of
−2. 0 means an integer like 123 (or 120). A precision
of 2 means at least two digits to the left of the decimal
point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have
different precisions, because 1200 can have P = 0, 1 or 2
(depending on what the initial value was). It could also
have p &lt; 0, when the digits after the decimal point are
zero.</p>
<p style="margin-left:9%; margin-top: 1em">The string
output (of floating point numbers) is padded with zeros:</p>
<p style="margin-left:9%; margin-top: 1em">Initial value P
A Result String <br/>

−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
<br/>
1234.01 −3 1000 1000 <br/>
1234 −2 1200 1200 <br/>
1234.5 −1 1230 1230 <br/>
1234.001 1 1234 1234.0 <br/>
1234.01 0 1234 1234 <br/>
1234.01 2 1234.01 1234.01 <br/>
1234.01 5 1234.01 1234.01000</p>
<p style="margin-left:9%; margin-top: 1em">For Math::BigInt
objects, no padding occurs.</p>
<h3>Accuracy A
<a name="Accuracy A"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Number of
significant digits. Leading zeros are not counted. A number
may have an accuracy greater than the non−zero digits
when there are zeros in it or trailing zeros. For example,
123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.45000
has 8 and 0.000123 has 3.</p>
<p style="margin-left:9%; margin-top: 1em">The string
output (of floating point numbers) is padded with zeros:</p>
<p style="margin-left:9%; margin-top: 1em">Initial value P
A Result String <br/>

−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
<br/>
1234.01 3 1230 1230 <br/>
1234.01 6 1234.01 1234.01 <br/>
1234.1 8 1234.1 1234.1000</p>
<p style="margin-left:9%; margin-top: 1em">For Math::BigInt
objects, no padding occurs.</p>
<h3>Fallback F
<a name="Fallback F"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When both A and
P are undefined, this is used as a fallback accuracy when
dividing numbers.</p>
<h3>Rounding mode R
<a name="Rounding mode R"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When rounding a
number, different 'styles' or 'kinds' of rounding are
possible. (Note that random rounding, as in Math::Round, is
not implemented.)</p>
<p style="margin-left:9%; margin-top: 1em"><i>Directed
rounding</i></p>
<p style="margin-left:9%; margin-top: 1em">These round
modes always round in the same direction. <br/>
'trunc'</p>
<p style="margin-left:14%;">Round towards zero. Remove all
digits following the rounding place, i.e., replace them with
zeros. Thus, 987.65 rounded to tens (P=1) becomes 980, and
rounded to the fourth significant digit becomes 987.6 (A=4).
123.456 rounded to the second place after the decimal point
(P=−2) becomes 123.46. This corresponds to the IEEE
754 rounding mode 'roundTowardZero'.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Rounding to
nearest</i></p>
<p style="margin-left:9%; margin-top: 1em">These rounding
modes round to the nearest digit. They differ in how they
determine which way to round in the ambiguous case when
there is a tie. <br/>
'even'</p>
<p style="margin-left:14%;">Round towards the nearest even
digit, e.g., when rounding to nearest integer, −5.5
becomes −6, 4.5 becomes 4, but 4.501 becomes 5. This
corresponds to the IEEE 754 rounding mode
'roundTiesToEven'.</p>
<p style="margin-left:9%;">'odd'</p>
<p style="margin-left:14%;">Round towards the nearest odd
digit, e.g., when rounding to nearest integer, 4.5 becomes
5, −5.5 becomes −5, but 5.501 becomes 6. This
corresponds to the IEEE 754 rounding mode
'roundTiesToOdd'.</p>
<p style="margin-left:9%;">'+inf'</p>
<p style="margin-left:14%;">Round towards plus infinity,
i.e., always round up. E.g., when rounding to the nearest
integer, 4.5 becomes 5, −5.5 becomes −5, and
4.501 also becomes 5. This corresponds to the IEEE 754
rounding mode 'roundTiesToPositive'.</p>
<p style="margin-left:9%;">'−inf'</p>
<p style="margin-left:14%;">Round towards minus infinity,
i.e., always round down. E.g., when rounding to the nearest
integer, 4.5 becomes 4, −5.5 becomes −6, but
4.501 becomes 5. This corresponds to the IEEE 754 rounding
mode 'roundTiesToNegative'.</p>
<p style="margin-left:9%;">'zero'</p>
<p style="margin-left:14%;">Round towards zero, i.e., round
positive numbers down and negative numbers up. E.g., when
rounding to the nearest integer, 4.5 becomes 4, −5.5
becomes −5, but 4.501 becomes 5. This corresponds to
the IEEE 754 rounding mode 'roundTiesToZero'.</p>
<p style="margin-left:9%;">'common'</p>
<p style="margin-left:14%;">Round away from zero, i.e.,
round to the number with the largest absolute value. E.g.,
when rounding to the nearest integer, −1.5 becomes
−2, 1.5 becomes 2 and 1.49 becomes 1. This corresponds
to the IEEE 754 rounding mode 'roundTiesToAway'.</p>
<p style="margin-left:9%; margin-top: 1em">The handling of
A &amp; P in MBI/MBF (the old core code shipped with Perl
versions &lt;= 5.7.2) is like this: <br/>
Precision</p>
<p style="margin-left:14%;">* bfround($p) is able to round
to $p number of digits after the decimal <br/>
point <br/>
* otherwise P is unused</p>
<p style="margin-left:9%;">Accuracy (significant
digits)</p>
<p style="margin-left:14%;">* bround($a) rounds to $a
significant digits <br/>
* only bdiv() and bsqrt() take A as (optional) parameter
<br/>
+ other operations simply create the same number (bneg etc),
or <br/>
more (bmul) of digits <br/>
+ rounding/truncating is only done when explicitly calling
one <br/>
of bround or bfround, and never for Math::BigInt (not
implemented) <br/>
* bsqrt() simply hands its accuracy argument over to bdiv.
<br/>
* the documentation and the comment in the code indicate two
<br/>
different ways on how bdiv() determines the maximum number
<br/>
of digits it should calculate, and the actual code does yet
<br/>
another thing <br/>
POD: <br/>

max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
<br/>
Comment: <br/>
result has at most max(scale, length(dividend),
length(divisor)) digits <br/>
Actual code: <br/>
scale = max(scale,
length(dividend)−1,length(divisor)−1); <br/>
scale += length(divisor) − length(dividend); <br/>
So for lx = 3, ly = 9, scale = 10, scale will actually be 16
(10 <br/>
So for lx = 3, ly = 9, scale = 10, scale will actually be 16
<br/>
(10+9−3). Actually, the 'difference' added to the
scale is cal− <br/>
culated from the number of "significant digits" in
dividend and <br/>
divisor, which is derived by looking at the length of the
man− <br/>
tissa. Which is wrong, since it includes the + sign (oops)
and <br/>
actually gets 2 for '+100' and 4 for '+101'. Oops again.
Thus <br/>
124/3 with div_scale=1 will get you '41.3' based on the
strange <br/>
assumption that 124 has 3 significant digits, while 120/7
will <br/>
get you '17', not '17.1' since 120 is thought to have 2
signif− <br/>
icant digits. The rounding after the division then uses the
<br/>
remainder and $y to determine whether it must round up or
down. <br/>
? I have no idea which is the right way. That's why I used a
slightly more <br/>
? simple scheme and tweaked the few failing testcases to
match it.</p>
<p style="margin-left:9%; margin-top: 1em">This is how it
works now: <br/>
Setting/Accessing</p>
<p style="margin-left:14%;">* You can set the A global via
Math::BigInt−&gt;accuracy() or <br/>
Math::BigFloat−&gt;accuracy() or whatever class you
are using. <br/>
* You can also set P globally by using
Math::SomeClass−&gt;precision() <br/>
likewise. <br/>
* Globals are classwide, and not inherited by subclasses.
<br/>
* to undefine A, use
Math::SomeClass−&gt;accuracy(undef); <br/>
* to undefine P, use
Math::SomeClass−&gt;precision(undef); <br/>
* Setting Math::SomeClass−&gt;accuracy() clears
automatically <br/>
Math::SomeClass−&gt;precision(), and vice versa. <br/>
* To be valid, A must be &gt; 0, P can have any value. <br/>
* If P is negative, this means round to the P'th place to
the right of the <br/>
decimal point; positive values mean to the left of the
decimal point. <br/>
P of 0 means round to integer. <br/>
* to find out the current global A, use
Math::SomeClass−&gt;accuracy() <br/>
* to find out the current global P, use
Math::SomeClass−&gt;precision() <br/>
* use $x−&gt;accuracy() respective
$x−&gt;precision() for the local <br/>
setting of $x. <br/>
* Please note that $x−&gt;accuracy() respective
$x−&gt;precision() <br/>
return eventually defined global A or P, when $x's A or P is
not <br/>
set.</p>
<p style="margin-left:9%;">Creating numbers</p>
<p style="margin-left:14%;">* When you create a number, you
can give the desired A or P via: <br/>
$x = Math::BigInt−&gt;new($number,$A,$P); <br/>
* Only one of A or P can be defined, otherwise the result is
NaN <br/>
* If no A or P is give ($x =
Math::BigInt−&gt;new($number) form), then the <br/>
globals (if set) will be used. Thus changing the global
defaults later on <br/>
will not change the A or P of previously created numbers
(i.e., A and P of <br/>
$x will be what was in effect when $x was created) <br/>
* If given undef for A and P, NO rounding will occur, and
the globals will <br/>
NOT be used. This is used by subclasses to create numbers
without <br/>
suffering rounding in the parent. Thus a subclass is able to
have its own <br/>
globals enforced upon creation of a number by using <br/>
$x = Math::BigInt−&gt;new($number,undef,undef): <br/>
use Math::BigInt::SomeSubclass; <br/>
use Math::BigInt; <br/>
Math::BigInt−&gt;accuracy(2); <br/>
Math::BigInt::SomeSubclass−&gt;accuracy(3); <br/>
$x = Math::BigInt::SomeSubclass−&gt;new(1234); <br/>
$x is now 1230, and not 1200. A subclass might choose to
implement <br/>
this otherwise, e.g. falling back to the parent's A and
P.</p>
<p style="margin-left:9%;">Usage</p>
<p style="margin-left:14%;">* If A or P are
enabled/defined, they are used to round the result of each
<br/>
operation according to the rules below <br/>
* Negative P is ignored in Math::BigInt, since Math::BigInt
objects never <br/>
have digits after the decimal point <br/>
* Math::BigFloat uses Math::BigInt internally, but setting A
or P inside <br/>
Math::BigInt as globals does not tamper with the parts of a
Math::BigFloat. <br/>
A flag is used to mark all Math::BigFloat numbers as 'never
round'.</p>
<p style="margin-left:9%;">Precedence</p>
<p style="margin-left:14%;">* It only makes sense that a
number has only one of A or P at a time. <br/>
If you set either A or P on one object, or globally, the
other one will <br/>
be automatically cleared. <br/>
* If two objects are involved in an operation, and one of
them has A in <br/>
effect, and the other P, this results in an error (NaN).
<br/>
* A takes precedence over P (Hint: A comes before P). <br/>
If neither of them is defined, nothing is used, i.e. the
result will have <br/>
as many digits as it can (with an exception for bdiv/bsqrt)
and will not <br/>
be rounded. <br/>
* There is another setting for bdiv() (and thus for
bsqrt()). If neither of <br/>
A or P is defined, bdiv() will use a fallback (F) of
$div_scale digits. <br/>
If either the dividend's or the divisor's mantissa has more
digits than <br/>
the value of F, the higher value will be used instead of F.
<br/>
This is to limit the digits (A) of the result (just consider
what would <br/>
happen with unlimited A and P in the case of 1/3 :−)
<br/>
* bdiv will calculate (at least) 4 more digits than required
(determined by <br/>
A, P or F), and, if F is not used, round the result <br/>
(this will still fail in the case of a result like
0.12345000000001 with A <br/>
or P of 5, but this can not be helped − or can it?)
<br/>
* Thus you can have the math done by on Math::Big* class in
two modi: <br/>
+ never round (this is the default): <br/>
This is done by setting A and P to undef. No math operation
<br/>
will round the result, with bdiv() and bsqrt() as exceptions
to guard <br/>
against overflows. You must explicitly call bround(),
bfround() or <br/>
round() (the latter with parameters). <br/>
Note: Once you have rounded a number, the settings will
'stick' on it <br/>
and 'infect' all other numbers engaged in math operations
with it, since <br/>
local settings have the highest precedence. So, to get
SaferRound[tm], <br/>
use a copy() before rounding like this: <br/>
$x = Math::BigFloat−&gt;new(12.34); <br/>
$y = Math::BigFloat−&gt;new(98.76); <br/>
$z = $x * $y; # 1218.6984 <br/>
print $x−&gt;copy()−&gt;bround(3); # 12.3 (but A
is now 3!) <br/>
$z = $x * $y; # still 1218.6984, without <br/>
# copy would have been 1210! <br/>
+ round after each op: <br/>
After each single operation (except for testing like
is_zero()), the <br/>
method round() is called and the result is rounded
appropriately. By <br/>
setting proper values for A and P, you can have
all−the−same−A or <br/>
all−the−same−P modes. For example,
Math::Currency might set A to undef, <br/>
and P to −2, globally. <br/>
?Maybe an extra option that forbids local A &amp; P settings
would be in order, <br/>
?so that intermediate rounding does not 'poison' further
math?</p>
<p style="margin-left:9%;">Overriding globals</p>
<p style="margin-left:14%;">* you will be able to give A, P
and R as an argument to all the calculation <br/>
routines; the second parameter is A, the third one is P, and
the fourth is <br/>
R (shift right by one for binary operations like badd). P is
used only if <br/>
the first parameter (A) is undefined. These three parameters
override the <br/>
globals in the order detailed as follows, i.e. the first
defined value <br/>
wins: <br/>
(local: per object, global: global default, parameter:
argument to sub) <br/>
+ parameter A <br/>
+ parameter P <br/>
+ local A (if defined on both of the operands: smaller one
is taken) <br/>
+ local P (if defined on both of the operands: bigger one is
taken) <br/>
+ global A <br/>
+ global P <br/>
+ global F <br/>
* bsqrt() will hand its arguments to bdiv(), as it used to,
only now for two <br/>
arguments (A and P) instead of one</p>
<p style="margin-left:9%;">Local settings</p>
<p style="margin-left:14%;">* You can set A or P locally by
using $x−&gt;accuracy() or <br/>
$x−&gt;precision() <br/>
and thus force different A and P for different
objects/numbers. <br/>
* Setting A or P this way immediately rounds $x to the new
value. <br/>
* $x−&gt;accuracy() clears $x−&gt;precision(),
and vice versa.</p>
<p style="margin-left:9%;">Rounding</p>
<p style="margin-left:14%;">* the rounding routines will
use the respective global or local settings. <br/>
bround() is for accuracy rounding, while bfround() is for
precision <br/>
* the two rounding functions take as the second parameter
one of the <br/>
following rounding modes (R): <br/>
'even', 'odd', '+inf', '−inf', 'zero', 'trunc',
'common' <br/>
* you can set/get the global R by using
Math::SomeClass−&gt;round_mode() <br/>
or by setting $Math::SomeClass::round_mode <br/>
* after each operation, $result−&gt;round() is called,
and the result may <br/>
eventually be rounded (that is, if A or P were set either
locally, <br/>
globally or as parameter to the operation) <br/>
* to manually round a number, call
$x−&gt;round($A,$P,$round_mode); <br/>
this will round the number by using the appropriate rounding
function <br/>
and then normalize it. <br/>
* rounding modifies the local settings of the number: <br/>
$x = Math::BigFloat−&gt;new(123.456); <br/>
$x−&gt;accuracy(5); <br/>
$x−&gt;bround(4); <br/>
Here 4 takes precedence over 5, so 123.5 is the result and
$x−&gt;accuracy() <br/>
will be 4 from now on.</p>
<p style="margin-left:9%;">Default values</p>
<p style="margin-left:14%;">* R: 'even' <br/>
* F: 40 <br/>
* A: undef <br/>
* P: undef</p>
<p style="margin-left:9%;">Remarks</p>
<p style="margin-left:14%;">* The defaults are set up so
that the new code gives the same results as <br/>
the old code (except in a few cases on bdiv): <br/>
+ Both A and P are undefined and thus will not be used for
rounding <br/>
after each operation. <br/>
+ round() is thus a no−op, unless given extra
parameters A and P</p>
<h2>Infinity and Not a Number
<a name="Infinity and Not a Number"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">While
Math::BigInt has extensive handling of inf and NaN, certain
quirks remain. <b><br/>
oct()</b>/<b>hex()</b></p>
<p style="margin-left:14%;">These perl routines currently
(as of Perl v.5.8.6) cannot handle passed inf.</p>
<p style="margin-left:14%; margin-top: 1em">te@linux:˜&gt;
perl −wle 'print 2 ** 3333' <br/>
Inf <br/>
te@linux:˜&gt; perl −wle 'print 2 ** 3333 == 2 **
3333' <br/>
1 <br/>
te@linux:˜&gt; perl −wle 'print oct(2 ** 3333)'
<br/>
0 <br/>
te@linux:˜&gt; perl −wle 'print hex(2 ** 3333)'
<br/>
Illegal hexadecimal digit 'I' ignored at −e line 1.
<br/>
0</p>
<p style="margin-left:14%; margin-top: 1em">The same
problems occur if you pass them
Math::BigInt−&gt;<b>binf()</b> objects. Since
overloading these routines is not possible, this cannot be
fixed from Math::BigInt.</p>
<h2>INTERNALS
<a name="INTERNALS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">You should
neither care about nor depend on the internal
representation; it might change without notice. Use
<b>ONLY</b> method calls like
"$x−&gt;sign();" instead relying on the
internal representation.</p>
<h3>MATH LIBRARY
<a name="MATH LIBRARY"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The mathematical
computations are performed by a backend library. It is not
required to specify which backend library to use, but some
backend libraries are much faster than the default
library.</p>
<p style="margin-left:9%; margin-top: 1em"><i>The default
library</i></p>
<p style="margin-left:9%; margin-top: 1em">The default
library is Math::BigInt::Calc, which is implemented in pure
Perl and hence does not require a compiler.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Specifying a
library</i></p>
<p style="margin-left:9%; margin-top: 1em">The simple
case</p>
<p style="margin-left:9%; margin-top: 1em">use
Math::BigInt;</p>
<p style="margin-left:9%; margin-top: 1em">is equivalent to
saying</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
try =&gt; 'Calc';</p>
<p style="margin-left:9%; margin-top: 1em">You can use a
different backend library with, e.g.,</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
try =&gt; 'GMP';</p>
<p style="margin-left:9%; margin-top: 1em">which attempts
to load the Math::BigInt::GMP library, and falls back to the
default library if the specified library can't be
loaded.</p>
<p style="margin-left:9%; margin-top: 1em">Multiple
libraries can be specified by separating them by a comma,
e.g.,</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
try =&gt; 'GMP,Pari';</p>
<p style="margin-left:9%; margin-top: 1em">If you request a
specific set of libraries and do not allow fallback to the
default library, specify them using "only",</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
only =&gt; 'GMP,Pari';</p>
<p style="margin-left:9%; margin-top: 1em">If you prefer a
specific set of libraries, but want to see a warning if the
fallback library is used, specify them using
"lib",</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
lib =&gt; 'GMP,Pari';</p>
<p style="margin-left:9%; margin-top: 1em">The following
first tries to find Math::BigInt::Foo, then
Math::BigInt::Bar, and if this also fails, reverts to
Math::BigInt::Calc:</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
try =&gt; 'Foo,Math::BigInt::Bar';</p>
<p style="margin-left:9%; margin-top: 1em"><i>Which library
to use?</i></p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b>:
General purpose packages should not be explicit about the
library to use; let the script author decide which is
best.</p>
<p style="margin-left:9%; margin-top: 1em">Math::BigInt::GMP,
Math::BigInt::Pari, and Math::BigInt::GMPz are in cases
involving big numbers much faster than Math::BigInt::Calc.
However these libraries are slower when dealing with very
small numbers (less than about 20 digits) and when
converting very large numbers to decimal (for instance for
printing, rounding, calculating their length in decimal
etc.).</p>
<p style="margin-left:9%; margin-top: 1em">So please select
carefully what library you want to use.</p>
<p style="margin-left:9%; margin-top: 1em">Different
low−level libraries use different formats to store the
numbers, so mixing them won't work. You should not depend on
the number having a specific internal format.</p>
<p style="margin-left:9%; margin-top: 1em">See the
respective math library module documentation for further
details.</p>
<p style="margin-left:9%; margin-top: 1em"><i>Loading
multiple libraries</i></p>
<p style="margin-left:9%; margin-top: 1em">The first
library that is successfully loaded is the one that will be
used. Any further attempts at loading a different module
will be ignored. This is to avoid the situation where module
A requires math library X, and module B requires math
library Y, causing modules A and B to be incompatible. For
example,</p>
<p style="margin-left:9%; margin-top: 1em">use
Math::BigInt; # loads default "Calc" <br/>
use Math::BigFloat only =&gt; "GMP"; # ignores
"GMP"</p>
<h3>SIGN
<a name="SIGN"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The sign is
either '+', '−', 'NaN', '+inf' or '−inf'.</p>
<p style="margin-left:9%; margin-top: 1em">A sign of 'NaN'
is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '−inf'
represent plus respectively minus infinity. You get '+inf'
when dividing a positive number by 0, and '−inf' when
dividing any negative number by 0.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use
Math::BigInt; <br/>
sub bigint { Math::BigInt−&gt;new(shift); } <br/>
$x = Math::BigInt−&gt;bstr("1234") # string
"1234" <br/>
$x = "$x"; # same as bstr() <br/>
$x = Math::BigInt−&gt;bneg("1234"); #
Math::BigInt "−1234" <br/>
$x = Math::BigInt−&gt;babs("−12345");
# Math::BigInt "12345" <br/>
$x = Math::BigInt−&gt;bnorm("−0.00");
# Math::BigInt "0" <br/>
$x = bigint(1) + bigint(2); # Math::BigInt "3"
<br/>
$x = bigint(1) + "2"; # ditto ("2"
becomes a Math::BigInt) <br/>
$x = bigint(1); # Math::BigInt "1" <br/>
$x = $x + 5 / 2; # Math::BigInt "3" <br/>
$x = $x ** 3; # Math::BigInt "27" <br/>
$x *= 2; # Math::BigInt "54" <br/>
$x = Math::BigInt−&gt;new(0); # Math::BigInt
"0" <br/>
$x−−; # Math::BigInt "−1" <br/>
$x = Math::BigInt−&gt;badd(4,5) # Math::BigInt
"9" <br/>
print $x−&gt;bsstr(); # 9e+0</p>
<p style="margin-left:9%; margin-top: 1em">Examples for
rounding:</p>
<p style="margin-left:9%; margin-top: 1em">use
Math::BigFloat; <br/>
use Test::More; <br/>
$x = Math::BigFloat−&gt;new(123.4567); <br/>
$y = Math::BigFloat−&gt;new(123.456789); <br/>
Math::BigFloat−&gt;accuracy(4); # no more A than 4
<br/>
is ($x−&gt;copy()−&gt;bround(),123.4); # even
rounding <br/>
print $x−&gt;copy()−&gt;bround(),"\n";
# 123.4 <br/>
Math::BigFloat−&gt;round_mode('odd'); # round to odd
<br/>
print $x−&gt;copy()−&gt;bround(),"\n";
# 123.5 <br/>
Math::BigFloat−&gt;accuracy(5); # no more A than 5
<br/>
Math::BigFloat−&gt;round_mode('odd'); # round to odd
<br/>
print $x−&gt;copy()−&gt;bround(),"\n";
# 123.46 <br/>
$y = $x−&gt;copy()−&gt;bround(4),"\n";
# A = 4: 123.4 <br/>
print "$y,
",$y−&gt;accuracy(),"\n"; # 123.4, 4
<br/>
Math::BigFloat−&gt;accuracy(undef); # A not important
now <br/>
Math::BigFloat−&gt;precision(2); # P important <br/>
print $x−&gt;copy()−&gt;bnorm(),"\n";
# 123.46 <br/>
print $x−&gt;copy()−&gt;bround(),"\n";
# 123.46</p>
<p style="margin-left:9%; margin-top: 1em">Examples for
converting:</p>
<p style="margin-left:9%; margin-top: 1em">my $x =
Math::BigInt−&gt;new('0b1'.'01' x 123); <br/>
print "bin: ",$x−&gt;as_bin(),"
hex:",$x−&gt;as_hex()," dec:
",$x,"\n";</p>
<h2>NUMERIC LITERALS
<a name="NUMERIC LITERALS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">After "use
Math::BigInt ':constant'" all numeric literals in the
given scope are converted to "Math::BigInt"
objects. This conversion happens at compile time. Every
non−integer is convert to a NaN.</p>
<p style="margin-left:9%; margin-top: 1em">For example,</p>
<p style="margin-left:9%; margin-top: 1em">perl
−MMath::BigInt=:constant −le 'print 2**150'</p>
<p style="margin-left:9%; margin-top: 1em">prints the exact
value of "2**150". Note that without conversion of
constants to objects the expression "2**150" is
calculated using Perl scalars, which leads to an inaccurate
result.</p>
<p style="margin-left:9%; margin-top: 1em">Please note that
strings are not affected, so that</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
qw/:constant/; <br/>
$x = "1234567890123456789012345678901234567890"
<br/>
+ "123456789123456789";</p>
<p style="margin-left:9%; margin-top: 1em">does give you
what you expect. You need an explicit
Math::BigInt−&gt;<b>new()</b> around at least one of
the operands. You should also quote large constants to
prevent loss of precision:</p>
<p style="margin-left:9%; margin-top: 1em">use
Math::BigInt; <br/>
$x =
Math::BigInt−&gt;new("1234567889123456789123456789123456789");</p>
<p style="margin-left:9%; margin-top: 1em">Without the
quotes Perl first converts the large number to a floating
point constant at compile time, and then converts the result
to a Math::BigInt object at run time, which results in an
inaccurate result.</p>
<h3>Hexadecimal, octal, and binary floating point literals
<a name="Hexadecimal, octal, and binary floating point literals"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Perl (and this
module) accepts hexadecimal, octal, and binary floating
point literals, but use them with care with Perl versions
before v5.32.0, because some versions of Perl silently give
the wrong result. Below are some examples of different ways
to write the number decimal 314.</p>
<p style="margin-left:9%; margin-top: 1em">Hexadecimal
floating point literals:</p>
<p style="margin-left:9%; margin-top: 1em">0x1.3ap+8
0X1.3AP+8 <br/>
0x1.3ap8 0X1.3AP8 <br/>
0x13a0p−4 0X13A0P−4</p>
<p style="margin-left:9%; margin-top: 1em">Octal floating
point literals (with "0" prefix):</p>
<p style="margin-left:9%; margin-top: 1em">01.164p+8
01.164P+8 <br/>
01.164p8 01.164P8 <br/>
011640p−4 011640P−4</p>
<p style="margin-left:9%; margin-top: 1em">Octal floating
point literals (with "0o" prefix) (requires
v5.34.0):</p>
<p style="margin-left:9%; margin-top: 1em">0o1.164p+8
0O1.164P+8 <br/>
0o1.164p8 0O1.164P8 <br/>
0o11640p−4 0O11640P−4</p>
<p style="margin-left:9%; margin-top: 1em">Binary floating
point literals:</p>
<p style="margin-left:9%; margin-top: 1em">0b1.0011101p+8
0B1.0011101P+8 <br/>
0b1.0011101p8 0B1.0011101P8 <br/>
0b10011101000p−2 0B10011101000P−2</p>
<h2>PERFORMANCE
<a name="PERFORMANCE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Using the form
$x += $y; etc over $x = $x + $y is faster, since a copy of
$x must be made in the second case. For long numbers, the
copy can eat up to 20% of the work (in the case of
addition/subtraction, less for multiplication/division). If
$y is very small compared to $x, the form $x += $y is MUCH
faster than $x = $x + $y since making the copy of $x takes
more time then the actual addition.</p>
<p style="margin-left:9%; margin-top: 1em">With a technique
called copy−on−write, the cost of copying with
overload could be minimized or even completely avoided. A
test implementation of COW did show performance gains for
overloaded math, but introduced a performance loss due to a
constant overhead for all other operations. So Math::BigInt
does currently not COW.</p>
<p style="margin-left:9%; margin-top: 1em">The rewritten
version of this module (vs. v0.01) is slower on certain
operations, like new(), bstr() and numify(). The reason are
that it does now more work and handles much more cases. The
time spent in these operations is usually gained in the
other math operations so that code on the average should get
(much) faster. If they don't, please contact the author.</p>
<p style="margin-left:9%; margin-top: 1em">Some operations
may be slower for small numbers, but are significantly
faster for big numbers. Other operations are now constant
(O(1), like bneg(), babs() etc), instead of O(N) and thus
nearly always take much less time. These optimizations were
done on purpose.</p>
<p style="margin-left:9%; margin-top: 1em">If you find the
Calc module to slow, try to install any of the replacement
modules and see if they help you.</p>
<h3>Alternative math libraries
<a name="Alternative math libraries"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">You can use an
alternative library to drive Math::BigInt. See the section
"MATH LIBRARY" for more information.</p>
<p style="margin-left:9%; margin-top: 1em">For more
benchmark results see
&lt;http://bloodgate.com/perl/benchmarks.html&gt;.</p>
<h2>SUBCLASSING
<a name="SUBCLASSING"></a>
</h2>
<h3>Subclassing Math::BigInt
<a name="Subclassing Math::BigInt"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The basic design
of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>The public API must remain consistent, i.e. if a
sub−class is overloading addition, the sub−class
must use the same name, in this case <b>badd()</b>. The
reason for this is that Math::BigInt is optimized to call
the object methods directly.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>The private object hash keys like
"$x−&gt;{sign}" may not be changed, but
additional keys can be added, like
"$x−&gt;{_custom}".</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Accessor functions are available for all existing object
hash keys and should be used instead of directly accessing
the internal hash keys. The reason for this is that
Math::BigInt itself has a pluggable interface which permits
it to support different storage methods.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">More complex
sub−classes may have to replicate more of the logic
internal of Math::BigInt if they need to change more basic
behaviors. A subclass that needs to merely change the output
only needs to overload bstr().</p>
<p style="margin-left:9%; margin-top: 1em">All other object
methods and overloaded functions can be directly inherited
from the parent class.</p>
<p style="margin-left:9%; margin-top: 1em">At the very
minimum, any subclass needs to provide its own new() and can
store additional hash keys in the object. There are also
some package globals that must be defined, e.g.:</p>
<p style="margin-left:9%; margin-top: 1em"># Globals <br/>
our $accuracy = 2; # round to 2 decimal places <br/>
our $precision = undef; <br/>
our $round_mode = 'even'; <br/>
our $div_scale = 40;</p>
<p style="margin-left:9%; margin-top: 1em">Additionally,
you might want to provide the following two globals to allow
auto−upgrading and auto−downgrading:</p>
<p style="margin-left:9%; margin-top: 1em">our $upgrade =
undef; <br/>
our $downgrade = undef;</p>
<p style="margin-left:9%; margin-top: 1em">This allows
Math::BigInt to correctly retrieve package globals from the
subclass, like $SubClass::precision. See
"t/Math/BigInt/Subclass.pm",
"t/Math/BigFloat/SubClass.pm", or
"t/Math/BigRat/SubClass.pm" for subclass
examples.</p>
<p style="margin-left:9%; margin-top: 1em">Don't forget
to</p>
<p style="margin-left:9%; margin-top: 1em">use
overload;</p>
<p style="margin-left:9%; margin-top: 1em">in your subclass
to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at
Math::String for an example.</p>
<h2>UPGRADING
<a name="UPGRADING"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">When used like
this:</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
upgrade =&gt; 'Foo::Bar';</p>
<p style="margin-left:9%; margin-top: 1em">any operation
whose result cannot be represented as an integer is upgraded
to the class Foo::Bar. Usually this is used in conjunction
with Math::BigFloat:</p>
<p style="margin-left:9%; margin-top: 1em">use Math::BigInt
upgrade =&gt; 'Math::BigFloat';</p>
<p style="margin-left:9%; margin-top: 1em">For example, the
following returns 3 as a Math::BigInt when no upgrading is
defined, and 3.125 as a Math::BigFloat if Math::BigInt is
set to upgrade to Math::BigFloat:</p>
<p style="margin-left:9%; margin-top: 1em">$x =
Math::BigInt −&gt; new(25) −&gt; bdiv(8);</p>
<p style="margin-left:9%; margin-top: 1em">As a shortcut,
you can use the module bignum:</p>
<p style="margin-left:9%; margin-top: 1em">use bignum;</p>
<p style="margin-left:9%; margin-top: 1em">which is also
good for one−liners:</p>
<p style="margin-left:9%; margin-top: 1em">perl
−Mbignum −le 'print 2 ** 255'</p>
<p style="margin-left:9%; margin-top: 1em">This makes it
possible to mix arguments of different classes (as in 2.5 +
2) as well es preserve accuracy (as in <b>sqrt</b>(3)).</p>
<p style="margin-left:9%; margin-top: 1em">Beware: This
feature is not fully implemented yet.</p>
<h3>Auto−upgrade
<a name="Auto−upgrade"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The following
methods upgrade themselves unconditionally; that is if
upgrade is in effect, they always hands up their work:</p>
<p style="margin-left:9%; margin-top: 1em">div bsqrt blog
bexp bpi bsin bcos batan batan2</p>
<p style="margin-left:9%; margin-top: 1em">All other
methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in $upgrade.</p>
<h2>EXPORTS
<a name="EXPORTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">"Math::BigInt"
exports nothing by default, but can export the following
methods:</p>
<p style="margin-left:9%; margin-top: 1em">bgcd <br/>
blcm</p>
<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Some things
might not work as you expect them. Below is documented what
is known to be troublesome: <br/>
Comparing numbers as strings</p>
<p style="margin-left:14%;">Both bstr() and bsstr() as well
as stringify via overload drop the leading '+'. This is to
be consistent with Perl and to make "cmp"
(especially with overloading) to work as you expect. It also
solves problems with "Test.pm" and Test::More,
which stringify arguments before comparing them.</p>
<p style="margin-left:14%; margin-top: 1em">Mark Biggar
said, when asked about to drop the '+' altogether, or make
only "cmp" work:</p>
<p style="margin-left:14%; margin-top: 1em">I agree (with
the first alternative), don't add the '+' on positive <br/>
numbers. It's not as important anymore with the new internal
form <br/>
for numbers. It made doing things like abs and neg easier,
but <br/>
those have to be done differently now anyway.</p>
<p style="margin-left:14%; margin-top: 1em">So, the
following examples now works as expected:</p>
<p style="margin-left:14%; margin-top: 1em">use Test::More
tests =&gt; 1; <br/>
use Math::BigInt; <br/>
my $x = Math::BigInt −&gt; new(3*3); <br/>
my $y = Math::BigInt −&gt; new(3*3); <br/>
is($x,3*3, 'multiplication'); <br/>
print "$x eq 9" if $x eq $y; <br/>
print "$x eq 9" if $x eq '9'; <br/>
print "$x eq 9" if $x eq 3*3;</p>
<p style="margin-left:14%; margin-top: 1em">Additionally,
the following still works:</p>
<p style="margin-left:14%; margin-top: 1em">print "$x
== 9" if $x == $y; <br/>
print "$x == 9" if $x == 9; <br/>
print "$x == 9" if $x == 3*3;</p>
<p style="margin-left:14%; margin-top: 1em">There is now a
bsstr() method to get the string in scientific notation aka
1e+2 instead of 100. Be advised that overloaded 'eq' always
uses <b>bstr()</b> for comparison, but Perl represents some
numbers as 100 and others as 1e+308. If in doubt, convert
both arguments to Math::BigInt before comparing them as
strings:</p>
<p style="margin-left:14%; margin-top: 1em">use Test::More
tests =&gt; 3; <br/>
use Math::BigInt; <br/>
$x = Math::BigInt−&gt;new('1e56'); <br/>
$y = 1e56; <br/>
is($x,$y); # fails <br/>
is($x−&gt;bsstr(), $y); # okay <br/>
$y = Math::BigInt−&gt;new($y); <br/>
is($x, $y); # okay</p>
<p style="margin-left:14%; margin-top: 1em">Alternatively,
simply use "&lt;=&gt;" for comparisons, this
always gets it right. There is not yet a way to get a number
automatically represented as a string that matches exactly
the way Perl represents it.</p>
<p style="margin-left:14%; margin-top: 1em">See also the
section about "Infinity and Not a Number" for
problems in comparing NaNs.</p>
<p style="margin-left:9%;"><b>int()</b></p>
<p style="margin-left:14%;">int() returns (at least for
Perl v5.7.1 and up) another Math::BigInt, not a Perl
scalar:</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigInt−&gt;new(123); <br/>
$y = int($x); # 123 as a Math::BigInt <br/>
$x = Math::BigFloat−&gt;new(123.45); <br/>
$y = int($x); # 123 as a Math::BigFloat</p>
<p style="margin-left:14%; margin-top: 1em">If you want a
real Perl scalar, use numify():</p>
<p style="margin-left:14%; margin-top: 1em">$y =
$x−&gt;numify(); # 123 as a scalar</p>
<p style="margin-left:14%; margin-top: 1em">This is seldom
necessary, though, because this is done automatically, like
when you access an array:</p>
<p style="margin-left:14%; margin-top: 1em">$z =
$array[$x]; # does work automatically</p>
<p style="margin-left:9%;">Modifying and =</p>
<p style="margin-left:14%;">Beware of:</p>
<p style="margin-left:14%; margin-top: 1em">$x =
Math::BigFloat−&gt;new(5); <br/>
$y = $x;</p>
<p style="margin-left:14%; margin-top: 1em">This makes a
second reference to the <b>same</b> object and stores it in
$y. Thus anything that modifies $x (except overloaded
operators) also modifies $y, and vice versa. Or in other
words, "=" is only safe if you modify your
Math::BigInt objects only via overloaded math. As soon as
you use a method call it breaks:</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bmul(2);
<br/>
print "$x, $y\n"; # prints '10, 10'</p>
<p style="margin-left:14%; margin-top: 1em">If you want a
true copy of $x, use:</p>
<p style="margin-left:14%; margin-top: 1em">$y =
$x−&gt;copy();</p>
<p style="margin-left:14%; margin-top: 1em">You can also
chain the calls like this, this first makes a copy and then
multiply it by 2:</p>
<p style="margin-left:14%; margin-top: 1em">$y =
$x−&gt;copy()−&gt;bmul(2);</p>
<p style="margin-left:14%; margin-top: 1em">See also the
documentation for overload.pm regarding "=".</p>
<p style="margin-left:9%;">Overloading −$x</p>
<p style="margin-left:14%;">The following:</p>
<p style="margin-left:14%; margin-top: 1em">$x =
−$x;</p>
<p style="margin-left:14%; margin-top: 1em">is slower
than</p>
<p style="margin-left:14%; margin-top: 1em">$x−&gt;bneg();</p>
<p style="margin-left:14%; margin-top: 1em">since overload
calls "sub($x,0,1);" instead of neg($x). The first
variant needs to preserve $x since it does not know that it
later gets overwritten. This makes a copy of $x and takes
O(N), but $x−&gt;<b>bneg()</b> is O(1).</p>
<p style="margin-left:9%;">Mixing different object
types</p>
<p style="margin-left:14%;">With overloaded operators, it
is the first (dominating) operand that determines which
method is called. Here are some examples showing what
actually gets called in various cases.</p>
<p style="margin-left:14%; margin-top: 1em">use
Math::BigInt; <br/>
use Math::BigFloat; <br/>
$mbf = Math::BigFloat−&gt;new(5); <br/>
$mbi2 = Math::BigInt−&gt;new(5); <br/>
$mbi = Math::BigInt−&gt;new(2); <br/>
# what actually gets called: <br/>
$float = $mbf + $mbi; # $mbf−&gt;badd($mbi) <br/>
$float = $mbf / $mbi; # $mbf−&gt;bdiv($mbi) <br/>
$integer = $mbi + $mbf; # $mbi−&gt;badd($mbf) <br/>
$integer = $mbi2 / $mbi; # $mbi2−&gt;bdiv($mbi) <br/>
$integer = $mbi2 / $mbf; # $mbi2−&gt;bdiv($mbf)</p>
<p style="margin-left:14%; margin-top: 1em">For instance,
Math::BigInt−&gt;<b>bdiv()</b> always returns a
Math::BigInt, regardless of whether the second operant is a
Math::BigFloat. To get a Math::BigFloat you either need to
call the operation manually, make sure each operand already
is a Math::BigFloat, or cast to that type via
Math::BigFloat−&gt;<b>new()</b>:</p>
<p style="margin-left:14%; margin-top: 1em">$float =
Math::BigFloat−&gt;new($mbi2) / $mbi; # = 2.5</p>
<p style="margin-left:14%; margin-top: 1em">Beware of
casting the entire expression, as this would cast the
result, at which point it is too late:</p>
<p style="margin-left:14%; margin-top: 1em">$float =
Math::BigFloat−&gt;new($mbi2 / $mbi); # = 2</p>
<p style="margin-left:14%; margin-top: 1em">Beware also of
the order of more complicated expressions like:</p>
<p style="margin-left:14%; margin-top: 1em">$integer =
($mbi2 + $mbi) / $mbf; # int / float =&gt; int <br/>
$integer = $mbi2 / Math::BigFloat−&gt;new($mbi); #
ditto</p>
<p style="margin-left:14%; margin-top: 1em">If in doubt,
break the expression into simpler terms, or cast all
operands to the desired resulting type.</p>
<p style="margin-left:14%; margin-top: 1em">Scalar values
are a bit different, since:</p>
<p style="margin-left:14%; margin-top: 1em">$float = 2 +
$mbf; <br/>
$float = $mbf + 2;</p>
<p style="margin-left:14%; margin-top: 1em">both result in
the proper type due to the way the overloaded math
works.</p>
<p style="margin-left:14%; margin-top: 1em">This section
also applies to other overloaded math packages, like
Math::String.</p>
<p style="margin-left:14%; margin-top: 1em">One solution to
you problem might be autoupgrading|upgrading. See the
pragmas bignum, bigint and bigrat for an easy way to do
this.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Please report
any bugs or feature requests to
"bug−math−bigint at rt.cpan.org", or
through the web interface at
&lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math−BigInt&gt;
(requires login). We will be notified, and then you'll
automatically be notified of progress on your bug as I make
changes.</p>
<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">You can find
documentation for this module with the perldoc command.</p>
<p style="margin-left:9%; margin-top: 1em">perldoc
Math::BigInt</p>
<p style="margin-left:9%; margin-top: 1em">You can also
look for information at:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="8%">
<p>GitHub</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">&lt;https://github.com/pjacklam/p5−Math−BigInt&gt;</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="33%">
<p style="margin-top: 1em">RT: CPAN's request tracker</p></td>
<td width="53%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">&lt;https://rt.cpan.org/Dist/Display.html?Name=Math−BigInt&gt;</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="10%">
<p style="margin-top: 1em">MetaCPAN</p></td>
<td width="76%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">&lt;https://metacpan.org/release/Math−BigInt&gt;</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="24%">
<p style="margin-top: 1em">CPAN Testers Matrix</p></td>
<td width="62%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">&lt;http://matrix.cpantesters.org/?dist=Math−BigInt&gt;</p>
<h2>LICENSE
<a name="LICENSE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This program is
free software; you may redistribute it and/or modify it
under the same terms as Perl itself.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Math::BigFloat
and Math::BigRat as well as the backend libraries
Math::BigInt::FastCalc, Math::BigInt::GMP, and
Math::BigInt::Pari, Math::BigInt::GMPz, and
Math::BigInt::BitVect.</p>
<p style="margin-left:9%; margin-top: 1em">The pragmas
bigint, bigfloat, and bigrat might also be of interest. In
addition there is the bignum pragma which does upgrading and
downgrading.</p>
<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="83%">
<p style="margin-top: 1em">Mark Biggar, overloaded
interface by Ilya Zakharevich, 1996−2001.</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="83%">
<p>Completely rewritten by Tels
&lt;http://bloodgate.com&gt;, 2001−2008.</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="83%">
<p>Florian Ragwitz &lt;flora@cpan.org&gt;, 2010.</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="83%">
<p>Peter John Acklam &lt;pjacklam@gmail.com&gt;,
2011−.</p> </td>
<td width="3%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Many people
contributed in one or more ways to the final beast, see the
file CREDITS for an (incomplete) list. If you miss your
name, please drop me a mail. Thank you!</p>
<hr/>
</body>
</html>
