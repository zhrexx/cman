<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:41:05 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DES_RANDOM_KEY</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">DES_RANDOM_KEY</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">DES_random_key,
DES_set_key, DES_key_sched, DES_set_key_checked,
DES_set_key_unchecked, DES_set_odd_parity, DES_is_weak_key,
DES_ecb_encrypt, DES_ecb2_encrypt, DES_ecb3_encrypt,
DES_ncbc_encrypt, DES_cfb_encrypt, DES_ofb_encrypt,
DES_pcbc_encrypt, DES_cfb64_encrypt, DES_ofb64_encrypt,
DES_xcbc_encrypt, DES_ede2_cbc_encrypt,
DES_ede2_cfb64_encrypt, DES_ede2_ofb64_encrypt,
DES_ede3_cbc_encrypt, DES_ede3_cfb64_encrypt,
DES_ede3_ofb64_encrypt, DES_cbc_cksum, DES_quad_cksum,
DES_string_to_key, DES_string_to_2keys, DES_fcrypt,
DES_crypt − DES encryption</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/des.h&gt;</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining <b>OPENSSL_API_COMPAT</b> with a
suitable version value, see
<b>openssl_user_macros</b>(7):</p>
<p style="margin-left:9%; margin-top: 1em">void
DES_random_key(DES_cblock *ret); <br/>
int DES_set_key(const_DES_cblock *key, DES_key_schedule
*schedule); <br/>
int DES_key_sched(const_DES_cblock *key, DES_key_schedule
*schedule); <br/>
int DES_set_key_checked(const_DES_cblock *key,
DES_key_schedule *schedule); <br/>
void DES_set_key_unchecked(const_DES_cblock *key,
DES_key_schedule *schedule); <br/>
void DES_set_odd_parity(DES_cblock *key); <br/>
int DES_is_weak_key(const_DES_cblock *key); <br/>
void DES_ecb_encrypt(const_DES_cblock *input, DES_cblock
*output, <br/>
DES_key_schedule *ks, int enc); <br/>
void DES_ecb2_encrypt(const_DES_cblock *input, DES_cblock
*output, <br/>
DES_key_schedule *ks1, DES_key_schedule *ks2, int enc); <br/>
void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock
*output, <br/>
DES_key_schedule *ks1, DES_key_schedule *ks2, <br/>
DES_key_schedule *ks3, int enc); <br/>
void DES_ncbc_encrypt(const unsigned char *input, unsigned
char *output, <br/>
long length, DES_key_schedule *schedule, DES_cblock *ivec,
<br/>
int enc); <br/>
void DES_cfb_encrypt(const unsigned char *in, unsigned char
*out, <br/>
int numbits, long length, DES_key_schedule *schedule, <br/>
DES_cblock *ivec, int enc); <br/>
void DES_ofb_encrypt(const unsigned char *in, unsigned char
*out, <br/>
int numbits, long length, DES_key_schedule *schedule, <br/>
DES_cblock *ivec); <br/>
void DES_pcbc_encrypt(const unsigned char *input, unsigned
char *output, <br/>
long length, DES_key_schedule *schedule, DES_cblock *ivec,
<br/>
int enc); <br/>
void DES_cfb64_encrypt(const unsigned char *in, unsigned
char *out, <br/>
long length, DES_key_schedule *schedule, DES_cblock *ivec,
<br/>
int *num, int enc); <br/>
void DES_ofb64_encrypt(const unsigned char *in, unsigned
char *out, <br/>
long length, DES_key_schedule *schedule, DES_cblock *ivec,
<br/>
int *num); <br/>
void DES_xcbc_encrypt(const unsigned char *input, unsigned
char *output, <br/>
long length, DES_key_schedule *schedule, DES_cblock *ivec,
<br/>
const_DES_cblock *inw, const_DES_cblock *outw, int enc);
<br/>
void DES_ede2_cbc_encrypt(const unsigned char *input,
unsigned char *output, <br/>
long length, DES_key_schedule *ks1, <br/>
DES_key_schedule *ks2, DES_cblock *ivec, int enc); <br/>
void DES_ede2_cfb64_encrypt(const unsigned char *in,
unsigned char *out, <br/>
long length, DES_key_schedule *ks1, <br/>
DES_key_schedule *ks2, DES_cblock *ivec, <br/>
int *num, int enc); <br/>
void DES_ede2_ofb64_encrypt(const unsigned char *in,
unsigned char *out, <br/>
long length, DES_key_schedule *ks1, <br/>
DES_key_schedule *ks2, DES_cblock *ivec, int *num); <br/>
void DES_ede3_cbc_encrypt(const unsigned char *input,
unsigned char *output, <br/>
long length, DES_key_schedule *ks1, <br/>
DES_key_schedule *ks2, DES_key_schedule *ks3, <br/>
DES_cblock *ivec, int enc); <br/>
void DES_ede3_cfb64_encrypt(const unsigned char *in,
unsigned char *out, <br/>
long length, DES_key_schedule *ks1, <br/>
DES_key_schedule *ks2, DES_key_schedule *ks3, <br/>
DES_cblock *ivec, int *num, int enc); <br/>
void DES_ede3_ofb64_encrypt(const unsigned char *in,
unsigned char *out, <br/>
long length, DES_key_schedule *ks1, <br/>
DES_key_schedule *ks2, DES_key_schedule *ks3, <br/>
DES_cblock *ivec, int *num); <br/>
DES_LONG DES_cbc_cksum(const unsigned char *input,
DES_cblock *output, <br/>
long length, DES_key_schedule *schedule, <br/>
const_DES_cblock *ivec); <br/>
DES_LONG DES_quad_cksum(const unsigned char *input,
DES_cblock output[], <br/>
long length, int out_count, DES_cblock *seed); <br/>
void DES_string_to_key(const char *str, DES_cblock *key);
<br/>
void DES_string_to_2keys(const char *str, DES_cblock *key1,
DES_cblock *key2); <br/>
char *DES_fcrypt(const char *buf, const char *salt, char
*ret); <br/>
char *DES_crypt(const char *buf, const char *salt);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All of the
functions described on this page are deprecated.
Applications should instead use
<b>EVP_EncryptInit_ex</b>(3), <b>EVP_EncryptUpdate</b>(3)
and <b>EVP_EncryptFinal_ex</b>(3) or the equivalently named
decrypt functions.</p>
<p style="margin-left:9%; margin-top: 1em">This library
contains a fast implementation of the DES encryption
algorithm.</p>
<p style="margin-left:9%; margin-top: 1em">There are two
phases to the use of DES encryption. The first is the
generation of a <i>DES_key_schedule</i> from a key, the
second is the actual encryption. A DES key is of type
<i>DES_cblock</i>. This type consists of 8 bytes with odd
parity. The least significant bit in each byte is the parity
bit. The key schedule is an expanded form of the key; it is
used to speed the encryption process.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_random_key()</b>
generates a random key. The random generator must be seeded
when calling this function. If the automatic seeding or
reseeding of the OpenSSL CSPRNG fails due to external
circumstances (see <b>RAND</b>(7)), the operation will fail.
If the function fails, 0 is returned.</p>
<p style="margin-left:9%; margin-top: 1em">Before a DES key
can be used, it must be converted into the architecture
dependent <i>DES_key_schedule</i> via the
<b>DES_set_key_checked()</b> or
<b>DES_set_key_unchecked()</b> function.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_set_key_checked()</b>
will check that the key passed is of odd parity and is not a
weak or semi−weak key. If the parity is wrong, then
−1 is returned. If the key is a weak key, then
−2 is returned. If an error is returned, the key
schedule is not generated.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_set_key()</b>
works like <b>DES_set_key_checked()</b> and remains for
backward compatibility.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_set_odd_parity()</b>
sets the parity of the passed <i>key</i> to odd.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_is_weak_key()</b>
returns 1 if the passed key is a weak key, 0 if it is
ok.</p>
<p style="margin-left:9%; margin-top: 1em">The following
routines mostly operate on an input and output stream of
<i>DES_cblock</i>s.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ecb_encrypt()</b>
is the basic DES encryption routine that encrypts or
decrypts a single 8−byte <i>DES_cblock</i> in
<i>electronic code book</i> (ECB) mode. It always transforms
the input data, pointed to by <i>input</i>, into the output
data, pointed to by the <i>output</i> argument. If the
<i>encrypt</i> argument is nonzero (DES_ENCRYPT), the
<i>input</i> (cleartext) is encrypted in to the
<i>output</i> (ciphertext) using the key_schedule specified
by the <i>schedule</i> argument, previously set via
<i>DES_set_key</i>. If <i>encrypt</i> is zero (DES_DECRYPT),
the <i>input</i> (now ciphertext) is decrypted into the
<i>output</i> (now cleartext). Input and output may overlap.
<b>DES_ecb_encrypt()</b> does not return a value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ecb3_encrypt()</b>
encrypts/decrypts the <i>input</i> block by using
three−key Triple−DES encryption in ECB mode.
This involves encrypting the input with <i>ks1</i>,
decrypting with the key schedule <i>ks2</i>, and then
encrypting with <i>ks3</i>. This routine greatly reduces the
chances of brute force breaking of DES and has the advantage
of if <i>ks1</i>, <i>ks2</i> and <i>ks3</i> are the same, it
is equivalent to just encryption using ECB mode and
<i>ks1</i> as the key.</p>
<p style="margin-left:9%; margin-top: 1em">The macro
<b>DES_ecb2_encrypt()</b> is provided to perform
two−key Triple−DES encryption by using
<i>ks1</i> for the final encryption.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ncbc_encrypt()</b>
encrypts/decrypts using the
<i>cipher−block−chaining</i> (CBC) mode of DES.
If the <i>encrypt</i> argument is nonzero, the routine
cipher−block−chain encrypts the cleartext data
pointed to by the <i>input</i> argument into the ciphertext
pointed to by the <i>output</i> argument, using the key
schedule provided by the <i>schedule</i> argument, and
initialization vector provided by the <i>ivec</i> argument.
If the <i>length</i> argument is not an integral multiple of
eight bytes, the last block is copied to a temporary area
and zero filled. The output is always an integral multiple
of eight bytes.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_xcbc_encrypt()</b>
is RSA's DESX mode of DES. It uses <i>inw</i> and
<i>outw</i> to 'whiten' the encryption. <i>inw</i> and
<i>outw</i> are secret (unlike the iv) and are as such, part
of the key. So the key is sort of 24 bytes. This is much
better than CBC DES.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ede3_cbc_encrypt()</b>
implements outer triple CBC DES encryption with three keys.
This means that each DES operation inside the CBC mode is
"C=E(ks3,D(ks2,E(ks1,M)))". This mode is used by
SSL.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>DES_ede2_cbc_encrypt()</b> macro implements two−key
Triple−DES by reusing <i>ks1</i> for the final
encryption. "C=E(ks1,D(ks2,E(ks1,M)))". This form
of Triple−DES is used by the RSAREF library.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_pcbc_encrypt()</b>
encrypts/decrypts using the propagating cipher block
chaining mode used by Kerberos v4. Its parameters are the
same as <b>DES_ncbc_encrypt()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_cfb_encrypt()</b>
encrypts/decrypts using cipher feedback mode. This method
takes an array of characters as input and outputs an array
of characters. It does not require any padding to 8
character groups. Note: the <i>ivec</i> variable is changed
and the new changed value needs to be passed to the next
call to this function. Since this function runs a complete
DES ECB encryption per <i>numbits</i>, this function is only
suggested for use when sending a small number of
characters.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_cfb64_encrypt()</b>
implements CFB mode of DES with 64−bit feedback. Why
is this useful you ask? Because this routine will allow you
to encrypt an arbitrary number of bytes, without 8 byte
padding. Each call to this routine will encrypt the input
bytes to output and then update ivec and num. num contains
'how far' we are though ivec. If this does not make much
sense, read more about CFB mode of DES.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ede3_cfb64_encrypt()</b>
and <b>DES_ede2_cfb64_encrypt()</b> is the same as
<b>DES_cfb64_encrypt()</b> except that Triple−DES is
used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ofb_encrypt()</b>
encrypts using output feedback mode. This method takes an
array of characters as input and outputs an array of
characters. It does not require any padding to 8 character
groups. Note: the <i>ivec</i> variable is changed and the
new changed value needs to be passed to the next call to
this function. Since this function runs a complete DES ECB
encryption per <i>numbits</i>, this function is only
suggested for use when sending a small number of
characters.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ofb64_encrypt()</b>
is the same as <b>DES_cfb64_encrypt()</b> using Output Feed
Back mode.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_ede3_ofb64_encrypt()</b>
and <b>DES_ede2_ofb64_encrypt()</b> is the same as
<b>DES_ofb64_encrypt()</b>, using Triple−DES.</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions are included in the DES library for compatibility
with the MIT Kerberos library.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_cbc_cksum()</b>
produces an 8 byte checksum based on the input stream (via
CBC encryption). The last 4 bytes of the checksum are
returned and the complete 8 bytes are placed in
<i>output</i>. This function is used by Kerberos v4. Other
applications should use <b>EVP_DigestInit</b>(3) etc.
instead.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_quad_cksum()</b>
is a Kerberos v4 function. It returns a 4 byte checksum from
the input bytes. The algorithm can be iterated over the
input, depending on <i>out_count</i>, 1, 2, 3 or 4 times. If
<i>output</i> is non−NULL, the 8 bytes generated by
each pass are written into <i>output</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The following
are DES−based transformations:</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_fcrypt()</b>
is a fast version of the Unix <b>crypt</b>(3) function. This
version takes only a small amount of space relative to other
fast <b>crypt()</b> implementations. This is different to
the normal <b>crypt()</b> in that the third parameter is the
buffer that the return value is written into. It needs to be
at least 14 bytes long. This function is thread safe, unlike
the normal <b>crypt()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_crypt()</b>
is a faster replacement for the normal system
<b>crypt()</b>. This function calls <b>DES_fcrypt()</b> with
a static array passed as the third parameter. This mostly
emulates the normal non−thread−safe semantics of
<b>crypt</b>(3). The <b>salt</b> must be two ASCII
characters.</p>
<p style="margin-left:9%; margin-top: 1em">The values
returned by <b>DES_fcrypt()</b> and <b>DES_crypt()</b> are
terminated by NUL character.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_enc_write()</b>
writes <i>len</i> bytes to file descriptor <i>fd</i> from
buffer <i>buf</i>. The data is encrypted via
<i>pcbc_encrypt</i> (default) using <i>sched</i> for the key
and <i>iv</i> as a starting vector. The actual data send
down <i>fd</i> consists of 4 bytes (in network byte order)
containing the length of the following encrypted data. The
encrypted data then follows, padded with random data out to
a multiple of 8 bytes.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>DES_cbc_encrypt()</b>
does not modify <b>ivec</b>; use <b>DES_ncbc_encrypt()</b>
instead.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_cfb_encrypt()</b>
and <b>DES_ofb_encrypt()</b> operates on input of 8 bits.
What this means is that if you set numbits to 12, and length
to 2, the first 12 bits will come from the 1st input byte
and the low half of the second input byte. The second 12
bits will have the low 8 bits taken from the 3rd input byte
and the top 4 bits taken from the 4th input byte. The same
holds for output. This function has been implemented this
way because most people will be using a multiple of 8 and
because once you get into pulling bytes input bytes apart
things get ugly!</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_string_to_key()</b>
is available for backward compatibility with the MIT
library. New applications should use a cryptographic hash
function. The same applies for
<b>DES_string_to_2key()</b>.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The <b>des</b>
library was written to be source code compatible with the
MIT Kerberos library.</p>
<p style="margin-left:9%; margin-top: 1em">Applications
should use the higher level functions
<b>EVP_EncryptInit</b>(3) etc. instead of calling these
functions directly.</p>
<p style="margin-left:9%; margin-top: 1em">Single−key
DES is insecure due to its short key size. ECB mode is not
suitable for most applications; see <b>des_modes</b>(7).</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>DES_set_key()</b>,
<b>DES_key_sched()</b>, and <b>DES_set_key_checked()</b>
return 0 on success or negative values on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_is_weak_key()</b>
returns 1 if the passed key is a weak key, 0 if it is
ok.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_cbc_cksum()</b>
and <b>DES_quad_cksum()</b> return 4−byte integer
representing the last 4 bytes of the checksum of the
input.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DES_fcrypt()</b>
returns a pointer to the caller−provided buffer and
<b>DES_crypt()</b> − to a static buffer on success;
otherwise they return NULL.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>des_modes</b>(7),
<b>EVP_EncryptInit</b>(3)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All of these
functions were deprecated in OpenSSL 3.0.</p>
<p style="margin-left:9%; margin-top: 1em">The requirement
that the <b>salt</b> parameter to <b>DES_crypt()</b> and
<b>DES_fcrypt()</b> be two ASCII characters was first
enforced in OpenSSL 1.1.0. Previous versions tried to use
the letter uppercase <b>A</b> if both character were not
present, and could crash when given non−ASCII on some
platforms.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2000−2020 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
