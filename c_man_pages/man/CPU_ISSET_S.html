<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:40:23 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CPU_SET</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">CPU_SET</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Dynamically sized CPU sets">Dynamically sized CPU sets</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">CPU_SET,
CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR,
CPU_XOR, CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE,
CPU_SET_S, CPU_CLR_S, CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S,
CPU_AND_S, CPU_OR_S, CPU_XOR_S, CPU_EQUAL_S − macros
for manipulating CPU sets</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#define
_GNU_SOURCE</b> /* See feature_test_macros(7) */ <b><br/>
#include &lt;sched.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
CPU_ZERO(cpu_set_t *</b><i>set</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
CPU_SET(int</b> <i>cpu</i><b>, cpu_set_t
*</b><i>set</i><b>); <br/>
void CPU_CLR(int</b> <i>cpu</i><b>, cpu_set_t
*</b><i>set</i><b>); <br/>
int CPU_ISSET(int</b> <i>cpu</i><b>, cpu_set_t
*</b><i>set</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
CPU_COUNT(cpu_set_t *</b><i>set</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
CPU_AND(cpu_set_t *</b><i>destset</i><b>, <br/>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br/>
void CPU_OR(cpu_set_t *</b><i>destset</i><b>, <br/>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br/>
void CPU_XOR(cpu_set_t *</b><i>destset</i><b>, <br/>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
CPU_EQUAL(cpu_set_t *</b><i>set1</i><b>, cpu_set_t
*</b><i>set2</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>cpu_set_t
*CPU_ALLOC(int</b> <i>num_cpus</i><b>); <br/>
void CPU_FREE(cpu_set_t *</b><i>set</i><b>); <br/>
size_t CPU_ALLOC_SIZE(int</b> <i>num_cpus</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
CPU_ZERO_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>set</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
CPU_SET_S(int</b> <i>cpu</i><b>, size_t</b>
<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>); <br/>
void CPU_CLR_S(int</b> <i>cpu</i><b>, size_t</b>
<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>); <br/>
int CPU_ISSET_S(int</b> <i>cpu</i><b>, size_t</b>
<i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
CPU_COUNT_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>set</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>void
CPU_AND_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>destset</i><b>, <br/>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br/>
void CPU_OR_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>destset</i><b>, <br/>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>); <br/>
void CPU_XOR_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>destset</i><b>, <br/>
cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t
*</b><i>srcset2</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
CPU_EQUAL_S(size_t</b> <i>setsize</i><b>, cpu_set_t
*</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<i>cpu_set_t</i> data structure represents a set of CPUs.
CPU sets are used by <b>sched_setaffinity</b>(2) and similar
interfaces.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>cpu_set_t</i> data type is implemented as a bit mask.
However, the data structure should be treated as opaque: all
manipulation of CPU sets should be done via the macros
described in this page.</p>
<p style="margin-left:9%; margin-top: 1em">The following
macros are provided to operate on the CPU set <i>set</i>:
<b><br/>
CPU_ZERO</b>()</p>
<p style="margin-left:18%;">Clears <i>set</i>, so that it
contains no CPUs.</p>
<p style="margin-left:9%;"><b>CPU_SET</b>()</p>
<p style="margin-left:18%;">Add CPU <i>cpu</i> to
<i>set</i>.</p>
<p style="margin-left:9%;"><b>CPU_CLR</b>()</p>
<p style="margin-left:18%;">Remove CPU <i>cpu</i> from
<i>set</i>.</p>
<p style="margin-left:9%;"><b>CPU_ISSET</b>()</p>
<p style="margin-left:18%;">Test to see if CPU <i>cpu</i>
is a member of <i>set</i>.</p>
<p style="margin-left:9%;"><b>CPU_COUNT</b>()</p>
<p style="margin-left:18%;">Return the number of CPUs in
<i>set</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Where a
<i>cpu</i> argument is specified, it should not produce side
effects, since the above macros may evaluate the argument
more than once.</p>
<p style="margin-left:9%; margin-top: 1em">The first CPU on
the system corresponds to a <i>cpu</i> value of 0, the next
CPU corresponds to a <i>cpu</i> value of 1, and so on. No
assumptions should be made about particular CPUs being
available, or the set of CPUs being contiguous, since CPUs
can be taken offline dynamically or be otherwise absent. The
constant <b>CPU_SETSIZE</b> (currently 1024) specifies a
value one greater than the maximum CPU number that can be
stored in <i>cpu_set_t</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The following
macros perform logical operations on CPU sets: <b><br/>
CPU_AND</b>()</p>
<p style="margin-left:18%;">Store the intersection of the
sets <i>srcset1</i> and <i>srcset2</i> in <i>destset</i>
(which may be one of the source sets).</p>
<p style="margin-left:9%;"><b>CPU_OR</b>()</p>
<p style="margin-left:18%;">Store the union of the sets
<i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which
may be one of the source sets).</p>
<p style="margin-left:9%;"><b>CPU_XOR</b>()</p>
<p style="margin-left:18%;">Store the XOR of the sets
<i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which
may be one of the source sets). The XOR means the set of
CPUs that are in either <i>srcset1</i> or <i>srcset2</i>,
but not both.</p>
<p style="margin-left:9%;"><b>CPU_EQUAL</b>()</p>
<p style="margin-left:18%;">Test whether two CPU set
contain exactly the same CPUs.</p>
<h3>Dynamically sized CPU sets
<a name="Dynamically sized CPU sets"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Because some
applications may require the ability to dynamically size CPU
sets (e.g., to allocate sets larger than that defined by the
standard <i>cpu_set_t</i> data type), glibc nowadays
provides a set of macros to support this.</p>
<p style="margin-left:9%; margin-top: 1em">The following
macros are used to allocate and deallocate CPU sets: <b><br/>
CPU_ALLOC</b>()</p>
<p style="margin-left:18%;">Allocate a CPU set large enough
to hold CPUs in the range 0 to <i>num_cpus−1</i>.</p>
<p style="margin-left:9%;"><b>CPU_ALLOC_SIZE</b>()</p>
<p style="margin-left:18%;">Return the size in bytes of the
CPU set that would be needed to hold CPUs in the range 0 to
<i>num_cpus−1</i>. This macro provides the value that
can be used for the <i>setsize</i> argument in the
<b>CPU_*_S</b>() macros described below.</p>
<p style="margin-left:9%;"><b>CPU_FREE</b>()</p>
<p style="margin-left:18%;">Free a CPU set previously
allocated by <b>CPU_ALLOC</b>().</p>
<p style="margin-left:9%; margin-top: 1em">The macros whose
names end with "_S" are the analogs of the
similarly named macros without the suffix. These macros
perform the same tasks as their analogs, but operate on the
dynamically allocated CPU set(s) whose size is
<i>setsize</i> bytes.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_ISSET</b>()
and <b>CPU_ISSET_S</b>() return nonzero if <i>cpu</i> is in
<i>set</i>; otherwise, it returns 0.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_COUNT</b>()
and <b>CPU_COUNT_S</b>() return the number of CPUs in
<i>set</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_EQUAL</b>()
and <b>CPU_EQUAL_S</b>() return nonzero if the two CPU sets
are equal; otherwise they return 0.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_ALLOC</b>()
returns a pointer on success, or NULL on failure. (Errors
are as for <b>malloc</b>(3).)</p>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_ALLOC_SIZE</b>()
returns the number of bytes required to store a CPU set of
the specified cardinality.</p>
<p style="margin-left:9%; margin-top: 1em">The other
functions do not return a value.</p>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>CPU_ZERO</b>(), <b>CPU_SET</b>(), <b>CPU_CLR</b>(), and
<b>CPU_ISSET</b>() macros were added in glibc 2.3.3.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_COUNT</b>()
first appeared in glibc 2.6.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CPU_AND</b>(),
<b>CPU_OR</b>(), <b>CPU_XOR</b>(), <b>CPU_EQUAL</b>(),
<b>CPU_ALLOC</b>(), <b>CPU_ALLOC_SIZE</b>(),
<b>CPU_FREE</b>(), <b>CPU_ZERO_S</b>(), <b>CPU_SET_S</b>(),
<b>CPU_CLR_S</b>(), <b>CPU_ISSET_S</b>(),
<b>CPU_AND_S</b>(), <b>CPU_OR_S</b>(), <b>CPU_XOR_S</b>(),
and <b>CPU_EQUAL_S</b>() first appeared in glibc 2.7.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To duplicate a
CPU set, use <b>memcpy</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">Since CPU sets
are bit masks allocated in units of long words, the actual
number of CPUs in a dynamically allocated CPU set will be
rounded up to the next multiple of <i>sizeof(unsigned
long)</i>. An application should consider the contents of
these extra bits to be undefined.</p>
<p style="margin-left:9%; margin-top: 1em">Notwithstanding
the similarity in the names, note that the constant
<b>CPU_SETSIZE</b> indicates the number of CPUs in the
<i>cpu_set_t</i> data type (thus, it is effectively a count
of the bits in the bit mask), while the <i>setsize</i>
argument of the <b>CPU_*_S</b>() macros is a size in
bytes.</p>
<p style="margin-left:9%; margin-top: 1em">The data types
for arguments and return values shown in the SYNOPSIS are
hints what about is expected in each case. However, since
these interfaces are implemented as macros, the compiler
won’t necessarily catch all type errors if you violate
the suggestions.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On 32-bit
platforms with glibc 2.8 and earlier, <b>CPU_ALLOC</b>()
allocates twice as much space as is required, and
<b>CPU_ALLOC_SIZE</b>() returns a value twice as large as it
should. This bug should not affect the semantics of a
program, but does result in wasted memory and less efficient
operation of the macros that operate on dynamically
allocated CPU sets. These bugs are fixed in glibc 2.9.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
program demonstrates the use of some of the macros used for
dynamically allocated CPU sets.</p>
<p style="margin-left:9%; margin-top: 1em">#define
_GNU_SOURCE <br/>
#include &lt;sched.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;unistd.h&gt; <br/>
#include &lt;assert.h&gt; <br/>
int <br/>
main(int argc, char *argv[]) <br/>
{ <br/>
cpu_set_t *cpusetp; <br/>
size_t size, num_cpus; <br/>
if (argc &lt; 2) { <br/>
fprintf(stderr, "Usage: %s
&lt;num−cpus&gt;\n", argv[0]); <br/>
exit(EXIT_FAILURE); <br/>
} <br/>
num_cpus = atoi(argv[1]); <br/>
cpusetp = CPU_ALLOC(num_cpus); <br/>
if (cpusetp == NULL) { <br/>
perror("CPU_ALLOC"); <br/>
exit(EXIT_FAILURE); <br/>
} <br/>
size = CPU_ALLOC_SIZE(num_cpus); <br/>
CPU_ZERO_S(size, cpusetp); <br/>
for (size_t cpu = 0; cpu &lt; num_cpus; cpu += 2) <br/>
CPU_SET_S(cpu, size, cpusetp); <br/>
printf("CPU_COUNT() of set: %d\n",
CPU_COUNT_S(size, cpusetp)); <br/>
CPU_FREE(cpusetp); <br/>
exit(EXIT_SUCCESS); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>sched_setaffinity</b>(2),
<b>pthread_attr_setaffinity_np</b>(3),
<b>pthread_setaffinity_np</b>(3), <b>cpuset</b>(7)</p>
<hr/>
</body>
</html>
