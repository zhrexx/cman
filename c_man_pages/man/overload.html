<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:47:23 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>overload</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">overload</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Fundamentals">Fundamentals</a><br/>
<a href="#Overloadable Operations">Overloadable Operations</a><br/>
<a href="#Magic Autogeneration">Magic Autogeneration</a><br/>
<a href='#Special Keys for "use overload"'>Special Keys for "use overload"</a><br/>
<a href="#How Perl Chooses an Operator Implementation">How Perl Chooses an Operator Implementation</a><br/>
<a href="#Losing Overloading">Losing Overloading</a><br/>
<a href="#Inheritance and Overloading">Inheritance and Overloading</a><br/>
<a href="#Run-time Overloading">Run-time Overloading</a><br/>
<a href="#Public Functions">Public Functions</a><br/>
<a href="#Overloading Constants">Overloading Constants</a><br/>
<a href="#IMPLEMENTATION">IMPLEMENTATION</a><br/>
<a href="#COOKBOOK">COOKBOOK</a><br/>
<a href="#Two-face Scalars">Two-face Scalars</a><br/>
<a href="#Two-face References">Two-face References</a><br/>
<a href="#Symbolic Calculator">Symbolic Calculator</a><br/>
<a href="#Really Symbolic Calculator">Really Symbolic Calculator</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br/>
<a href="#BUGS AND PITFALLS">BUGS AND PITFALLS</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">overload −
Package for overloading Perl operations</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">package
SomeThing; <br/>
use overload <br/>
'+' =&gt; \&amp;myadd, <br/>
'−' =&gt; \&amp;mysub; <br/>
# etc <br/>
... <br/>
package main; <br/>
$a = SomeThing−&gt;new( 57 ); <br/>
$b = 5 + $a; <br/>
... <br/>
if (overload::Overloaded $b) {...} <br/>
... <br/>
$strval = overload::StrVal $b;</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This pragma
allows overloading of Perl’s operators for a class. To
overload built-in functions, see "Overriding Built-in
Functions" in perlsub instead.</p>
<h3>Fundamentals
<a name="Fundamentals"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><i>Declaration</i></p>
<p style="margin-left:9%; margin-top: 1em">Arguments of the
"use overload" directive are (key, value) pairs.
For the full set of legal keys, see "Overloadable
Operations" below.</p>
<p style="margin-left:9%; margin-top: 1em">Operator
implementations (the values) can be subroutines, references
to subroutines, or anonymous subroutines − in other
words, anything legal inside a "&amp;{ ... }"
call. Values specified as strings are interpreted as method
names. Thus</p>
<p style="margin-left:9%; margin-top: 1em">package Number;
<br/>
use overload <br/>
"−" =&gt; "minus", <br/>
"*=" =&gt; \&amp;muas, <br/>
'""' =&gt; sub { ...; };</p>
<p style="margin-left:9%; margin-top: 1em">declares that
subtraction is to be implemented by method minus() in the
class "Number" (or one of its base classes), and
that the function Number::muas() is to be used for the
assignment form of multiplication, "*=". It also
defines an anonymous subroutine to implement
stringification: this is called whenever an object blessed
into the package "Number" is used in a string
context (this subroutine might, for example, return the
number as a Roman numeral).</p>
<p style="margin-left:9%; margin-top: 1em"><i>Calling
Conventions and Magic Autogeneration</i></p>
<p style="margin-left:9%; margin-top: 1em">The following
sample implementation of minus() (which assumes that
"Number" objects are simply blessed references to
scalars) illustrates the calling conventions:</p>
<p style="margin-left:9%; margin-top: 1em">package Number;
<br/>
sub minus { <br/>
my ($self, $other, $swap) = @_; <br/>
my $result = $$self − $other; # * <br/>
$result = −$result if $swap; <br/>
ref $result ? $result : bless \$result; <br/>
} <br/>
# * may recurse once − see table below</p>
<p style="margin-left:9%; margin-top: 1em">Three arguments
are passed to all subroutines specified in the "use
overload" directive (with exceptions − see below,
particularly "nomethod").</p>
<p style="margin-left:9%; margin-top: 1em">The first of
these is the operand providing the overloaded operator
implementation − in this case, the object whose
minus() method is being called.</p>
<p style="margin-left:9%; margin-top: 1em">The second
argument is the other operand, or "undef" in the
case of a unary operator.</p>
<p style="margin-left:9%; margin-top: 1em">The third
argument is set to TRUE if (and only if) the two operands
have been swapped. Perl may do this to ensure that the first
argument ($self) is an object implementing the overloaded
operation, in line with general object calling conventions.
For example, if $x and $y are "Number"s:</p>
<p style="margin-left:9%; margin-top: 1em">operation |
generates a call to <br/>
============|====================== <br/>
$x − $y | minus($x, $y, '') <br/>
$x − 7 | minus($x, 7, '') <br/>
7 − $x | minus($x, 7, 1)</p>
<p style="margin-left:9%; margin-top: 1em">Perl may also
use minus() to implement other operators which have not been
specified in the "use overload" directive,
according to the rules for "Magic Autogeneration"
described later. For example, the "use overload"
above declared no subroutine for any of the operators
"−−", "neg" (the overload
key for unary minus), or "−=". Thus</p>
<p style="margin-left:9%; margin-top: 1em">operation |
generates a call to <br/>
============|====================== <br/>
−$x | minus($x, 0, 1) <br/>
$x−− | minus($x, 1, undef) <br/>
$x −= 3 | minus($x, 3, undef)</p>
<p style="margin-left:9%; margin-top: 1em">Note the
"undef"s: where autogeneration results in the
method for a standard operator which does not change either
of its operands, such as "−", being used to
implement an operator which changes the operand
("mutators": here, "−−" and
"−="), Perl passes undef as the third
argument. This still evaluates as FALSE, consistent with the
fact that the operands have not been swapped, but gives the
subroutine a chance to alter its behaviour in these
cases.</p>
<p style="margin-left:9%; margin-top: 1em">In all the above
examples, minus() is required only to return the result of
the subtraction: Perl takes care of the assignment to $x. In
fact, such methods should <i>not</i> modify their operands,
even if "undef" is passed as the third argument
(see "Overloadable Operations").</p>
<p style="margin-left:9%; margin-top: 1em">The same is not
true of implementations of "++" and
"−−": these are expected to modify
their operand. An appropriate implementation of
"−−" might look like</p>
<p style="margin-left:9%; margin-top: 1em">use overload
'−−' =&gt; "decr", <br/>
# ... <br/>
sub decr { −−${$_[0]}; }</p>
<p style="margin-left:9%; margin-top: 1em">If the
"bitwise" feature is enabled (see feature), a
fifth TRUE argument is passed to subroutines handling
"&amp;", "|", "ˆ" and
"˜". This indicates that the caller is
expecting numeric behaviour. The fourth argument will be
"undef", as that position ($_[3]) is reserved for
use by "nomethod".</p>
<p style="margin-left:9%; margin-top: 1em"><i>Mathemagic,
Mutators, and Copy Constructors</i></p>
<p style="margin-left:9%; margin-top: 1em">The term
’mathemagic’ describes the overloaded
implementation of mathematical operators. Mathemagical
operations raise an issue. Consider the code:</p>
<p style="margin-left:9%; margin-top: 1em">$a = $b; <br/>
−−$a;</p>
<p style="margin-left:9%; margin-top: 1em">If $a and $b are
scalars then after these statements</p>
<p style="margin-left:9%; margin-top: 1em">$a == $b −
1</p>
<p style="margin-left:9%; margin-top: 1em">An object,
however, is a reference to blessed data, so if $a and $b are
objects then the assignment "$a = $b" copies only
the reference, leaving $a and $b referring to the same
object data. One might therefore expect the operation
"−−$a" to decrement $b as well as $a.
However, this would not be consistent with how we expect the
mathematical operators to work.</p>
<p style="margin-left:9%; margin-top: 1em">Perl resolves
this dilemma by transparently calling a copy constructor
before calling a method defined to implement a mutator
("−−", "+=", and so on.). In
the above example, when Perl reaches the decrement
statement, it makes a copy of the object data in $a and
assigns to $a a reference to the copied data. Only then does
it call decr(), which alters the copied data, leaving $b
unchanged. Thus the object metaphor is preserved as far as
possible, while mathemagical operations still work according
to the arithmetic metaphor.</p>
<p style="margin-left:9%; margin-top: 1em">Note: the
preceding paragraph describes what happens when Perl
autogenerates the copy constructor for an object based on a
scalar. For other cases, see "Copy
Constructor".</p>
<h3>Overloadable Operations
<a name="Overloadable Operations"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The complete
list of keys that can be specified in the "use
overload" directive are given, separated by spaces, in
the values of the hash %overload::ops:</p>
<p style="margin-left:9%; margin-top: 1em">with_assign
=&gt; '+ − * / % ** &lt;&lt; &gt;&gt; x .', <br/>
assign =&gt; '+= −= *= /= %= **= &lt;&lt;= &gt;&gt;=
x= .=', <br/>
num_comparison =&gt; '&lt; &lt;= &gt; &gt;= == !=', <br/>
'3way_comparison' =&gt; '&lt;=&gt; cmp', <br/>
str_comparison =&gt; 'lt le gt ge eq ne', <br/>
binary =&gt; '&amp; &amp;= | |= ˆ ˆ= &amp;.
&amp;.= |. |.= ˆ. ˆ.=', <br/>
unary =&gt; 'neg ! ˜ ˜.', <br/>
mutators =&gt; '++ −−', <br/>
func =&gt; 'atan2 cos sin exp abs log sqrt int', <br/>
conversion =&gt; 'bool "" 0+ qr', <br/>
iterators =&gt; '&lt;&gt;', <br/>
filetest =&gt; '−X', <br/>
dereferencing =&gt; '${} @{} %{} &amp;{} *{}', <br/>
matching =&gt; '˜˜', <br/>
special =&gt; 'nomethod fallback =',</p>
<p style="margin-left:9%; margin-top: 1em">Most of the
overloadable operators map one-to-one to these keys.
Exceptions, including additional overloadable operations not
apparent from this hash, are included in the notes which
follow. This list is subject to growth over time.</p>
<p style="margin-left:9%; margin-top: 1em">A warning is
issued if an attempt is made to register an operator not
found above.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="5%"></td>
<td width="7%">
<p>"not"</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">The operator
"not" is not a valid key for "use
overload". However, if the operator "!" is
overloaded then the same implementation will be used for
"not" (since the two operators differ only in
precedence).</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="7%">
<p style="margin-top: 1em">"neg"</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">The key
"neg" is used for unary minus to disambiguate it
from binary "−".</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="13%">
<p style="margin-top: 1em">"++",
"−−"</p> </td>
<td width="72%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">Assuming they
are to behave analogously to Perl’s "++" and
"−−", overloaded implementations of
these operators are required to mutate their operands.</p>
<p style="margin-left:15%; margin-top: 1em">No distinction
is made between prefix and postfix forms of the increment
and decrement operators: these differ only in the point at
which Perl calls the associated subroutine when evaluating
an expression.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="14%">
<p style="margin-top: 1em"><i>Assignments</i></p></td>
<td width="71%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">+= −= *=
/= %= **= &lt;&lt;= &gt;&gt;= x= .= <br/>
&amp;= |= ˆ= &amp;.= |.= ˆ.=</p>
<p style="margin-left:15%; margin-top: 1em">Simple
assignment is not overloadable (the '=' key is used for the
"Copy Constructor"). Perl does have a way to make
assignments to an object do whatever you want, but this
involves using <b>tie()</b>, not overload − see
"tie" in perlfunc and the "COOKBOOK"
examples below.</p>
<p style="margin-left:15%; margin-top: 1em">The subroutine
for the assignment variant of an operator is required only
to return the result of the operation. It is permitted to
change the value of its operand (this is safe because Perl
calls the copy constructor first), but this is optional
since Perl assigns the returned value to the left-hand
operand anyway.</p>
<p style="margin-left:15%; margin-top: 1em">An object that
overloads an assignment operator does so only in respect of
assignments to that object. In other words, Perl never calls
the corresponding methods with the third argument (the
"swap" argument) set to TRUE. For example, the
operation</p>
<p style="margin-left:15%; margin-top: 1em">$a *= $b</p>
<p style="margin-left:15%; margin-top: 1em">cannot lead to
$b’s implementation of "*=" being called,
even if $a is a scalar. (It can, however, generate a call to
$b’s method for "*").</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="45%">
<p style="margin-top: 1em"><i>Non-mutators with a mutator
variant</i></p> </td>
<td width="40%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">+ − * / %
** &lt;&lt; &gt;&gt; x . <br/>
&amp; | ˆ &amp;. |. ˆ.</p>
<p style="margin-left:15%; margin-top: 1em">As described
above, Perl may call methods for operators like
"+" and "&amp;" in the course of
implementing missing operations like "++",
"+=", and "&amp;=". While these methods
may detect this usage by testing the definedness of the
third argument, they should in all cases avoid changing
their operands. This is because Perl does not call the copy
constructor before invoking these methods.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="7%">
<p style="margin-top: 1em">"int"</p></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">Traditionally,
the Perl function "int" rounds to 0 (see
"int" in perlfunc), and so for floating-point-like
types one should follow the same semantic.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="62%">
<p style="margin-top: 1em"><i>String, numeric, boolean, and
regexp conversions</i></p></td>
<td width="23%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">"" 0+
bool</p>
<p style="margin-left:15%; margin-top: 1em">These
conversions are invoked according to context as necessary.
For example, the subroutine for '""' (stringify)
may be used where the overloaded object is passed as an
argument to "print", and that for 'bool' where it
is tested in the condition of a flow control statement (like
"while") or the ternary "?:"
operation.</p>
<p style="margin-left:15%; margin-top: 1em">Of course, in
contexts like, for example, "$obj + 1", Perl will
invoke $obj’s implementation of "+" rather
than (in this example) converting $obj to a number using the
numify method '0+' (an exception to this is when no method
has been provided for '+' and "fallback" is set to
TRUE).</p>
<p style="margin-left:15%; margin-top: 1em">The subroutines
for '""', '0+', and 'bool' can return any
arbitrary Perl value. If the corresponding operation for
this value is overloaded too, the operation will be called
again with this value.</p>
<p style="margin-left:15%; margin-top: 1em">As a special
case if the overload returns the object itself then it will
be used directly. An overloaded conversion returning the
object is probably a bug, because you’re likely to get
something that looks like
"YourPackage=HASH(0x8172b34)".</p>
<p style="margin-left:15%; margin-top: 1em">qr</p>
<p style="margin-left:15%; margin-top: 1em">The subroutine
for 'qr' is used wherever the object is interpolated into or
used as a regexp, including when it appears on the RHS of a
"=˜" or "!˜" operator.</p>
<p style="margin-left:15%; margin-top: 1em">"qr"
must return a compiled regexp, or a ref to a compiled regexp
(such as "qr//" returns), and any further
overloading on the return value will be ignored.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="12%">
<p style="margin-top: 1em"><i>Iteration</i></p></td>
<td width="73%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">If
"&lt;&gt;" is overloaded then the same
implementation is used for both the <i>read-filehandle</i>
syntax "&lt;$var&gt;" and <i>globbing</i> syntax
"&lt;${var}&gt;".</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="13%">
<p style="margin-top: 1em"><i>File tests</i></p></td>
<td width="72%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">The key
'−X' is used to specify a subroutine to handle all the
filetest operators ("−f",
"−x", and so on: see "−X" in
perlfunc for the full list); it is not possible to overload
any filetest operator individually. To distinguish them, the
letter following the ’−’ is passed as the
second argument (that is, in the slot that for binary
operators is used to pass the second operand).</p>
<p style="margin-left:15%; margin-top: 1em">Calling an
overloaded filetest operator does not affect the stat value
associated with the special filehandle "_". It
still refers to the result of the last "stat",
"lstat" or unoverloaded filetest.</p>
<p style="margin-left:15%; margin-top: 1em">This overload
was introduced in Perl 5.12.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="11%">
<p style="margin-top: 1em"><i>Matching</i></p></td>
<td width="74%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">The key
"˜˜" allows you to override the smart
matching logic used by the "˜˜" operator
and the switch construct
("given"/"when"). See "Switch
Statements" in perlsyn and feature.</p>
<p style="margin-left:15%; margin-top: 1em">Unusually, the
overloaded implementation of the smart match operator does
not get full control of the smart match behaviour. In
particular, in the following code:</p>
<p style="margin-left:15%; margin-top: 1em">package Foo;
<br/>
use overload '˜˜' =&gt; 'match'; <br/>
my $obj = Foo−&gt;new(); <br/>
$obj ˜˜ [ 1,2,3 ];</p>
<p style="margin-left:15%; margin-top: 1em">the smart match
does <i>not</i> invoke the method call like this:</p>
<p style="margin-left:15%; margin-top: 1em">$obj−&gt;match([1,2,3],0);</p>
<p style="margin-left:15%; margin-top: 1em">rather, the
smart match distributive rule takes precedence, so $obj is
smart matched against each array element in turn until a
match is found, so you may see between one and three of
these calls instead:</p>
<p style="margin-left:15%; margin-top: 1em">$obj−&gt;match(1,0);
<br/>
$obj−&gt;match(2,0); <br/>
$obj−&gt;match(3,0);</p>
<p style="margin-left:15%; margin-top: 1em">Consult the
match table in "Smartmatch Operator" in perlop for
details of when overloading is invoked.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="17%">
<p style="margin-top: 1em"><i>Dereferencing</i></p></td>
<td width="68%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">${} @{} %{}
&amp;{} *{}</p>
<p style="margin-left:15%; margin-top: 1em">If these
operators are not explicitly overloaded then they work in
the normal way, yielding the underlying scalar, array, or
whatever stores the object data (or the appropriate error
message if the dereference operator doesn’t match it).
Defining a catch-all 'nomethod' (see below) makes no
difference to this as the catch-all function will not be
called to implement a missing dereference operator.</p>
<p style="margin-left:15%; margin-top: 1em">If a
dereference operator is overloaded then it must return a
<i>reference</i> of the appropriate type (for example, the
subroutine for key '${}' should return a reference to a
scalar, not a scalar), or another object which overloads the
operator: that is, the subroutine only determines what is
dereferenced and the actual dereferencing is left to Perl.
As a special case, if the subroutine returns the object
itself then it will not be called again − avoiding
infinite recursion.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="9%">
<p style="margin-top: 1em"><i>Special</i></p></td>
<td width="76%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">nomethod
fallback =</p>
<p style="margin-left:15%; margin-top: 1em">See
"Special Keys for "use overload"".</p>
<h3>Magic Autogeneration
<a name="Magic Autogeneration"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If a method for
an operation is not found then Perl tries to autogenerate a
substitute implementation from the operations that have been
defined.</p>
<p style="margin-left:9%; margin-top: 1em">Note: the
behaviour described in this section can be disabled by
setting "fallback" to FALSE (see
"fallback").</p>
<p style="margin-left:9%; margin-top: 1em">In the following
tables, numbers indicate priority. For example, the table
below states that, if no implementation for '!' has been
defined then Perl will implement it using 'bool' (that is,
by inverting the value returned by the method for 'bool');
if boolean conversion is also unimplemented then Perl will
use '0+' or, failing that, '""'.</p>
<p style="margin-left:9%; margin-top: 1em">operator | can
be autogenerated from <br/>
| <br/>
| 0+ "" bool . x <br/>
=========|========================== <br/>
0+ | 1 2 <br/>
"" | 1 2 <br/>
bool | 1 2 <br/>
int | 1 2 3 <br/>
! | 2 3 1 <br/>
qr | 2 1 3 <br/>
. | 2 1 3 <br/>
x | 2 1 3 <br/>
.= | 3 2 4 1 <br/>
x= | 3 2 4 1 <br/>
&lt;&gt; | 2 1 3 <br/>
−X | 2 1 3</p>
<p style="margin-left:9%; margin-top: 1em">Note: The
iterator ('&lt;&gt;') and file test ('−X') operators
work as normal: if the operand is not a blessed glob or IO
reference then it is converted to a string (using the method
for '""', '0+', or 'bool') to be interpreted as a
glob or filename.</p>
<p style="margin-left:9%; margin-top: 1em">operator | can
be autogenerated from <br/>
| <br/>
| &lt; &lt;=&gt; neg −= − <br/>
=========|========================== <br/>
neg | 1 <br/>
−= | 1 <br/>
−− | 1 2 <br/>
abs | a1 a2 b1 b2 [*] <br/>
&lt; | 1 <br/>
&lt;= | 1 <br/>
&gt; | 1 <br/>
&gt;= | 1 <br/>
== | 1 <br/>
!= | 1 <br/>
* one from [a1, a2] and one from [b1, b2]</p>
<p style="margin-left:9%; margin-top: 1em">Just as numeric
comparisons can be autogenerated from the method for
'&lt;=&gt;', string comparisons can be autogenerated from
that for 'cmp':</p>
<p style="margin-left:9%; margin-top: 1em">operators | can
be autogenerated from <br/>
====================|=========================== <br/>
lt gt le ge eq ne | cmp</p>
<p style="margin-left:9%; margin-top: 1em">Similarly,
autogeneration for keys '+=' and '++' is analogous to
'−=' and '−−' above:</p>
<p style="margin-left:9%; margin-top: 1em">operator | can
be autogenerated from <br/>
| <br/>
| += + <br/>
=========|========================== <br/>
+= | 1 <br/>
++ | 1 2</p>
<p style="margin-left:9%; margin-top: 1em">And other
assignment variations are analogous to '+=' and '−='
(and similar to '.=' and 'x=' above):</p>
<p style="margin-left:9%; margin-top: 1em">operator || *=
/= %= **= &lt;&lt;= &gt;&gt;= &amp;= ˆ= |= &amp;.=
ˆ.= |.= <br/>

−−−−−−−−−−−−−−−−−−−||−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
<br/>
autogenerated from || * / % ** &lt;&lt; &gt;&gt; &amp;
ˆ | &amp;. ˆ. |.</p>
<p style="margin-left:9%; margin-top: 1em">Note also that
the copy constructor (key '=') may be autogenerated, but
only for objects based on scalars. See "Copy
Constructor".</p>
<p style="margin-left:9%; margin-top: 1em"><i>Minimal Set
of Overloaded Operations</i></p>
<p style="margin-left:9%; margin-top: 1em">Since some
operations can be automatically generated from others, there
is a minimal set of operations that need to be overloaded in
order to have the complete set of overloaded operations at
one’s disposal. Of course, the autogenerated
operations may not do exactly what the user expects. The
minimal set is:</p>
<p style="margin-left:9%; margin-top: 1em">+ − * / %
** &lt;&lt; &gt;&gt; x <br/>
&lt;=&gt; cmp <br/>
&amp; | ˆ ˜ &amp;. |. ˆ. ˜. <br/>
atan2 cos sin exp log sqrt int <br/>
"" 0+ bool <br/>
˜˜</p>
<p style="margin-left:9%; margin-top: 1em">Of the
conversions, only one of string, boolean or numeric is
needed because each can be generated from either of the
other two.</p>
<h3>Special Keys for "use overload"
<a name='Special Keys for "use overload"'></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><i>"nomethod"</i></p>
<p style="margin-left:9%; margin-top: 1em">The 'nomethod'
key is used to specify a catch-all function to be called for
any operator that is not individually overloaded. The
specified function will be passed four parameters. The first
three arguments coincide with those that would have been
passed to the corresponding method if it had been defined.
The fourth argument is the "use overload" key for
that missing method. If the "bitwise" feature is
enabled (see feature), a fifth TRUE argument is passed to
subroutines handling "&amp;", "|",
"ˆ" and "˜" to indicate that
the caller is expecting numeric behaviour.</p>
<p style="margin-left:9%; margin-top: 1em">For example, if
$a is an object blessed into a package declaring</p>
<p style="margin-left:9%; margin-top: 1em">use overload
'nomethod' =&gt; 'catch_all', # ...</p>
<p style="margin-left:9%; margin-top: 1em">then the
operation</p>
<p style="margin-left:9%; margin-top: 1em">3 + $a</p>
<p style="margin-left:9%; margin-top: 1em">could (unless a
method is specifically declared for the key '+') result in a
call</p>
<p style="margin-left:9%; margin-top: 1em">catch_all($a, 3,
1, '+')</p>
<p style="margin-left:9%; margin-top: 1em">See "How
Perl Chooses an Operator Implementation".</p>
<p style="margin-left:9%; margin-top: 1em"><i>"fallback"</i></p>
<p style="margin-left:9%; margin-top: 1em">The value
assigned to the key 'fallback' tells Perl how hard it should
try to find an alternative way to implement a missing
operator.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="23%">
<p style="margin-top: 1em">defined, but FALSE</p></td>
<td width="63%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">use overload
"fallback" =&gt; 0, # ... ;</p>
<p style="margin-left:14%; margin-top: 1em">This disables
"Magic Autogeneration".</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="9%">
<p style="margin-top: 1em">"undef"</p></td>
<td width="77%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">In the default
case where no value is explicitly assigned to
"fallback", magic autogeneration is enabled.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="5%">
<p style="margin-top: 1em">TRUE</p></td>
<td width="81%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">The same as for
"undef", but if a missing operator cannot be
autogenerated then, instead of issuing an error message,
Perl is allowed to revert to what it would have done for
that operator if there had been no "use overload"
directive.</p>
<p style="margin-left:14%; margin-top: 1em">Note: in most
cases, particularly the "Copy Constructor", this
is unlikely to be appropriate behaviour.</p>
<p style="margin-left:9%; margin-top: 1em">See "How
Perl Chooses an Operator Implementation".</p>
<p style="margin-left:9%; margin-top: 1em"><i>Copy
Constructor</i></p>
<p style="margin-left:9%; margin-top: 1em">As mentioned
above, this operation is called when a mutator is applied to
a reference that shares its object with some other
reference. For example, if $b is mathemagical, and '++' is
overloaded with 'incr', and '=' is overloaded with 'clone',
then the code</p>
<p style="margin-left:9%; margin-top: 1em">$a = $b; <br/>
# ... (other code which does not modify $a or $b) ... <br/>
++$b;</p>
<p style="margin-left:9%; margin-top: 1em">would be
executed in a manner equivalent to</p>
<p style="margin-left:9%; margin-top: 1em">$a = $b; <br/>
# ... <br/>
$b = $b−&gt;clone(undef, ""); <br/>
$b−&gt;incr(undef, "");</p>
<p style="margin-left:9%; margin-top: 1em">Note:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">The subroutine for '=' does not
overload the Perl assignment operator: it is used only to
allow mutators to work as described here. (See
"Assignments" above.)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>As for other operations, the subroutine implementing
’=’ is passed three arguments, though the last
two are always "undef" and ''.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>The copy constructor is called only before a call to a
function declared to implement a mutator, for example, if
"++$b;" in the code above is effected via a method
declared for key '++' (or ’nomethod’, passed
'++' as the fourth argument) or, by autogeneration, '+='. It
is not called if the increment operation is effected by a
call to the method for '+' since, in the equivalent
code,</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">$a = $b; <br/>
$b = $b + 1;</p>
<p style="margin-left:14%; margin-top: 1em">the data
referred to by $a is unchanged by the assignment to $b of a
reference to new object data.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">The copy constructor is not
called if Perl determines that it is unnecessary because
there is no other reference to the data being modified.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>If 'fallback' is undefined or TRUE then a copy
constructor can be autogenerated, but only for objects based
on scalars. In other cases it needs to be defined
explicitly. Where an object’s data is stored as, for
example, an array of scalars, the following might be
appropriate:</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">use overload
'=' =&gt; sub { bless [ @{$_[0]} ] }, # ...</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">If 'fallback' is TRUE and no
copy constructor is defined then, for objects not based on
scalars, Perl may silently fall back on simple assignment
− that is, assignment of the object reference. In
effect, this disables the copy constructor mechanism since
no new copy of the object data is created. This is almost
certainly not what you want. (It is, however, consistent:
for example, Perl’s fallback for the "++"
operator is to increment the reference itself.)</p></td></tr>
</table>
<h3>How Perl Chooses an Operator Implementation
<a name="How Perl Chooses an Operator Implementation"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Which is checked
first, "nomethod" or "fallback"? If the
two operands of an operator are of different types and both
overload the operator, which implementation is used? The
following are the precedence rules:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em">1.</p></td>
<td width="2%"></td>
<td width="86%">
<p style="margin-top: 1em">If the first operand has
declared a subroutine to overload the operator then use that
implementation.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="86%">
<p>Otherwise, if fallback is TRUE or undefined for the
first operand then see if the rules for autogeneration
allows another of its operators to be used instead.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>3.</p></td>
<td width="2%"></td>
<td width="86%">
<p>Unless the operator is an assignment ("+=",
"−=", etc.), repeat step (1) in respect of
the second operand.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>4.</p></td>
<td width="2%"></td>
<td width="86%">
<p>Repeat Step (2) in respect of the second operand.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>5.</p></td>
<td width="2%"></td>
<td width="86%">
<p>If the first operand has a "nomethod" method
then use that.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>6.</p></td>
<td width="2%"></td>
<td width="86%">
<p>If the second operand has a "nomethod" method
then use that.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>7.</p></td>
<td width="2%"></td>
<td width="86%">
<p>If "fallback" is TRUE for both operands then
perform the usual operation for the operator, treating the
operands as numbers, strings, or booleans as appropriate for
the operator (see note).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>8.</p></td>
<td width="2%"></td>
<td width="86%">
<p>Nothing worked − die.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Where there is
only one operand (or only one operand with overloading) the
checks in respect of the other operand above are
skipped.</p>
<p style="margin-left:9%; margin-top: 1em">There are
exceptions to the above rules for dereference operations
(which, if Step 1 fails, always fall back to the normal,
built-in implementations − see Dereferencing), and for
"˜˜" (which has its own set of rules
− see "Matching" under "Overloadable
Operations" above).</p>
<p style="margin-left:9%; margin-top: 1em">Note on Step 7:
some operators have a different semantic depending on the
type of their operands. As there is no way to instruct Perl
to treat the operands as, e.g., numbers instead of strings,
the result here may not be what you expect. See "BUGS
AND PITFALLS".</p>
<h3>Losing Overloading
<a name="Losing Overloading"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The restriction
for the comparison operation is that even if, for example,
"cmp" should return a blessed reference, the
autogenerated "lt" function will produce only a
standard logical value based on the numerical value of the
result of "cmp". In particular, a working numeric
conversion is needed in this case (possibly expressed in
terms of other conversions).</p>
<p style="margin-left:9%; margin-top: 1em">Similarly,
".=" and "x=" operators lose their
mathemagical properties if the string conversion
substitution is applied.</p>
<p style="margin-left:9%; margin-top: 1em">When you
<b>chop()</b> a mathemagical object it is promoted to a
string and its mathemagical properties are lost. The same
can happen with other operations as well.</p>
<h3>Inheritance and Overloading
<a name="Inheritance and Overloading"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Overloading
respects inheritance via the @ISA hierarchy. Inheritance
interacts with overloading in two ways. <br/>
Method names in the "use overload" directive</p>
<p style="margin-left:14%;">If "value" in</p>
<p style="margin-left:14%; margin-top: 1em">use overload
key =&gt; value;</p>
<p style="margin-left:14%; margin-top: 1em">is a string, it
is interpreted as a method name − which may (in the
usual way) be inherited from another class.</p>
<p style="margin-left:9%;">Overloading of an operation is
inherited by derived classes</p>
<p style="margin-left:14%;">Any class derived from an
overloaded class is also overloaded and inherits its
operator implementations. If the same operator is overloaded
in more than one ancestor then the implementation is
determined by the usual inheritance rules.</p>
<p style="margin-left:14%; margin-top: 1em">For example, if
"A" inherits from "B" and "C"
(in that order), "B" overloads "+" with
"\&amp;D::plus_sub", and "C" overloads
"+" by "plus_meth", then the subroutine
"D::plus_sub" will be called to implement
operation "+" for an object in package
"A".</p>
<p style="margin-left:9%; margin-top: 1em">Note that in
Perl version prior to 5.18 inheritance of the
"fallback" key was not governed by the above
rules. The value of "fallback" in the first
overloaded ancestor was used. This was fixed in 5.18 to
follow the usual rules of inheritance.</p>
<h3>Run-time Overloading
<a name="Run-time Overloading"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Since all
"use" directives are executed at compile-time, the
only way to change overloading during run-time is to</p>
<p style="margin-left:9%; margin-top: 1em">eval 'use
overload "+" =&gt; \&amp;addmethod';</p>
<p style="margin-left:9%; margin-top: 1em">You can also
use</p>
<p style="margin-left:9%; margin-top: 1em">eval 'no
overload "+", "−−",
"&lt;="';</p>
<p style="margin-left:9%; margin-top: 1em">though the use
of these constructs during run-time is questionable.</p>
<h3>Public Functions
<a name="Public Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Package
"overload.pm" provides the following public
functions: <br/>
overload::StrVal(arg)</p>
<p style="margin-left:15%;">Gives the string value of
"arg" as in the absence of stringify overloading.
If you are using this to get the address of a reference
(useful for checking if two references point to the same
thing) then you may be better off using builtin::refaddr()
or Scalar::Util::refaddr(), which are faster.</p>
<p style="margin-left:9%;">overload::Overloaded(arg)</p>
<p style="margin-left:15%;">Returns true if "arg"
is subject to overloading of some operations.</p>
<p style="margin-left:9%;">overload::Method(obj,op)</p>
<p style="margin-left:15%;">Returns "undef" or a
reference to the method that implements "op".</p>
<p style="margin-left:15%; margin-top: 1em">Such a method
always takes three arguments, which will be enforced if it
is an XS method.</p>
<h3>Overloading Constants
<a name="Overloading Constants"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">For some
applications, the Perl parser mangles constants too much. It
is possible to hook into this process via
overload::constant() and overload::remove_constant()
functions.</p>
<p style="margin-left:9%; margin-top: 1em">These functions
take a hash as an argument. The recognized keys of this hash
are:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="9%">
<p>integer</p></td>
<td width="1%"></td>
<td width="81%">
<p>to overload integer constants,</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="9%">
<p>float</p></td>
<td width="1%"></td>
<td width="81%">
<p>to overload floating point constants,</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="9%">
<p>binary</p></td>
<td width="1%"></td>
<td width="81%">
<p>to overload octal and hexadecimal constants,</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="9%">
<p>q</p></td>
<td width="1%"></td>
<td width="81%">
<p>to overload "q"−quoted strings, constant
pieces of "qq"− and
"qx"−quoted strings and here-documents,</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="9%">
<p>qr</p></td>
<td width="1%"></td>
<td width="81%">
<p>to overload constant pieces of regular expressions.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The
corresponding values are references to functions which take
three arguments: the first one is the <i>initial</i> string
form of the constant, the second one is how Perl interprets
this constant, the third one is how the constant is used.
Note that the initial string form does not contain string
delimiters, and has backslashes in backslash-delimiter
combinations stripped (thus the value of delimiter is not
relevant for processing of this string). The return value of
this function is how this constant is going to be
interpreted by Perl. The third argument is undefined unless
for overloaded "q"− and
"qr"− constants, it is "q" in
single-quote context (comes from strings, regular
expressions, and single-quote HERE documents), it is
"tr" for arguments of "tr"/"y"
operators, it is "s" for right-hand side of
"s"−operator, and it is "qq"
otherwise.</p>
<p style="margin-left:9%; margin-top: 1em">Since an
expression "ab$cd,," is just a shortcut for 'ab' .
$cd . ',,', it is expected that overloaded constant strings
are equipped with reasonable overloaded catenation operator,
otherwise absurd results will result. Similarly, negative
numbers are considered as negations of positive
constants.</p>
<p style="margin-left:9%; margin-top: 1em">Note that it is
probably meaningless to call the functions
<b>overload::constant()</b> and
<b>overload::remove_constant()</b> from anywhere but
<b>import()</b> and <b>unimport()</b> methods. From these
methods they may be called as</p>
<p style="margin-left:9%; margin-top: 1em">sub import {
<br/>
shift; <br/>
return unless @_; <br/>
die "unknown import: @_" unless @_ == 1 and $_[0]
eq ':constant'; <br/>
overload::constant integer =&gt; sub
{Math::BigInt−&gt;new(shift)}; <br/>
}</p>
<h2>IMPLEMENTATION
<a name="IMPLEMENTATION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">What follows is
subject to change RSN.</p>
<p style="margin-left:9%; margin-top: 1em">The table of
methods for all operations is cached in magic for the symbol
table hash for the package. The cache is invalidated during
processing of "use overload", "no
overload", new function definitions, and changes in
@ISA.</p>
<p style="margin-left:9%; margin-top: 1em">(Every SVish
thing has a magic queue, and magic is an entry in that
queue. This is how a single variable may participate in
multiple forms of magic simultaneously. For instance,
environment variables regularly have two forms at once:
their %ENV magic and their taint magic. However, the magic
which implements overloading is applied to the stashes,
which are rarely used directly, thus should not slow down
Perl.)</p>
<p style="margin-left:9%; margin-top: 1em">If a package
uses overload, it carries a special flag. This flag is also
set when new functions are defined or @ISA is modified.
There will be a slight speed penalty on the very first
operation thereafter that supports overloading, while the
overload tables are updated. If there is no overloading
present, the flag is turned off. Thus the only speed penalty
thereafter is the checking of this flag.</p>
<p style="margin-left:9%; margin-top: 1em">It is expected
that arguments to methods that are not explicitly supposed
to be changed are constant (but this is not enforced).</p>
<h2>COOKBOOK
<a name="COOKBOOK"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Please add
examples to what follows!</p>
<h3>Two-face Scalars
<a name="Two-face Scalars"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Put this in
<i>two_face.pm</i> in your Perl library directory:</p>
<p style="margin-left:9%; margin-top: 1em">package
two_face; # Scalars with separate string and <br/>
# numeric values. <br/>
sub new { my $p = shift; bless [@_], $p } <br/>
use overload '""' =&gt; \&amp;str, '0+' =&gt;
\&amp;num, fallback =&gt; 1; <br/>
sub num {shift−&gt;[1]} <br/>
sub str {shift−&gt;[0]}</p>
<p style="margin-left:9%; margin-top: 1em">Use it as
follows:</p>
<p style="margin-left:9%; margin-top: 1em">require
two_face; <br/>
my $seven = two_face−&gt;new("vii", 7); <br/>
printf "seven=$seven, seven=%d, eight=%d\n",
$seven, $seven+1; <br/>
print "seven contains 'i'\n" if $seven =˜
/i/;</p>
<p style="margin-left:9%; margin-top: 1em">(The second line
creates a scalar which has both a string value, and a
numeric value.) This prints:</p>
<p style="margin-left:9%; margin-top: 1em">seven=vii,
seven=7, eight=8 <br/>
seven contains 'i'</p>
<h3>Two-face References
<a name="Two-face References"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Suppose you want
to create an object which is accessible as both an array
reference and a hash reference.</p>
<p style="margin-left:9%; margin-top: 1em">package
two_refs; <br/>
use overload '%{}' =&gt; \&amp;gethash, '@{}' =&gt; sub { $
{shift()} }; <br/>
sub new { <br/>
my $p = shift; <br/>
bless \ [@_], $p; <br/>
} <br/>
sub gethash { <br/>
my %h; <br/>
my $self = shift; <br/>
tie %h, ref $self, $self; <br/>
\%h; <br/>
} <br/>
sub TIEHASH { my $p = shift; bless \ shift, $p } <br/>
my %fields; <br/>
my $i = 0; <br/>
$fields{$_} = $i++ foreach qw{zero one two three}; <br/>
sub STORE { <br/>
my $self = ${shift()}; <br/>
my $key = $fields{shift()}; <br/>
defined $key or die "Out of band access"; <br/>
$$self−&gt;[$key] = shift; <br/>
} <br/>
sub FETCH { <br/>
my $self = ${shift()}; <br/>
my $key = $fields{shift()}; <br/>
defined $key or die "Out of band access"; <br/>
$$self−&gt;[$key]; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Now one can
access an object using both the array and hash syntax:</p>
<p style="margin-left:9%; margin-top: 1em">my $bar =
two_refs−&gt;new(3,4,5,6); <br/>
$bar−&gt;[2] = 11; <br/>
$bar−&gt;{two} == 11 or die 'bad hash fetch';</p>
<p style="margin-left:9%; margin-top: 1em">Note several
important features of this example. First of all, the
<i>actual</i> type of $bar is a scalar reference, and we do
not overload the scalar dereference. Thus we can get the
<i>actual</i> non-overloaded contents of $bar by just using
$$bar (what we do in functions which overload dereference).
Similarly, the object returned by the <b>TIEHASH()</b>
method is a scalar reference.</p>
<p style="margin-left:9%; margin-top: 1em">Second, we
create a new tied hash each time the hash syntax is used.
This allows us not to worry about a possibility of a
reference loop, which would lead to a memory leak.</p>
<p style="margin-left:9%; margin-top: 1em">Both these
problems can be cured. Say, if we want to overload hash
dereference on a reference to an object which is
<i>implemented</i> as a hash itself, the only problem one
has to circumvent is how to access this <i>actual</i> hash
(as opposed to the <i>virtual</i> hash exhibited by the
overloaded dereference operator). Here is one possible
fetching routine:</p>
<p style="margin-left:9%; margin-top: 1em">sub access_hash
{ <br/>
my ($self, $key) = (shift, shift); <br/>
my $class = ref $self; <br/>
bless $self, 'overload::dummy'; # Disable overloading of %{}
<br/>
my $out = $self−&gt;{$key}; <br/>
bless $self, $class; # Restore overloading <br/>
$out; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">To remove
creation of the tied hash on each access, one may an extra
level of indirection which allows a non-circular structure
of references:</p>
<p style="margin-left:9%; margin-top: 1em">package
two_refs1; <br/>
use overload <br/>
'%{}' =&gt; sub { ${shift()}−&gt;[1] }, <br/>
'@{}' =&gt; sub { ${shift()}−&gt;[0] }; <br/>
sub new { <br/>
my $p = shift; <br/>
my $a = [@_]; <br/>
my %h; <br/>
tie %h, $p, $a; <br/>
bless \ [$a, \%h], $p; <br/>
} <br/>
sub gethash { <br/>
my %h; <br/>
my $self = shift; <br/>
tie %h, ref $self, $self; <br/>
\%h; <br/>
} <br/>
sub TIEHASH { my $p = shift; bless \ shift, $p } <br/>
my %fields; <br/>
my $i = 0; <br/>
$fields{$_} = $i++ foreach qw{zero one two three}; <br/>
sub STORE { <br/>
my $a = ${shift()}; <br/>
my $key = $fields{shift()}; <br/>
defined $key or die "Out of band access"; <br/>
$a−&gt;[$key] = shift; <br/>
} <br/>
sub FETCH { <br/>
my $a = ${shift()}; <br/>
my $key = $fields{shift()}; <br/>
defined $key or die "Out of band access"; <br/>
$a−&gt;[$key]; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Now if $baz is
overloaded like this, then $baz is a reference to a
reference to the intermediate array, which keeps a reference
to an actual array, and the access hash. The <b>tie()</b>ing
object for the access hash is a reference to a reference to
the actual array, so</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">There are no loops of
references.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Both "objects" which are blessed into the
class "two_refs1" are references to a reference to
an array, thus references to a <i>scalar</i>. Thus the
accessor expression "$$foo−&gt;[$ind]"
involves no overloaded operations.</p></td></tr>
</table>
<h3>Symbolic Calculator
<a name="Symbolic Calculator"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Put this in
<i>symbolic.pm</i> in your Perl library directory:</p>
<p style="margin-left:9%; margin-top: 1em">package
symbolic; # Primitive symbolic calculator <br/>
use overload nomethod =&gt; \&amp;wrap; <br/>
sub new { shift; bless ['n', @_] } <br/>
sub wrap { <br/>
my ($obj, $other, $inv, $meth) = @_; <br/>
($obj, $other) = ($other, $obj) if $inv; <br/>
bless [$meth, $obj, $other]; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">This module is
very unusual as overloaded modules go: it does not provide
any usual overloaded operators, instead it provides an
implementation for "nomethod". In this example the
"nomethod" subroutine returns an object which
encapsulates operations done over the objects:
"symbolic−&gt;new(3)" contains "['n',
3]", "2 + symbolic−&gt;new(3)" contains
"['+', 2, ['n', 3]]".</p>
<p style="margin-left:9%; margin-top: 1em">Here is an
example of the script which "calculates" the side
of circumscribed octagon using the above package:</p>
<p style="margin-left:9%; margin-top: 1em">require
symbolic; <br/>
my $iter = 1; # 2**($iter+2) = 8 <br/>
my $side = symbolic−&gt;new(1); <br/>
my $cnt = $iter; <br/>
while ($cnt−−) { <br/>
$side = (sqrt(1 + $side**2) − 1)/$side; <br/>
} <br/>
print "OK\n";</p>
<p style="margin-left:9%; margin-top: 1em">The value of
$side is</p>
<p style="margin-left:9%; margin-top: 1em">['/',
['−', ['sqrt', ['+', 1, ['**', ['n', 1], 2]], <br/>
undef], 1], ['n', 1]]</p>
<p style="margin-left:9%; margin-top: 1em">Note that while
we obtained this value using a nice little script, there is
no simple way to <i>use</i> this value. In fact this value
may be inspected in debugger (see perldebug), but only if
"bareStringify" <b>O</b>ption is set, and not via
"p" command.</p>
<p style="margin-left:9%; margin-top: 1em">If one attempts
to print this value, then the overloaded operator
"" will be called, which will call
"nomethod" operator. The result of this operator
will be stringified again, but this result is again of type
"symbolic", which will lead to an infinite
loop.</p>
<p style="margin-left:9%; margin-top: 1em">Add a
pretty-printer method to the module <i>symbolic.pm</i>:</p>
<p style="margin-left:9%; margin-top: 1em">sub pretty {
<br/>
my ($meth, $a, $b) = @{+shift}; <br/>
$a = 'u' unless defined $a; <br/>
$b = 'u' unless defined $b; <br/>
$a = $a−&gt;pretty if ref $a; <br/>
$b = $b−&gt;pretty if ref $b; <br/>
"[$meth $a $b]"; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Now one can
finish the script by</p>
<p style="margin-left:9%; margin-top: 1em">print "side
= ", $side−&gt;pretty, "\n";</p>
<p style="margin-left:9%; margin-top: 1em">The method
"pretty" is doing object-to-string conversion, so
it is natural to overload the operator "" using
this method. However, inside such a method it is not
necessary to pretty-print the <i>components</i> $a and $b of
an object. In the above subroutine "[$meth $a $b]"
is a catenation of some strings and components $a and $b. If
these components use overloading, the catenation operator
will look for an overloaded operator "."; if not
present, it will look for an overloaded operator
"". Thus it is enough to use</p>
<p style="margin-left:9%; margin-top: 1em">use overload
nomethod =&gt; \&amp;wrap, '""' =&gt; \&amp;str;
<br/>
sub str { <br/>
my ($meth, $a, $b) = @{+shift}; <br/>
$a = 'u' unless defined $a; <br/>
$b = 'u' unless defined $b; <br/>
"[$meth $a $b]"; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Now one can
change the last line of the script to</p>
<p style="margin-left:9%; margin-top: 1em">print "side
= $side\n";</p>
<p style="margin-left:9%; margin-top: 1em">which
outputs</p>
<p style="margin-left:9%; margin-top: 1em">side = [/
[− [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]</p>
<p style="margin-left:9%; margin-top: 1em">and one can
inspect the value in debugger using all the possible
methods.</p>
<p style="margin-left:9%; margin-top: 1em">Something is
still amiss: consider the loop variable $cnt of the script.
It was a number, not an object. We cannot make this value of
type "symbolic", since then the loop will not
terminate.</p>
<p style="margin-left:9%; margin-top: 1em">Indeed, to
terminate the cycle, the $cnt should become false. However,
the operator "bool" for checking falsity is
overloaded (this time via overloaded ""), and
returns a long string, thus any object of type
"symbolic" is true. To overcome this, we need a
way to compare an object to 0. In fact, it is easier to
write a numeric conversion routine.</p>
<p style="margin-left:9%; margin-top: 1em">Here is the text
of <i>symbolic.pm</i> with such a routine added (and
slightly modified <b>str()</b>):</p>
<p style="margin-left:9%; margin-top: 1em">package
symbolic; # Primitive symbolic calculator <br/>
use overload <br/>
nomethod =&gt; \&amp;wrap, '""' =&gt; \&amp;str,
'0+' =&gt; \&amp;num; <br/>
sub new { shift; bless ['n', @_] } <br/>
sub wrap { <br/>
my ($obj, $other, $inv, $meth) = @_; <br/>
($obj, $other) = ($other, $obj) if $inv; <br/>
bless [$meth, $obj, $other]; <br/>
} <br/>
sub str { <br/>
my ($meth, $a, $b) = @{+shift}; <br/>
$a = 'u' unless defined $a; <br/>
if (defined $b) { <br/>
"[$meth $a $b]"; <br/>
} else { <br/>
"[$meth $a]"; <br/>
} <br/>
} <br/>
my %subr = ( <br/>
n =&gt; sub {$_[0]}, <br/>
sqrt =&gt; sub {sqrt $_[0]}, <br/>
'−' =&gt; sub {shift() − shift()}, <br/>
'+' =&gt; sub {shift() + shift()}, <br/>
'/' =&gt; sub {shift() / shift()}, <br/>
'*' =&gt; sub {shift() * shift()}, <br/>
'**' =&gt; sub {shift() ** shift()}, <br/>
); <br/>
sub num { <br/>
my ($meth, $a, $b) = @{+shift}; <br/>
my $subr = $subr{$meth} <br/>
or die "Do not know how to ($meth) in symbolic";
<br/>
$a = $a−&gt;num if ref $a eq __PACKAGE__; <br/>
$b = $b−&gt;num if ref $b eq __PACKAGE__; <br/>
$subr−&gt;($a,$b); <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">All the work of
numeric conversion is done in %subr and <b>num()</b>. Of
course, %subr is not complete, it contains only operators
used in the example below. Here is the extra-credit
question: why do we need an explicit recursion in
<b>num()</b>? (Answer is at the end of this section.)</p>
<p style="margin-left:9%; margin-top: 1em">Use this module
like this:</p>
<p style="margin-left:9%; margin-top: 1em">require
symbolic; <br/>
my $iter = symbolic−&gt;new(2); # 16−gon <br/>
my $side = symbolic−&gt;new(1); <br/>
my $cnt = $iter; <br/>
while ($cnt) { <br/>
$cnt = $cnt − 1; # Mutator '−−' not
implemented <br/>
$side = (sqrt(1 + $side**2) − 1)/$side; <br/>
} <br/>
printf "%s=%f\n", $side, $side; <br/>
printf "pi=%f\n", $side*(2**($iter+2));</p>
<p style="margin-left:9%; margin-top: 1em">It prints
(without so many line breaks)</p>
<p style="margin-left:9%; margin-top: 1em">[/ [−
[sqrt [+ 1 [** [/ [− [sqrt [+ 1 [** [n 1] 2]]] 1] <br/>
[n 1]] 2]]] 1] <br/>
[/ [− [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
<br/>
pi=3.182598</p>
<p style="margin-left:9%; margin-top: 1em">The above module
is very primitive. It does not implement mutator methods
("++", "−=" and so on), does not
do deep copying (not required without mutators!), and
implements only those arithmetic operations which are used
in the example.</p>
<p style="margin-left:9%; margin-top: 1em">To implement
most arithmetic operations is easy; one should just use the
tables of operations, and change the code which fills %subr
to</p>
<p style="margin-left:9%; margin-top: 1em">my %subr = ( 'n'
=&gt; sub {$_[0]} ); <br/>
foreach my $op (split " ",
$overload::ops{with_assign}) { <br/>
$subr{$op} = $subr{"$op="} = eval "sub
{shift() $op shift()}"; <br/>
} <br/>
my @bins = qw(binary 3way_comparison num_comparison
str_comparison); <br/>
foreach my $op (split " ", "@overload::ops{
@bins }") { <br/>
$subr{$op} = eval "sub {shift() $op shift()}";
<br/>
} <br/>
foreach my $op (split " ",
"@overload::ops{qw(unary func)}") { <br/>
print "defining '$op'\n"; <br/>
$subr{$op} = eval "sub {$op shift()}"; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Since
subroutines implementing assignment operators are not
required to modify their operands (see "Overloadable
Operations" above), we do not need anything special to
make "+=" and friends work, besides adding these
operators to %subr and defining a copy constructor (needed
since Perl has no way to know that the implementation of
'+=' does not mutate the argument − see "Copy
Constructor").</p>
<p style="margin-left:9%; margin-top: 1em">To implement a
copy constructor, add "'=' =&gt; \&amp;cpy" to
"use overload" line, and code (this code assumes
that mutators change things one level deep only, so
recursive copying is not needed):</p>
<p style="margin-left:9%; margin-top: 1em">sub cpy { <br/>
my $self = shift; <br/>
bless [@$self], ref $self; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">To make
"++" and "−−" work, we need
to implement actual mutators, either directly, or in
"nomethod". We continue to do things inside
"nomethod", thus add</p>
<p style="margin-left:9%; margin-top: 1em">if ($meth eq
'++' or $meth eq '−−') { <br/>
@$obj = ($meth, (bless [@$obj]), 1); # Avoid circular
reference <br/>
return $obj; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">after the first
line of <b>wrap()</b>. This is not a most effective
implementation, one may consider</p>
<p style="margin-left:9%; margin-top: 1em">sub inc { $_[0]
= bless ['++', shift, 1]; }</p>
<p style="margin-left:9%; margin-top: 1em">instead.</p>
<p style="margin-left:9%; margin-top: 1em">As a final
remark, note that one can fill %subr by</p>
<p style="margin-left:9%; margin-top: 1em">my %subr = ( 'n'
=&gt; sub {$_[0]} ); <br/>
foreach my $op (split " ",
$overload::ops{with_assign}) { <br/>
$subr{$op} = $subr{"$op="} = eval "sub
{shift() $op shift()}"; <br/>
} <br/>
my @bins = qw(binary 3way_comparison num_comparison
str_comparison); <br/>
foreach my $op (split " ", "@overload::ops{
@bins }") { <br/>
$subr{$op} = eval "sub {shift() $op shift()}";
<br/>
} <br/>
foreach my $op (split " ",
"@overload::ops{qw(unary func)}") { <br/>
$subr{$op} = eval "sub {$op shift()}"; <br/>
} <br/>
$subr{'++'} = $subr{'+'}; <br/>
$subr{'−−'} = $subr{'−'};</p>
<p style="margin-left:9%; margin-top: 1em">This finishes
implementation of a primitive symbolic calculator in 50
lines of Perl code. Since the numeric values of
subexpressions are not cached, the calculator is very
slow.</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
answer for the exercise: In the case of <b>str()</b>, we
need no explicit recursion since the overloaded
"."−operator will fall back to an existing
overloaded operator "". Overloaded arithmetic
operators <i>do not</i> fall back to numeric conversion if
"fallback" is not explicitly requested. Thus
without an explicit recursion <b>num()</b> would convert
"['+', $a, $b]" to "$a + $b", which
would just rebuild the argument of <b>num()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">If you wonder
why defaults for conversion are different for <b>str()</b>
and <b>num()</b>, note how easy it was to write the symbolic
calculator. This simplicity is due to an appropriate choice
of defaults. One extra note: due to the explicit recursion
<b>num()</b> is more fragile than <b>sym()</b>: we need to
explicitly check for the type of $a and $b. If components $a
and $b happen to be of some related type, this may lead to
problems.</p>
<h3>Really Symbolic Calculator
<a name="Really Symbolic Calculator"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">One may wonder
why we call the above calculator symbolic. The reason is
that the actual calculation of the value of expression is
postponed until the value is <i>used</i>.</p>
<p style="margin-left:9%; margin-top: 1em">To see it in
action, add a method</p>
<p style="margin-left:9%; margin-top: 1em">sub STORE { <br/>
my $obj = shift; <br/>
$#$obj = 1; <br/>
@$obj−&gt;[0,1] = ('=', shift); <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">to the package
"symbolic". After this change one can do</p>
<p style="margin-left:9%; margin-top: 1em">my $a =
symbolic−&gt;new(3); <br/>
my $b = symbolic−&gt;new(4); <br/>
my $c = sqrt($a**2 + $b**2);</p>
<p style="margin-left:9%; margin-top: 1em">and the numeric
value of $c becomes 5. However, after calling</p>
<p style="margin-left:9%; margin-top: 1em">$a−&gt;STORE(12);
$b−&gt;STORE(5);</p>
<p style="margin-left:9%; margin-top: 1em">the numeric
value of $c becomes 13. There is no doubt now that the
module symbolic provides a <i>symbolic</i> calculator
indeed.</p>
<p style="margin-left:9%; margin-top: 1em">To hide the
rough edges under the hood, provide a <b>tie()</b>d
interface to the package "symbolic". Add
methods</p>
<p style="margin-left:9%; margin-top: 1em">sub TIESCALAR {
my $pack = shift; $pack−&gt;new(@_) } <br/>
sub FETCH { shift } <br/>
sub nop { } # Around a bug</p>
<p style="margin-left:9%; margin-top: 1em">(the bug, fixed
in Perl 5.14, is described in "BUGS"). One can use
this new interface as</p>
<p style="margin-left:9%; margin-top: 1em">tie $a,
'symbolic', 3; <br/>
tie $b, 'symbolic', 4; <br/>
$a−&gt;nop; $b−&gt;nop; # Around a bug <br/>
my $c = sqrt($a**2 + $b**2);</p>
<p style="margin-left:9%; margin-top: 1em">Now numeric
value of $c is 5. After "$a = 12; $b = 5" the
numeric value of $c becomes 13. To insulate the user of the
module add a method</p>
<p style="margin-left:9%; margin-top: 1em">sub vars { my $p
= shift; tie($_, $p), $_−&gt;nop foreach @_; }</p>
<p style="margin-left:9%; margin-top: 1em">Now</p>
<p style="margin-left:9%; margin-top: 1em">my ($a, $b);
<br/>
symbolic−&gt;vars($a, $b); <br/>
my $c = sqrt($a**2 + $b**2); <br/>
$a = 3; $b = 4; <br/>
printf "c5 %s=%f\n", $c, $c; <br/>
$a = 12; $b = 5; <br/>
printf "c13 %s=%f\n", $c, $c;</p>
<p style="margin-left:9%; margin-top: 1em">shows that the
numeric value of $c follows changes to the values of $a and
$b.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Ilya Zakharevich
&lt;<i>ilya@math.mps.ohio−state.edu</i>&gt;.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
"overloading" pragma can be used to enable or
disable overloaded operations within a lexical scope −
see overloading.</p>
<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">When Perl is run
with the <b>−Do</b> switch or its equivalent,
overloading induces diagnostic messages.</p>
<p style="margin-left:9%; margin-top: 1em">Using the
"m" command of Perl debugger (see perldebug) one
can deduce which operations are overloaded (and which
ancestor triggers this overloading). Say, if "eq"
is overloaded, then the method "(eq" is shown by
debugger. The method "()" corresponds to the
"fallback" key (in fact a presence of this method
shows that this package has overloading enabled, and it is
what is used by the "Overloaded" function of
module "overload").</p>
<p style="margin-left:9%; margin-top: 1em">The module might
issue the following warnings: <br/>
Odd number of arguments for overload::constant</p>
<p style="margin-left:14%;">(W) The call to
overload::constant contained an odd number of arguments. The
arguments should come in pairs.</p>
<p style="margin-left:9%;">’%s’ is not an
overloadable type</p>
<p style="margin-left:14%;">(W) You tried to overload a
constant type the overload package is unaware of.</p>
<p style="margin-left:9%;">’%s’ is not a code
reference</p>
<p style="margin-left:14%;">(W) The second (fourth, sixth,
...) argument of overload::constant needs to be a code
reference. Either an anonymous subroutine, or a reference to
a subroutine.</p>
<p style="margin-left:9%;">overload arg ’%s’ is
invalid</p>
<p style="margin-left:14%;">(W) "use overload"
was passed an argument it did not recognize. Did you mistype
an operator?</p>
<h2>BUGS AND PITFALLS
<a name="BUGS AND PITFALLS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">A pitfall when fallback is TRUE
and Perl resorts to a built-in implementation of an operator
is that some operators have more than one semantic, for
example "|":</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">use overload
'0+' =&gt; sub { $_[0]−&gt;{n}; }, <br/>
fallback =&gt; 1; <br/>
my $x = bless { n =&gt; 4 }, "main"; <br/>
my $y = bless { n =&gt; 8 }, "main"; <br/>
print $x | $y, "\n";</p>
<p style="margin-left:14%; margin-top: 1em">You might
expect this to output "12". In fact, it prints
"&lt;": the ASCII result of treating "|"
as a bitwise string operator − that is, the result of
treating the operands as the strings "4" and
"8" rather than numbers. The fact that numify
("0+") is implemented but stringify ("")
isn’t makes no difference since the latter is simply
autogenerated from the former.</p>
<p style="margin-left:14%; margin-top: 1em">The only way to
change this is to provide your own subroutine for '|'.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Magic autogeneration increases
the potential for inadvertently creating self-referential
structures. Currently Perl will not free self-referential
structures until cycles are explicitly broken. For
example,</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">use overload
'+' =&gt; 'add'; <br/>
sub add { bless [ \$_[0], \$_[1] ] };</p>
<p style="margin-left:14%; margin-top: 1em">is asking for
trouble, since</p>
<p style="margin-left:14%; margin-top: 1em">$obj += $y;</p>
<p style="margin-left:14%; margin-top: 1em">will
effectively become</p>
<p style="margin-left:14%; margin-top: 1em">$obj =
add($obj, $y, undef);</p>
<p style="margin-left:14%; margin-top: 1em">with the same
result as</p>
<p style="margin-left:14%; margin-top: 1em">$obj = [\$obj,
\$foo];</p>
<p style="margin-left:14%; margin-top: 1em">Even if no
<i>explicit</i> assignment-variants of operators are present
in the script, they may be generated by the optimizer. For
example,</p>
<p style="margin-left:14%; margin-top: 1em">"obj =
$obj\n"</p>
<p style="margin-left:14%; margin-top: 1em">may be
optimized to</p>
<p style="margin-left:14%; margin-top: 1em">my $tmp = 'obj
= ' . $obj; $tmp .= "\n";</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">The symbol table is filled with
names looking like line-noise.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>This bug was fixed in Perl 5.18, but may still trip you
up if you are using older versions:</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">For the purpose
of inheritance every overloaded package behaves as if
"fallback" is present (possibly undefined). This
may create interesting effects if some package is not
overloaded, but inherits from two overloaded packages.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Before Perl 5.14, the relation
between overloading and <b>tie()</b>ing was broken.
Overloading was triggered or not based on the
<i>previous</i> class of the <b>tie()</b>d variable.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">This happened
because the presence of overloading was checked too early,
before any <b>tie()</b>d access was attempted. If the class
of the value <b>FETCH()</b>ed from the tied variable does
not change, a simple workaround for code that is to run on
older Perl versions is to access the value (via "() =
$foo" or some such) immediately after <b>tie()</b>ing,
so that after this call the <i>previous</i> class coincides
with the current one.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="73%">
<p style="margin-top: 1em">Barewords are not covered by
overloaded string constants.</p></td>
<td width="13%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="73%">
<p>The range operator ".." cannot be
overloaded.</p> </td>
<td width="13%">
</td></tr>
</table>
<hr/>
</body>
</html>
