<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:39:03 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>timer_create</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">timer_create</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#VERSIONS">VERSIONS</a><br/>
<a href="#C library/kernel differences">C library/kernel differences</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#Program source">Program source</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">timer_create
− create a POSIX per-process timer</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Real-time
library (<i>librt</i>, <i>−lrt</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;signal.h&gt;</b> /* Definition of <b>SIGEV_*</b>
constants */ <b><br/>
#include &lt;time.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
timer_create(clockid_t</b> <i>clockid</i><b>, <br/>
struct sigevent *_Nullable restrict</b> <i>sevp</i><b>, <br/>
timer_t *restrict</b> <i>timerid</i><b>);</b></p>
<p style="margin-left:4%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<b>feature_test_macros</b>(7)):</p>
<p style="margin-left:9%; margin-top: 1em"><b>timer_create</b>():
<br/>
_POSIX_C_SOURCE &gt;= 199309L</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>timer_create</b>()
creates a new per-process interval timer. The ID of the new
timer is returned in the buffer pointed to by
<i>timerid</i>, which must be a non-null pointer. This ID is
unique within the process, until the timer is deleted. The
new timer is initially disarmed.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>clockid</i> argument specifies the clock that the new
timer uses to measure time. It can be specified as one of
the following values: <b><br/>
CLOCK_REALTIME</b></p>
<p style="margin-left:18%;">A settable system-wide
real-time clock.</p>
<p style="margin-left:9%;"><b>CLOCK_MONOTONIC</b></p>
<p style="margin-left:18%;">A nonsettable monotonically
increasing clock that measures time from some unspecified
point in the past that does not change after system
startup.</p>
<p style="margin-left:9%;"><b>CLOCK_PROCESS_CPUTIME_ID</b>
(since Linux 2.6.12)</p>
<p style="margin-left:18%;">A clock that measures (user and
system) CPU time consumed by (all of the threads in) the
calling process.</p>
<p style="margin-left:9%;"><b>CLOCK_THREAD_CPUTIME_ID</b>
(since Linux 2.6.12)</p>
<p style="margin-left:18%;">A clock that measures (user and
system) CPU time consumed by the calling thread.</p>
<p style="margin-left:9%;"><b>CLOCK_BOOTTIME</b> (Since
Linux 2.6.39)</p>
<p style="margin-left:18%;">Like <b>CLOCK_MONOTONIC</b>,
this is a monotonically increasing clock. However, whereas
the <b>CLOCK_MONOTONIC</b> clock does not measure the time
while a system is suspended, the <b>CLOCK_BOOTTIME</b> clock
does include the time during which the system is suspended.
This is useful for applications that need to be
suspend-aware. <b>CLOCK_REALTIME</b> is not suitable for
such applications, since that clock is affected by
discontinuous changes to the system clock.</p>
<p style="margin-left:9%;"><b>CLOCK_REALTIME_ALARM</b>
(since Linux 3.0)</p>
<p style="margin-left:18%;">This clock is like
<b>CLOCK_REALTIME</b>, but will wake the system if it is
suspended. The caller must have the <b>CAP_WAKE_ALARM</b>
capability in order to set a timer against this clock.</p>
<p style="margin-left:9%;"><b>CLOCK_BOOTTIME_ALARM</b>
(since Linux 3.0)</p>
<p style="margin-left:18%;">This clock is like
<b>CLOCK_BOOTTIME</b>, but will wake the system if it is
suspended. The caller must have the <b>CAP_WAKE_ALARM</b>
capability in order to set a timer against this clock.</p>
<p style="margin-left:9%;"><b>CLOCK_TAI</b> (since Linux
3.10)</p>
<p style="margin-left:18%;">A system-wide clock derived
from wall-clock time but counting leap seconds.</p>
<p style="margin-left:9%; margin-top: 1em">See
<b>clock_getres</b>(2) for some further details on the above
clocks.</p>
<p style="margin-left:9%; margin-top: 1em">As well as the
above values, <i>clockid</i> can be specified as the
<i>clockid</i> returned by a call to
<b>clock_getcpuclockid</b>(3) or
<b>pthread_getcpuclockid</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">The <i>sevp</i>
argument points to a <i>sigevent</i> structure that
specifies how the caller should be notified when the timer
expires. For the definition and general details of this
structure, see <b>sigevent</b>(3type).</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>sevp.sigev_notify</i> field can have the following
values: <b><br/>
SIGEV_NONE</b></p>
<p style="margin-left:18%;">Don’t asynchronously
notify when the timer expires. Progress of the timer can be
monitored using <b>timer_gettime</b>(2).</p>
<p style="margin-left:9%;"><b>SIGEV_SIGNAL</b></p>
<p style="margin-left:18%;">Upon timer expiration, generate
the signal <i>sigev_signo</i> for the process. See
<b>sigevent</b>(3type) for general details. The
<i>si_code</i> field of the <i>siginfo_t</i> structure will
be set to <b>SI_TIMER</b>. At any point in time, at most one
signal is queued to the process for a given timer; see
<b>timer_getoverrun</b>(2) for more details.</p>
<p style="margin-left:9%;"><b>SIGEV_THREAD</b></p>
<p style="margin-left:18%;">Upon timer expiration, invoke
<i>sigev_notify_function</i> as if it were the start
function of a new thread. See <b>sigevent</b>(3type) for
details.</p>
<p style="margin-left:9%;"><b>SIGEV_THREAD_ID</b>
(Linux-specific)</p>
<p style="margin-left:18%;">As for <b>SIGEV_SIGNAL</b>, but
the signal is targeted at the thread whose ID is given in
<i>sigev_notify_thread_id</i>, which must be a thread in the
same process as the caller. The
<i>sigev_notify_thread_id</i> field specifies a kernel
thread ID, that is, the value returned by <b>clone</b>(2) or
<b>gettid</b>(2). This flag is intended only for use by
threading libraries.</p>
<p style="margin-left:9%; margin-top: 1em">Specifying
<i>sevp</i> as NULL is equivalent to specifying a pointer to
a <i>sigevent</i> structure in which <i>sigev_notify</i> is
<b>SIGEV_SIGNAL</b>, <i>sigev_signo</i> is <b>SIGALRM</b>,
and <i>sigev_value.sival_int</i> is the timer ID.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On success,
<b>timer_create</b>() returns 0, and the ID of the new timer
is placed in <i>*timerid</i>. On failure, −1 is
returned, and <i>errno</i> is set to indicate the error.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><b>EAGAIN</b></p></td>
<td width="1%"></td>
<td width="82%">
<p style="margin-top: 1em">Temporary error during kernel
allocation of timer structures.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>Clock ID, <i>sigev_notify</i>, <i>sigev_signo</i>, or
<i>sigev_notify_thread_id</i> is invalid.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOMEM</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>Could not allocate memory.</p></td></tr>
</table>
<p style="margin-left:9%;"><b>ENOTSUP</b></p>
<p style="margin-left:18%;">The kernel does not support
creating a timer against this <i>clockid</i>.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="6%">
<p><b>EPERM</b></p></td>
<td width="3%"></td>
<td width="82%">
<p><i>clockid</i> was <b>CLOCK_REALTIME_ALARM</b> or
<b>CLOCK_BOOTTIME_ALARM</b> but the caller did not have the
<b>CAP_WAKE_ALARM</b> capability.</p></td></tr>
</table>
<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>
<h3>C library/kernel differences
<a name="C library/kernel differences"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Part of the
implementation of the POSIX timers API is provided by glibc.
In particular:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">Much of the functionality for
<b>SIGEV_THREAD</b> is implemented within glibc, rather than
the kernel. (This is necessarily so, since the thread
involved in handling the notification is one that must be
managed by the C library POSIX threads implementation.)
Although the notification delivered to the process is via a
thread, internally the NPTL implementation uses a
<i>sigev_notify</i> value of <b>SIGEV_THREAD_ID</b> along
with a real-time signal that is reserved by the
implementation (see <b>nptl</b>(7)).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>The implementation of the default case where <i>evp</i>
is NULL is handled inside glibc, which invokes the
underlying system call with a suitably populated
<i>sigevent</i> structure.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>The timer IDs presented at user level are maintained by
glibc, which maps these IDs to the timer IDs employed by the
kernel.</p> </td></tr>
</table>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2008.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux 2.6.
POSIX.1-2001.</p>
<p style="margin-left:9%; margin-top: 1em">Prior to Linux
2.6, glibc provided an incomplete user-space implementation
(<b>CLOCK_REALTIME</b> timers only) using POSIX threads, and
before glibc 2.17, the implementation falls back to this
technique on systems running kernels older than Linux
2.6.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">A program may
create multiple interval timers using
<b>timer_create</b>().</p>
<p style="margin-left:9%; margin-top: 1em">Timers are not
inherited by the child of a <b>fork</b>(2), and are disarmed
and deleted during an <b>execve</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em">The kernel
preallocates a "queued real-time signal" for each
timer created using <b>timer_create</b>(). Consequently, the
number of timers is limited by the <b>RLIMIT_SIGPENDING</b>
resource limit (see <b>setrlimit</b>(2)).</p>
<p style="margin-left:9%; margin-top: 1em">The timers
created by <b>timer_create</b>() are commonly known as
"POSIX (interval) timers". The POSIX timers API
consists of the following interfaces: <b><br/>
timer_create</b>()</p>
<p style="margin-left:18%;">Create a timer.</p>
<p style="margin-left:9%;"><b>timer_settime</b>(2)</p>
<p style="margin-left:18%;">Arm (start) or disarm (stop) a
timer.</p>
<p style="margin-left:9%;"><b>timer_gettime</b>(2)</p>
<p style="margin-left:18%;">Fetch the time remaining until
the next expiration of a timer, along with the interval
setting of the timer.</p>
<p style="margin-left:9%;"><b>timer_getoverrun</b>(2)</p>
<p style="margin-left:18%;">Return the overrun count for
the last timer expiration.</p>
<p style="margin-left:9%;"><b>timer_delete</b>(2)</p>
<p style="margin-left:18%;">Disarm and delete a timer.</p>
<p style="margin-left:9%; margin-top: 1em">Since Linux
3.10, the <i>/proc/</i>pid<i>/timers</i> file can be used to
list the POSIX timers for the process with PID <i>pid</i>.
See <b>proc</b>(5) for further information.</p>
<p style="margin-left:9%; margin-top: 1em">Since Linux
4.10, support for POSIX timers is a configurable option that
is enabled by default. Kernel support can be disabled via
the <b>CONFIG_POSIX_TIMERS</b> option.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The program
below takes two arguments: a sleep period in seconds, and a
timer frequency in nanoseconds. The program establishes a
handler for the signal it uses for the timer, blocks that
signal, creates and arms a timer that expires with the given
frequency, sleeps for the specified number of seconds, and
then unblocks the timer signal. Assuming that the timer
expired at least once while the program slept, the signal
handler will be invoked, and the handler displays some
information about the timer notification. The program
terminates after one invocation of the signal handler.</p>
<p style="margin-left:9%; margin-top: 1em">In the following
example run, the program sleeps for 1 second, after creating
a timer that has a frequency of 100 nanoseconds. By the time
the signal is unblocked and delivered, there have been
around ten million overruns.</p>
<p style="margin-left:14%; margin-top: 1em">$ <b>./a.out 1
100</b> <br/>
Establishing handler for signal 34 <br/>
Blocking signal 34 <br/>
timer ID is 0x804c008 <br/>
Sleeping for 1 seconds <br/>
Unblocking signal 34 <br/>
Caught signal 34 <br/>
sival_ptr = 0xbfb174f4; *sival_ptr = 0x804c008 <br/>
overrun count = 10004886</p>
<h3>Program source
<a name="Program source"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;signal.h&gt; <br/>
#include &lt;stdint.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;time.h&gt; <br/>
#include &lt;unistd.h&gt; <br/>
#define CLOCKID CLOCK_REALTIME <br/>
#define SIG SIGRTMIN <br/>
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
<br/>
} while (0) <br/>
static void <br/>
print_siginfo(siginfo_t *si) <br/>
{ <br/>
int or; <br/>
timer_t *tidp; <br/>
tidp = si−&gt;si_value.sival_ptr; <br/>
printf(" sival_ptr = %p; ",
si−&gt;si_value.sival_ptr); <br/>
printf(" *sival_ptr = %#jx\n", (uintmax_t) *tidp);
<br/>
or = timer_getoverrun(*tidp); <br/>
if (or == −1) <br/>
errExit("timer_getoverrun"); <br/>
else <br/>
printf(" overrun count = %d\n", or); <br/>
} <br/>
static void <br/>
handler(int sig, siginfo_t *si, void *uc) <br/>
{ <br/>
/* Note: calling printf() from a signal handler is not safe
<br/>
(and should not be done in production programs), since <br/>
printf() is not async−signal−safe; see
signal−safety(7). <br/>
Nevertheless, we use printf() here as a simple way of <br/>
showing that the handler was called. */ <br/>
printf("Caught signal %d\n", sig); <br/>
print_siginfo(si); <br/>
signal(sig, SIG_IGN); <br/>
} <br/>
int <br/>
main(int argc, char *argv[]) <br/>
{ <br/>
timer_t timerid; <br/>
sigset_t mask; <br/>
long long freq_nanosecs; <br/>
struct sigevent sev; <br/>
struct sigaction sa; <br/>
struct itimerspec its; <br/>
if (argc != 3) { <br/>
fprintf(stderr, "Usage: %s &lt;sleep−secs&gt;
&lt;freq−nanosecs&gt;\n", <br/>
argv[0]); <br/>
exit(EXIT_FAILURE); <br/>
} <br/>
/* Establish handler for timer signal. */ <br/>
printf("Establishing handler for signal %d\n",
SIG); <br/>
sa.sa_flags = SA_SIGINFO; <br/>
sa.sa_sigaction = handler; <br/>
sigemptyset(&amp;sa.sa_mask); <br/>
if (sigaction(SIG, &amp;sa, NULL) == −1) <br/>
errExit("sigaction"); <br/>
/* Block timer signal temporarily. */ <br/>
printf("Blocking signal %d\n", SIG); <br/>
sigemptyset(&amp;mask); <br/>
sigaddset(&amp;mask, SIG); <br/>
if (sigprocmask(SIG_SETMASK, &amp;mask, NULL) == −1)
<br/>
errExit("sigprocmask"); <br/>
/* Create the timer. */ <br/>
sev.sigev_notify = SIGEV_SIGNAL; <br/>
sev.sigev_signo = SIG; <br/>
sev.sigev_value.sival_ptr = &amp;timerid; <br/>
if (timer_create(CLOCKID, &amp;sev, &amp;timerid) ==
−1) <br/>
errExit("timer_create"); <br/>
printf("timer ID is %#jx\n", (uintmax_t) timerid);
<br/>
/* Start the timer. */ <br/>
freq_nanosecs = atoll(argv[2]); <br/>
its.it_value.tv_sec = freq_nanosecs / 1000000000; <br/>
its.it_value.tv_nsec = freq_nanosecs % 1000000000; <br/>
its.it_interval.tv_sec = its.it_value.tv_sec; <br/>
its.it_interval.tv_nsec = its.it_value.tv_nsec; <br/>
if (timer_settime(timerid, 0, &amp;its, NULL) == −1)
<br/>
errExit("timer_settime"); <br/>
/* Sleep for a while; meanwhile, the timer may expire <br/>
multiple times. */ <br/>
printf("Sleeping for %d seconds\n",
atoi(argv[1])); <br/>
sleep(atoi(argv[1])); <br/>
/* Unlock the timer signal, so that timer notification <br/>
can be delivered. */ <br/>
printf("Unblocking signal %d\n", SIG); <br/>
if (sigprocmask(SIG_UNBLOCK, &amp;mask, NULL) == −1)
<br/>
errExit("sigprocmask"); <br/>
exit(EXIT_SUCCESS); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>clock_gettime</b>(2),
<b>setitimer</b>(2), <b>timer_delete</b>(2),
<b>timer_getoverrun</b>(2), <b>timer_settime</b>(2),
<b>timerfd_create</b>(2), <b>clock_getcpuclockid</b>(3),
<b>pthread_getcpuclockid</b>(3), <b>pthreads</b>(7),
<b>sigevent</b>(3type), <b>signal</b>(7), <b>time</b>(7)</p>
<hr/>
</body>
</html>
