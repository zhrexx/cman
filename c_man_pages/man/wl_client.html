<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:54:51 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>wl_client</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">wl_client</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Public Member Functions">Public Member Functions</a><br/>
<a href="#Data Fields">Data Fields</a><br/>
<a href="#Member Function Documentation">Member Function Documentation</a><br/>
<a href="#void wl_client_add_destroy_late_listener (struct wl_client * client, structwl_listener * listener)">void wl_client_add_destroy_late_listener (struct wl_client * client, structwl_listener * listener)</a><br/>
<a href="#void wl_client_add_destroy_listener (struct wl_client * client, structwl_listener * listener)">void wl_client_add_destroy_listener (struct wl_client * client, structwl_listener * listener)</a><br/>
<a href="#void wl_client_add_resource_created_listener (struct wl_client * client,struct wl_listener * listener)">void wl_client_add_resource_created_listener (struct wl_client * client,struct wl_listener * listener)</a><br/>
<a href="#void wl_client_flush (struct wl_client * client)">void wl_client_flush (struct wl_client * client)</a><br/>
<a href="#void wl_client_for_each_resource (struct wl_client * client,wl_client_for_each_resource_iterator_func_t iterator, void * user_data)">void wl_client_for_each_resource (struct wl_client * client,wl_client_for_each_resource_iterator_func_t iterator, void * user_data)</a><br/>
<a href="#struct wl_client * wl_client_from_link (struct wl_list * link)">struct wl_client * wl_client_from_link (struct wl_list * link)</a><br/>
<a href="#void wl_client_get_credentials (struct wl_client * client, pid_t * pid,uid_t * uid, gid_t * gid)">void wl_client_get_credentials (struct wl_client * client, pid_t * pid,uid_t * uid, gid_t * gid)</a><br/>
<a href="#struct wl_display * wl_client_get_display (struct wl_client * client)">struct wl_display * wl_client_get_display (struct wl_client * client)</a><br/>
<a href="#int wl_client_get_fd (struct wl_client * client)">int wl_client_get_fd (struct wl_client * client)</a><br/>
<a href="#struct wl_list * wl_client_get_link (struct wl_client * client)">struct wl_list * wl_client_get_link (struct wl_client * client)</a><br/>
<a href="#struct wl_resource * wl_client_get_object (struct wl_client * client,uint32_t id)">struct wl_resource * wl_client_get_object (struct wl_client * client,uint32_t id)</a><br/>
<a href="#void wl_client_post_implementation_error (struct wl_client * client, charconst * msg, ...)">void wl_client_post_implementation_error (struct wl_client * client, charconst * msg, ...)</a><br/>
<a href="#void wl_client_set_max_buffer_size (struct wl_client * client, size_tmax_buffer_size)">void wl_client_set_max_buffer_size (struct wl_client * client, size_tmax_buffer_size)</a><br/>
<a href="#Field Documentation">Field Documentation</a><br/>
<a href="#struct wl_connection* wl_client::connection">struct wl_connection* wl_client::connection</a><br/>
<a href="#void* wl_client::data">void* wl_client::data</a><br/>
<a href="#wl_user_data_destroy_func_t wl_client::data_dtor">wl_user_data_destroy_func_t wl_client::data_dtor</a><br/>
<a href="#struct wl_priv_signal wl_client::destroy_late_signal">struct wl_priv_signal wl_client::destroy_late_signal</a><br/>
<a href="#struct wl_priv_signal wl_client::destroy_signal">struct wl_priv_signal wl_client::destroy_signal</a><br/>
<a href="#struct wl_display* wl_client::display">struct wl_display* wl_client::display</a><br/>
<a href="#struct wl_resource* wl_client::display_resource">struct wl_resource* wl_client::display_resource</a><br/>
<a href="#bool wl_client::error">bool wl_client::error</a><br/>
<a href="#gid_t wl_client::gid">gid_t wl_client::gid</a><br/>
<a href="#struct wl_list wl_client::link">struct wl_list wl_client::link</a><br/>
<a href="#struct wl_map wl_client::objects">struct wl_map wl_client::objects</a><br/>
<a href="#pid_t wl_client::pid">pid_t wl_client::pid</a><br/>
<a href="#struct wl_priv_signal wl_client::resource_created_signal">struct wl_priv_signal wl_client::resource_created_signal</a><br/>
<a href="#struct wl_event_source* wl_client::source">struct wl_event_source* wl_client::source</a><br/>
<a href="#uid_t wl_client::uid">uid_t wl_client::uid</a><br/>
<a href="#Author">Author</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">wl_client</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<h3>Public Member Functions
<a name="Public Member Functions"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">void
<b>wl_client_flush</b> (struct <b>wl_client</b> *client)
<br/>
struct <b>wl_display</b> * <b>wl_client_get_display</b>
(struct <b>wl_client</b> *client) <br/>
void <b>wl_client_get_credentials</b> (struct
<b>wl_client</b> *client, pid_t *<b>pid</b>, uid_t
*<b>uid</b>, gid_t *<b>gid</b>) <br/>
int <b>wl_client_get_fd</b> (struct <b>wl_client</b>
*client) <br/>
struct <b>wl_resource</b> * <b>wl_client_get_object</b>
(struct <b>wl_client</b> *client, uint32_t id) <br/>
void <b>wl_client_post_implementation_error</b> (struct
<b>wl_client</b> *client, char const *msg,...) <br/>
void <b>wl_client_add_destroy_listener</b> (struct
<b>wl_client</b> *client, struct <b>wl_listener</b>
*listener) <br/>
void <b>wl_client_add_destroy_late_listener</b> (struct
<b>wl_client</b> *client, struct <b>wl_listener</b>
*listener) <br/>
struct <b>wl_list</b> * <b>wl_client_get_link</b> (struct
<b>wl_client</b> *client) <br/>
struct <b>wl_client</b> * <b>wl_client_from_link</b> (struct
<b>wl_list</b> *<b>link</b>) <br/>
void <b>wl_client_add_resource_created_listener</b> (struct
<b>wl_client</b> *client, struct <b>wl_listener</b>
*listener) <br/>
void <b>wl_client_for_each_resource</b> (struct
<b>wl_client</b> *client,
<b>wl_client_for_each_resource_iterator_func_t</b> iterator,
void *user_data) <br/>
void <b>wl_client_set_max_buffer_size</b> (struct
<b>wl_client</b> *client, size_t max_buffer_size)</p>
<h3>Data Fields
<a name="Data Fields"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">struct
wl_connection * <b>connection</b> <br/>
struct <b>wl_event_source</b> * <b>source</b> <br/>
struct <b>wl_display</b> * <b>display</b> <br/>
struct <b>wl_resource</b> * <b>display_resource</b> <br/>
struct <b>wl_list link</b> <br/>
struct wl_map <b>objects</b> <br/>
struct wl_priv_signal <b>destroy_signal</b> <br/>
struct wl_priv_signal <b>destroy_late_signal</b> <br/>
pid_t <b>pid</b> <br/>
uid_t <b>uid</b> <br/>
gid_t <b>gid</b> <br/>
bool <b>error</b> <br/>
struct wl_priv_signal <b>resource_created_signal</b> <br/>
void * <b>data <br/>
wl_user_data_destroy_func_t data_dtor</b></p>
<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>
<h3>void wl_client_add_destroy_late_listener (struct wl_client * client, structwl_listener * listener)
<a name="void wl_client_add_destroy_late_listener (struct wl_client * client, structwl_listener * listener)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Add a listener
to be called at the end of <b>wl_client</b> destruction</p>
<p style="margin-left:9%; margin-top: 1em">The listener
provided will be called when <b>wl_client</b> destroy is
nearly complete, after all of that client’s resources
have been destroyed.</p>
<p style="margin-left:9%; margin-top: 1em">There is no
requirement to remove the link of the <b>wl_listener</b>
when the signal is emitted.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.22.0</p>
<h3>void wl_client_add_destroy_listener (struct wl_client * client, structwl_listener * listener)
<a name="void wl_client_add_destroy_listener (struct wl_client * client, structwl_listener * listener)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Add a listener
to be called at the beginning of <b>wl_client</b>
destruction</p>
<p style="margin-left:9%; margin-top: 1em">The listener
provided will be called when <b>wl_client</b> destroy has
begun, before any of that client’s resources have been
destroyed.</p>
<p style="margin-left:9%; margin-top: 1em">There is no
requirement to remove the link of the <b>wl_listener</b>
when the signal is emitted.</p>
<h3>void wl_client_add_resource_created_listener (struct wl_client * client,struct wl_listener * listener)
<a name="void wl_client_add_resource_created_listener (struct wl_client * client,struct wl_listener * listener)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Add a listener
for the client’s resource creation signal</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client object
<i><br/>
listener</i> The listener to be added</p>
<p style="margin-left:9%; margin-top: 1em">When a new
resource is created for this client the listener will be
notified, carrying the new resource as the data
argument.</p>
<h3>void wl_client_flush (struct wl_client * client)
<a name="void wl_client_flush (struct wl_client * client)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Flush pending
events to the client</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client
object</p>
<p style="margin-left:9%; margin-top: 1em">Events sent to
clients are queued in a buffer and written to the socket
later - typically when the compositor has handled all
requests and goes back to block in the event loop. This
function flushes all queued up events for a client
immediately.</p>
<h3>void wl_client_for_each_resource (struct wl_client * client,wl_client_for_each_resource_iterator_func_t iterator, void * user_data)
<a name="void wl_client_for_each_resource (struct wl_client * client,wl_client_for_each_resource_iterator_func_t iterator, void * user_data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Iterate over all
the resources of a client</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client object
<i><br/>
iterator</i> The iterator function <i><br/>
user_data</i> The user data pointer</p>
<p style="margin-left:9%; margin-top: 1em">The function
pointed by <i>iterator</i> will be called for each resource
owned by the client. The <i>user_data</i> will be passed as
the second argument of the iterator function. If the
<i>iterator</i> function returns <i>WL_ITERATOR_CONTINUE</i>
the iteration will continue, if it returns
<i>WL_ITERATOR_STOP</i> it will stop.</p>
<p style="margin-left:9%; margin-top: 1em">Creating and
destroying resources while iterating is safe, but new
resources may or may not be picked up by the iterator.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_iterator_result</b></p>
<h3>struct wl_client * wl_client_from_link (struct wl_list * link)
<a name="struct wl_client * wl_client_from_link (struct wl_list * link)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get a
<b>wl_client</b> by its link</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>link</i> The link of a
<b>wl_client</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_client_for_each()</b></p>
<p style="margin-left:14%; margin-top: 1em"><b>wl_display_get_client_list()</b></p>
<p style="margin-left:14%; margin-top: 1em"><b>wl_client_get_link()</b></p>
<h3>void wl_client_get_credentials (struct wl_client * client, pid_t * pid,uid_t * uid, gid_t * gid)
<a name="void wl_client_get_credentials (struct wl_client * client, pid_t * pid,uid_t * uid, gid_t * gid)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Return Unix
credentials for the client</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The display
object <i><br/>
pid</i> Returns the process ID <i><br/>
uid</i> Returns the user ID <i><br/>
gid</i> Returns the group ID</p>
<p style="margin-left:9%; margin-top: 1em">This function
returns the process ID, the user ID and the group ID for the
given client. The credentials come from getsockopt() with
SO_PEERCRED, on the client socket fd. All the pointers can
be NULL, if the caller is not interested in a particular
ID.</p>
<p style="margin-left:9%; margin-top: 1em">Note, process
IDs are subject to race conditions and are not a reliable
way to identify a client.</p>
<p style="margin-left:9%; margin-top: 1em">Be aware that
for clients that a compositor forks and execs and then
connects using socketpair(), this function will return the
credentials for the compositor. The credentials for the
socketpair are set at creation time in the compositor.</p>
<h3>struct wl_display * wl_client_get_display (struct wl_client * client)
<a name="struct wl_display * wl_client_get_display (struct wl_client * client)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the display
object for the given client</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The display object the client
is associated with.</p>
<h3>int wl_client_get_fd (struct wl_client * client)
<a name="int wl_client_get_fd (struct wl_client * client)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the file
descriptor for the client</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The display
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The file descriptor to use for
the connection</p>
<p style="margin-left:9%; margin-top: 1em">This function
returns the file descriptor for the given client.</p>
<p style="margin-left:9%; margin-top: 1em">Be sure to use
the file descriptor from the client for inspection only. If
the caller does anything to the file descriptor that changes
its state, it will likely cause problems.</p>
<p style="margin-left:9%; margin-top: 1em">See also
<b>wl_client_get_credentials()</b>. It is recommended that
you evaluate whether <b>wl_client_get_credentials()</b> can
be applied to your use case instead of this function.</p>
<p style="margin-left:9%; margin-top: 1em">If you would
like to distinguish just between the client and the
compositor itself from the client’s request, it can be
done by getting the client credentials and by checking the
PID of the client and the compositor’s PID. Regarding
the case in which the socketpair() is being used, you need
to be careful. Please note the documentation for
<b>wl_client_get_credentials()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">This function
can be used for a compositor to validate a request from a
client if there are additional information provided from the
client’s file descriptor. For instance, suppose you
can get the security contexts from the client’s file
descriptor. The compositor can validate the client’s
request with the contexts and make a decision whether it
permits or deny it.</p>
<h3>struct wl_list * wl_client_get_link (struct wl_client * client)
<a name="struct wl_list * wl_client_get_link (struct wl_client * client)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the link by
which a client is inserted in the client list</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_client_for_each()</b></p>
<p style="margin-left:14%; margin-top: 1em"><b>wl_display_get_client_list()</b></p>
<p style="margin-left:14%; margin-top: 1em"><b>wl_client_from_link()</b></p>
<h3>struct wl_resource * wl_client_get_object (struct wl_client * client,uint32_t id)
<a name="struct wl_resource * wl_client_get_object (struct wl_client * client,uint32_t id)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Look up an
object in the client name space</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client object
<i><br/>
id</i> The object id</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The object or NULL if there is
not object for the given ID</p>
<p style="margin-left:9%; margin-top: 1em">This looks up an
object in the client object name space by its object ID.</p>
<h3>void wl_client_post_implementation_error (struct wl_client * client, charconst * msg, ...)
<a name="void wl_client_post_implementation_error (struct wl_client * client, charconst * msg, ...)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Report an
internal server error</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client object
<i><br/>
msg</i> A printf-style format string <i><br/>
...</i> Format string arguments</p>
<p style="margin-left:9%; margin-top: 1em">Report an
unspecified internal implementation error and disconnect the
client.</p>
<h3>void wl_client_set_max_buffer_size (struct wl_client * client, size_tmax_buffer_size)
<a name="void wl_client_set_max_buffer_size (struct wl_client * client, size_tmax_buffer_size)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Adjust the
maximum size of the client connection buffers</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>client</i> The client object
<i><br/>
max_buffer_size</i> The maximum size of the connection
buffers</p>
<p style="margin-left:9%; margin-top: 1em">The actual size
of the connection buffers is a power of two, the requested
<i>max_buffer_size</i> is therefore rounded up to the
nearest power of two value.</p>
<p style="margin-left:9%; margin-top: 1em">Lowering the
maximum size may not take effect immediately if the current
content of the buffer does not fit within the new size
limit.</p>
<p style="margin-left:9%; margin-top: 1em">The minimum
buffer size is 4096. The default buffers size can be set
using <b>wl_display_set_default_max_buffer_size()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_set_default_max_buffer_size()</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.22.90</p>
<h2>Field Documentation
<a name="Field Documentation"></a>
</h2>
<h3>struct wl_connection* wl_client::connection
<a name="struct wl_connection* wl_client::connection"></a>
</h3>
<h3>void* wl_client::data
<a name="void* wl_client::data"></a>
</h3>
<h3>wl_user_data_destroy_func_t wl_client::data_dtor
<a name="wl_user_data_destroy_func_t wl_client::data_dtor"></a>
</h3>
<h3>struct wl_priv_signal wl_client::destroy_late_signal
<a name="struct wl_priv_signal wl_client::destroy_late_signal"></a>
</h3>
<h3>struct wl_priv_signal wl_client::destroy_signal
<a name="struct wl_priv_signal wl_client::destroy_signal"></a>
</h3>
<h3>struct wl_display* wl_client::display
<a name="struct wl_display* wl_client::display"></a>
</h3>
<h3>struct wl_resource* wl_client::display_resource
<a name="struct wl_resource* wl_client::display_resource"></a>
</h3>
<h3>bool wl_client::error
<a name="bool wl_client::error"></a>
</h3>
<h3>gid_t wl_client::gid
<a name="gid_t wl_client::gid"></a>
</h3>
<h3>struct wl_list wl_client::link
<a name="struct wl_list wl_client::link"></a>
</h3>
<h3>struct wl_map wl_client::objects
<a name="struct wl_map wl_client::objects"></a>
</h3>
<h3>pid_t wl_client::pid
<a name="pid_t wl_client::pid"></a>
</h3>
<h3>struct wl_priv_signal wl_client::resource_created_signal
<a name="struct wl_priv_signal wl_client::resource_created_signal"></a>
</h3>
<h3>struct wl_event_source* wl_client::source
<a name="struct wl_event_source* wl_client::source"></a>
</h3>
<h3>uid_t wl_client::uid
<a name="uid_t wl_client::uid"></a>
</h3>
<h2>Author
<a name="Author"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated
automatically by Doxygen for Wayland from the source
code.</p>
<hr/>
</body>
</html>
