<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:41:08 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Test</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Test</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#QUICK START GUIDE">QUICK START GUIDE</a><br/>
<a href="#Functions">Functions</a><br/>
<a href="#TEST TYPES">TEST TYPES</a><br/>
<a href="#ONFAIL">ONFAIL</a><br/>
<a href="#BUGS and CAVEATS">BUGS and CAVEATS</a><br/>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br/>
<a href="#NOTE">NOTE</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Test −
provides a simple framework for writing test scripts</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use Test; <br/>
# use a BEGIN block so we print our plan before MyModule is
loaded <br/>
BEGIN { plan tests =&gt; 14, todo =&gt; [3,4] } <br/>
# load your module... <br/>
use MyModule; <br/>
# Helpful notes. All note−lines must start with a
"#". <br/>
print "# I'm testing MyModule version
$MyModule::VERSION\n"; <br/>
ok(0); # failure <br/>
ok(1); # success <br/>
ok(0); # ok, expected failure (see todo list, above) <br/>
ok(1); # surprise success! <br/>
ok(0,1); # failure: '0' ne '1' <br/>
ok('broke','fixed'); # failure: 'broke' ne 'fixed' <br/>
ok('fixed','fixed'); # success: 'fixed' eq 'fixed' <br/>
ok('fixed',qr/x/); # success: 'fixed' =˜ qr/x/ <br/>
ok(sub { 1+1 }, 2); # success: '2' eq '2' <br/>
ok(sub { 1+1 }, 3); # failure: '2' ne '3' <br/>
my @list = (0,0); <br/>
ok @list, 3, "\@list=".join(',',@list); #extra
notes <br/>
ok 'segmentation fault', '/(?i)success/'; #regex match <br/>
skip( <br/>
$ˆO =˜ m/MSWin/ ? "Skip if MSWin" : 0, #
whether to skip <br/>
$foo, $bar # arguments just like for ok(...) <br/>
); <br/>
skip( <br/>
$ˆO =˜ m/MSWin/ ? 0 : "Skip unless
MSWin", # whether to skip <br/>
$foo, $bar # arguments just like for ok(...) <br/>
);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module
simplifies the task of writing test files for Perl modules,
such that their output is in the format that Test::Harness
expects to see.</p>
<h2>QUICK START GUIDE
<a name="QUICK START GUIDE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">To write a test
for your new (and probably not even done) module, create a
new file called <i>t/test.t</i> (in a new <i>t</i>
directory). If you have multiple test files, to test the
"foo", "bar", and "baz"
feature sets, then feel free to call your files
<i>t/foo.t</i>, <i>t/bar.t</i>, and <i>t/baz.t</i></p>
<h3>Functions
<a name="Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This module
defines three public functions, plan(...), ok(...), and
skip(...). By default, all three are exported by the
"use Test;" statement. <br/>
plan(...)</p>
<p style="margin-left:14%;">BEGIN { plan %theplan; }</p>
<p style="margin-left:14%; margin-top: 1em">This should be
the first thing you call in your test script. It declares
your testing plan, how many there will be, if any of them
should be allowed to fail, and so on.</p>
<p style="margin-left:14%; margin-top: 1em">Typical usage
is just:</p>
<p style="margin-left:14%; margin-top: 1em">use Test; <br/>
BEGIN { plan tests =&gt; 23 }</p>
<p style="margin-left:14%; margin-top: 1em">These are the
things that you can put in the parameters to plan: <br/>
"tests =&gt; <i>number</i>"</p>
<p style="margin-left:19%;">The number of tests in your
script. This means all <b>ok()</b> and <b>skip()</b>
calls.</p>
<p style="margin-left:14%;">"todo =&gt;
[<i>1,5,14</i>]"</p>
<p style="margin-left:19%;">A reference to a list of tests
which are allowed to fail. See "TODO TESTS".</p>
<p style="margin-left:14%;">"onfail =&gt; sub { ...
}" <br/>
"onfail =&gt; \&amp;some_sub"</p>
<p style="margin-left:19%;">A subroutine reference to be
run at the end of the test script, if any of the tests fail.
See "ONFAIL".</p>
<p style="margin-left:14%; margin-top: 1em">You must call
plan(...) once and only once. You should call it in a
"BEGIN {...}" block, like so:</p>
<p style="margin-left:14%; margin-top: 1em">BEGIN { plan
tests =&gt; 23 }</p>
<p style="margin-left:9%;">ok(...)</p>
<p style="margin-left:14%;">ok(1 + 1 == 2); <br/>
ok($have, $expect); <br/>
ok($have, $expect, $diagnostics);</p>
<p style="margin-left:14%; margin-top: 1em">This function
is the reason for "Test"’s existence.
It’s the basic function that handles printing
""ok"" or ""not
ok"", along with the current test number.
(That’s what "Test::Harness" wants to
see.)</p>
<p style="margin-left:14%; margin-top: 1em">In its most
basic usage, ok(...) simply takes a single scalar
expression. If its value is true, the test passes; if false,
the test fails. Examples:</p>
<p style="margin-left:14%; margin-top: 1em"># Examples of
ok(scalar) <br/>
ok( 1 + 1 == 2 ); # ok if 1 + 1 == 2 <br/>
ok( $foo =˜ /bar/ ); # ok if $foo contains 'bar' <br/>
ok( baz($x + $y) eq 'Armondo' ); # ok if baz($x + $y)
returns <br/>
# 'Armondo' <br/>
ok( @a == @b ); # ok if @a and @b are the same <br/>
# length</p>
<p style="margin-left:14%; margin-top: 1em">The expression
is evaluated in scalar context. So the following will
work:</p>
<p style="margin-left:14%; margin-top: 1em">ok( @stuff ); #
ok if @stuff has any <br/>
# elements <br/>
ok( !grep !defined $_, @stuff ); # ok if everything in
@stuff <br/>
# is defined.</p>
<p style="margin-left:14%; margin-top: 1em">A special case
is if the expression is a subroutine reference (in either
"sub {...}" syntax or "\&amp;foo"
syntax). In that case, it is executed and its value (true or
false) determines if the test passes or fails. For
example,</p>
<p style="margin-left:14%; margin-top: 1em">ok( sub { # See
whether sleep works at least passably <br/>
my $start_time = time; <br/>
sleep 5; <br/>
time() − $start_time &gt;= 4 <br/>
});</p>
<p style="margin-left:14%; margin-top: 1em">In its
two-argument form, "ok(<i>arg1</i>, <i>arg2</i>)"
compares the two scalar values to see if they match. They
match if both are undefined, or if <i>arg2</i> is a regex
that matches <i>arg1</i>, or if they compare equal with
"eq".</p>
<p style="margin-left:14%; margin-top: 1em"># Example of
ok(scalar, scalar) <br/>
ok( "this", "that" ); # not ok, 'this'
ne 'that' <br/>
ok( "", undef ); # not ok, "" is
defined</p>
<p style="margin-left:14%; margin-top: 1em">The second
argument is considered a regex if it is either a regex
object or a string that looks like a regex. Regex objects
are constructed with the qr// operator in recent versions of
perl. A string is considered to look like a regex if its
first and last characters are "/", or if the first
character is "m" and its second and last
characters are both the same non-alphanumeric non-whitespace
character. These regexp</p>
<p style="margin-left:14%; margin-top: 1em">Regex
examples:</p>
<p style="margin-left:14%; margin-top: 1em">ok( 'JaffO',
'/Jaff/' ); # ok, 'JaffO' =˜ /Jaff/ <br/>
ok( 'JaffO', 'm|Jaff|' ); # ok, 'JaffO' =˜ m|Jaff| <br/>
ok( 'JaffO', qr/Jaff/ ); # ok, 'JaffO' =˜ qr/Jaff/;
<br/>
ok( 'JaffO', '/(?i)jaff/ ); # ok, 'JaffO' =˜
/jaff/i;</p>
<p style="margin-left:14%; margin-top: 1em">If either (or
both!) is a subroutine reference, it is run and used as the
value for comparing. For example:</p>
<p style="margin-left:14%; margin-top: 1em">ok sub { <br/>
open(OUT, '&gt;', 'x.dat') || die $!; <br/>
print OUT "\x{e000}"; <br/>
close OUT; <br/>
my $bytecount = −s 'x.dat'; <br/>
unlink 'x.dat' or warn "Can't unlink : $!"; <br/>
return $bytecount; <br/>
}, <br/>
4 <br/>
;</p>
<p style="margin-left:14%; margin-top: 1em">The above test
passes two values to "ok(arg1, arg2)"
−− the first a coderef, and the second is the
number 4. Before "ok" compares them, it calls the
coderef, and uses its return value as the real value of this
parameter. Assuming that $bytecount returns 4,
"ok" ends up testing "4 eq 4". Since
that’s true, this test passes.</p>
<p style="margin-left:14%; margin-top: 1em">Finally, you
can append an optional third argument, in
"ok(<i>arg1</i>,<i>arg2</i>, <i>note</i>)", where
<i>note</i> is a string value that will be printed if the
test fails. This should be some useful information about the
test, pertaining to why it failed, and/or a description of
the test. For example:</p>
<p style="margin-left:14%; margin-top: 1em">ok( grep($_ eq
'something unique', @stuff), 1, <br/>
"Something that should be unique isn't!\n". <br/>
'@stuff = '.join ', ', @stuff <br/>
);</p>
<p style="margin-left:14%; margin-top: 1em">Unfortunately,
a note cannot be used with the single argument style of
ok(). That is, if you try "ok(<i>arg1</i>,
<i>note</i>)", then "Test" will interpret
this as "ok(<i>arg1</i>, <i>arg2</i>)", and
probably end up testing "<i>arg1</i> eq
<i>arg2</i>" −− and that’s not what
you want!</p>
<p style="margin-left:14%; margin-top: 1em">All of the
above special cases can occasionally cause some problems.
See "BUGS and CAVEATS".</p>
<p style="margin-left:9%;">"skip(<i>skip_if_true</i>,
<i>args...</i>)"</p>
<p style="margin-left:14%;">This is used for tests that
under some conditions can be skipped. It’s basically
equivalent to:</p>
<p style="margin-left:14%; margin-top: 1em">if(
$skip_if_true ) { <br/>
ok(1); <br/>
} else { <br/>
ok( args... ); <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">...except that
the ok(1) emits not just ""ok
<i>testnum</i>"" but actually ""ok
<i>testnum</i> # <i>skip_if_true_value</i>"".</p>
<p style="margin-left:14%; margin-top: 1em">The arguments
after the <i>skip_if_true</i> are what is fed to ok(...) if
this test isn’t skipped.</p>
<p style="margin-left:14%; margin-top: 1em">Example
usage:</p>
<p style="margin-left:14%; margin-top: 1em">my $if_MSWin =
<br/>
$ˆO =˜ m/MSWin/ ? 'Skip if under MSWin' : ''; <br/>
# A test to be skipped if under MSWin (i.e., run except
under <br/>
# MSWin) <br/>
skip($if_MSWin, thing($foo), thing($bar) );</p>
<p style="margin-left:14%; margin-top: 1em">Or, going the
other way:</p>
<p style="margin-left:14%; margin-top: 1em">my
$unless_MSWin = <br/>
$ˆO =˜ m/MSWin/ ? '' : 'Skip unless under MSWin';
<br/>
# A test to be skipped unless under MSWin (i.e., run only
under <br/>
# MSWin) <br/>
skip($unless_MSWin, thing($foo), thing($bar) );</p>
<p style="margin-left:14%; margin-top: 1em">The tricky
thing to remember is that the first parameter is true if you
want to <i>skip</i> the test, not <i>run</i> it; and it also
doubles as a note about why it’s being skipped. So in
the first codeblock above, read the code as "skip if
MSWin −− (otherwise) test whether thing($foo) is
thing($bar)" or for the second case, "skip unless
MSWin...".</p>
<p style="margin-left:14%; margin-top: 1em">Also, when your
<i>skip_if_reason</i> string is true, it really should (for
backwards compatibility with older Test.pm versions) start
with the string "Skip", as shown in the above
examples.</p>
<p style="margin-left:14%; margin-top: 1em">Note that in
the above cases, thing($foo) and thing($bar) <i>are</i>
evaluated −− but as long as the
"skip_if_true" is true, then we skip(...) just
tosses out their value (i.e., not bothering to treat them
like values to ok(...). But if you need to <i>not</i> eval
the arguments when skipping the test, use this format:</p>
<p style="margin-left:14%; margin-top: 1em">skip(
$unless_MSWin, <br/>
sub { <br/>
# This code returns true if the test passes. <br/>
# (But it doesn't even get called if the test is skipped.)
<br/>
thing($foo) eq thing($bar) <br/>
} <br/>
);</p>
<p style="margin-left:14%; margin-top: 1em">or even this,
which is basically equivalent:</p>
<p style="margin-left:14%; margin-top: 1em">skip(
$unless_MSWin, <br/>
sub { thing($foo) }, sub { thing($bar) } <br/>
);</p>
<p style="margin-left:14%; margin-top: 1em">That is, both
are like this:</p>
<p style="margin-left:14%; margin-top: 1em">if(
$unless_MSWin ) { <br/>
ok(1); # but it actually appends "# $unless_MSWin"
<br/>
# so that Test::Harness can tell it's a skip <br/>
} else { <br/>
# Not skipping, so actually call and evaluate... <br/>
ok( sub { thing($foo) }, sub { thing($bar) } ); <br/>
}</p>
<h2>TEST TYPES
<a name="TEST TYPES"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="15%">
<p style="margin-top: 1em">NORMAL TESTS</p></td>
<td width="71%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">These tests are
expected to succeed. Usually, most or all of your tests are
in this category. If a normal test doesn’t succeed,
then that means that something is <i>wrong</i>.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="17%">
<p style="margin-top: 1em">SKIPPED TESTS</p></td>
<td width="69%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">The skip(...)
function is for tests that might or might not be possible to
run, depending on the availability of platform-specific
features. The first argument should evaluate to true (think
"yes, please skip") if the required feature is
<i>not</i> available. After the first argument, skip(...)
works exactly the same way as ok(...) does.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="13%">
<p style="margin-top: 1em">TODO TESTS</p></td>
<td width="73%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">TODO tests are
designed for maintaining an <b>executable TODO list</b>.
These tests are <i>expected to fail.</i> If a TODO test does
succeed, then the feature in question shouldn’t be on
the TODO list, now should it?</p>
<p style="margin-left:14%; margin-top: 1em">Packages should
NOT be released with succeeding TODO tests. As soon as a
TODO test starts working, it should be promoted to a normal
test, and the newly working feature should be documented in
the release notes or in the change log.</p>
<h2>ONFAIL
<a name="ONFAIL"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">BEGIN { plan
test =&gt; 4, onfail =&gt; sub { warn "CALL 911!"
} }</p>
<p style="margin-left:9%; margin-top: 1em">Although test
failures should be enough, extra diagnostics can be
triggered at the end of a test run. "onfail" is
passed an array ref of hash refs that describe each test
failure. Each hash will contain at least the following
fields: "package", "repetition", and
"result". (You shouldn’t rely on any other
fields being present.) If the test had an expected value or
a diagnostic (or "note") string, these will also
be included.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>optional</i> "onfail" hook might be used simply
to print out the version of your package and/or how to
report problems. It might also be used to generate extremely
sophisticated diagnostics for a particularly bizarre test
failure. However it’s not a panacea. Core dumps or
other unrecoverable errors prevent the "onfail"
hook from running. (It is run inside an "END"
block.) Besides, "onfail" is probably over-kill in
most cases. (Your test code should be simpler than the code
it is testing, yes?)</p>
<h2>BUGS and CAVEATS
<a name="BUGS and CAVEATS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">ok(...)’s special handing
of strings which look like they might be regexes can also
cause unexpected behavior. An innocent:</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">ok( $fileglob,
'/path/to/some/*stuff/' );</p>
<p style="margin-left:14%; margin-top: 1em">will fail,
since Test.pm considers the second argument to be a regex!
The best bet is to use the one-argument form:</p>
<p style="margin-left:14%; margin-top: 1em">ok( $fileglob
eq '/path/to/some/*stuff/' );</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">ok(...)’s use of string
"eq" can sometimes cause odd problems when
comparing numbers, especially if you’re casting a
string to a number:</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">$foo =
"1.0"; <br/>
ok( $foo, 1 ); # not ok, "1.0" ne 1</p>
<p style="margin-left:14%; margin-top: 1em">Your best bet
is to use the single argument form:</p>
<p style="margin-left:14%; margin-top: 1em">ok( $foo == 1
); # ok "1.0" == 1</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">As you may have inferred from
the above documentation and examples, "ok"’s
prototype is "($;$$)" (and, incidentally,
"skip"’s is "($;$$$)"). This
means, for example, that you can do "ok @foo,
@bar" to compare the <i>size</i> of the two arrays. But
don’t be fooled into thinking that "ok @foo,
@bar" means a comparison of the contents of two arrays
−− you’re comparing <i>just</i> the number
of elements of each. It’s so easy to make that mistake
in reading "ok @foo, @bar" that you might want to
be very explicit about it, and instead write ok
scalar(@foo), scalar(@bar).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>This almost definitely doesn’t do what you
expect:</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">ok
$thingy−&gt;can('some_method');</p>
<p style="margin-left:14%; margin-top: 1em">Why? Because
"can" returns a coderef to mean "yes it can
(and the method is this...)", and then "ok"
sees a coderef and thinks you’re passing a function
that you want it to call and consider the truth of the
result of! I.e., just like:</p>
<p style="margin-left:14%; margin-top: 1em">ok
$thingy−&gt;can('some_method')−&gt;();</p>
<p style="margin-left:14%; margin-top: 1em">What you
probably want instead is this:</p>
<p style="margin-left:14%; margin-top: 1em">ok
$thingy−&gt;can('some_method') &amp;&amp; 1;</p>
<p style="margin-left:14%; margin-top: 1em">If the
"can" returns false, then that is passed to
"ok". If it returns true, then the larger
expression
"$thingy−&gt;can('some_method') &amp;&amp; 1"
returns 1, which "ok" sees as a simple signal of
success, as you would expect.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">The syntax for "skip"
is about the only way it can be, but it’s still quite
confusing. Just start with the above examples and
you’ll be okay.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Moreover, users
may expect this:</p>
<p style="margin-left:14%; margin-top: 1em">skip
$unless_mswin, foo($bar), baz($quux);</p>
<p style="margin-left:14%; margin-top: 1em">to not evaluate
foo($bar) and baz($quux) when the test is being skipped. But
in reality, they <i>are</i> evaluated, but "skip"
just won’t bother comparing them if $unless_mswin is
true.</p>
<p style="margin-left:14%; margin-top: 1em">You could do
this:</p>
<p style="margin-left:14%; margin-top: 1em">skip
$unless_mswin, sub{foo($bar)}, sub{baz($quux)};</p>
<p style="margin-left:14%; margin-top: 1em">But
that’s not terribly pretty. You may find it simpler or
clearer in the long run to just do things like this:</p>
<p style="margin-left:14%; margin-top: 1em">if( $ˆO
=˜ m/MSWin/ ) { <br/>
print "# Yay, we're under $ˆO\n"; <br/>
ok foo($bar), baz($quux); <br/>
ok thing($whatever), baz($stuff); <br/>
ok blorp($quux, $whatever); <br/>
ok foo($barzbarz), thang($quux); <br/>
} else { <br/>
print "# Feh, we're under $ˆO. Watch me skip some
tests...\n"; <br/>
for(1 .. 4) { skip "Skip unless under MSWin" }
<br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">But be quite
sure that "ok" is called exactly as many times in
the first block as "skip" is called in the second
block.</p>
<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">If
"PERL_TEST_DIFF" environment variable is set, it
will be used as a command for comparing unexpected multiline
results. If you have GNU diff installed, you might want to
set "PERL_TEST_DIFF" to "diff −u".
If you don’t have a suitable program, you might
install the "Text::Diff" module and then set
"PERL_TEST_DIFF" to be "perl
−MText::Diff −e 'print diff(@ARGV)'". If
"PERL_TEST_DIFF" isn’t set but the
"Algorithm::Diff" module is available, then it
will be used to show the differences in multiline
results.</p>
<h2>NOTE
<a name="NOTE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">A past developer
of this module once said that it was no longer being
actively developed. However, rumors of its demise were
greatly exaggerated. Feedback and suggestions are quite
welcome.</p>
<p style="margin-left:9%; margin-top: 1em">Be aware that
the main value of this module is its simplicity. Note that
there are already more ambitious modules out there, such as
Test::More and Test::Unit.</p>
<p style="margin-left:9%; margin-top: 1em">Some earlier
versions of this module had docs with some confusing typos
in the description of skip(...).</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Test::Harness</p>
<p style="margin-left:9%; margin-top: 1em">Test::Simple,
Test::More, Devel::Cover</p>
<p style="margin-left:9%; margin-top: 1em">Test::Builder
for building your own testing library.</p>
<p style="margin-left:9%; margin-top: 1em">Test::Unit is an
interesting XUnit-style testing library.</p>
<p style="margin-left:9%; margin-top: 1em">Test::Inline
lets you embed tests in code.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright (c)
1998−2000 Joshua Nathaniel Pritikin.</p>
<p style="margin-left:9%; margin-top: 1em">Copyright (c)
2001−2002 Michael G. Schwern.</p>
<p style="margin-left:9%; margin-top: 1em">Copyright (c)
2002−2004 Sean M. Burke.</p>
<p style="margin-left:9%; margin-top: 1em">Current
maintainer: Jesse Vincent.
&lt;jesse@bestpractical.com&gt;</p>
<p style="margin-left:9%; margin-top: 1em">This package is
free software and is provided "as is" without
express or implied warranty. It may be used, redistributed
and/or modified under the same terms as Perl itself.</p>
<hr/>
</body>
</html>
