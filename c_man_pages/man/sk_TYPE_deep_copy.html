<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:50:45 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DEFINE_STACK_OF</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">DEFINE_STACK_OF</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">DEFINE_STACK_OF,
DEFINE_STACK_OF_CONST, DEFINE_SPECIAL_STACK_OF,
DEFINE_SPECIAL_STACK_OF_CONST, sk_TYPE_num, sk_TYPE_value,
sk_TYPE_new, sk_TYPE_new_null, sk_TYPE_reserve,
sk_TYPE_free, sk_TYPE_zero, sk_TYPE_delete,
sk_TYPE_delete_ptr, sk_TYPE_push, sk_TYPE_unshift,
sk_TYPE_pop, sk_TYPE_shift, sk_TYPE_pop_free,
sk_TYPE_insert, sk_TYPE_set, sk_TYPE_find, sk_TYPE_find_ex,
sk_TYPE_find_all, sk_TYPE_sort, sk_TYPE_is_sorted,
sk_TYPE_dup, sk_TYPE_deep_copy, sk_TYPE_set_cmp_func,
sk_TYPE_new_reserve, OPENSSL_sk_deep_copy,
OPENSSL_sk_delete, OPENSSL_sk_delete_ptr, OPENSSL_sk_dup,
OPENSSL_sk_find, OPENSSL_sk_find_ex, OPENSSL_sk_find_all,
OPENSSL_sk_free, OPENSSL_sk_insert, OPENSSL_sk_is_sorted,
OPENSSL_sk_new, OPENSSL_sk_new_null, OPENSSL_sk_new_reserve,
OPENSSL_sk_num, OPENSSL_sk_pop, OPENSSL_sk_pop_free,
OPENSSL_sk_push, OPENSSL_sk_reserve, OPENSSL_sk_set,
OPENSSL_sk_set_cmp_func, OPENSSL_sk_shift, OPENSSL_sk_sort,
OPENSSL_sk_unshift, OPENSSL_sk_value, OPENSSL_sk_zero
− stack container</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/safestack.h&gt; <br/>
STACK_OF(TYPE) <br/>
DEFINE_STACK_OF(TYPE) <br/>
DEFINE_STACK_OF_CONST(TYPE) <br/>
DEFINE_SPECIAL_STACK_OF(FUNCTYPE, TYPE) <br/>
DEFINE_SPECIAL_STACK_OF_CONST(FUNCTYPE, TYPE) <br/>
typedef int (*sk_TYPE_compfunc)(const TYPE *const *a, const
TYPE *const *b); <br/>
typedef TYPE * (*sk_TYPE_copyfunc)(const TYPE *a); <br/>
typedef void (*sk_TYPE_freefunc)(TYPE *a); <br/>
int sk_TYPE_num(const STACK_OF(TYPE) *sk); <br/>
TYPE *sk_TYPE_value(const STACK_OF(TYPE) *sk, int idx); <br/>
STACK_OF(TYPE) *sk_TYPE_new(sk_TYPE_compfunc compare); <br/>
STACK_OF(TYPE) *sk_TYPE_new_null(void); <br/>
int sk_TYPE_reserve(STACK_OF(TYPE) *sk, int n); <br/>
void sk_TYPE_free(STACK_OF(TYPE) *sk); <br/>
void sk_TYPE_zero(STACK_OF(TYPE) *sk); <br/>
TYPE *sk_TYPE_delete(STACK_OF(TYPE) *sk, int i); <br/>
TYPE *sk_TYPE_delete_ptr(STACK_OF(TYPE) *sk, TYPE *ptr);
<br/>
int sk_TYPE_push(STACK_OF(TYPE) *sk, const TYPE *ptr); <br/>
int sk_TYPE_unshift(STACK_OF(TYPE) *sk, const TYPE *ptr);
<br/>
TYPE *sk_TYPE_pop(STACK_OF(TYPE) *sk); <br/>
TYPE *sk_TYPE_shift(STACK_OF(TYPE) *sk); <br/>
void sk_TYPE_pop_free(STACK_OF(TYPE) *sk, sk_TYPE_freefunc
freefunc); <br/>
int sk_TYPE_insert(STACK_OF(TYPE) *sk, TYPE *ptr, int idx);
<br/>
TYPE *sk_TYPE_set(STACK_OF(TYPE) *sk, int idx, const TYPE
*ptr); <br/>
int sk_TYPE_find(STACK_OF(TYPE) *sk, TYPE *ptr); <br/>
int sk_TYPE_find_ex(STACK_OF(TYPE) *sk, TYPE *ptr); <br/>
int sk_TYPE_find_all(STACK_OF(TYPE) *sk, TYPE *ptr, int
*pnum); <br/>
void sk_TYPE_sort(const STACK_OF(TYPE) *sk); <br/>
int sk_TYPE_is_sorted(const STACK_OF(TYPE) *sk); <br/>
STACK_OF(TYPE) *sk_TYPE_dup(const STACK_OF(TYPE) *sk); <br/>
STACK_OF(TYPE) *sk_TYPE_deep_copy(const STACK_OF(TYPE) *sk,
<br/>
sk_TYPE_copyfunc copyfunc, <br/>
sk_TYPE_freefunc freefunc); <br/>
sk_TYPE_compfunc (*sk_TYPE_set_cmp_func(STACK_OF(TYPE) *sk,
<br/>
sk_TYPE_compfunc compare)); <br/>
STACK_OF(TYPE) *sk_TYPE_new_reserve(sk_TYPE_compfunc
compare, int n);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Applications can
create and use their own stacks by placing any of the macros
described below in a header file. These macros define
typesafe inline functions that wrap around the utility
<b>OPENSSL_sk_</b> API. In the description here,
<b><i>TYPE</i></b> is used as a placeholder for any of the
OpenSSL datatypes, such as <b>X509</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>STACK_OF()</b> macro returns the name for a stack of the
specified <b><i>TYPE</i></b>. This is an opaque pointer to a
structure declaration. This can be used in every header file
that references the stack. There are several
<b>DEFINE...</b> macros that create static inline functions
for all of the functions described on this page. This should
normally be used in one source file, and the stack
manipulation is wrapped with application−specific
functions.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DEFINE_STACK_OF()</b>
creates set of functions for a stack of <b><i>TYPE</i></b>
elements. The type is referenced by
<b>STACK_OF</b>(<b><i>TYPE</i></b>) and each function name
begins with <b>sk_</b><b><i>TYPE</i></b><b>_</b>.
<b>DEFINE_STACK_OF_CONST()</b> is identical to
<b>DEFINE_STACK_OF()</b> except each element is
constant.</p>
<p style="margin-left:9%; margin-top: 1em">/*
DEFINE_STACK_OF(TYPE) */ <br/>
TYPE *sk_TYPE_value(STACK_OF(TYPE) *sk, int idx); <br/>
/* DEFINE_STACK_OF_CONST(TYPE) */ <br/>
const TYPE *sk_TYPE_value(STACK_OF(TYPE) *sk, int idx);</p>
<p style="margin-left:9%; margin-top: 1em"><b>DEFINE_SPECIAL_STACK_OF()</b>
and <b>DEFINE_SPECIAL_STACK_OF_CONST()</b> are similar
except <b>FUNCNAME</b> is used in the function names:</p>
<p style="margin-left:9%; margin-top: 1em">/*
DEFINE_SPECIAL_STACK_OF(TYPE, FUNCNAME) */ <br/>
TYPE *sk_FUNCNAME_value(STACK_OF(TYPE) *sk, int idx); <br/>
/* DEFINE_SPECIAL_STACK_OF(TYPE, FUNCNAME) */ <br/>
const TYPE *sk_FUNCNAME_value(STACK_OF(TYPE) *sk, int
idx);</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_num</b>()
returns the number of elements in <i>sk</i> or −1 if
<i>sk</i> is NULL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_value</b>()
returns element <i>idx</i> in <i>sk</i>, where <i>idx</i>
starts at zero. If <i>idx</i> is out of range then NULL is
returned.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_new</b>()
allocates a new empty stack using comparison function
<i>compare</i>. If <i>compare</i> is NULL then no comparison
function is used. This function is equivalent to
<b>sk_</b><b><i>TYPE</i></b><b>_new_reserve</b>(<i>compare</i>,
0).</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_new_null</b>()
allocates a new empty stack with no comparison function.
This function is equivalent to
<b>sk_</b><b><i>TYPE</i></b><b>_new_reserve</b>(NULL,
0).</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_reserve</b>()
allocates additional memory in the <i>sk</i> structure such
that the next <i>n</i> calls to
<b>sk_</b><b><i>TYPE</i></b><b>_insert</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_push</b>() or
<b>sk_</b><b><i>TYPE</i></b><b>_unshift</b>() will not fail
or cause memory to be allocated or reallocated. If <i>n</i>
is zero, any excess space allocated in the <i>sk</i>
structure is freed. On error <i>sk</i> is unchanged.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_new_reserve</b>()
allocates a new stack. The new stack will have additional
memory allocated to hold <i>n</i> elements if <i>n</i> is
positive. The next <i>n</i> calls to
<b>sk_</b><b><i>TYPE</i></b><b>_insert</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_push</b>() or
<b>sk_</b><b><i>TYPE</i></b><b>_unshift</b>() will not fail
or cause memory to be allocated or reallocated. If <i>n</i>
is zero or less than zero, no memory is allocated.
<b>sk_</b><b><i>TYPE</i></b><b>_new_reserve</b>() also sets
the comparison function <i>compare</i> to the newly created
stack. If <i>compare</i> is NULL then no comparison function
is used.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_set_cmp_func</b>()
sets the comparison function of <i>sk</i> to <i>compare</i>.
The previous comparison function is returned or NULL if
there was no previous comparison function.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_free</b>()
frees up the <i>sk</i> structure. It does <i>not</i> free up
any elements of <i>sk</i>. After this call <i>sk</i> is no
longer valid.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_zero</b>()
sets the number of elements in <i>sk</i> to zero. It does
not free <i>sk</i> so after this call <i>sk</i> is still
valid.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_pop_free</b>()
frees up all elements of <i>sk</i> and <i>sk</i> itself. The
free function <b>freefunc()</b> is called on each element to
free it.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_delete</b>()
deletes element <i>i</i> from <i>sk</i>. It returns the
deleted element or NULL if <i>i</i> is out of range.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_delete_ptr</b>()
deletes element matching <i>ptr</i> from <i>sk</i>. It
returns the deleted element or NULL if no element matching
<i>ptr</i> was found.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_insert</b>()
inserts <i>ptr</i> into <i>sk</i> at position <i>idx</i>.
Any existing elements at or after <i>idx</i> are moved
downwards. If <i>idx</i> is out of range the new element is
appended to <i>sk</i>.
<b>sk_</b><b><i>TYPE</i></b><b>_insert</b>() either returns
the number of elements in <i>sk</i> after the new element is
inserted or zero if an error (such as memory allocation
failure) occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_push</b>()
appends <i>ptr</i> to <i>sk</i> it is equivalent to:</p>
<p style="margin-left:9%; margin-top: 1em">sk_TYPE_insert(sk,
ptr, −1);</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_unshift</b>()
inserts <i>ptr</i> at the start of <i>sk</i> it is
equivalent to:</p>
<p style="margin-left:9%; margin-top: 1em">sk_TYPE_insert(sk,
ptr, 0);</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_pop</b>()
returns and removes the last element from <i>sk</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_shift</b>()
returns and removes the first element from <i>sk</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_set</b>()
sets element <i>idx</i> of <i>sk</i> to <i>ptr</i> replacing
the current element. The new element value is returned or
NULL if an error occurred: this will only happen if
<i>sk</i> is NULL or <i>idx</i> is out of range.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_find</b>()
searches <i>sk</i> for the element <i>ptr</i>. In the case
where no comparison function has been specified, the
function performs a linear search for a pointer equal to
<i>ptr</i>. The index of the first matching element is
returned or <b>−1</b> if there is no match. In the
case where a comparison function has been specified,
<i>sk</i> is sorted and
<b>sk_</b><b><i>TYPE</i></b><b>_find</b>() returns the index
of a matching element or <b>−1</b> if there is no
match. Note that, in this case the comparison function will
usually compare the values pointed to rather than the
pointers themselves and the order of elements in <i>sk</i>
can change.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_find_ex</b>()
operates like <b>sk_</b><b><i>TYPE</i></b><b>_find</b>()
except when a comparison function has been specified and no
matching element is found. Instead of returning
<b>−1</b>,
<b>sk_</b><b><i>TYPE</i></b><b>_find_ex</b>() returns the
index of the element either before or after the location
where <i>ptr</i> would be if it were present in <i>sk</i>.
The function also does not guarantee that the first matching
element in the sorted stack is returned.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_find_all</b>()
operates like <b>sk_</b><b><i>TYPE</i></b><b>_find</b>() but
it also sets the <i>*pnum</i> to number of matching elements
in the stack. In case no comparison function has been
specified the <i>*pnum</i> will be always set to 1 if
matching element was found, 0 otherwise.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_sort</b>()
sorts <i>sk</i> using the supplied comparison function.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_is_sorted</b>()
returns <b>1</b> if <i>sk</i> is sorted and <b>0</b>
otherwise.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_dup</b>()
returns a shallow copy of <i>sk</i> or an empty stack if the
passed stack is NULL. Note the pointers in the copy are
identical to the original.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_deep_copy</b>()
returns a new stack where each element has been copied or an
empty stack if the passed stack is NULL. Copying is
performed by the supplied <b>copyfunc()</b> and freeing by
<b>freefunc()</b>. The function <b>freefunc()</b> is only
called if an error occurs.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Care should be
taken when accessing stacks in multi−threaded
environments. Any operation which increases the size of a
stack such as <b>sk_</b><b><i>TYPE</i></b><b>_insert</b>()
or <b>sk_</b><b><i>TYPE</i></b><b>_push</b>() can
"grow" the size of an internal array and cause
race conditions if the same stack is accessed in a different
thread. Operations such as
<b>sk_</b><b><i>TYPE</i></b><b>_find</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_sort</b>() can also reorder
the stack.</p>
<p style="margin-left:9%; margin-top: 1em">Any comparison
function supplied should use a metric suitable for use in a
binary search operation. That is it should return zero, a
positive or negative value if <i>a</i> is equal to, greater
than or less than <i>b</i> respectively.</p>
<p style="margin-left:9%; margin-top: 1em">Care should be
taken when checking the return values of the functions
<b>sk_</b><b><i>TYPE</i></b><b>_find</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_find_ex</b>(). They return
an index to the matching element. In particular <b>0</b>
indicates a matching first element. A failed search is
indicated by a <b>−1</b> return value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>STACK_OF()</b>,
<b>DEFINE_STACK_OF()</b>, <b>DEFINE_STACK_OF_CONST()</b>,
and <b>DEFINE_SPECIAL_STACK_OF()</b> are implemented as
macros.</p>
<p style="margin-left:9%; margin-top: 1em">It is not an
error to call <b>sk_</b><b><i>TYPE</i></b><b>_num</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_value</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_free</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_zero</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_pop_free</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_delete</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_delete_ptr</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_pop</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_shift</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_find</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_find_ex</b>(), and
<b>sk_</b><b><i>TYPE</i></b><b>_find_all</b>() on a NULL
stack, empty stack, or with an invalid index. An error is
not raised in these conditions.</p>
<p style="margin-left:9%; margin-top: 1em">The underlying
utility <b>OPENSSL_sk_</b> API should not be used directly.
It defines these functions: <b>OPENSSL_sk_deep_copy()</b>,
<b>OPENSSL_sk_delete()</b>, <b>OPENSSL_sk_delete_ptr()</b>,
<b>OPENSSL_sk_dup()</b>, <b>OPENSSL_sk_find()</b>,
<b>OPENSSL_sk_find_ex()</b>, <b>OPENSSL_sk_find_all()</b>,
<b>OPENSSL_sk_free()</b>, <b>OPENSSL_sk_insert()</b>,
<b>OPENSSL_sk_is_sorted()</b>, <b>OPENSSL_sk_new()</b>,
<b>OPENSSL_sk_new_null()</b>,
<b>OPENSSL_sk_new_reserve()</b>, <b>OPENSSL_sk_num()</b>,
<b>OPENSSL_sk_pop()</b>, <b>OPENSSL_sk_pop_free()</b>,
<b>OPENSSL_sk_push()</b>, <b>OPENSSL_sk_reserve()</b>,
<b>OPENSSL_sk_set()</b>, <b>OPENSSL_sk_set_cmp_func()</b>,
<b>OPENSSL_sk_shift()</b>, <b>OPENSSL_sk_sort()</b>,
<b>OPENSSL_sk_unshift()</b>, <b>OPENSSL_sk_value()</b>,
<b>OPENSSL_sk_zero()</b>.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_num</b>()
returns the number of elements in the stack or
<b>−1</b> if the passed stack is NULL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_value</b>()
returns a pointer to a stack element or NULL if the index is
out of range.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_new</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_new_null</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_new_reserve</b>() return an
empty stack or NULL if an error occurs.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_reserve</b>()
returns <b>1</b> on successful allocation of the required
memory or <b>0</b> on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_set_cmp_func</b>()
returns the old comparison function or NULL if there was no
old comparison function.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_free</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_zero</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_pop_free</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_sort</b>() do not return
values.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_pop</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_shift</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_delete</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_delete_ptr</b>() return a
pointer to the deleted element or NULL on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_insert</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_push</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_unshift</b>() return the
total number of elements in the stack and 0 if an error
occurred. <b>sk_</b><b><i>TYPE</i></b><b>_push</b>() further
returns −1 if <i>sk</i> is NULL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_set</b>()
returns a pointer to the replacement element or NULL on
error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_find</b>()
and <b>sk_</b><b><i>TYPE</i></b><b>_find_ex</b>() return an
index to the found element or <b>−1</b> on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_is_sorted</b>()
returns <b>1</b> if the stack is sorted and <b>0</b> if it
is not.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_dup</b>()
and <b>sk_</b><b><i>TYPE</i></b><b>_deep_copy</b>() return a
pointer to the copy of the stack or NULL on error.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Before OpenSSL
1.1.0, this was implemented via macros and not inline
functions and was not a public API.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sk_</b><b><i>TYPE</i></b><b>_reserve</b>()
and <b>sk_</b><b><i>TYPE</i></b><b>_new_reserve</b>() were
added in OpenSSL 1.1.1.</p>
<p style="margin-left:9%; margin-top: 1em">From OpenSSL
3.2.0, the <b>sk_</b><b><i>TYPE</i></b><b>_find</b>(),
<b>sk_</b><b><i>TYPE</i></b><b>_find_ex</b>() and
<b>sk_</b><b><i>TYPE</i></b><b>_find_all</b>() calls are
read−only and do not sort the stack. To avoid any
performance implications this change introduces,
<b>sk_</b><b><i>TYPE</i></b><b>_sort</b>() should be called
before these find operations.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2000−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
