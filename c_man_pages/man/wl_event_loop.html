<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:52:40 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>wl_event_loop</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">wl_event_loop</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Public Member Functions">Public Member Functions</a><br/>
<a href="#Detailed Description">Detailed Description</a><br/>
<a href="#Member Function Documentation">Member Function Documentation</a><br/>
<a href="#void wl_event_loop_add_destroy_listener (struct wl_event_loop * loop,struct wl_listener * listener)">void wl_event_loop_add_destroy_listener (struct wl_event_loop * loop,struct wl_listener * listener)</a><br/>
<a href="#struct wl_event_loop * wl_event_loop_create (void )">struct wl_event_loop * wl_event_loop_create (void )</a><br/>
<a href="#void wl_event_loop_destroy (struct wl_event_loop * loop)">void wl_event_loop_destroy (struct wl_event_loop * loop)</a><br/>
<a href="#int wl_event_loop_dispatch (struct wl_event_loop * loop, int timeout)">int wl_event_loop_dispatch (struct wl_event_loop * loop, int timeout)</a><br/>
<a href="#void wl_event_loop_dispatch_idle (struct wl_event_loop * loop)">void wl_event_loop_dispatch_idle (struct wl_event_loop * loop)</a><br/>
<a href="#struct wl_listener * wl_event_loop_get_destroy_listener (structwl_event_loop * loop, wl_notify_func_t notify)">struct wl_listener * wl_event_loop_get_destroy_listener (structwl_event_loop * loop, wl_notify_func_t notify)</a><br/>
<a href="#int wl_event_loop_get_fd (struct wl_event_loop * loop)">int wl_event_loop_get_fd (struct wl_event_loop * loop)</a><br/>
<a href="#Author">Author</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">wl_event_loop
− An event loop context.</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;wayland−server−core.h&gt;</p>
<h3>Public Member Functions
<a name="Public Member Functions"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">struct
<b>wl_event_loop</b> * <b>wl_event_loop_create</b> (void)
<br/>
void <b>wl_event_loop_destroy</b> (struct
<b>wl_event_loop</b> *loop) <br/>
void <b>wl_event_loop_dispatch_idle</b> (struct
<b>wl_event_loop</b> *loop) <br/>
int <b>wl_event_loop_dispatch</b> (struct
<b>wl_event_loop</b> *loop, int timeout) <br/>
int <b>wl_event_loop_get_fd</b> (struct <b>wl_event_loop</b>
*loop) <br/>
void <b>wl_event_loop_add_destroy_listener</b> (struct
<b>wl_event_loop</b> *loop, struct <b>wl_listener</b>
*listener) <br/>
struct <b>wl_listener</b> *
<b>wl_event_loop_get_destroy_listener</b> (struct
<b>wl_event_loop</b> *loop, <b>wl_notify_func_t</b>
notify)</p>
<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">An event loop
context.</p>
<p style="margin-left:9%; margin-top: 1em">Usually you
create an event loop context, add sources to it, and call
<b>wl_event_loop_dispatch()</b> in a loop to process
events.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_source</b></p>
<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>
<h3>void wl_event_loop_add_destroy_listener (struct wl_event_loop * loop,struct wl_listener * listener)
<a name="void wl_event_loop_add_destroy_listener (struct wl_event_loop * loop,struct wl_listener * listener)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Register a
destroy listener for an event loop context</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop
context whose destruction to listen for. <i><br/>
listener</i> The listener with the callback to be
called.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_listener</b></p>
<h3>struct wl_event_loop * wl_event_loop_create (void )
<a name="struct wl_event_loop * wl_event_loop_create (void )"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a new
event loop context</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new event loop context
object.</p>
<p style="margin-left:9%; margin-top: 1em">This creates a
new event loop context. Initially this context is empty.
Event sources need to be explicitly added to it.</p>
<p style="margin-left:9%; margin-top: 1em">Normally the
event loop is run by calling <b>wl_event_loop_dispatch()</b>
in a loop until the program terminates. Alternatively, an
event loop can be embedded in another event loop by its file
descriptor, see <b>wl_event_loop_get_fd()</b>.</p>
<h3>void wl_event_loop_destroy (struct wl_event_loop * loop)
<a name="void wl_event_loop_destroy (struct wl_event_loop * loop)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Destroy an event
loop context</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop to
be destroyed.</p>
<p style="margin-left:9%; margin-top: 1em">This emits the
event loop destroy signal, closes the event loop file
descriptor, and frees loop.</p>
<p style="margin-left:9%; margin-top: 1em">If the event
loop has existing sources, those cannot be safely removed
afterwards. Therefore one must call
<b>wl_event_source_remove()</b> on all event sources before
destroying the event loop context.</p>
<h3>int wl_event_loop_dispatch (struct wl_event_loop * loop, int timeout)
<a name="int wl_event_loop_dispatch (struct wl_event_loop * loop, int timeout)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Wait for events
and dispatch them</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop
whose sources to wait for. <i><br/>
timeout</i> The polling timeout in milliseconds.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 for success, -1 for polling
(or timer update) error.</p>
<p style="margin-left:9%; margin-top: 1em">All the
associated event sources are polled. This function blocks
until any event source delivers an event (idle sources
excluded), or the timeout expires. A timeout of -1 disables
the timeout, causing the function to block indefinitely. A
timeout of zero causes the poll to always return
immediately.</p>
<p style="margin-left:9%; margin-top: 1em">All idle sources
are dispatched before blocking. An idle source is destroyed
when it is dispatched. After blocking, all other ready
sources are dispatched. Then, idle sources are dispatched
again, in case the dispatched events created idle sources.
Finally, all sources marked with
<b>wl_event_source_check()</b> are dispatched in a loop
until their dispatch functions all return zero.</p>
<h3>void wl_event_loop_dispatch_idle (struct wl_event_loop * loop)
<a name="void wl_event_loop_dispatch_idle (struct wl_event_loop * loop)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Dispatch the
idle sources</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop
whose idle sources are dispatched.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_event_loop_add_idle()</b></p>
<h3>struct wl_listener * wl_event_loop_get_destroy_listener (structwl_event_loop * loop, wl_notify_func_t notify)
<a name="struct wl_listener * wl_event_loop_get_destroy_listener (structwl_event_loop * loop, wl_notify_func_t notify)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the listener
struct for the specified callback</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop
context to inspect. <i><br/>
notify</i> The destroy callback to find.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The <b>wl_listener</b>
registered to the event loop context with the given callback
pointer.</p>
<h3>int wl_event_loop_get_fd (struct wl_event_loop * loop)
<a name="int wl_event_loop_get_fd (struct wl_event_loop * loop)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the event
loop file descriptor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>loop</i> The event loop
context.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The aggregate file
descriptor.</p>
<p style="margin-left:9%; margin-top: 1em">This function
returns the aggregate file descriptor, that represents all
the event sources (idle sources excluded) associated with
the given event loop context. When any event source makes an
event available, it will be reflected in the aggregate file
descriptor.</p>
<p style="margin-left:9%; margin-top: 1em">When the
aggregate file descriptor delivers an event, one can call
<b>wl_event_loop_dispatch()</b> on the event loop context to
dispatch all the available events.</p>
<h2>Author
<a name="Author"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated
automatically by Doxygen for Wayland from the source
code.</p>
<hr/>
</body>
</html>
