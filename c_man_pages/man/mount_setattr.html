<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:38:52 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>mount_setattr</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">mount_setattr</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#ID-mapped mounts">ID-mapped mounts</a><br/>
<a href="#Extensibility">Extensibility</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">mount_setattr
− change properties of a mount or mount tree</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;linux/fcntl.h&gt;</b> /* Definition of <b>AT_*</b>
constants */ <b><br/>
#include &lt;linux/mount.h&gt;</b> /* Definition of
<b>MOUNT_ATTR_*</b> constants */ <b><br/>
#include &lt;sys/syscall.h&gt;</b> /* Definition of
<b>SYS_*</b> constants */ <b><br/>
#include &lt;unistd.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
syscall(SYS_mount_setattr, int</b> <i>dirfd</i><b>, const
char *</b><i>pathname</i><b>, <br/>
unsigned int</b> <i>flags</i><b>, struct mount_attr
*</b><i>attr</i><b>, size_t</b> <i>size</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><i>Note</i>:
glibc provides no wrapper for <b>mount_setattr</b>(),
necessitating the use of <b>syscall</b>(2).</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>mount_setattr</b>() system call changes the mount
properties of a mount or an entire mount tree. If
<i>pathname</i> is a relative pathname, then it is
interpreted relative to the directory referred to by the
file descriptor <i>dirfd</i>. If <i>dirfd</i> is the special
value <b>AT_FDCWD</b>, then <i>pathname</i> is interpreted
relative to the current working directory of the calling
process. If <i>pathname</i> is the empty string and
<b>AT_EMPTY_PATH</b> is specified in <i>flags</i>, then the
mount properties of the mount identified by <i>dirfd</i> are
changed. (See <b>openat</b>(2) for an explanation of why the
<i>dirfd</i> argument is useful.)</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>mount_setattr</b>() system call uses an extensible
structure (<i>struct mount_attr</i>) to allow for future
extensions. Any non-flag extensions to
<b>mount_setattr</b>() will be implemented as new fields
appended to the this structure, with a zero value in a new
field resulting in the kernel behaving as though that
extension field was not present. Therefore, the caller
<i>must</i> zero-fill this structure on initialization. See
the "Extensibility" subsection under <b>NOTES</b>
for more details.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>size</i>
argument should usually be specified as <i>sizeof(struct
mount_attr)</i>. However, if the caller is using a kernel
that supports an extended <i>struct mount_attr</i>, but the
caller does not intend to make use of these features, it is
possible to pass the size of an earlier version of the
structure together with the extended structure. This allows
the kernel to not copy later parts of the structure that
aren’t used anyway. With each extension that changes
the size of <i>struct mount_attr</i>, the kernel will expose
a definition of the form
<b>MOUNT_ATTR_SIZE_VER</b><i>number</i>. For example, the
macro for the size of the initial version of <i>struct
mount_attr</i> is <b>MOUNT_ATTR_SIZE_VER0</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>flags</i>
argument can be used to alter the pathname resolution
behavior. The supported values are: <b><br/>
AT_EMPTY_PATH</b></p>
<p style="margin-left:18%;">If <i>pathname</i> is the empty
string, change the mount properties on <i>dirfd</i>
itself.</p>
<p style="margin-left:9%;"><b>AT_RECURSIVE</b></p>
<p style="margin-left:18%;">Change the mount properties of
the entire mount tree.</p>
<p style="margin-left:9%;"><b>AT_SYMLINK_NOFOLLOW</b></p>
<p style="margin-left:18%;">Don’t follow trailing
symbolic links.</p>
<p style="margin-left:9%;"><b>AT_NO_AUTOMOUNT</b></p>
<p style="margin-left:18%;">Don’t trigger
automounts.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>attr</i>
argument of <b>mount_setattr</b>() is a structure of the
following form:</p>
<p style="margin-left:14%; margin-top: 1em">struct
mount_attr { <br/>
__u64 attr_set; /* Mount properties to set */ <br/>
__u64 attr_clr; /* Mount properties to clear */ <br/>
__u64 propagation; /* Mount propagation type */ <br/>
__u64 userns_fd; /* User namespace file descriptor */ <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>attr_set</i> and <i>attr_clr</i> members are used to
specify the mount properties that are supposed to be set or
cleared for a mount or mount tree. Flags set in
<i>attr_set</i> enable a property on a mount or mount tree,
and flags set in <i>attr_clr</i> remove a property from a
mount or mount tree.</p>
<p style="margin-left:9%; margin-top: 1em">When changing
mount properties, the kernel will first clear the flags
specified in the <i>attr_clr</i> field, and then set the
flags specified in the <i>attr_set</i> field. For example,
these settings:</p>
<p style="margin-left:14%; margin-top: 1em">struct
mount_attr attr = { <br/>
.attr_clr = MOUNT_ATTR_NOEXEC | MOUNT_ATTR_NODEV, <br/>
.attr_set = MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID, <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">are equivalent
to the following steps:</p>
<p style="margin-left:14%; margin-top: 1em">unsigned int
current_mnt_flags = mnt−&gt;mnt_flags; <br/>
/* <br/>
* Clear all flags set in .attr_clr, <br/>
* clearing MOUNT_ATTR_NOEXEC and MOUNT_ATTR_NODEV. <br/>
*/ <br/>
current_mnt_flags &amp;= ~attr−&gt;attr_clr; <br/>
/* <br/>
* Now set all flags set in .attr_set, <br/>
* applying MOUNT_ATTR_RDONLY and MOUNT_ATTR_NOSUID. <br/>
*/ <br/>
current_mnt_flags |= attr−&gt;attr_set; <br/>
mnt−&gt;mnt_flags = current_mnt_flags;</p>
<p style="margin-left:9%; margin-top: 1em">As a result of
this change, the mount or mount tree (a) is read-only; (b)
blocks the execution of set-user-ID and set-group-ID
programs; (c) allows execution of programs; and (d) allows
access to devices.</p>
<p style="margin-left:9%; margin-top: 1em">Multiple changes
with the same set of flags requested in <i>attr_clr</i> and
<i>attr_set</i> are guaranteed to be idempotent after the
changes have been applied.</p>
<p style="margin-left:9%; margin-top: 1em">The following
mount attributes can be specified in the <i>attr_set</i> or
<i>attr_clr</i> fields: <b><br/>
MOUNT_ATTR_RDONLY</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
makes the mount read-only. If set in <i>attr_clr</i>,
removes the read-only setting if set on the mount.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR_NOSUID</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
causes the mount not to honor the set-user-ID and
set-group-ID mode bits and file capabilities when executing
programs. If set in <i>attr_clr</i>, clears the set-user-ID,
set-group-ID, and file capability restriction if set on this
mount.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR_NODEV</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
prevents access to devices on this mount. If set in
<i>attr_clr</i>, removes the restriction that prevented
accessing devices on this mount.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR_NOEXEC</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
prevents executing programs on this mount. If set in
<i>attr_clr</i>, removes the restriction that prevented
executing programs on this mount.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR_NOSYMFOLLOW</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
prevents following symbolic links on this mount. If set in
<i>attr_clr</i>, removes the restriction that prevented
following symbolic links on this mount.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR_NODIRATIME</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
prevents updating access time for directories on this mount.
If set in <i>attr_clr</i>, removes the restriction that
prevented updating access time for directories. Note that
<b>MOUNT_ATTR_NODIRATIME</b> can be combined with other
access-time settings and is implied by the noatime setting.
All other access-time settings are mutually exclusive.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR__ATIME</b> -
changing access-time settings</p>
<p style="margin-left:18%;">The access-time values listed
below are an enumeration that includes the value zero,
expressed in the bits defined by the mask
<b>MOUNT_ATTR__ATIME</b>. Even though these bits are an
enumeration (in contrast to the other mount flags such as
<b>MOUNT_ATTR_NOEXEC</b>), they are nonetheless passed in
<i>attr_set</i> and <i>attr_clr</i> for consistency with
<b>fsmount</b>(2), which introduced this behavior.</p>
<p style="margin-left:18%; margin-top: 1em">Note that,
since the access-time values are an enumeration rather than
bit values, a caller wanting to transition to a different
access-time setting cannot simply specify the access-time
setting in <i>attr_set</i>, but must also include
<b>MOUNT_ATTR__ATIME</b> in the <i>attr_clr</i> field. The
kernel will verify that <b>MOUNT_ATTR__ATIME</b> isn’t
partially set in <i>attr_clr</i> (i.e., either all bits in
the <b>MOUNT_ATTR__ATIME</b> bit field are either set or
clear), and that <i>attr_set</i> doesn’t have any
access-time bits set if <b>MOUNT_ATTR__ATIME</b> isn’t
set in <i>attr_clr</i>. <b><br/>
MOUNT_ATTR_RELATIME</b></p>
<p style="margin-left:27%;">When a file is accessed via
this mount, update the file’s last access time (atime)
only if the current value of atime is less than or equal to
the file’s last modification time (mtime) or last
status change time (ctime).</p>
<p style="margin-left:27%; margin-top: 1em">To enable this
access-time setting on a mount or mount tree,
<b>MOUNT_ATTR_RELATIME</b> must be set in <i>attr_set</i>
and <b>MOUNT_ATTR__ATIME</b> must be set in the
<i>attr_clr</i> field.</p>
<p style="margin-left:18%;"><b>MOUNT_ATTR_NOATIME</b></p>
<p style="margin-left:27%;">Do not update access times for
(all types of) files on this mount.</p>
<p style="margin-left:27%; margin-top: 1em">To enable this
access-time setting on a mount or mount tree,
<b>MOUNT_ATTR_NOATIME</b> must be set in <i>attr_set</i> and
<b>MOUNT_ATTR__ATIME</b> must be set in the <i>attr_clr</i>
field.</p>
<p style="margin-left:18%;"><b>MOUNT_ATTR_STRICTATIME</b></p>
<p style="margin-left:27%;">Always update the last access
time (atime) when files are accessed on this mount.</p>
<p style="margin-left:27%; margin-top: 1em">To enable this
access-time setting on a mount or mount tree,
<b>MOUNT_ATTR_STRICTATIME</b> must be set in <i>attr_set</i>
and <b>MOUNT_ATTR__ATIME</b> must be set in the
<i>attr_clr</i> field.</p>
<p style="margin-left:9%;"><b>MOUNT_ATTR_IDMAP</b></p>
<p style="margin-left:18%;">If set in <i>attr_set</i>,
creates an ID-mapped mount. The ID mapping is taken from the
user namespace specified in <i>userns_fd</i> and attached to
the mount.</p>
<p style="margin-left:18%; margin-top: 1em">Since it is not
supported to change the ID mapping of a mount after it has
been ID mapped, it is invalid to specify
<b>MOUNT_ATTR_IDMAP</b> in <i>attr_clr</i>.</p>
<p style="margin-left:18%; margin-top: 1em">For further
details, see the subsection "ID-mapped mounts"
under NOTES.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>propagation</i> field is used to specify the propagation
type of the mount or mount tree. This field either has the
value zero, meaning leave the propagation type unchanged, or
it has one of the following values: <b><br/>
MS_PRIVATE</b></p>
<p style="margin-left:18%;">Turn all mounts into private
mounts.</p>
<p style="margin-left:9%;"><b>MS_SHARED</b></p>
<p style="margin-left:18%;">Turn all mounts into shared
mounts.</p>
<p style="margin-left:9%;"><b>MS_SLAVE</b></p>
<p style="margin-left:18%;">Turn all mounts into dependent
mounts.</p>
<p style="margin-left:9%;"><b>MS_UNBINDABLE</b></p>
<p style="margin-left:18%;">Turn all mounts into unbindable
mounts.</p>
<p style="margin-left:9%; margin-top: 1em">For further
details on the above propagation types, see
<b>mount_namespaces</b>(7).</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On success,
<b>mount_setattr</b>() returns zero. On error, −1 is
returned and <i>errno</i> is set to indicate the cause of
the error.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><b>EBADF</b></p></td>
<td width="1%"></td>
<td width="82%">
<p style="margin-top: 1em"><i>pathname</i> is relative but
<i>dirfd</i> is neither <b>AT_FDCWD</b> nor a valid file
descriptor.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EBADF</b></p></td>
<td width="1%"></td>
<td width="82%">
<p><i>userns_fd</i> is not a valid file descriptor.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EBUSY</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The caller tried to change the mount to
<b>MOUNT_ATTR_RDONLY</b>, but the mount still holds files
open for writing.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EBUSY</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The caller tried to create an ID-mapped mount raising
<b>MOUNT_ATTR_IDMAP</b> and specifying <i>userns_fd</i> but
the mount still holds files open for writing.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The pathname specified via the <i>dirfd</i> and
<i>pathname</i> arguments to <b>mount_setattr</b>()
isn’t a mount point.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An unsupported value was set in <i>flags</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An unsupported value was specified in the
<i>attr_set</i> field of <i>mount_attr</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An unsupported value was specified in the
<i>attr_clr</i> field of <i>mount_attr</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An unsupported value was specified in the
<i>propagation</i> field of <i>mount_attr</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>More than one of <b>MS_SHARED</b>, <b>MS_SLAVE</b>,
<b>MS_PRIVATE</b>, or <b>MS_UNBINDABLE</b> was set in the
<i>propagation</i> field of <i>mount_attr</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An access-time setting was specified in the
<i>attr_set</i> field without <b>MOUNT_ATTR__ATIME</b> being
set in the <i>attr_clr</i> field.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p><b>MOUNT_ATTR_IDMAP</b> was specified in
<i>attr_clr</i>.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>A file descriptor value was specified in
<i>userns_fd</i> which exceeds <b>INT_MAX</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>A valid file descriptor value was specified in
<i>userns_fd</i>, but the file descriptor did not refer to a
user namespace.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The underlying filesystem does not support ID-mapped
mounts.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The mount that is to be ID mapped is not a detached
mount; that is, the mount has not previously been visible in
a mount namespace.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>A partial access-time setting was specified in
<i>attr_clr</i> instead of <b>MOUNT_ATTR__ATIME</b> being
set.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The mount is located outside the caller’s mount
namespace.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The underlying filesystem has been mounted in a mount
namespace that is owned by a noninitial user namespace</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOENT</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>A pathname was empty or had a nonexistent component.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOMEM</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>When changing mount propagation to <b>MS_SHARED</b>, a
new peer group ID needs to be allocated for all mounts
without a peer group ID set. This allocation failed because
there was not enough memory to allocate the relevant
internal structures.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOSPC</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>When changing mount propagation to <b>MS_SHARED</b>, a
new peer group ID needs to be allocated for all mounts
without a peer group ID set. This allocation failed because
the kernel has run out of IDs.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EPERM</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>One of the mounts had at least one of
<b>MOUNT_ATTR_NOATIME</b>, <b>MOUNT_ATTR_NODEV</b>,
<b>MOUNT_ATTR_NODIRATIME</b>, <b>MOUNT_ATTR_NOEXEC</b>,
<b>MOUNT_ATTR_NOSUID</b>, or <b>MOUNT_ATTR_RDONLY</b> set
and the flag is locked. Mount attributes become locked on a
mount if:</p></td></tr>
</table>
<p style="margin-left:18%;">•</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="10%"></td>
<td width="3%"></td>
<td width="78%">
<p style="margin-top: 1em">A new mount or mount tree is
created causing mount propagation across user namespaces
(i.e., propagation to a mount namespace owned by a different
user namespace). The kernel will lock the aforementioned
flags to prevent these sensitive properties from being
altered.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="10%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>A new mount and user namespace pair is created. This
happens for example when specifying <b>CLONE_NEWUSER |
CLONE_NEWNS</b> in <b>unshare</b>(2), <b>clone</b>(2), or
<b>clone3</b>(2). The aforementioned flags become locked in
the new mount namespace to prevent sensitive mount
properties from being altered. Since the newly created mount
namespace will be owned by the newly created user namespace,
a calling process that is privileged in the new user
namespace would—in the absence of such
locking—be able to alter sensitive mount properties
(e.g., to remount a mount that was marked read-only as
read-write in the new mount namespace).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="10%">
<p><b>EPERM</b></p></td>
<td width="3%"></td>
<td width="78%">
</td></tr>
</table>
<p style="margin-left:18%; margin-top: 1em">A valid file
descriptor value was specified in <i>userns_fd</i>, but the
file descriptor refers to the initial user namespace.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="6%">
<p style="margin-top: 1em"><b>EPERM</b></p></td>
<td width="3%"></td>
<td width="82%">
<p style="margin-top: 1em">An attempt was made to add an ID
mapping to a mount that is already ID mapped.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="6%">
<p><b>EPERM</b></p></td>
<td width="3%"></td>
<td width="82%">
<p>The caller does not have <b>CAP_SYS_ADMIN</b> in the
initial user namespace.</p></td></tr>
</table>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux 5.12.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<h3>ID-mapped mounts
<a name="ID-mapped mounts"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Creating an
ID-mapped mount makes it possible to change the ownership of
all files located under a mount. Thus, ID-mapped mounts make
it possible to change ownership in a temporary and localized
way. It is a localized change because the ownership changes
are visible only via a specific mount. All other users and
locations where the filesystem is exposed are unaffected. It
is a temporary change because the ownership changes are tied
to the lifetime of the mount.</p>
<p style="margin-left:9%; margin-top: 1em">Whenever callers
interact with the filesystem through an ID-mapped mount, the
ID mapping of the mount will be applied to user and group
IDs associated with filesystem objects. This encompasses the
user and group IDs associated with inodes and also the
following <b>xattr</b>(7) keys:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em"><i>security.capability</i>,
whenever filesystem capabilities are stored or returned in
the <b>VFS_CAP_REVISION_3</b> format, which stores a root
user ID alongside the capabilities (see
<b>capabilities</b>(7)).</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>system.posix_acl_access</i> and
<i>system.posix_acl_default</i>, whenever user IDs or group
IDs are stored in <b>ACL_USER</b> or <b>ACL_GROUP</b>
entries.</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The following
conditions must be met in order to create an ID-mapped
mount:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">The caller must have the
<b>CAP_SYS_ADMIN</b> capability in the user namespace the
filesystem was mounted in.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>The underlying filesystem must support ID-mapped mounts.
Currently, the following filesystems support ID-mapped
mounts:</p> </td></tr>
</table>
<p style="margin-left:13%;">•</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%"></td>
<td width="3%"></td>
<td width="83%">
<p style="margin-top: 1em"><b>xfs</b>(5) (since Linux
5.12)</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>ext4</b>(5) (since Linux 5.12)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>FAT</b> (since Linux 5.12)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>btrfs</b>(5) (since Linux 5.15)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>ntfs3</b> (since Linux 5.15)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>f2fs</b> (since Linux 5.18)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>erofs</b> (since Linux 5.19)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>overlayfs</b> (ID-mapped lower and upper layers
supported since Linux 5.19)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>squashfs</b> (since Linux 6.2)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>tmpfs</b> (since Linux 6.3)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>cephfs</b> (since Linux 6.7)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
<p><b>hugetlbfs</b> (since Linux 6.9)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p>•</p></td>
<td width="3%"></td>
<td width="83%">
</td></tr>
</table>
<p style="margin-left:13%; margin-top: 1em">The mount must
not already be ID-mapped. This also implies that the ID
mapping of a mount cannot be altered.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">The mount must not have any
writers.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>The mount must be a detached mount; that is, it must
have been created by calling <b>open_tree</b>(2) with the
<b>OPEN_TREE_CLONE</b> flag and it must not already have
been visible in a mount namespace. (To put things another
way: the mount must not have been attached to the filesystem
hierarchy with a system call such as
<b>move_mount</b>(2).)</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">ID mappings can
be created for user IDs, group IDs, and project IDs. An ID
mapping is essentially a mapping of a range of user or group
IDs into another or the same range of user or group IDs. ID
mappings are written to map files as three numbers separated
by white space. The first two numbers specify the starting
user or group ID in each of the two user namespaces. The
third number specifies the range of the ID mapping. For
example, a mapping for user IDs such as
"1000 1001 1" would indicate that user
ID 1000 in the caller’s user namespace is mapped to
user ID 1001 in its ancestor user namespace. Since the map
range is 1, only user ID 1000 is mapped.</p>
<p style="margin-left:9%; margin-top: 1em">It is possible
to specify up to 340 ID mappings for each ID mapping type.
If any user IDs or group IDs are not mapped, all files owned
by that unmapped user or group ID will appear as being owned
by the overflow user ID or overflow group ID
respectively.</p>
<p style="margin-left:9%; margin-top: 1em">Further details
on setting up ID mappings can be found in
<b>user_namespaces</b>(7).</p>
<p style="margin-left:9%; margin-top: 1em">In the common
case, the user namespace passed in <i>userns_fd</i>
(together with <b>MOUNT_ATTR_IDMAP</b> in <i>attr_set</i>)
to create an ID-mapped mount will be the user namespace of a
container. In other scenarios it will be a dedicated user
namespace associated with a user’s login session as is
the case for portable home directories in
<b>systemd-homed.service</b>(8)). It is also perfectly fine
to create a dedicated user namespace for the sake of ID
mapping a mount.</p>
<p style="margin-left:9%; margin-top: 1em">ID-mapped mounts
can be useful in the following and a variety of other
scenarios:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">Sharing files or filesystems
between multiple users or multiple machines, especially in
complex scenarios. For example, ID-mapped mounts are used to
implement portable home directories in
<b>systemd-homed.service</b>(8), where they allow users to
move their home directory to an external storage device and
use it on multiple computers where they are assigned
different user IDs and group IDs. This effectively makes it
possible to assign random user IDs and group IDs at login
time.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Sharing files or filesystems from the host with
unprivileged containers. This allows a user to avoid having
to change ownership permanently through <b>chown</b>(2).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>ID mapping a container’s root filesystem. Users
don’t need to change ownership permanently through
<b>chown</b>(2). Especially for large root filesystems,
using <b>chown</b>(2) can be prohibitively expensive.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Sharing files or filesystems between containers with
non-overlapping ID mappings.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Implementing discretionary access (DAC) permission
checking for filesystems lacking a concept of ownership.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Efficiently changing ownership on a per-mount basis. In
contrast to <b>chown</b>(2), changing ownership of large
sets of files is instantaneous with ID-mapped mounts. This
is especially useful when ownership of an entire root
filesystem of a virtual machine or container is to be
changed as mentioned above. With ID-mapped mounts, a single
<b>mount_setattr</b>() system call will be sufficient to
change the ownership of all files.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Taking the current ownership into account. ID mappings
specify precisely what a user or group ID is supposed to be
mapped to. This contrasts with the <b>chown</b>(2) system
call which cannot by itself take the current ownership of
the files it changes into account. It simply changes the
ownership to the specified user ID and group ID.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Locally and temporarily restricted ownership changes.
ID-mapped mounts make it possible to change ownership
locally, restricting the ownership changes to specific
mounts, and temporarily as the ownership changes only apply
as long as the mount exists. By contrast, changing ownership
via the <b>chown</b>(2) system call changes the ownership
globally and permanently.</p></td></tr>
</table>
<h3>Extensibility
<a name="Extensibility"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In order to
allow for future extensibility, <b>mount_setattr</b>()
requires the user-space application to specify the size of
the <i>mount_attr</i> structure that it is passing. By
providing this information, it is possible for
<b>mount_setattr</b>() to provide both forwards- and
backwards-compatibility, with <i>size</i> acting as an
implicit version number. (Because new extension fields will
always be appended, the structure size will always
increase.) This extensibility design is very similar to
other system calls such as <b>perf_setattr</b>(2),
<b>perf_event_open</b>(2), <b>clone3</b>(2) and
<b>openat2</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em">Let <i>usize</i>
be the size of the structure as specified by the user-space
application, and let <i>ksize</i> be the size of the
structure which the kernel supports, then there are three
cases to consider:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em">If <i>ksize</i> equals
<i>usize</i>, then there is no version mismatch and
<i>attr</i> can be used verbatim.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>If <i>ksize</i> is larger than <i>usize</i>, then there
are some extension fields that the kernel supports which the
user-space application is unaware of. Because a zero value
in any added extension field signifies a no-op, the kernel
treats all of the extension fields not provided by the
user-space application as having zero values. This provides
backwards-compatibility.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>If <i>ksize</i> is smaller than <i>usize</i>, then there
are some extension fields which the user-space application
is aware of but which the kernel does not support. Because
any extension field must have its zero values signify a
no-op, the kernel can safely ignore the unsupported
extension fields if they are all zero. If any unsupported
extension fields are non-zero, then −1 is returned and
<i>errno</i> is set to <b>E2BIG</b>. This provides
forwards-compatibility.</p> </td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Because the
definition of <i>struct mount_attr</i> may change in the
future (with new fields being added when system headers are
updated), user-space applications should zero-fill <i>struct
mount_attr</i> to ensure that recompiling the program with
new headers will not result in spurious errors at run time.
The simplest way is to use a designated initializer:</p>
<p style="margin-left:14%; margin-top: 1em">struct
mount_attr attr = { <br/>
.attr_set = MOUNT_ATTR_RDONLY, <br/>
.attr_clr = MOUNT_ATTR_NODEV <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">Alternatively,
the structure can be zero-filled using <b>memset</b>(3) or
similar functions:</p>
<p style="margin-left:14%; margin-top: 1em">struct
mount_attr attr; <br/>
memset(&amp;attr, 0, sizeof(attr)); <br/>
attr.attr_set = MOUNT_ATTR_RDONLY; <br/>
attr.attr_clr = MOUNT_ATTR_NODEV;</p>
<p style="margin-left:9%; margin-top: 1em">A user-space
application that wishes to determine which extensions the
running kernel supports can do so by conducting a binary
search on <i>size</i> with a structure which has every byte
nonzero (to find the largest value which doesn’t
produce an error of <b>E2BIG</b>).</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">/* <br/>
* This program allows the caller to create a new detached
mount <br/>
* and set various properties on it. <br/>
*/ <br/>
#define _GNU_SOURCE <br/>
#include &lt;err.h&gt; <br/>
#include &lt;fcntl.h&gt; <br/>
#include &lt;getopt.h&gt; <br/>
#include &lt;linux/mount.h&gt; <br/>
#include &lt;linux/types.h&gt; <br/>
#include &lt;stdbool.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;string.h&gt; <br/>
#include &lt;sys/syscall.h&gt; <br/>
#include &lt;unistd.h&gt; <br/>
static inline int <br/>
mount_setattr(int dirfd, const char *pathname, unsigned int
flags, <br/>
struct mount_attr *attr, size_t size) <br/>
{ <br/>
return syscall(SYS_mount_setattr, dirfd, pathname, flags,
<br/>
attr, size); <br/>
} <br/>
static inline int <br/>
open_tree(int dirfd, const char *filename, unsigned int
flags) <br/>
{ <br/>
return syscall(SYS_open_tree, dirfd, filename, flags); <br/>
} <br/>
static inline int <br/>
move_mount(int from_dirfd, const char *from_pathname, <br/>
int to_dirfd, const char *to_pathname, unsigned int flags)
<br/>
{ <br/>
return syscall(SYS_move_mount, from_dirfd, from_pathname,
<br/>
to_dirfd, to_pathname, flags); <br/>
} <br/>
static const struct option longopts[] = { <br/>
{"map−mount", required_argument, NULL, 'a'},
<br/>
{"recursive", no_argument, NULL, 'b'}, <br/>
{"read−only", no_argument, NULL, 'c'}, <br/>
{"block−setid", no_argument, NULL, 'd'},
<br/>
{"block−devices", no_argument, NULL, 'e'},
<br/>
{"block−exec", no_argument, NULL, 'f'}, <br/>
{"no−access−time", no_argument, NULL,
'g'}, <br/>
{ NULL, 0, NULL, 0 }, <br/>
}; <br/>
int <br/>
main(int argc, char *argv[]) <br/>
{ <br/>
int fd_userns = −1; <br/>
int fd_tree; <br/>
int index = 0; <br/>
int ret; <br/>
bool recursive = false; <br/>
const char *source; <br/>
const char *target; <br/>
struct mount_attr *attr = &amp;(struct mount_attr){}; <br/>
while ((ret = getopt_long_only(argc, argv, "",
<br/>
longopts, &amp;index)) != −1) { <br/>
switch (ret) { <br/>
case 'a': <br/>
fd_userns = open(optarg, O_RDONLY | O_CLOEXEC); <br/>
if (fd_userns == −1) <br/>
err(EXIT_FAILURE, "open(%s)", optarg); <br/>
break; <br/>
case 'b': <br/>
recursive = true; <br/>
break; <br/>
case 'c': <br/>
attr−&gt;attr_set |= MOUNT_ATTR_RDONLY; <br/>
break; <br/>
case 'd': <br/>
attr−&gt;attr_set |= MOUNT_ATTR_NOSUID; <br/>
break; <br/>
case 'e': <br/>
attr−&gt;attr_set |= MOUNT_ATTR_NODEV; <br/>
break; <br/>
case 'f': <br/>
attr−&gt;attr_set |= MOUNT_ATTR_NOEXEC; <br/>
break; <br/>
case 'g': <br/>
attr−&gt;attr_set |= MOUNT_ATTR_NOATIME; <br/>
attr−&gt;attr_clr |= MOUNT_ATTR__ATIME; <br/>
break; <br/>
default: <br/>
errx(EXIT_FAILURE, "Invalid argument specified");
<br/>
} <br/>
} <br/>
if ((argc − optind) &lt; 2) <br/>
errx(EXIT_FAILURE, "Missing source or target mount
point"); <br/>
source = argv[optind]; <br/>
target = argv[optind + 1]; <br/>
/* In the following, −1 as the 'dirfd' argument
ensures that <br/>
open_tree() fails if 'source' is not an absolute pathname.
*/ <br/>
fd_tree = open_tree(−1, source, <br/>
OPEN_TREE_CLONE | OPEN_TREE_CLOEXEC | <br/>
AT_EMPTY_PATH | (recursive ? AT_RECURSIVE : 0)); <br/>
if (fd_tree == −1) <br/>
err(EXIT_FAILURE, "open(%s)", source); <br/>
if (fd_userns &gt;= 0) { <br/>
attr−&gt;attr_set |= MOUNT_ATTR_IDMAP; <br/>
attr−&gt;userns_fd = fd_userns; <br/>
} <br/>
ret = mount_setattr(fd_tree, "", <br/>
AT_EMPTY_PATH | (recursive ? AT_RECURSIVE : 0), <br/>
attr, sizeof(struct mount_attr)); <br/>
if (ret == −1) <br/>
err(EXIT_FAILURE, "mount_setattr"); <br/>
close(fd_userns); <br/>
/* In the following, −1 as the 'to_dirfd' argument
ensures that <br/>
open_tree() fails if 'target' is not an absolute pathname.
*/ <br/>
ret = move_mount(fd_tree, "", −1, target,
<br/>
MOVE_MOUNT_F_EMPTY_PATH); <br/>
if (ret == −1) <br/>
err(EXIT_FAILURE, "move_mount() to %s", target);
<br/>
close(fd_tree); <br/>
exit(EXIT_SUCCESS); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>newgidmap</b>(1),
<b>newuidmap</b>(1), <b>clone</b>(2), <b>mount</b>(2),
<b>unshare</b>(2), <b>proc</b>(5), <b>capabilities</b>(7),
<b>mount_namespaces</b>(7), <b>user_namespaces</b>(7),
<b>xattr</b>(7)</p>
<hr/>
</body>
</html>
