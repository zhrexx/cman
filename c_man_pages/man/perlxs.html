<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:49:48 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>perlxs</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">perlxs</h1>
<a href="#NAME">NAME</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Introduction">Introduction</a><br/>
<a href="#On The Road">On The Road</a><br/>
<a href="#The Anatomy of an XSUB">The Anatomy of an XSUB</a><br/>
<a href="#The Argument Stack">The Argument Stack</a><br/>
<a href="#The RETVAL Variable">The RETVAL Variable</a><br/>
<a href="#Returning SVs, AVs and HVs through RETVAL">Returning SVs, AVs and HVs through RETVAL</a><br/>
<a href="#The MODULE Keyword">The MODULE Keyword</a><br/>
<a href="#The PACKAGE Keyword">The PACKAGE Keyword</a><br/>
<a href="#The PREFIX Keyword">The PREFIX Keyword</a><br/>
<a href="#The OUTPUT: Keyword">The OUTPUT: Keyword</a><br/>
<a href="#The NO_OUTPUT Keyword">The NO_OUTPUT Keyword</a><br/>
<a href="#The CODE: Keyword">The CODE: Keyword</a><br/>
<a href="#The INIT: Keyword">The INIT: Keyword</a><br/>
<a href="#The NO_INIT Keyword">The NO_INIT Keyword</a><br/>
<a href="#The TYPEMAP: Keyword">The TYPEMAP: Keyword</a><br/>
<a href="#Initializing Function Parameters">Initializing Function Parameters</a><br/>
<a href="#Default Parameter Values">Default Parameter Values</a><br/>
<a href="#The PREINIT: Keyword">The PREINIT: Keyword</a><br/>
<a href="#The SCOPE: Keyword">The SCOPE: Keyword</a><br/>
<a href="#The INPUT: Keyword">The INPUT: Keyword</a><br/>
<a href="#The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords">The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords</a><br/>
<a href="#The length(NAME) Keyword">The length(NAME) Keyword</a><br/>
<a href="#Variable−length Parameter Lists">Variable−length Parameter Lists</a><br/>
<a href="#The C_ARGS: Keyword">The C_ARGS: Keyword</a><br/>
<a href="#The PPCODE: Keyword">The PPCODE: Keyword</a><br/>
<a href="#Returning Undef And Empty Lists">Returning Undef And Empty Lists</a><br/>
<a href="#The REQUIRE: Keyword">The REQUIRE: Keyword</a><br/>
<a href="#The CLEANUP: Keyword">The CLEANUP: Keyword</a><br/>
<a href="#The POSTCALL: Keyword">The POSTCALL: Keyword</a><br/>
<a href="#The BOOT: Keyword">The BOOT: Keyword</a><br/>
<a href="#The VERSIONCHECK: Keyword">The VERSIONCHECK: Keyword</a><br/>
<a href="#The PROTOTYPES: Keyword">The PROTOTYPES: Keyword</a><br/>
<a href="#The PROTOTYPE: Keyword">The PROTOTYPE: Keyword</a><br/>
<a href="#The ALIAS: Keyword">The ALIAS: Keyword</a><br/>
<a href="#The OVERLOAD: Keyword">The OVERLOAD: Keyword</a><br/>
<a href="#The FALLBACK: Keyword">The FALLBACK: Keyword</a><br/>
<a href="#The INTERFACE: Keyword">The INTERFACE: Keyword</a><br/>
<a href="#The INTERFACE_MACRO: Keyword">The INTERFACE_MACRO: Keyword</a><br/>
<a href="#The INCLUDE: Keyword">The INCLUDE: Keyword</a><br/>
<a href="#The INCLUDE_COMMAND: Keyword">The INCLUDE_COMMAND: Keyword</a><br/>
<a href="#The CASE: Keyword">The CASE: Keyword</a><br/>
<a href="#The EXPORT_XSUB_SYMBOLS: Keyword">The EXPORT_XSUB_SYMBOLS: Keyword</a><br/>
<a href="#The &amp; Unary Operator">The &amp; Unary Operator</a><br/>
<a href="#Inserting POD, Comments and C Preprocessor Directives">Inserting POD, Comments and C Preprocessor Directives</a><br/>
<a href="#Using XS With C++">Using XS With C++</a><br/>
<a href="#Interface Strategy">Interface Strategy</a><br/>
<a href="#Perl Objects And C Structures">Perl Objects And C Structures</a><br/>
<a href="#Safely Storing Static Data in XS">Safely Storing Static Data in XS</a><br/>
<a href="#Thread−aware system interfaces">Thread−aware system interfaces</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#CAVEATS">CAVEATS</a><br/>
<a href="#XS VERSION">XS VERSION</a><br/>
<a href="#AUTHOR DIAGNOSTICS">AUTHOR DIAGNOSTICS</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">perlxs −
XS language reference manual</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<h3>Introduction
<a name="Introduction"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">XS is an
interface description file format used to create an
extension interface between Perl and C code (or a C library)
which one wishes to use with Perl. The XS interface is
combined with the library to create a new library which can
then be either dynamically loaded or statically linked into
perl. The XS interface description is written in the XS
language and is the core component of the Perl extension
interface.</p>
<p style="margin-left:9%; margin-top: 1em">Before writing
XS, read the "CAVEATS" section below.</p>
<p style="margin-left:9%; margin-top: 1em">An <b>XSUB</b>
forms the basic unit of the XS interface. After compilation
by the <b>xsubpp</b> compiler, each XSUB amounts to a C
function definition which will provide the glue between Perl
calling conventions and C calling conventions.</p>
<p style="margin-left:9%; margin-top: 1em">The glue code
pulls the arguments from the Perl stack, converts these Perl
values to the formats expected by a C function, calls this C
function, and then transfers the return values of the C
function back to Perl. Return values here may be a
conventional C return value or any C function arguments that
may serve as output parameters. These return values may be
passed back to Perl either by putting them on the Perl
stack, or by modifying the arguments supplied from the Perl
side.</p>
<p style="margin-left:9%; margin-top: 1em">The above is a
somewhat simplified view of what really happens. Since Perl
allows more flexible calling conventions than C, XSUBs may
do much more in practice, such as checking input parameters
for validity, throwing exceptions (or returning undef/empty
list) if the return value from the C function indicates
failure, calling different C functions based on numbers and
types of the arguments, providing an object−oriented
interface, etc.</p>
<p style="margin-left:9%; margin-top: 1em">Of course, one
could write such glue code directly in C. However, this
would be a tedious task, especially if one needs to write
glue for multiple C functions, and/or one is not familiar
enough with the Perl stack discipline and other such arcana.
XS comes to the rescue here: instead of writing this glue C
code in long−hand, one can write a more concise
short−hand <i>description</i> of what should be done
by the glue, and let the XS compiler <b>xsubpp</b> handle
the rest.</p>
<p style="margin-left:9%; margin-top: 1em">The XS language
allows one to describe the mapping between how the C routine
is used, and how the corresponding Perl routine is used. It
also allows creation of Perl routines which are directly
translated to C code and which are not related to a
pre−existing C function. In cases when the C interface
coincides with the Perl interface, the XSUB declaration is
almost identical to a declaration of a C function (in
K&amp;R style). In such circumstances, there is another tool
called "h2xs" that is able to translate an entire
C header file into a corresponding XS file that will provide
glue to the functions/macros described in the header
file.</p>
<p style="margin-left:9%; margin-top: 1em">The XS compiler
is called <b>xsubpp</b>. This compiler creates the
constructs necessary to let an XSUB manipulate Perl values,
and creates the glue necessary to let Perl call the XSUB.
The compiler uses <b>typemaps</b> to determine how to map C
function parameters and output values to Perl values and
back. The default typemap (which comes with Perl) handles
many common C types. A supplementary typemap may also be
needed to handle any special structures and types for the
library being linked. For more information on typemaps, see
perlxstypemap.</p>
<p style="margin-left:9%; margin-top: 1em">A file in XS
format starts with a C language section which goes until the
first "MODULE =" directive. Other XS directives
and XSUB definitions may follow this line. The
"language" used in this part of the file is
usually referred to as the XS language. <b>xsubpp</b>
recognizes and skips POD (see perlpod) in both the C and XS
language sections, which allows the XS file to contain
embedded documentation.</p>
<p style="margin-left:9%; margin-top: 1em">See perlxstut
for a tutorial on the whole extension creation process.</p>
<p style="margin-left:9%; margin-top: 1em">Note: For some
extensions, Dave Beazley's SWIG system may provide a
significantly more convenient mechanism for creating the
extension glue code. See &lt;http://www.swig.org/&gt; for
more information.</p>
<p style="margin-left:9%; margin-top: 1em">For simple
bindings to C libraries as well as other machine code
libraries, consider instead using the much simpler libffi
&lt;http://sourceware.org/libffi/&gt; interface via CPAN
modules like FFI::Platypus or FFI::Raw.</p>
<h3>On The Road
<a name="On The Road"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Many of the
examples which follow will concentrate on creating an
interface between Perl and the ONC+ RPC bind library
functions. The <b>rpcb_gettime()</b> function is used to
demonstrate many features of the XS language. This function
has two parameters; the first is an input parameter and the
second is an output parameter. The function also returns a
status value.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t
rpcb_gettime(const char *host, time_t *timep);</p>
<p style="margin-left:9%; margin-top: 1em">From C this
function will be called with the following statements.</p>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;rpc/rpc.h&gt; <br/>
bool_t status; <br/>
time_t timep; <br/>
status = rpcb_gettime( "localhost", &amp;timep
);</p>
<p style="margin-left:9%; margin-top: 1em">If an XSUB is
created to offer a direct translation between this function
and Perl, then this XSUB will be used from Perl with the
following code. The $status and $timep variables will
contain the output of the function.</p>
<p style="margin-left:9%; margin-top: 1em">use RPC; <br/>
$status = rpcb_gettime( "localhost", $timep );</p>
<p style="margin-left:9%; margin-top: 1em">The following XS
file shows an XS subroutine, or XSUB, which demonstrates one
possible interface to the <b>rpcb_gettime()</b> function.
This XSUB represents a direct translation between C and Perl
and so preserves the interface even from Perl. This XSUB
will be invoked from Perl with the usage shown above. Note
that the first three #include statements, for
"EXTERN.h", "perl.h", and
"XSUB.h", will always be present at the beginning
of an XS file. This approach and others will be expanded
later in this document. A #define for
"PERL_NO_GET_CONTEXT" should be present to fetch
the interpreter context more efficiently, see perlguts for
details.</p>
<p style="margin-left:9%; margin-top: 1em">#define
PERL_NO_GET_CONTEXT <br/>
#include "EXTERN.h" <br/>
#include "perl.h" <br/>
#include "XSUB.h" <br/>
#include &lt;rpc/rpc.h&gt; <br/>
MODULE = RPC PACKAGE = RPC <br/>
bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">Any extension to
Perl, including those containing XSUBs, should have a Perl
module to serve as the bootstrap which pulls the extension
into Perl. This module will export the extension's functions
and variables to the Perl program and will cause the
extension's XSUBs to be linked into Perl. The following
module will be used for most of the examples in this
document and should be used from Perl with the
"use" command as shown earlier. Perl modules are
explained in more detail later in this document.</p>
<p style="margin-left:9%; margin-top: 1em">package RPC;
<br/>
require Exporter; <br/>
require DynaLoader; <br/>
@ISA = qw(Exporter DynaLoader); <br/>
@EXPORT = qw( rpcb_gettime ); <br/>
bootstrap RPC; <br/>
1;</p>
<p style="margin-left:9%; margin-top: 1em">Throughout this
document a variety of interfaces to the
<b>rpcb_gettime()</b> XSUB will be explored. The XSUBs will
take their parameters in different orders or will take
different numbers of parameters. In each case the XSUB is an
abstraction between Perl and the real C
<b>rpcb_gettime()</b> function, and the XSUB must always
ensure that the real <b>rpcb_gettime()</b> function is
called with the correct parameters. This abstraction will
allow the programmer to create a more Perl−like
interface to the C function.</p>
<h3>The Anatomy of an XSUB
<a name="The Anatomy of an XSUB"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The simplest
XSUBs consist of 3 parts: a description of the return value,
the name of the XSUB routine and the names of its arguments,
and a description of types or formats of the arguments.</p>
<p style="margin-left:9%; margin-top: 1em">The following
XSUB allows a Perl program to access a C library function
called <b>sin()</b>. The XSUB will imitate the C function
which takes a single argument and returns a single
value.</p>
<p style="margin-left:9%; margin-top: 1em">double <br/>
sin(x) <br/>
double x</p>
<p style="margin-left:9%; margin-top: 1em">Optionally, one
can merge the description of types and the list of argument
names, rewriting this as</p>
<p style="margin-left:9%; margin-top: 1em">double <br/>
sin(double x)</p>
<p style="margin-left:9%; margin-top: 1em">This makes this
XSUB look similar to an ANSI C declaration. An optional
semicolon is allowed after the argument list, as in</p>
<p style="margin-left:9%; margin-top: 1em">double <br/>
sin(double x);</p>
<p style="margin-left:9%; margin-top: 1em">Parameters with
C pointer types can have different semantic: C functions
with similar declarations</p>
<p style="margin-left:9%; margin-top: 1em">bool
string_looks_as_a_number(char *s); <br/>
bool make_char_uppercase(char *c);</p>
<p style="margin-left:9%; margin-top: 1em">are used in
absolutely incompatible manner. Parameters to these
functions could be described to <b>xsubpp</b> like this:</p>
<p style="margin-left:9%; margin-top: 1em">char * s <br/>
char &amp;c</p>
<p style="margin-left:9%; margin-top: 1em">Both these XS
declarations correspond to the "char*" C type, but
they have different semantics, see "The &amp; Unary
Operator".</p>
<p style="margin-left:9%; margin-top: 1em">It is convenient
to think that the indirection operator "*" should
be considered as a part of the type and the address operator
"&amp;" should be considered part of the variable.
See perlxstypemap for more info about handling qualifiers
and unary operators in C types.</p>
<p style="margin-left:9%; margin-top: 1em">The function
name and the return type must be placed on separate lines
and should be flush left−adjusted.</p>
<p style="margin-left:9%; margin-top: 1em">INCORRECT
CORRECT <br/>
double sin(x) double <br/>
double x sin(x) <br/>
double x</p>
<p style="margin-left:9%; margin-top: 1em">The rest of the
function description may be indented or left−adjusted.
The following example shows a function with its body
left−adjusted. Most examples in this document will
indent the body for better readability.</p>
<p style="margin-left:9%; margin-top: 1em">CORRECT <br/>
double <br/>
sin(x) <br/>
double x</p>
<p style="margin-left:9%; margin-top: 1em">More complicated
XSUBs may contain many other sections. Each section of an
XSUB starts with the corresponding keyword, such as INIT: or
CLEANUP:. However, the first two lines of an XSUB always
contain the same data: descriptions of the return type and
the names of the function and its parameters. Whatever
immediately follows these is considered to be an INPUT:
section unless explicitly marked with another keyword. (See
"The INPUT: Keyword".)</p>
<p style="margin-left:9%; margin-top: 1em">An XSUB section
continues until another section−start keyword is
found.</p>
<h3>The Argument Stack
<a name="The Argument Stack"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The Perl
argument stack is used to store the values which are sent as
parameters to the XSUB and to store the XSUB's return
value(s). In reality all Perl functions (including
non−XSUB ones) keep their values on this stack all the
same time, each limited to its own range of positions on the
stack. In this document the first position on that stack
which belongs to the active function will be referred to as
position 0 for that function.</p>
<p style="margin-left:9%; margin-top: 1em">XSUBs refer to
their stack arguments with the macro <b>ST(x)</b>, where
<i>x</i> refers to a position in this XSUB's part of the
stack. Position 0 for that function would be known to the
XSUB as <b>ST</b>(0). The XSUB's incoming parameters and
outgoing return values always begin at <b>ST</b>(0). For
many simple cases the <b>xsubpp</b> compiler will generate
the code necessary to handle the argument stack by embedding
code fragments found in the typemaps. In more complex cases
the programmer must supply the code.</p>
<h3>The RETVAL Variable
<a name="The RETVAL Variable"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The RETVAL
variable is a special C variable that is declared
automatically for you. The C type of RETVAL matches the
return type of the C library function. The <b>xsubpp</b>
compiler will declare this variable in each XSUB with
non−"void" return type. By default the
generated C function will use RETVAL to hold the return
value of the C library function being called. In simple
cases the value of RETVAL will be placed in <b>ST</b>(0) of
the argument stack where it can be received by Perl as the
return value of the XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">If the XSUB has
a return type of "void" then the compiler will not
declare a RETVAL variable for that function. When using a
PPCODE: section no manipulation of the RETVAL variable is
required, the section may use direct stack manipulation to
place output values on the stack.</p>
<p style="margin-left:9%; margin-top: 1em">If PPCODE:
directive is not used, "void" return value should
be used only for subroutines which do not return a value,
<i>even if</i> CODE: directive is used which sets
<b>ST</b>(0) explicitly.</p>
<p style="margin-left:9%; margin-top: 1em">Older versions
of this document recommended to use "void" return
value in such cases. It was discovered that this could lead
to segfaults in cases when XSUB was <i>truly</i>
"void". This practice is now deprecated, and may
be not supported at some future version. Use the return
value "SV *" in such cases. (Currently
"xsubpp" contains some heuristic code which tries
to disambiguate between "truly−void" and
"old−practice−declared−as−void"
functions. Hence your code is at mercy of this heuristics
unless you use "SV *" as return value.)</p>
<h3>Returning SVs, AVs and HVs through RETVAL
<a name="Returning SVs, AVs and HVs through RETVAL"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When you're
using RETVAL to return an "SV *", there's some
magic going on behind the scenes that should be mentioned.
When you're manipulating the argument stack using the ST(x)
macro, for example, you usually have to pay special
attention to reference counts. (For more about reference
counts, see perlguts.) To make your life easier, the typemap
file automatically makes "RETVAL" mortal when
you're returning an "SV *". Thus, the following
two XSUBs are more or less equivalent:</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
alpha() <br/>
PPCODE: <br/>
ST(0) = newSVpv("Hello World",0); <br/>
sv_2mortal(ST(0)); <br/>
XSRETURN(1); <br/>
SV * <br/>
beta() <br/>
CODE: <br/>
RETVAL = newSVpv("Hello World",0); <br/>
OUTPUT: <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">This is quite
useful as it usually improves readability. While this works
fine for an "SV *", it's unfortunately not as easy
to have "AV *" or "HV *" as a return
value. You <i>should</i> be able to write:</p>
<p style="margin-left:9%; margin-top: 1em">AV * <br/>
array() <br/>
CODE: <br/>
RETVAL = newAV(); <br/>
/* do something with RETVAL */ <br/>
OUTPUT: <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">But due to an
unfixable bug (fixing it would break lots of existing CPAN
modules) in the typemap file, the reference count of the
"AV *" is not properly decremented. Thus, the
above XSUB would leak memory whenever it is being called.
The same problem exists for "HV *", "CV
*", and "SVREF" (which indicates a scalar
reference, not a general "SV *"). In XS code on
perls starting with perl 5.16, you can override the typemaps
for any of these types with a version that has proper
handling of refcounts. In your "TYPEMAP" section,
do</p>
<p style="margin-left:9%; margin-top: 1em">AV*
T_AVREF_REFCOUNT_FIXED</p>
<p style="margin-left:9%; margin-top: 1em">to get the
repaired variant. For backward compatibility with older
versions of perl, you can instead decrement the reference
count manually when you're returning one of the
aforementioned types using "sv_2mortal":</p>
<p style="margin-left:9%; margin-top: 1em">AV * <br/>
array() <br/>
CODE: <br/>
RETVAL = newAV(); <br/>
sv_2mortal((SV*)RETVAL); <br/>
/* do something with RETVAL */ <br/>
OUTPUT: <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">Remember that
you don't have to do this for an "SV *". The
reference documentation for all core typemaps can be found
in perlxstypemap.</p>
<h3>The MODULE Keyword
<a name="The MODULE Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The MODULE
keyword is used to start the XS code and to specify the
package of the functions which are being defined. All text
preceding the first MODULE keyword is considered C code and
is passed through to the output with POD stripped, but
otherwise untouched. Every XS module will have a bootstrap
function which is used to hook the XSUBs into Perl. The
package name of this bootstrap function will match the value
of the last MODULE statement in the XS source files. The
value of MODULE should always remain constant within the
same XS file, though this is not required.</p>
<p style="margin-left:9%; margin-top: 1em">The following
example will start the XS code and will place all functions
in a package named RPC.</p>
<p style="margin-left:9%; margin-top: 1em">MODULE = RPC</p>
<h3>The PACKAGE Keyword
<a name="The PACKAGE Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When functions
within an XS source file must be separated into packages the
PACKAGE keyword should be used. This keyword is used with
the MODULE keyword and must follow immediately after it when
used.</p>
<p style="margin-left:9%; margin-top: 1em">MODULE = RPC
PACKAGE = RPC <br/>
[ XS code in package RPC ] <br/>
MODULE = RPC PACKAGE = RPCB <br/>
[ XS code in package RPCB ] <br/>
MODULE = RPC PACKAGE = RPC <br/>
[ XS code in package RPC ]</p>
<p style="margin-left:9%; margin-top: 1em">The same package
name can be used more than once, allowing for
non−contiguous code. This is useful if you have a
stronger ordering principle than package names.</p>
<p style="margin-left:9%; margin-top: 1em">Although this
keyword is optional and in some cases provides redundant
information it should always be used. This keyword will
ensure that the XSUBs appear in the desired package.</p>
<h3>The PREFIX Keyword
<a name="The PREFIX Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The PREFIX
keyword designates prefixes which should be removed from the
Perl function names. If the C function is rpcb_gettime() and
the PREFIX value is "rpcb_" then Perl will see
this function as gettime().</p>
<p style="margin-left:9%; margin-top: 1em">This keyword
should follow the PACKAGE keyword when used. If PACKAGE is
not used then PREFIX should follow the MODULE keyword.</p>
<p style="margin-left:9%; margin-top: 1em">MODULE = RPC
PREFIX = rpc_ <br/>
MODULE = RPC PACKAGE = RPCB PREFIX = rpcb_</p>
<h3>The OUTPUT: Keyword
<a name="The OUTPUT: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The OUTPUT:
keyword indicates that certain function parameters should be
updated (new values made visible to Perl) when the XSUB
terminates or that certain values should be returned to the
calling Perl function. For simple functions which have no
CODE: or PPCODE: section, such as the <b>sin()</b> function
above, the RETVAL variable is automatically designated as an
output value. For more complex functions the <b>xsubpp</b>
compiler will need help to determine which variables are
output variables.</p>
<p style="margin-left:9%; margin-top: 1em">This keyword
will normally be used to complement the CODE: keyword. The
RETVAL variable is not recognized as an output variable when
the CODE: keyword is present. The OUTPUT: keyword is used in
this situation to tell the compiler that RETVAL really is an
output variable.</p>
<p style="margin-left:9%; margin-top: 1em">The OUTPUT:
keyword can also be used to indicate that function
parameters are output variables. This may be necessary when
a parameter has been modified within the function and the
programmer would like the update to be seen by Perl.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">The OUTPUT:
keyword will also allow an output parameter to be mapped to
a matching piece of code rather than to a typemap.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
OUTPUT: <br/>
timep sv_setnv(ST(1), (double)timep);</p>
<p style="margin-left:9%; margin-top: 1em"><b>xsubpp</b>
emits an automatic SvSETMAGIC() for all parameters in the
OUTPUT section of the XSUB, except RETVAL. This is the
usually desired behavior, as it takes care of properly
invoking 'set' magic on output parameters (needed for hash
or array element parameters that must be created if they
didn't exist). If for some reason, this behavior is not
desired, the OUTPUT section may contain a "SETMAGIC:
DISABLE" line to disable it for the remainder of the
parameters in the OUTPUT section. Likewise, "SETMAGIC:
ENABLE" can be used to reenable it for the remainder of
the OUTPUT section. See perlguts for more details about
'set' magic.</p>
<h3>The NO_OUTPUT Keyword
<a name="The NO_OUTPUT Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The NO_OUTPUT
can be placed as the first token of the XSUB. This keyword
indicates that while the C subroutine we provide an
interface to has a non−"void" return type,
the return value of this C subroutine should not be returned
from the generated Perl subroutine.</p>
<p style="margin-left:9%; margin-top: 1em">With this
keyword present "The RETVAL Variable" is created,
and in the generated call to the subroutine this variable is
assigned to, but the value of this variable is not going to
be used in the auto−generated code.</p>
<p style="margin-left:9%; margin-top: 1em">This keyword
makes sense only if "RETVAL" is going to be
accessed by the user−supplied code. It is especially
useful to make a function interface more Perl−like,
especially when the C return value is just an error
condition indicator. For example,</p>
<p style="margin-left:9%; margin-top: 1em">NO_OUTPUT int
<br/>
delete_file(char *name) <br/>
POSTCALL: <br/>
if (RETVAL != 0) <br/>
croak("Error %d while deleting file '%s'", RETVAL,
name);</p>
<p style="margin-left:9%; margin-top: 1em">Here the
generated XS function returns nothing on success, and will
<b>die()</b> with a meaningful error message on error.</p>
<h3>The CODE: Keyword
<a name="The CODE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword is
used in more complicated XSUBs which require special
handling for the C function. The RETVAL variable is still
declared, but it will not be returned unless it is specified
in the OUTPUT: section.</p>
<p style="margin-left:9%; margin-top: 1em">The following
XSUB is for a C function which requires special handling of
its parameters. The Perl usage is given first.</p>
<p style="margin-left:9%; margin-top: 1em">$status =
rpcb_gettime( "localhost", $timep );</p>
<p style="margin-left:9%; margin-top: 1em">The XSUB
follows.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t timep <br/>
CODE: <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<h3>The INIT: Keyword
<a name="The INIT: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The INIT:
keyword allows initialization to be inserted into the XSUB
before the compiler generates the call to the C function.
Unlike the CODE: keyword above, this keyword does not affect
the way the compiler handles RETVAL.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
INIT: <br/>
printf("# Host is %s\n", host ); <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">Another use for
the INIT: section is to check for preconditions before
making a call to the C function:</p>
<p style="margin-left:9%; margin-top: 1em">long long <br/>
lldiv(a,b) <br/>
long long a <br/>
long long b <br/>
INIT: <br/>
if (a == 0 &amp;&amp; b == 0) <br/>
XSRETURN_UNDEF; <br/>
if (b == 0) <br/>
croak("lldiv: cannot divide by 0");</p>
<h3>The NO_INIT Keyword
<a name="The NO_INIT Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The NO_INIT
keyword is used to indicate that a function parameter is
being used only as an output value. The <b>xsubpp</b>
compiler will normally generate code to read the values of
all function parameters from the argument stack and assign
them to C variables upon entry to the function. NO_INIT will
tell the compiler that some parameters will be used for
output rather than for input and that they will be handled
before the function terminates.</p>
<p style="margin-left:9%; margin-top: 1em">The following
example shows a variation of the <b>rpcb_gettime()</b>
function. This function uses the timep variable only as an
output variable and does not care about its initial
contents.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep = NO_INIT <br/>
OUTPUT: <br/>
timep</p>
<h3>The TYPEMAP: Keyword
<a name="The TYPEMAP: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Starting with
Perl 5.16, you can embed typemaps into your XS code instead
of or in addition to typemaps in a separate file. Multiple
such embedded typemaps will be processed in order of
appearance in the XS code and like local typemap files take
precedence over the default typemap, the embedded typemaps
may overwrite previous definitions of TYPEMAP, INPUT, and
OUTPUT stanzas. The syntax for embedded typemaps is</p>
<p style="margin-left:9%; margin-top: 1em">TYPEMAP:
&lt;&lt;HERE <br/>
... your typemap code here ... <br/>
HERE</p>
<p style="margin-left:9%; margin-top: 1em">where the
"TYPEMAP" keyword must appear in the first column
of a new line.</p>
<p style="margin-left:9%; margin-top: 1em">Refer to
perlxstypemap for details on writing typemaps.</p>
<h3>Initializing Function Parameters
<a name="Initializing Function Parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">C function
parameters are normally initialized with their values from
the argument stack (which in turn contains the parameters
that were passed to the XSUB from Perl). The typemaps
contain the code segments which are used to translate the
Perl values to the C parameters. The programmer, however, is
allowed to override the typemaps and supply alternate (or
additional) initialization code. Initialization code starts
with the first "=", ";" or "+"
on a line in the INPUT: section. The only exception happens
if this ";" terminates the line, then this
";" is quietly ignored.</p>
<p style="margin-left:9%; margin-top: 1em">The following
code demonstrates how to supply initialization code for
function parameters. The initialization code is eval'ed
within double quotes by the compiler before it is added to
the output so anything which should be interpreted literally
[mainly "$", "@", or "\\"]
must be protected with backslashes. The variables $var,
$arg, and $type can be used as in typemaps.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host = (char *)SvPVbyte_nolen($arg); <br/>
time_t &amp;timep = 0; <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">This should not
be used to supply default values for parameters. One would
normally use this when a function parameter must be
processed by another library function before it can be used.
Default parameters are covered in the next section.</p>
<p style="margin-left:9%; margin-top: 1em">If the
initialization begins with "=", then it is output
in the declaration for the input variable, replacing the
initialization supplied by the typemap. If the
initialization begins with ";" or "+",
then it is performed after all of the input variables have
been declared. In the ";" case the initialization
normally supplied by the typemap is not performed. For the
"+" case, the declaration for the variable will
include the initialization from the typemap. A global
variable, %v, is available for the truly rare case where
information from one initialization is needed in another
initialization.</p>
<p style="margin-left:9%; margin-top: 1em">Here's a truly
obscure example:</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
time_t &amp;timep; /* \$v{timep}=@{[$v{timep}=$arg]} */ <br/>
char *host + SvOK($v{timep}) ? SvPVbyte_nolen($arg) : NULL;
<br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">The construct
"\$v{timep}=@{[$v{timep}=$arg]}" used in the above
example has a two−fold purpose: first, when this line
is processed by <b>xsubpp</b>, the Perl snippet
"$v{timep}=$arg" is evaluated. Second, the text of
the evaluated snippet is output into the generated C file
(inside a C comment)! During the processing of "char
*host" line, $arg will evaluate to ST(0), and $v{timep}
will evaluate to ST(1).</p>
<h3>Default Parameter Values
<a name="Default Parameter Values"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Default values
for XSUB arguments can be specified by placing an assignment
statement in the parameter list. The default value may be a
number, a string or the special string "NO_INIT".
Defaults should always be used on the right−most
parameters only.</p>
<p style="margin-left:9%; margin-top: 1em">To allow the
XSUB for <b>rpcb_gettime()</b> to have a default host value
the parameters to the XSUB could be rearranged. The XSUB
will then call the real <b>rpcb_gettime()</b> function with
the parameters in the correct order. This XSUB can be called
from Perl with either of the following statements:</p>
<p style="margin-left:9%; margin-top: 1em">$status =
rpcb_gettime( $timep, $host ); <br/>
$status = rpcb_gettime( $timep );</p>
<p style="margin-left:9%; margin-top: 1em">The XSUB will
look like the code which follows. A CODE: block is used to
call the real <b>rpcb_gettime()</b> function with the
parameters in the correct order for that function.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep,host="localhost") <br/>
char *host <br/>
time_t timep = NO_INIT <br/>
CODE: <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<h3>The PREINIT: Keyword
<a name="The PREINIT: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The PREINIT:
keyword allows extra variables to be declared immediately
before or after the declarations of the parameters from the
INPUT: section are emitted.</p>
<p style="margin-left:9%; margin-top: 1em">If a variable is
declared inside a CODE: section it will follow any typemap
code that is emitted for the input parameters. This may
result in the declaration ending up after C code, which is C
syntax error. Similar errors may happen with an explicit
";"−type or "+"−type
initialization of parameters is used (see "Initializing
Function Parameters"). Declaring these variables in an
INIT: section will not help.</p>
<p style="margin-left:9%; margin-top: 1em">In such cases,
to force an additional variable to be declared together with
declarations of other variables, place the declaration into
a PREINIT: section. The PREINIT: keyword may be used one or
more times within an XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">The following
examples are equivalent, but if the code is using complex
typemaps then the first example is safer.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep) <br/>
time_t timep = NO_INIT <br/>
PREINIT: <br/>
char *host = "localhost"; <br/>
CODE: <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">For this
particular case an INIT: keyword would generate the same C
code as the PREINIT: keyword. Another correct, but
error−prone example:</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep) <br/>
time_t timep = NO_INIT <br/>
CODE: <br/>
char *host = "localhost"; <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">Another way to
declare "host" is to use a C block in the CODE:
section:</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep) <br/>
time_t timep = NO_INIT <br/>
CODE: <br/>
{ <br/>
char *host = "localhost"; <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
} <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">The ability to
put additional declarations before the typemap entries are
processed is very handy in the cases when typemap
conversions manipulate some global state:</p>
<p style="margin-left:9%; margin-top: 1em">MyObject <br/>
mutate(o) <br/>
PREINIT: <br/>
MyState st = global_state; <br/>
INPUT: <br/>
MyObject o; <br/>
CLEANUP: <br/>
reset_to(global_state, st);</p>
<p style="margin-left:9%; margin-top: 1em">Here we suppose
that conversion to "MyObject" in the INPUT:
section and from MyObject when processing RETVAL will modify
a global variable "global_state". After these
conversions are performed, we restore the old value of
"global_state" (to avoid memory leaks, for
example).</p>
<p style="margin-left:9%; margin-top: 1em">There is another
way to trade clarity for compactness: INPUT sections allow
declaration of C variables which do not appear in the
parameter list of a subroutine. Thus the above code for
<b>mutate()</b> can be rewritten as</p>
<p style="margin-left:9%; margin-top: 1em">MyObject <br/>
mutate(o) <br/>
MyState st = global_state; <br/>
MyObject o; <br/>
CLEANUP: <br/>
reset_to(global_state, st);</p>
<p style="margin-left:9%; margin-top: 1em">and the code for
<b>rpcb_gettime()</b> can be rewritten as</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep) <br/>
time_t timep = NO_INIT <br/>
char *host = "localhost"; <br/>
C_ARGS: <br/>
host, &amp;timep <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<h3>The SCOPE: Keyword
<a name="The SCOPE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The SCOPE:
keyword allows scoping to be enabled for a particular XSUB.
If enabled, the XSUB will invoke ENTER and LEAVE
automatically.</p>
<p style="margin-left:9%; margin-top: 1em">To support
potentially complex type mappings, if a typemap entry used
by an XSUB contains a comment like "/*scope*/"
then scoping will be automatically enabled for that
XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">To enable
scoping:</p>
<p style="margin-left:9%; margin-top: 1em">SCOPE:
ENABLE</p>
<p style="margin-left:9%; margin-top: 1em">To disable
scoping:</p>
<p style="margin-left:9%; margin-top: 1em">SCOPE:
DISABLE</p>
<h3>The INPUT: Keyword
<a name="The INPUT: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The XSUB's
parameters are usually evaluated immediately after entering
the XSUB. The INPUT: keyword can be used to force those
parameters to be evaluated a little later. The INPUT:
keyword can be used multiple times within an XSUB and can be
used to list one or more input variables. This keyword is
used with the PREINIT: keyword.</p>
<p style="margin-left:9%; margin-top: 1em">The following
example shows how the input parameter "timep" can
be evaluated late, after a PREINIT.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
PREINIT: <br/>
time_t tt; <br/>
INPUT: <br/>
time_t timep <br/>
CODE: <br/>
RETVAL = rpcb_gettime( host, &amp;tt ); <br/>
timep = tt; <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">The next example
shows each input parameter evaluated late.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
PREINIT: <br/>
time_t tt; <br/>
INPUT: <br/>
char *host <br/>
PREINIT: <br/>
char *h; <br/>
INPUT: <br/>
time_t timep <br/>
CODE: <br/>
h = host; <br/>
RETVAL = rpcb_gettime( h, &amp;tt ); <br/>
timep = tt; <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">Since INPUT
sections allow declaration of C variables which do not
appear in the parameter list of a subroutine, this may be
shortened to:</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
time_t tt; <br/>
char *host; <br/>
char *h = host; <br/>
time_t timep; <br/>
CODE: <br/>
RETVAL = rpcb_gettime( h, &amp;tt ); <br/>
timep = tt; <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">(We used our
knowledge that input conversion for "char *" is a
"simple" one, thus "host" is initialized
on the declaration line, and our assignment "h =
host" is not performed too early. Otherwise one would
need to have the assignment "h = host" in a CODE:
or INIT: section.)</p>
<h3>The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords
<a name="The IN/OUTLIST/IN_OUTLIST/OUT/IN_OUT Keywords"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In the list of
parameters for an XSUB, one can precede parameter names by
the
"IN"/"OUTLIST"/"IN_OUTLIST"/"OUT"/"IN_OUT"
keywords. "IN" keyword is the default, the other
keywords indicate how the Perl interface should differ from
the C interface.</p>
<p style="margin-left:9%; margin-top: 1em">Parameters
preceded by
"OUTLIST"/"IN_OUTLIST"/"OUT"/"IN_OUT"
keywords are considered to be used by the C subroutine
<i>via pointers</i>. "OUTLIST"/"OUT"
keywords indicate that the C subroutine does not inspect the
memory pointed by this parameter, but will write through
this pointer to provide additional return values.</p>
<p style="margin-left:9%; margin-top: 1em">Parameters
preceded by "OUTLIST" keyword do not appear in the
usage signature of the generated Perl function.</p>
<p style="margin-left:9%; margin-top: 1em">Parameters
preceded by
"IN_OUTLIST"/"IN_OUT"/"OUT"
<i>do</i> appear as parameters to the Perl function. With
the exception of "OUT"−parameters, these
parameters are converted to the corresponding C type, then
pointers to these data are given as arguments to the C
function. It is expected that the C function will write
through these pointers.</p>
<p style="margin-left:9%; margin-top: 1em">The return list
of the generated Perl function consists of the C return
value from the function (unless the XSUB is of
"void" return type or "The NO_OUTPUT
Keyword" was used) followed by all the
"OUTLIST" and "IN_OUTLIST" parameters
(in the order of appearance). On the return from the XSUB
the "IN_OUT"/"OUT" Perl parameter will
be modified to have the values written by the C
function.</p>
<p style="margin-left:9%; margin-top: 1em">For example, an
XSUB</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
day_month(OUTLIST day, IN unix_time, OUTLIST month) <br/>
int day <br/>
int unix_time <br/>
int month</p>
<p style="margin-left:9%; margin-top: 1em">should be used
from Perl as</p>
<p style="margin-left:9%; margin-top: 1em">my ($day,
$month) = day_month(time);</p>
<p style="margin-left:9%; margin-top: 1em">The C signature
of the corresponding function should be</p>
<p style="margin-left:9%; margin-top: 1em">void
day_month(int *day, int unix_time, int *month);</p>
<p style="margin-left:9%; margin-top: 1em">The
"IN"/"OUTLIST"/"IN_OUTLIST"/"IN_OUT"/"OUT"
keywords can be mixed with ANSI−style declarations, as
in</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
day_month(OUTLIST int day, int unix_time, OUTLIST int
month)</p>
<p style="margin-left:9%; margin-top: 1em">(here the
optional "IN" keyword is omitted).</p>
<p style="margin-left:9%; margin-top: 1em">The
"IN_OUT" parameters are identical with parameters
introduced with "The &amp; Unary Operator" and put
into the "OUTPUT:" section (see "The OUTPUT:
Keyword"). The "IN_OUTLIST" parameters are
very similar, the only difference being that the value C
function writes through the pointer would not modify the
Perl parameter, but is put in the output list.</p>
<p style="margin-left:9%; margin-top: 1em">The
"OUTLIST"/"OUT" parameter differ from
"IN_OUTLIST"/"IN_OUT" parameters only by
the initial value of the Perl parameter not being read (and
not being given to the C function − which gets some
garbage instead). For example, the same C function as above
can be interfaced with as</p>
<p style="margin-left:9%; margin-top: 1em">void
day_month(OUT int day, int unix_time, OUT int month);</p>
<p style="margin-left:9%; margin-top: 1em">or</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
day_month(day, unix_time, month) <br/>
int &amp;day = NO_INIT <br/>
int unix_time <br/>
int &amp;month = NO_INIT <br/>
OUTPUT: <br/>
day <br/>
month</p>
<p style="margin-left:9%; margin-top: 1em">However, the
generated Perl function is called in very C−ish
style:</p>
<p style="margin-left:9%; margin-top: 1em">my ($day,
$month); <br/>
day_month($day, time, $month);</p>
<h3>The length(NAME) Keyword
<a name="The length(NAME) Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If one of the
input arguments to the C function is the length of a string
argument "NAME", one can substitute the name of
the length−argument by length(NAME) in the XSUB
declaration. This argument must be omitted when the
generated Perl function is called. E.g.,</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
dump_chars(char *s, short l) <br/>
{ <br/>
short n = 0; <br/>
while (n &lt; l) { <br/>
printf("s[%d] = \"\\%#03o\"\n", n,
(int)s[n]); <br/>
n++; <br/>
} <br/>
} <br/>
MODULE = x PACKAGE = x <br/>
void dump_chars(char *s, short length(s))</p>
<p style="margin-left:9%; margin-top: 1em">should be called
as dump_chars($string).</p>
<p style="margin-left:9%; margin-top: 1em">This directive
is supported with ANSI−type function declarations
only.</p>
<h3>Variable−length Parameter Lists
<a name="Variable−length Parameter Lists"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">XSUBs can have
variable−length parameter lists by specifying an
ellipsis "(...)" in the parameter list. This use
of the ellipsis is similar to that found in ANSI C. The
programmer is able to determine the number of arguments
passed to the XSUB by examining the "items"
variable which the <b>xsubpp</b> compiler supplies for all
XSUBs. By using this mechanism one can create an XSUB which
accepts a list of parameters of unknown length.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>host</i>
parameter for the <b>rpcb_gettime()</b> XSUB can be optional
so the ellipsis can be used to indicate that the XSUB will
take a variable number of parameters. Perl should be able to
call this XSUB with either of the following statements.</p>
<p style="margin-left:9%; margin-top: 1em">$status =
rpcb_gettime( $timep, $host ); <br/>
$status = rpcb_gettime( $timep );</p>
<p style="margin-left:9%; margin-top: 1em">The XS code,
with ellipsis, follows.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep, ...) <br/>
time_t timep = NO_INIT <br/>
PREINIT: <br/>
char *host = "localhost"; <br/>
CODE: <br/>
if( items &gt; 1 ) <br/>
host = (char *)SvPVbyte_nolen(ST(1)); <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<h3>The C_ARGS: Keyword
<a name="The C_ARGS: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The C_ARGS:
keyword allows creating of XSUBS which have different
calling sequence from Perl than from C, without a need to
write CODE: or PPCODE: section. The contents of the C_ARGS:
paragraph is put as the argument to the called C function
without any change.</p>
<p style="margin-left:9%; margin-top: 1em">For example,
suppose that a C function is declared as</p>
<p style="margin-left:9%; margin-top: 1em">symbolic
nth_derivative(int n, symbolic function, int flags);</p>
<p style="margin-left:9%; margin-top: 1em">and that the
default flags are kept in a global C variable
"default_flags". Suppose that you want to create
an interface which is called as</p>
<p style="margin-left:9%; margin-top: 1em">$second_deriv =
$function−&gt;nth_derivative(2);</p>
<p style="margin-left:9%; margin-top: 1em">To do this,
declare the XSUB as</p>
<p style="margin-left:9%; margin-top: 1em">symbolic <br/>
nth_derivative(function, n) <br/>
symbolic function <br/>
int n <br/>
C_ARGS: <br/>
n, function, default_flags</p>
<h3>The PPCODE: Keyword
<a name="The PPCODE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The PPCODE:
keyword is an alternate form of the CODE: keyword and is
used to tell the <b>xsubpp</b> compiler that the programmer
is supplying the code to control the argument stack for the
XSUBs return values. Occasionally one will want an XSUB to
return a list of values rather than a single value. In these
cases one must use PPCODE: and then explicitly push the list
of values on the stack. The PPCODE: and CODE: keywords
should not be used together within the same XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">The actual
difference between PPCODE: and CODE: sections is in the
initialization of "SP" macro (which stands for the
<i>current</i> Perl stack pointer), and in the handling of
data on the stack when returning from an XSUB. In CODE:
sections SP preserves the value which was on entry to the
XSUB: SP is on the function pointer (which follows the last
parameter). In PPCODE: sections SP is moved backward to the
beginning of the parameter list, which allows
"PUSH*()" macros to place output values in the
place Perl expects them to be when the XSUB returns back to
Perl.</p>
<p style="margin-left:9%; margin-top: 1em">The generated
trailer for a CODE: section ensures that the number of
return values Perl will see is either 0 or 1 (depending on
the "void"ness of the return value of the C
function, and heuristics mentioned in "The RETVAL
Variable"). The trailer generated for a PPCODE: section
is based on the number of return values and on the number of
times "SP" was updated by "[X]PUSH*()"
macros.</p>
<p style="margin-left:9%; margin-top: 1em">Note that macros
ST(i), "XST_m*()" and "XSRETURN*()" work
equally well in CODE: sections and PPCODE: sections.</p>
<p style="margin-left:9%; margin-top: 1em">The following
XSUB will call the C <b>rpcb_gettime()</b> function and will
return its two output values, timep and status, to Perl as a
single list.</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
rpcb_gettime(host) <br/>
char *host <br/>
PREINIT: <br/>
time_t timep; <br/>
bool_t status; <br/>
PPCODE: <br/>
status = rpcb_gettime( host, &amp;timep ); <br/>
EXTEND(SP, 2); <br/>
PUSHs(sv_2mortal(newSViv(status))); <br/>
PUSHs(sv_2mortal(newSViv(timep)));</p>
<p style="margin-left:9%; margin-top: 1em">Notice that the
programmer must supply the C code necessary to have the real
<b>rpcb_gettime()</b> function called and to have the return
values properly placed on the argument stack.</p>
<p style="margin-left:9%; margin-top: 1em">The
"void" return type for this function tells the
<b>xsubpp</b> compiler that the RETVAL variable is not
needed or used and that it should not be created. In most
scenarios the void return type should be used with the
PPCODE: directive.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>EXTEND()</b> macro is used to make room on the argument
stack for 2 return values. The PPCODE: directive causes the
<b>xsubpp</b> compiler to create a stack pointer available
as "SP", and it is this pointer which is being
used in the <b>EXTEND()</b> macro. The values are then
pushed onto the stack with the <b>PUSHs()</b> macro.</p>
<p style="margin-left:9%; margin-top: 1em">Now the
<b>rpcb_gettime()</b> function can be used from Perl with
the following statement.</p>
<p style="margin-left:9%; margin-top: 1em">($status,
$timep) = rpcb_gettime("localhost");</p>
<p style="margin-left:9%; margin-top: 1em">When handling
output parameters with a PPCODE section, be sure to handle
'set' magic properly. See perlguts for details about 'set'
magic.</p>
<h3>Returning Undef And Empty Lists
<a name="Returning Undef And Empty Lists"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Occasionally the
programmer will want to return simply "undef" or
an empty list if a function fails rather than a separate
status value. The <b>rpcb_gettime()</b> function offers just
this situation. If the function succeeds we would like to
have it return the time and if it fails we would like to
have undef returned. In the following Perl code the value of
$timep will either be undef or it will be a valid time.</p>
<p style="margin-left:9%; margin-top: 1em">$timep =
rpcb_gettime( "localhost" );</p>
<p style="margin-left:9%; margin-top: 1em">The following
XSUB uses the "SV *" return type as a mnemonic
only, and uses a CODE: block to indicate to the compiler
that the programmer has supplied all the necessary code. The
<b>sv_newmortal()</b> call will initialize the return value
to undef, making that the default return value.</p>
<p style="margin-left:9%; margin-top: 1em">SV * <br/>
rpcb_gettime(host) <br/>
char * host <br/>
PREINIT: <br/>
time_t timep; <br/>
bool_t x; <br/>
CODE: <br/>
ST(0) = sv_newmortal(); <br/>
if( rpcb_gettime( host, &amp;timep ) ) <br/>
sv_setnv( ST(0), (double)timep);</p>
<p style="margin-left:9%; margin-top: 1em">The next example
demonstrates how one would place an explicit undef in the
return value, should the need arise.</p>
<p style="margin-left:9%; margin-top: 1em">SV * <br/>
rpcb_gettime(host) <br/>
char * host <br/>
PREINIT: <br/>
time_t timep; <br/>
bool_t x; <br/>
CODE: <br/>
if( rpcb_gettime( host, &amp;timep ) ){ <br/>
ST(0) = sv_newmortal(); <br/>
sv_setnv( ST(0), (double)timep); <br/>
} <br/>
else{ <br/>
ST(0) = &amp;PL_sv_undef; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">To return an
empty list one must use a PPCODE: block and then not push
return values on the stack.</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
rpcb_gettime(host) <br/>
char *host <br/>
PREINIT: <br/>
time_t timep; <br/>
PPCODE: <br/>
if( rpcb_gettime( host, &amp;timep ) ) <br/>
PUSHs(sv_2mortal(newSViv(timep))); <br/>
else{ <br/>
/* Nothing pushed on stack, so an empty <br/>
* list is implicitly returned. */ <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Some people may
be inclined to include an explicit "return" in the
above XSUB, rather than letting control fall through to the
end. In those situations "XSRETURN_EMPTY" should
be used, instead. This will ensure that the XSUB stack is
properly adjusted. Consult perlapi for other
"XSRETURN" macros.</p>
<p style="margin-left:9%; margin-top: 1em">Since
"XSRETURN_*" macros can be used with CODE blocks
as well, one can rewrite this example as:</p>
<p style="margin-left:9%; margin-top: 1em">int <br/>
rpcb_gettime(host) <br/>
char *host <br/>
PREINIT: <br/>
time_t timep; <br/>
CODE: <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
if (RETVAL == 0) <br/>
XSRETURN_UNDEF; <br/>
OUTPUT: <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">In fact, one can
put this check into a POSTCALL: section as well. Together
with PREINIT: simplifications, this leads to:</p>
<p style="margin-left:9%; margin-top: 1em">int <br/>
rpcb_gettime(host) <br/>
char *host <br/>
time_t timep; <br/>
POSTCALL: <br/>
if (RETVAL == 0) <br/>
XSRETURN_UNDEF;</p>
<h3>The REQUIRE: Keyword
<a name="The REQUIRE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The REQUIRE:
keyword is used to indicate the minimum version of the
<b>xsubpp</b> compiler needed to compile the XS module. An
XS module which contains the following statement will
compile with only <b>xsubpp</b> version 1.922 or
greater:</p>
<p style="margin-left:9%; margin-top: 1em">REQUIRE:
1.922</p>
<h3>The CLEANUP: Keyword
<a name="The CLEANUP: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword can
be used when an XSUB requires special cleanup procedures
before it terminates. When the CLEANUP: keyword is used it
must follow any CODE:, or OUTPUT: blocks which are present
in the XSUB. The code specified for the cleanup block will
be added as the last statements in the XSUB.</p>
<h3>The POSTCALL: Keyword
<a name="The POSTCALL: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword can
be used when an XSUB requires special procedures executed
after the C subroutine call is performed. When the POSTCALL:
keyword is used it must precede OUTPUT: and CLEANUP: blocks
which are present in the XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">See examples in
"The NO_OUTPUT Keyword" and "Returning Undef
And Empty Lists".</p>
<p style="margin-left:9%; margin-top: 1em">The POSTCALL:
block does not make a lot of sense when the C subroutine
call is supplied by user by providing either CODE: or
PPCODE: section.</p>
<h3>The BOOT: Keyword
<a name="The BOOT: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The BOOT:
keyword is used to add code to the extension's bootstrap
function. The bootstrap function is generated by the
<b>xsubpp</b> compiler and normally holds the statements
necessary to register any XSUBs with Perl. With the BOOT:
keyword the programmer can tell the compiler to add extra
statements to the bootstrap function.</p>
<p style="margin-left:9%; margin-top: 1em">This keyword may
be used any time after the first MODULE keyword and should
appear on a line by itself. The first blank line after the
keyword will terminate the code block.</p>
<p style="margin-left:9%; margin-top: 1em">BOOT: <br/>
# The following message will be printed when the <br/>
# bootstrap function executes. <br/>
printf("Hello from the bootstrap!\n");</p>
<h3>The VERSIONCHECK: Keyword
<a name="The VERSIONCHECK: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
VERSIONCHECK: keyword corresponds to <b>xsubpp</b>'s
"−versioncheck" and
"−noversioncheck" options. This keyword
overrides the command line options. Version checking is
enabled by default. When version checking is enabled the XS
module will attempt to verify that its version matches the
version of the PM module.</p>
<p style="margin-left:9%; margin-top: 1em">To enable
version checking:</p>
<p style="margin-left:9%; margin-top: 1em">VERSIONCHECK:
ENABLE</p>
<p style="margin-left:9%; margin-top: 1em">To disable
version checking:</p>
<p style="margin-left:9%; margin-top: 1em">VERSIONCHECK:
DISABLE</p>
<p style="margin-left:9%; margin-top: 1em">Note that if the
version of the PM module is an NV (a floating point number),
it will be stringified with a possible loss of precision
(currently chopping to nine decimal places) so that it may
not match the version of the XS module anymore. Quoting the
$VERSION declaration to make it a string is recommended if
long version numbers are used.</p>
<h3>The PROTOTYPES: Keyword
<a name="The PROTOTYPES: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The PROTOTYPES:
keyword corresponds to <b>xsubpp</b>'s
"−prototypes" and
"−noprototypes" options. This keyword
overrides the command line options. Prototypes are disabled
by default. When prototypes are enabled, XSUBs will be given
Perl prototypes. This keyword may be used multiple times in
an XS module to enable and disable prototypes for different
parts of the module. Note that <b>xsubpp</b> will nag you if
you don't explicitly enable or disable prototypes, with:</p>
<p style="margin-left:9%; margin-top: 1em">Please specify
prototyping behavior for Foo.xs (see perlxs manual)</p>
<p style="margin-left:9%; margin-top: 1em">To enable
prototypes:</p>
<p style="margin-left:9%; margin-top: 1em">PROTOTYPES:
ENABLE</p>
<p style="margin-left:9%; margin-top: 1em">To disable
prototypes:</p>
<p style="margin-left:9%; margin-top: 1em">PROTOTYPES:
DISABLE</p>
<h3>The PROTOTYPE: Keyword
<a name="The PROTOTYPE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword is
similar to the PROTOTYPES: keyword above but can be used to
force <b>xsubpp</b> to use a specific prototype for the
XSUB. This keyword overrides all other prototype options and
keywords but affects only the current XSUB. Consult
"Prototypes" in perlsub for information about Perl
prototypes.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(timep, ...) <br/>
time_t timep = NO_INIT <br/>
PROTOTYPE: $;$ <br/>
PREINIT: <br/>
char *host = "localhost"; <br/>
CODE: <br/>
if( items &gt; 1 ) <br/>
host = (char *)SvPVbyte_nolen(ST(1)); <br/>
RETVAL = rpcb_gettime( host, &amp;timep ); <br/>
OUTPUT: <br/>
timep <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">If the
prototypes are enabled, you can disable it locally for a
given XSUB as in the following example:</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
rpcb_gettime_noproto() <br/>
PROTOTYPE: DISABLE <br/>
...</p>
<h3>The ALIAS: Keyword
<a name="The ALIAS: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The ALIAS:
keyword allows an XSUB to have two or more unique Perl names
and to know which of those names was used when it was
invoked. The Perl names may be fully−qualified with
package names. Each alias is given an index. The compiler
will setup a variable called "ix" which contain
the index of the alias which was used. When the XSUB is
called with its declared name "ix" will be 0.</p>
<p style="margin-left:9%; margin-top: 1em">The following
example will create aliases FOO::gettime() and BAR::getit()
for this function.</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
ALIAS: <br/>
FOO::gettime = 1 <br/>
BAR::getit = 2 <br/>
INIT: <br/>
printf("# ix = %d\n", ix ); <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">A warning will
be produced when you create more than one alias to the same
value. This may be worked around in a backwards compatible
way by creating multiple defines which resolve to the same
value, or with a modern version of ExtUtils::ParseXS you can
use a symbolic alias, which are denoted with a
"=&gt;" instead of a "=". For instance
you could change the above so that the alias section looked
like this:</p>
<p style="margin-left:9%; margin-top: 1em">ALIAS: <br/>
FOO::gettime = 1 <br/>
BAR::getit = 2 <br/>
BAZ::gettime =&gt; FOO::gettime</p>
<p style="margin-left:9%; margin-top: 1em">this would have
the same effect as this:</p>
<p style="margin-left:9%; margin-top: 1em">ALIAS: <br/>
FOO::gettime = 1 <br/>
BAR::getit = 2 <br/>
BAZ::gettime = 1</p>
<p style="margin-left:9%; margin-top: 1em">except that the
latter will produce warnings during the build process. A
mechanism that would work in a backwards compatible way with
older versions of our tool chain would be to do this:</p>
<p style="margin-left:9%; margin-top: 1em">#define
FOO_GETTIME 1 <br/>
#define BAR_GETIT 2 <br/>
#define BAZ_GETTIME 1 <br/>
bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
ALIAS: <br/>
FOO::gettime = FOO_GETTIME <br/>
BAR::getit = BAR_GETIT <br/>
BAZ::gettime = BAZ_GETTIME <br/>
INIT: <br/>
printf("# ix = %d\n", ix ); <br/>
OUTPUT: <br/>
timep</p>
<h3>The OVERLOAD: Keyword
<a name="The OVERLOAD: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Instead of
writing an overloaded interface using pure Perl, you can
also use the OVERLOAD keyword to define additional Perl
names for your functions (like the ALIAS: keyword above).
However, the overloaded functions must be defined in such a
way as to accept the number of parameters supplied by perl's
overload system. For most overload methods, it will be three
parameters; for the "nomethod" function it will be
four. However, the bitwise operators "&amp;",
"|", "ˆ", and "˜"
may be called with three <i>or</i> five arguments (see
overload).</p>
<p style="margin-left:9%; margin-top: 1em">If any function
has the OVERLOAD: keyword, several additional lines will be
defined in the c file generated by xsubpp in order to
register with the overload magic.</p>
<p style="margin-left:9%; margin-top: 1em">Since blessed
objects are actually stored as RV's, it is useful to use the
typemap features to preprocess parameters and extract the
actual SV stored within the blessed RV. See the sample for
T_PTROBJ_SPECIAL below.</p>
<p style="margin-left:9%; margin-top: 1em">To use the
OVERLOAD: keyword, create an XS function which takes three
input parameters (or use the C−style '...' definition)
like this:</p>
<p style="margin-left:9%; margin-top: 1em">SV * <br/>
cmp (lobj, robj, swap) <br/>
My_Module_obj lobj <br/>
My_Module_obj robj <br/>
IV swap <br/>
OVERLOAD: cmp &lt;=&gt; <br/>
{ /* function defined here */}</p>
<p style="margin-left:9%; margin-top: 1em">In this case,
the function will overload both of the three way comparison
operators. For all overload operations using non−alpha
characters, you must type the parameter without quoting,
separating multiple overloads with whitespace. Note that
"" (the stringify overload) should be entered as
\"\" (i.e. escaped).</p>
<p style="margin-left:9%; margin-top: 1em">Since, as
mentioned above, bitwise operators may take extra arguments,
you may want to use something like "(lobj, robj, swap,
...)" (with literal "...") as your parameter
list.</p>
<h3>The FALLBACK: Keyword
<a name="The FALLBACK: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In addition to
the OVERLOAD keyword, if you need to control how Perl
autogenerates missing overloaded operators, you can set the
FALLBACK keyword in the module header section, like
this:</p>
<p style="margin-left:9%; margin-top: 1em">MODULE = RPC
PACKAGE = RPC <br/>
FALLBACK: TRUE <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">where FALLBACK
can take any of the three values TRUE, FALSE, or UNDEF. If
you do not set any FALLBACK value when using OVERLOAD, it
defaults to UNDEF. FALLBACK is not used except when one or
more functions using OVERLOAD have been defined. Please see
"fallback" in overload for more details.</p>
<h3>The INTERFACE: Keyword
<a name="The INTERFACE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword
declares the current XSUB as a keeper of the given calling
signature. If some text follows this keyword, it is
considered as a list of functions which have this signature,
and should be attached to the current XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">For example, if
you have 4 C functions <b>multiply()</b>, <b>divide()</b>,
<b>add()</b>, <b>subtract()</b> all having the
signature:</p>
<p style="margin-left:9%; margin-top: 1em">symbolic
f(symbolic, symbolic);</p>
<p style="margin-left:9%; margin-top: 1em">you can make
them all to use the same XSUB using this:</p>
<p style="margin-left:9%; margin-top: 1em">symbolic <br/>
interface_s_ss(arg1, arg2) <br/>
symbolic arg1 <br/>
symbolic arg2 <br/>
INTERFACE: <br/>
multiply divide <br/>
add subtract</p>
<p style="margin-left:9%; margin-top: 1em">(This is the
complete XSUB code for 4 Perl functions!) Four generated
Perl function share names with corresponding C
functions.</p>
<p style="margin-left:9%; margin-top: 1em">The advantage of
this approach comparing to ALIAS: keyword is that there is
no need to code a switch statement, each Perl function
(which shares the same XSUB) knows which C function it
should call. Additionally, one can attach an extra function
<b>remainder()</b> at runtime by using</p>
<p style="margin-left:9%; margin-top: 1em">CV *mycv =
newXSproto("Symbolic::remainder", <br/>
XS_Symbolic_interface_s_ss, __FILE__, "$$"); <br/>
XSINTERFACE_FUNC_SET(mycv, remainder);</p>
<p style="margin-left:9%; margin-top: 1em">say, from
another XSUB. (This example supposes that there was no
INTERFACE_MACRO: section, otherwise one needs to use
something else instead of "XSINTERFACE_FUNC_SET",
see the next section.)</p>
<h3>The INTERFACE_MACRO: Keyword
<a name="The INTERFACE_MACRO: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword
allows one to define an INTERFACE using a different way to
extract a function pointer from an XSUB. The text which
follows this keyword should give the name of macros which
would extract/set a function pointer. The extractor macro is
given return type, "CV*", and
"XSANY.any_dptr" for this "CV*". The
setter macro is given cv, and the function pointer.</p>
<p style="margin-left:9%; margin-top: 1em">The default
value is "XSINTERFACE_FUNC" and
"XSINTERFACE_FUNC_SET". An INTERFACE keyword with
an empty list of functions can be omitted if INTERFACE_MACRO
keyword is used.</p>
<p style="margin-left:9%; margin-top: 1em">Suppose that in
the previous example functions pointers for
<b>multiply()</b>, <b>divide()</b>, <b>add()</b>,
<b>subtract()</b> are kept in a global C array
"fp[]" with offsets being
"multiply_off", "divide_off",
"add_off", "subtract_off". Then one can
use</p>
<p style="margin-left:9%; margin-top: 1em">#define
XSINTERFACE_FUNC_BYOFFSET(ret,cv,f) \ <br/>
((XSINTERFACE_CVT_ANON(ret))fp[CvXSUBANY(cv).any_i32]) <br/>
#define XSINTERFACE_FUNC_BYOFFSET_set(cv,f) \ <br/>
CvXSUBANY(cv).any_i32 = CAT2( f, _off )</p>
<p style="margin-left:9%; margin-top: 1em">in C
section,</p>
<p style="margin-left:9%; margin-top: 1em">symbolic <br/>
interface_s_ss(arg1, arg2) <br/>
symbolic arg1 <br/>
symbolic arg2 <br/>
INTERFACE_MACRO: <br/>
XSINTERFACE_FUNC_BYOFFSET <br/>
XSINTERFACE_FUNC_BYOFFSET_set <br/>
INTERFACE: <br/>
multiply divide <br/>
add subtract</p>
<p style="margin-left:9%; margin-top: 1em">in XSUB
section.</p>
<h3>The INCLUDE: Keyword
<a name="The INCLUDE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This keyword can
be used to pull other files into the XS module. The other
files may have XS code. INCLUDE: can also be used to run a
command to generate the XS code to be pulled into the
module.</p>
<p style="margin-left:9%; margin-top: 1em">The file
<i>Rpcb1.xsh</i> contains our rpcb_gettime() function:</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">The XS module
can use INCLUDE: to pull that file into it.</p>
<p style="margin-left:9%; margin-top: 1em">INCLUDE:
Rpcb1.xsh</p>
<p style="margin-left:9%; margin-top: 1em">If the
parameters to the INCLUDE: keyword are followed by a pipe
("|") then the compiler will interpret the
parameters as a command. This feature is mildly deprecated
in favour of the "INCLUDE_COMMAND:" directive, as
documented below.</p>
<p style="margin-left:9%; margin-top: 1em">INCLUDE: cat
Rpcb1.xsh |</p>
<p style="margin-left:9%; margin-top: 1em">Do not use this
to run perl: "INCLUDE: perl |" will run the perl
that happens to be the first in your path and not
necessarily the same perl that is used to run
"xsubpp". See "The INCLUDE_COMMAND:
Keyword".</p>
<h3>The INCLUDE_COMMAND: Keyword
<a name="The INCLUDE_COMMAND: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Runs the
supplied command and includes its output into the current XS
document. "INCLUDE_COMMAND" assigns special
meaning to the $ˆX token in that it runs the same perl
interpreter that is running "xsubpp":</p>
<p style="margin-left:9%; margin-top: 1em">INCLUDE_COMMAND:
cat Rpcb1.xsh <br/>
INCLUDE_COMMAND: $ˆX −e ...</p>
<h3>The CASE: Keyword
<a name="The CASE: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The CASE:
keyword allows an XSUB to have multiple distinct parts with
each part acting as a virtual XSUB. CASE: is greedy and if
it is used then all other XS keywords must be contained
within a CASE:. This means nothing may precede the first
CASE: in the XSUB and anything following the last CASE: is
included in that case.</p>
<p style="margin-left:9%; margin-top: 1em">A CASE: might
switch via a parameter of the XSUB, via the "ix"
ALIAS: variable (see "The ALIAS: Keyword"), or
maybe via the "items" variable (see
"Variable−length Parameter Lists"). The last
CASE: becomes the <b>default</b> case if it is not
associated with a conditional. The following example shows
CASE switched via "ix" with a function
rpcb_gettime() having an alias x_gettime(). When the
function is called as rpcb_gettime() its parameters are the
usual "(char *host, time_t *timep)", but when the
function is called as x_gettime() its parameters are
reversed, "(time_t *timep, char *host)".</p>
<p style="margin-left:9%; margin-top: 1em">long <br/>
rpcb_gettime(a,b) <br/>
CASE: ix == 1 <br/>
ALIAS: <br/>
x_gettime = 1 <br/>
INPUT: <br/>
# 'a' is timep, 'b' is host <br/>
char *b <br/>
time_t a = NO_INIT <br/>
CODE: <br/>
RETVAL = rpcb_gettime( b, &amp;a ); <br/>
OUTPUT: <br/>
a <br/>
RETVAL <br/>
CASE: <br/>
# 'a' is host, 'b' is timep <br/>
char *a <br/>
time_t &amp;b = NO_INIT <br/>
OUTPUT: <br/>
b <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">That function
can be called with either of the following statements. Note
the different argument lists.</p>
<p style="margin-left:9%; margin-top: 1em">$status =
rpcb_gettime( $host, $timep ); <br/>
$status = x_gettime( $timep, $host );</p>
<h3>The EXPORT_XSUB_SYMBOLS: Keyword
<a name="The EXPORT_XSUB_SYMBOLS: Keyword"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
EXPORT_XSUB_SYMBOLS: keyword is likely something you will
never need. In perl versions earlier than 5.16.0, this
keyword does nothing. Starting with 5.16, XSUB symbols are
no longer exported by default. That is, they are
"static" functions. If you include</p>
<p style="margin-left:9%; margin-top: 1em">EXPORT_XSUB_SYMBOLS:
ENABLE</p>
<p style="margin-left:9%; margin-top: 1em">in your XS code,
the XSUBs following this line will not be declared
"static". You can later disable this with</p>
<p style="margin-left:9%; margin-top: 1em">EXPORT_XSUB_SYMBOLS:
DISABLE</p>
<p style="margin-left:9%; margin-top: 1em">which, again, is
the default that you should probably never change. You
cannot use this keyword on versions of perl before 5.16 to
make XSUBs "static".</p>
<h3>The &amp; Unary Operator
<a name="The &amp; Unary Operator"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
"&amp;" unary operator in the INPUT: section is
used to tell <b>xsubpp</b> that it should convert a Perl
value to/from C using the C type to the left of
"&amp;", but provide a pointer to this value when
the C function is called.</p>
<p style="margin-left:9%; margin-top: 1em">This is useful
to avoid a CODE: block for a C function which takes a
parameter by reference. Typically, the parameter should be
not a pointer type (an "int" or "long"
but not an "int*" or "long*").</p>
<p style="margin-left:9%; margin-top: 1em">The following
XSUB will generate incorrect C code. The <b>xsubpp</b>
compiler will turn this into code which calls rpcb_gettime()
with parameters "(char *host, time_t timep)", but
the real rpcb_gettime() wants the "timep"
parameter to be of type "time_t*" rather than
"time_t".</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t timep <br/>
OUTPUT: <br/>
timep</p>
<p style="margin-left:9%; margin-top: 1em">That problem is
corrected by using the "&amp;" operator. The
<b>xsubpp</b> compiler will now turn this into code which
calls rpcb_gettime() correctly with parameters "(char
*host, time_t *timep)". It does this by carrying the
"&amp;" through, so the function call looks like
"rpcb_gettime(host, &amp;timep)".</p>
<p style="margin-left:9%; margin-top: 1em">bool_t <br/>
rpcb_gettime(host,timep) <br/>
char *host <br/>
time_t &amp;timep <br/>
OUTPUT: <br/>
timep</p>
<h3>Inserting POD, Comments and C Preprocessor Directives
<a name="Inserting POD, Comments and C Preprocessor Directives"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">C preprocessor
directives are allowed within BOOT:, PREINIT: INIT:, CODE:,
PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside
the functions. Comments are allowed anywhere after the
MODULE keyword. The compiler will pass the preprocessor
directives through untouched and will remove the commented
lines. POD documentation is allowed at any point, both in
the C and XS language sections. POD must be terminated with
a "=cut" command; "xsubpp" will exit
with an error if it does not. It is very unlikely that human
generated C code will be mistaken for POD, as most indenting
styles result in whitespace in front of any line starting
with "=". Machine generated XS files may fall into
this trap unless care is taken to ensure that a space breaks
the sequence "\n=".</p>
<p style="margin-left:9%; margin-top: 1em">Comments can be
added to XSUBs by placing a "#" as the first
non−whitespace of a line. Care should be taken to
avoid making the comment look like a C preprocessor
directive, lest it be interpreted as such. The simplest way
to prevent this is to put whitespace in front of the
"#".</p>
<p style="margin-left:9%; margin-top: 1em">If you use
preprocessor directives to choose one of two versions of a
function, use</p>
<p style="margin-left:9%; margin-top: 1em">#if ... version1
<br/>
#else /* ... version2 */ <br/>
#endif</p>
<p style="margin-left:9%; margin-top: 1em">and not</p>
<p style="margin-left:9%; margin-top: 1em">#if ... version1
<br/>
#endif <br/>
#if ... version2 <br/>
#endif</p>
<p style="margin-left:9%; margin-top: 1em">because
otherwise <b>xsubpp</b> will believe that you made a
duplicate definition of the function. Also, put a blank line
before the #else/#endif so it will not be seen as part of
the function body.</p>
<h3>Using XS With C++
<a name="Using XS With C++"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If an XSUB name
contains "::", it is considered to be a C++
method. The generated Perl function will assume that its
first argument is an object pointer. The object pointer will
be stored in a variable called THIS. The object should have
been created by C++ with the <b>new()</b> function and
should be blessed by Perl with the <b>sv_setref_pv()</b>
macro. The blessing of the object by Perl can be handled by
a typemap. An example typemap is shown at the end of this
section.</p>
<p style="margin-left:9%; margin-top: 1em">If the return
type of the XSUB includes "static", the method is
considered to be a static method. It will call the C++
function using the <b>class::method()</b> syntax. If the
method is not static the function will be called using the
THIS−&gt;<b>method()</b> syntax.</p>
<p style="margin-left:9%; margin-top: 1em">The next
examples will use the following C++ class.</p>
<p style="margin-left:9%; margin-top: 1em">class color {
<br/>
public: <br/>
color(); <br/>
˜color(); <br/>
int blue(); <br/>
void set_blue( int ); <br/>
private: <br/>
int c_blue; <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">The XSUBs for
the <b>blue()</b> and <b>set_blue()</b> methods are defined
with the class name but the parameter for the object (THIS,
or "self") is implicit and is not listed.</p>
<p style="margin-left:9%; margin-top: 1em">int <br/>
color::blue() <br/>
void <br/>
color::set_blue( val ) <br/>
int val</p>
<p style="margin-left:9%; margin-top: 1em">Both Perl
functions will expect an object as the first parameter. In
the generated C++ code the object is called
"THIS", and the method call will be performed on
this object. So in the C++ code the <b>blue()</b> and
<b>set_blue()</b> methods will be called as this:</p>
<p style="margin-left:9%; margin-top: 1em">RETVAL =
THIS−&gt;blue(); <br/>
THIS−&gt;set_blue( val );</p>
<p style="margin-left:9%; margin-top: 1em">You could also
write a single get/set method using an optional
argument:</p>
<p style="margin-left:9%; margin-top: 1em">int <br/>
color::blue( val = NO_INIT ) <br/>
int val <br/>
PROTOTYPE $;$ <br/>
CODE: <br/>
if (items &gt; 1) <br/>
THIS−&gt;set_blue( val ); <br/>
RETVAL = THIS−&gt;blue(); <br/>
OUTPUT: <br/>
RETVAL</p>
<p style="margin-left:9%; margin-top: 1em">If the
function's name is <b>DESTROY</b> then the C++
"delete" function will be called and
"THIS" will be given as its parameter. The
generated C++ code for</p>
<p style="margin-left:9%; margin-top: 1em">void <br/>
color::DESTROY()</p>
<p style="margin-left:9%; margin-top: 1em">will look like
this:</p>
<p style="margin-left:9%; margin-top: 1em">color *THIS =
...; // Initialized as in typemap <br/>
delete THIS;</p>
<p style="margin-left:9%; margin-top: 1em">If the
function's name is <b>new</b> then the C++ "new"
function will be called to create a dynamic C++ object. The
XSUB will expect the class name, which will be kept in a
variable called "CLASS", to be given as the first
argument.</p>
<p style="margin-left:9%; margin-top: 1em">color * <br/>
color::new()</p>
<p style="margin-left:9%; margin-top: 1em">The generated
C++ code will call "new".</p>
<p style="margin-left:9%; margin-top: 1em">RETVAL = new
color();</p>
<p style="margin-left:9%; margin-top: 1em">The following is
an example of a typemap that could be used for this C++
example.</p>
<p style="margin-left:9%; margin-top: 1em">TYPEMAP <br/>
color * O_OBJECT <br/>
OUTPUT <br/>
# The Perl object is blessed into 'CLASS', which should be a
<br/>
# char* having the name of the package for the blessing.
<br/>
O_OBJECT <br/>
sv_setref_pv( $arg, CLASS, (void*)$var ); <br/>
INPUT <br/>
O_OBJECT <br/>
if( sv_isobject($arg) &amp;&amp; (SvTYPE(SvRV($arg)) ==
SVt_PVMG) ) <br/>
$var = ($type)SvIV((SV*)SvRV( $arg )); <br/>
else{ <br/>
warn(\"${Package}::$func_name() −− \"
<br/>
\"$var is not a blessed SV reference\"); <br/>
XSRETURN_UNDEF; <br/>
}</p>
<h3>Interface Strategy
<a name="Interface Strategy"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When designing
an interface between Perl and a C library a straight
translation from C to XS (such as created by "h2xs
−x") is often sufficient. However, sometimes the
interface will look very C−like and occasionally
nonintuitive, especially when the C function modifies one of
its parameters, or returns failure inband (as in
"negative return values mean failure"). In cases
where the programmer wishes to create a more Perl−like
interface the following strategy may help to identify the
more critical parts of the interface.</p>
<p style="margin-left:9%; margin-top: 1em">Identify the C
functions with input/output or output parameters. The XSUBs
for these functions may be able to return lists to Perl.</p>
<p style="margin-left:9%; margin-top: 1em">Identify the C
functions which use some inband info as an indication of
failure. They may be candidates to return undef or an empty
list in case of failure. If the failure may be detected
without a call to the C function, you may want to use an
INIT: section to report the failure. For failures detectable
after the C function returns one may want to use a POSTCALL:
section to process the failure. In more complicated cases
use CODE: or PPCODE: sections.</p>
<p style="margin-left:9%; margin-top: 1em">If many
functions use the same failure indication based on the
return value, you may want to create a special typedef to
handle this situation. Put</p>
<p style="margin-left:9%; margin-top: 1em">typedef int
negative_is_failure;</p>
<p style="margin-left:9%; margin-top: 1em">near the
beginning of XS file, and create an OUTPUT typemap entry for
"negative_is_failure" which converts negative
values to "undef", or maybe <b>croak()</b>s. After
this the return value of type
"negative_is_failure" will create more
Perl−like interface.</p>
<p style="margin-left:9%; margin-top: 1em">Identify which
values are used by only the C and XSUB functions themselves,
say, when a parameter to a function should be a contents of
a global variable. If Perl does not need to access the
contents of the value then it may not be necessary to
provide a translation for that value from C to Perl.</p>
<p style="margin-left:9%; margin-top: 1em">Identify the
pointers in the C function parameter lists and return
values. Some pointers may be used to implement input/output
or output parameters, they can be handled in XS with the
"&amp;" unary operator, and, possibly, using the
NO_INIT keyword. Some others will require handling of types
like "int *", and one needs to decide what a
useful Perl translation will do in such a case. When the
semantic is clear, it is advisable to put the translation
into a typemap file.</p>
<p style="margin-left:9%; margin-top: 1em">Identify the
structures used by the C functions. In many cases it may be
helpful to use the T_PTROBJ typemap for these structures so
they can be manipulated by Perl as blessed objects. (This is
handled automatically by "h2xs −x".)</p>
<p style="margin-left:9%; margin-top: 1em">If the same C
type is used in several different contexts which require
different translations, "typedef" several new
types mapped to this C type, and create separate
<i>typemap</i> entries for these new types. Use these types
in declarations of return type and parameters to XSUBs.</p>
<h3>Perl Objects And C Structures
<a name="Perl Objects And C Structures"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When dealing
with C structures one should select either <b>T_PTROBJ</b>
or <b>T_PTRREF</b> for the XS type. Both types are designed
to handle pointers to complex objects. The T_PTRREF type
will allow the Perl object to be unblessed while the
T_PTROBJ type requires that the object be blessed. By using
T_PTROBJ one can achieve a form of type−checking
because the XSUB will attempt to verify that the Perl object
is of the expected type.</p>
<p style="margin-left:9%; margin-top: 1em">The following XS
code shows the <b>getnetconfigent()</b> function which is
used with ONC+ TIRPC. The <b>getnetconfigent()</b> function
will return a pointer to a C structure and has the C
prototype shown below. The example will demonstrate how the
C pointer will become a Perl reference. Perl will consider
this reference to be a pointer to a blessed object and will
attempt to call a destructor for the object. A destructor
will be provided in the XS source to free the memory used by
<b>getnetconfigent()</b>. Destructors in XS can be created
by specifying an XSUB function whose name ends with the word
<b>DESTROY</b>. XS destructors can be used to free memory
which may have been malloc'd by another XSUB.</p>
<p style="margin-left:9%; margin-top: 1em">struct netconfig
*getnetconfigent(const char *netid);</p>
<p style="margin-left:9%; margin-top: 1em">A
"typedef" will be created for "struct
netconfig". The Perl object will be blessed in a class
matching the name of the C type, with the tag
"Ptr" appended, and the name should not have
embedded spaces if it will be a Perl package name. The
destructor will be placed in a class corresponding to the
class of the object and the PREFIX keyword will be used to
trim the name to the word DESTROY as Perl will expect.</p>
<p style="margin-left:9%; margin-top: 1em">typedef struct
netconfig Netconfig; <br/>
MODULE = RPC PACKAGE = RPC <br/>
Netconfig * <br/>
getnetconfigent(netid) <br/>
char *netid <br/>
MODULE = RPC PACKAGE = NetconfigPtr PREFIX = rpcb_ <br/>
void <br/>
rpcb_DESTROY(netconf) <br/>
Netconfig *netconf <br/>
CODE: <br/>
printf("Now in NetconfigPtr::DESTROY\n"); <br/>
free( netconf );</p>
<p style="margin-left:9%; margin-top: 1em">This example
requires the following typemap entry. Consult perlxstypemap
for more information about adding new typemaps for an
extension.</p>
<p style="margin-left:9%; margin-top: 1em">TYPEMAP <br/>
Netconfig * T_PTROBJ</p>
<p style="margin-left:9%; margin-top: 1em">This example
will be used with the following Perl statements.</p>
<p style="margin-left:9%; margin-top: 1em">use RPC; <br/>
$netconf = getnetconfigent("udp");</p>
<p style="margin-left:9%; margin-top: 1em">When Perl
destroys the object referenced by $netconf it will send the
object to the supplied XSUB DESTROY function. Perl cannot
determine, and does not care, that this object is a C struct
and not a Perl object. In this sense, there is no difference
between the object created by the <b>getnetconfigent()</b>
XSUB and an object created by a normal Perl subroutine.</p>
<h3>Safely Storing Static Data in XS
<a name="Safely Storing Static Data in XS"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Starting with
Perl 5.8, a macro framework has been defined to allow static
data to be safely stored in XS modules that will be accessed
from a multi−threaded Perl.</p>
<p style="margin-left:9%; margin-top: 1em">Although
primarily designed for use with multi−threaded Perl,
the macros have been designed so that they will work with
non−threaded Perl as well.</p>
<p style="margin-left:9%; margin-top: 1em">It is therefore
strongly recommended that these macros be used by all XS
modules that make use of static data.</p>
<p style="margin-left:9%; margin-top: 1em">The easiest way
to get a template set of macros to use is by specifying the
"−g" ("−−global")
option with h2xs (see h2xs).</p>
<p style="margin-left:9%; margin-top: 1em">Below is an
example module that makes use of the macros.</p>
<p style="margin-left:9%; margin-top: 1em">#define
PERL_NO_GET_CONTEXT <br/>
#include "EXTERN.h" <br/>
#include "perl.h" <br/>
#include "XSUB.h" <br/>
/* Global Data */ <br/>
#define MY_CXT_KEY "BlindMice::_guts" XS_VERSION
<br/>
typedef struct { <br/>
int count; <br/>
char name[3][100]; <br/>
} my_cxt_t; <br/>
START_MY_CXT <br/>
MODULE = BlindMice PACKAGE = BlindMice <br/>
BOOT: <br/>
{ <br/>
MY_CXT_INIT; <br/>
MY_CXT.count = 0; <br/>
strcpy(MY_CXT.name[0], "None"); <br/>
strcpy(MY_CXT.name[1], "None"); <br/>
strcpy(MY_CXT.name[2], "None"); <br/>
} <br/>
int <br/>
newMouse(char * name) <br/>
PREINIT: <br/>
dMY_CXT; <br/>
CODE: <br/>
if (MY_CXT.count &gt;= 3) { <br/>
warn("Already have 3 blind mice"); <br/>
RETVAL = 0; <br/>
} <br/>
else { <br/>
RETVAL = ++ MY_CXT.count; <br/>
strcpy(MY_CXT.name[MY_CXT.count − 1], name); <br/>
} <br/>
OUTPUT: <br/>
RETVAL <br/>
char * <br/>
get_mouse_name(index) <br/>
int index <br/>
PREINIT: <br/>
dMY_CXT; <br/>
CODE: <br/>
if (index &gt; MY_CXT.count) <br/>
croak("There are only 3 blind mice."); <br/>
else <br/>
RETVAL = MY_CXT.name[index − 1]; <br/>
OUTPUT: <br/>
RETVAL <br/>
void <br/>
CLONE(...) <br/>
CODE: <br/>
MY_CXT_CLONE;</p>
<p style="margin-left:9%; margin-top: 1em"><i>MY_CXT
REFERENCE</i> <br/>
MY_CXT_KEY</p>
<p style="margin-left:15%;">This macro is used to define a
unique key to refer to the static data for an XS module. The
suggested naming scheme, as used by h2xs, is to use a string
that consists of the module name, the string
"::_guts" and the module version number.</p>
<p style="margin-left:15%; margin-top: 1em">#define
MY_CXT_KEY "MyModule::_guts" XS_VERSION</p>
<p style="margin-left:9%;">typedef my_cxt_t</p>
<p style="margin-left:15%;">This struct typedef <i>must</i>
always be called "my_cxt_t". The other
"CXT*" macros assume the existence of the
"my_cxt_t" typedef name.</p>
<p style="margin-left:15%; margin-top: 1em">Declare a
typedef named "my_cxt_t" that is a structure that
contains all the data that needs to be
interpreter−local.</p>
<p style="margin-left:15%; margin-top: 1em">typedef struct
{ <br/>
int some_value; <br/>
} my_cxt_t;</p>
<p style="margin-left:9%;">START_MY_CXT</p>
<p style="margin-left:15%;">Always place the START_MY_CXT
macro directly after the declaration of
"my_cxt_t".</p>
<p style="margin-left:9%;">MY_CXT_INIT</p>
<p style="margin-left:15%;">The MY_CXT_INIT macro
initializes storage for the "my_cxt_t" struct.</p>
<p style="margin-left:15%; margin-top: 1em">It <i>must</i>
be called exactly once, typically in a BOOT: section. If you
are maintaining multiple interpreters, it should be called
once in each interpreter instance, except for interpreters
cloned from existing ones. (But see "MY_CXT_CLONE"
below.)</p>
<p style="margin-left:9%;">dMY_CXT</p>
<p style="margin-left:15%;">Use the dMY_CXT macro (a
declaration) in all the functions that access MY_CXT.</p>
<p style="margin-left:9%;">MY_CXT</p>
<p style="margin-left:15%;">Use the MY_CXT macro to access
members of the "my_cxt_t" struct. For example, if
"my_cxt_t" is</p>
<p style="margin-left:15%; margin-top: 1em">typedef struct
{ <br/>
int index; <br/>
} my_cxt_t;</p>
<p style="margin-left:15%; margin-top: 1em">then use this
to access the "index" member</p>
<p style="margin-left:15%; margin-top: 1em">dMY_CXT; <br/>
MY_CXT.index = 2;</p>
<p style="margin-left:9%;">aMY_CXT/pMY_CXT</p>
<p style="margin-left:15%;">"dMY_CXT" may be
quite expensive to calculate, and to avoid the overhead of
invoking it in each function it is possible to pass the
declaration onto other functions using the
"aMY_CXT"/"pMY_CXT" macros, eg</p>
<p style="margin-left:15%; margin-top: 1em">void sub1() {
<br/>
dMY_CXT; <br/>
MY_CXT.index = 1; <br/>
sub2(aMY_CXT); <br/>
} <br/>
void sub2(pMY_CXT) { <br/>
MY_CXT.index = 2; <br/>
}</p>
<p style="margin-left:15%; margin-top: 1em">Analogously to
"pTHX", there are equivalent forms for when the
macro is the first or last in multiple arguments, where an
underscore represents a comma, i.e. "_aMY_CXT",
"aMY_CXT_", "_pMY_CXT" and
"pMY_CXT_".</p>
<p style="margin-left:9%;">MY_CXT_CLONE</p>
<p style="margin-left:15%;">By default, when a new
interpreter is created as a copy of an existing one (eg via
"threads−&gt;create()"), both interpreters
share the same physical my_cxt_t structure. Calling
"MY_CXT_CLONE" (typically via the package's
CLONE() function), causes a byte−for−byte copy
of the structure to be taken, and any future dMY_CXT will
cause the copy to be accessed instead.</p>
<p style="margin-left:9%;">MY_CXT_INIT_INTERP(my_perl) <br/>
dMY_CXT_INTERP(my_perl)</p>
<p style="margin-left:15%;">These are versions of the
macros which take an explicit interpreter as an
argument.</p>
<p style="margin-left:9%; margin-top: 1em">Note that these
macros will only work together within the <i>same</i> source
file; that is, a dMY_CTX in one source file will access a
different structure than a dMY_CTX in another source
file.</p>
<h3>Thread−aware system interfaces
<a name="Thread−aware system interfaces"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Starting from
Perl 5.8, in C/C++ level Perl knows how to wrap
system/library interfaces that have thread−aware
versions (e.g. <b>getpwent_r()</b>) into frontend macros
(e.g. <b>getpwent()</b>) that correctly handle the
multithreaded interaction with the Perl interpreter. This
will happen transparently, the only thing you need to do is
to instantiate a Perl interpreter.</p>
<p style="margin-left:9%; margin-top: 1em">This wrapping
happens always when compiling Perl core source (PERL_CORE is
defined) or the Perl core extensions (PERL_EXT is defined).
When compiling XS code outside of the Perl core, the
wrapping does not take place before Perl 5.28. Starting in
that release you can</p>
<p style="margin-left:9%; margin-top: 1em">#define
PERL_REENTRANT</p>
<p style="margin-left:9%; margin-top: 1em">in your code to
enable the wrapping. It is advisable to do so if you are
using such functions, as intermixing the
"_r"−forms (as Perl compiled for
multithreaded operation will do) and the
"_r"−less forms is neither
well−defined (inconsistent results, data corruption,
or even crashes become more likely), nor is it very
portable. Unfortunately, not all systems have all the
"_r" forms, but using this "#define"
gives you whatever protection that Perl is aware is
available on each system.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">File
"RPC.xs": Interface to some ONC+ RPC bind library
functions.</p>
<p style="margin-left:9%; margin-top: 1em">#define
PERL_NO_GET_CONTEXT <br/>
#include "EXTERN.h" <br/>
#include "perl.h" <br/>
#include "XSUB.h" <br/>
/* Note: On glibc 2.13 and earlier, this needs be
&lt;rpc/rpc.h&gt; */ <br/>
#include &lt;tirpc/rpc.h&gt; <br/>
typedef struct netconfig Netconfig; <br/>
MODULE = RPC PACKAGE = RPC <br/>
SV * <br/>
rpcb_gettime(host="localhost") <br/>
char *host <br/>
PREINIT: <br/>
time_t timep; <br/>
CODE: <br/>
ST(0) = sv_newmortal(); <br/>
if( rpcb_gettime( host, &amp;timep ) ) <br/>
sv_setnv( ST(0), (double)timep ); <br/>
Netconfig * <br/>
getnetconfigent(netid="udp") <br/>
char *netid <br/>
MODULE = RPC PACKAGE = NetconfigPtr PREFIX = rpcb_ <br/>
void <br/>
rpcb_DESTROY(netconf) <br/>
Netconfig *netconf <br/>
CODE: <br/>
printf("NetconfigPtr::DESTROY\n"); <br/>
free( netconf );</p>
<p style="margin-left:9%; margin-top: 1em">File
"typemap": Custom typemap for RPC.xs. (cf.
perlxstypemap)</p>
<p style="margin-left:9%; margin-top: 1em">TYPEMAP <br/>
Netconfig * T_PTROBJ</p>
<p style="margin-left:9%; margin-top: 1em">File
"RPC.pm": Perl module for the RPC extension.</p>
<p style="margin-left:9%; margin-top: 1em">package RPC;
<br/>
require Exporter; <br/>
require DynaLoader; <br/>
@ISA = qw(Exporter DynaLoader); <br/>
@EXPORT = qw(rpcb_gettime getnetconfigent); <br/>
bootstrap RPC; <br/>
1;</p>
<p style="margin-left:9%; margin-top: 1em">File
"rpctest.pl": Perl test program for the RPC
extension.</p>
<p style="margin-left:9%; margin-top: 1em">use RPC; <br/>
$netconf = getnetconfigent(); <br/>
$a = rpcb_gettime(); <br/>
print "time = $a\n"; <br/>
print "netconf = $netconf\n"; <br/>
$netconf = getnetconfigent("tcp"); <br/>
$a = rpcb_gettime("poplar"); <br/>
print "time = $a\n"; <br/>
print "netconf = $netconf\n";</p>
<p style="margin-left:9%; margin-top: 1em">In Makefile.PL
add −ltirpc and −I/usr/include/tirpc.</p>
<h2>CAVEATS
<a name="CAVEATS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">XS code has full
access to system calls including C library functions. It
thus has the capability of interfering with things that the
Perl core or other modules have set up, such as signal
handlers or file handles. It could mess with the memory, or
any number of harmful things. Don't.</p>
<p style="margin-left:9%; margin-top: 1em">Some modules
have an event loop, waiting for user−input. It is
highly unlikely that two such modules would work adequately
together in a single Perl application.</p>
<p style="margin-left:9%; margin-top: 1em">In general, the
perl interpreter views itself as the center of the universe
as far as the Perl program goes. XS code is viewed as a
help−mate, to accomplish things that perl doesn't do,
or doesn't do fast enough, but always subservient to perl.
The closer XS code adheres to this model, the less likely
conflicts will occur.</p>
<p style="margin-left:9%; margin-top: 1em">One area where
there has been conflict is in regards to C locales. (See
perllocale.) perl, with one exception and unless told
otherwise, sets up the underlying locale the program is
running in to the locale passed into it from the
environment. This is an important difference from a generic
C language program, where the underlying locale is the
"C" locale unless the program changes it. As of
v5.20, this underlying locale is completely hidden from pure
Perl code outside the lexical scope of
"use locale" except for a couple of function
calls in the POSIX module which of necessity use it. But the
underlying locale, with that one exception is exposed to XS
code, affecting all C library routines whose behavior is
locale−dependent. Your XS code better not assume that
the underlying locale is "C". The exception is the
"LC_NUMERIC" locale category, and the reason it is
an exception is that experience has shown that it can be
problematic for XS code, whereas we have not had reports of
problems with the other locale categories. And the reason
for this one category being problematic is that the
character used as a decimal point can vary. Many European
languages use a comma, whereas English, and hence Perl are
expecting a dot (U+002E: FULL STOP). Many modules can handle
only the radix character being a dot, and so perl attempts
to make it so. Up through Perl v5.20, the attempt was merely
to set "LC_NUMERIC" upon startup to the
"C" locale. Any <b>setlocale()</b> otherwise would
change it; this caused some failures. Therefore, starting in
v5.22, perl tries to keep "LC_NUMERIC" always set
to "C" for XS code.</p>
<p style="margin-left:9%; margin-top: 1em">To summarize,
here's what to expect and how to handle locales in XS code:
<br/>
Non−locale−aware XS code</p>
<p style="margin-left:14%;">Keep in mind that even if you
think your code is not locale−aware, it may call a
library function that is. Hopefully the man page for such a
function will indicate that dependency, but the
documentation is imperfect.</p>
<p style="margin-left:14%; margin-top: 1em">The current
locale is exposed to XS code except possibly
"LC_NUMERIC" (explained in the next paragraph).
There have not been reports of problems with the other
categories. Perl initializes things on start−up so
that the current locale is the one which is indicated by the
user's environment in effect at that time. See
"ENVIRONMENT" in perllocale.</p>
<p style="margin-left:14%; margin-top: 1em">However, up
through v5.20, Perl initialized things on start−up so
that "LC_NUMERIC" was set to the "C"
locale. But if any code anywhere changed it, it would stay
changed. This means that your module can't count on
"LC_NUMERIC" being something in particular, and
you can't expect floating point numbers (including version
strings) to have dots in them. If you don't allow for a
non−dot, your code could break if anyone anywhere
changed the locale. For this reason, v5.22 changed the
behavior so that Perl tries to keep "LC_NUMERIC"
in the "C" locale except around the operations
internally where it should be something else. Misbehaving XS
code will always be able to change the locale anyway, but
the most common instance of this is checked for and
handled.</p>
<p style="margin-left:9%;">Locale−aware XS code</p>
<p style="margin-left:14%;">If the locale from the user's
environment is desired, there should be no need for XS code
to set the locale except for "LC_NUMERIC", as perl
has already set the others up. XS code should avoid changing
the locale, as it can adversely affect other, unrelated,
code and may not be thread−safe. To minimize problems,
the macros "STORE_LC_NUMERIC_SET_TO_NEEDED" in
perlapi, "STORE_LC_NUMERIC_FORCE_TO_UNDERLYING" in
perlapi, and "RESTORE_LC_NUMERIC" in perlapi
should be used to affect any needed change.</p>
<p style="margin-left:14%; margin-top: 1em">But, starting
with Perl v5.28, locales are thread−safe on platforms
that support this functionality. Windows has this starting
with Visual Studio 2005. Many other modern platforms support
the thread−safe POSIX 2008 functions. The C
"#define" "USE_THREAD_SAFE_LOCALE" will
be defined iff this build is using these. From
Perl−space, the read−only variable
"${SAFE_LOCALES}" is 1 if either the build is not
threaded, or if "USE_THREAD_SAFE_LOCALE" is
defined; otherwise it is 0.</p>
<p style="margin-left:14%; margin-top: 1em">The way this
works under−the−hood is that every thread has a
choice of using a locale specific to it (this is the Windows
and POSIX 2008 functionality), or the global locale that is
accessible to all threads (this is the functionality that
has always been there). The implementations for Windows and
POSIX are completely different. On Windows, the runtime can
be set up so that the standard setlocale(3) function either
only knows about the global locale or the locale for this
thread. On POSIX, "setlocale" always deals with
the global locale, and other functions have been created to
handle per−thread locales. Perl makes this transparent
to perl−space code. It continues to use
POSIX::setlocale(), and the interpreter translates that into
the per−thread functions.</p>
<p style="margin-left:14%; margin-top: 1em">All other
locale−sensitive functions automatically use the
per−thread locale, if that is turned on, and failing
that, the global locale. Thus calls to "setlocale"
are ineffective on POSIX systems for the current thread if
that thread is using a per−thread locale. If perl is
compiled for single−thread operation, it does not use
the per−thread functions, so "setlocale"
does work as expected.</p>
<p style="margin-left:14%; margin-top: 1em">If you have
loaded the "POSIX" module you can use the methods
given in perlcall to call "POSIX::setlocale" to
safely change or query the locale (on systems where it is
safe to do so), or you can use the new 5.28 function
"Perl_setlocale" in perlapi instead, which is a
drop−in replacement for the system setlocale(3), and
handles single−threaded and multi−threaded
applications transparently.</p>
<p style="margin-left:14%; margin-top: 1em">There are some
locale−related library calls that still aren't
thread−safe because they return data in a buffer
global to all threads. In the past, these didn't matter as
locales weren't thread−safe at all. But now you have
to be aware of them in case your module is called in a
multi−threaded application. The known ones are</p>
<p style="margin-left:14%; margin-top: 1em">asctime() <br/>
ctime() <br/>
gcvt() [POSIX.1−2001 only (function removed in
POSIX.1−2008)] <br/>
getdate() <br/>
wcrtomb() if its final argument is NULL <br/>
wcsrtombs() if its final argument is NULL <br/>
wcstombs() <br/>
wctomb()</p>
<p style="margin-left:14%; margin-top: 1em">Some of these
shouldn't really be called in a Perl application, and for
others there are thread−safe versions of these already
implemented:</p>
<p style="margin-left:14%; margin-top: 1em">asctime_r()
<br/>
ctime_r() <br/>
Perl_langinfo()</p>
<p style="margin-left:14%; margin-top: 1em">The
"_r" forms are automatically used, starting in
Perl 5.28, if you compile your code, with</p>
<p style="margin-left:14%; margin-top: 1em">#define
PERL_REENTRANT</p>
<p style="margin-left:14%; margin-top: 1em">See also
"Perl_langinfo" in perlapi. You can use the
methods given in perlcall, to get the best available
locale−safe versions of these</p>
<p style="margin-left:14%; margin-top: 1em">POSIX::localeconv()
<br/>
POSIX::wcstombs() <br/>
POSIX::wctomb()</p>
<p style="margin-left:14%; margin-top: 1em">And note, that
some items returned by "Localeconv" are available
through "Perl_langinfo" in perlapi.</p>
<p style="margin-left:14%; margin-top: 1em">The others
shouldn't be used in a threaded application.</p>
<p style="margin-left:14%; margin-top: 1em">Some modules
may call a non−perl library that is
locale−aware. This is fine as long as it doesn't try
to query or change the locale using the system
"setlocale". But if these do call the system
"setlocale", those calls may be ineffective.
Instead, "Perl_setlocale" works in all
circumstances. Plain setlocale is ineffective on
multi−threaded POSIX 2008 systems. It operates only on
the global locale, whereas each thread has its own locale,
paying no attention to the global one. Since converting
these non−Perl libraries to "Perl_setlocale"
is out of the question, there is a new function in v5.28
"switch_to_global_locale" that will switch the
thread it is called from so that any system
"setlocale" calls will have their desired effect.
The function "sync_locale" must be called before
returning to perl.</p>
<p style="margin-left:14%; margin-top: 1em">This thread can
change the locale all it wants and it won't affect any other
thread, except any that also have been switched to the
global locale. This means that a multi−threaded
application can have a single thread using an alien library
without a problem; but no more than a single thread can be
so−occupied. Bad results likely will happen.</p>
<p style="margin-left:14%; margin-top: 1em">In perls
without multi−thread locale support, some alien
libraries, such as "Gtk" change locales. This can
cause problems for the Perl core and other modules. For
these, before control is returned to perl, starting in
v5.20.1, calling the function <b>sync_locale()</b> from XS
should be sufficient to avoid most of these problems. Prior
to this, you need a pure Perl statement that does this:</p>
<p style="margin-left:14%; margin-top: 1em">POSIX::setlocale(LC_ALL,
POSIX::setlocale(LC_ALL));</p>
<p style="margin-left:14%; margin-top: 1em">or use the
methods given in perlcall.</p>
<h2>XS VERSION
<a name="XS VERSION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This document
covers features supported by "ExtUtils::ParseXS"
(also known as "xsubpp") 3.51</p>
<h2>AUTHOR DIAGNOSTICS
<a name="AUTHOR DIAGNOSTICS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">As of version
3.49 certain warnings are disabled by default. While
developing you can set $ENV{AUTHOR_WARNINGS} to true in your
environment or in your Makefile.PL, or set
$ExtUtils::ParseXS::AUTHOR_WARNINGS to true via code, or
pass "author_warnings=&gt;1" into
<b>process_file()</b> explicitly. Currently this will enable
stricter alias checking but more warnings might be added in
the future. The kind of warnings this will enable are only
helpful to the author of the XS file, and the diagnostics
produced will not include installation specific details so
they are only useful to the maintainer of the XS code
itself.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Originally
written by Dean Roehrich
&lt;<i>roehrich@cray.com</i>&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Maintained since
1996 by The Perl Porters
&lt;<i>perl5−porters@perl.org</i>&gt;.</p>
<hr/>
</body>
</html>
