<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:51:10 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SD_NOTIFY</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">SD_NOTIFY</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#WELL−KNOWN ASSIGNMENTS">WELL−KNOWN ASSIGNMENTS</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#Standalone Implementations">Standalone Implementations</a><br/>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#NOTES">NOTES</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">sd_notify,
sd_notifyf, sd_pid_notify, sd_pid_notifyf,
sd_pid_notify_with_fds, sd_pid_notifyf_with_fds,
sd_notify_barrier, sd_pid_notify_barrier − Notify
service manager about start−up completion and other
service status changes</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;systemd/sd−daemon.h&gt;</b></p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_notify(int </b><i>unset_environment</i><b>,
const char *</b><i>state</i><b>);</b></p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_notifyf(int </b><i>unset_environment</i><b>,
const char *</b><i>format</i><b>, ...);</b></p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_pid_notify(pid_t </b><i>pid</i><b>,
int </b><i>unset_environment</i><b>,
const char *</b><i>state</i><b>);</b></p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_pid_notifyf(pid_t </b><i>pid</i><b>,
int </b><i>unset_environment</i><b>,
const char *</b><i>format</i><b>, ...);</b></p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_pid_notify_with_fds(pid_t </b><i>pid</i><b>,
int </b><i>unset_environment</i><b>,
const char *</b><i>state</i><b>,
const int *</b><i>fds</i><b>,
unsigned </b><i>n_fds</i><b>);</b></p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_pid_notifyf_with_fds(pid_t </b><i>pid</i><b>,
int </b><i>unset_environment</i><b>,
const int *</b><i>fds</i><b>,
size_t </b><i>n_fds</i><b>,
const char *</b><i>format</i><b>, ...);</b></p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_notify_barrier(int </b><i>unset_environment</i><b>,
uint64_t </b><i>timeout</i><b>);</b></p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em"><b>int
sd_pid_notify_barrier(pid_t </b><i>pid</i><b>,
int </b><i>unset_environment</i><b>,
uint64_t </b><i>timeout</i><b>);</b></p> </td></tr>
</table>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>sd_notify()</b>
may be called by a service to notify the service manager
about state changes. It can be used to send arbitrary
information, encoded in an
environment−block−like string. Most importantly,
it can be used for start−up or reload completion
notifications.</p>
<p style="margin-left:9%; margin-top: 1em">If the
<i>unset_environment</i> parameter is non−zero,
<b>sd_notify()</b> will unset the <i>$NOTIFY_SOCKET</i>
environment variable before returning (regardless of whether
the function call itself succeeded or not). Further calls to
<b>sd_notify()</b> will then silently do nothing, and the
variable is no longer inherited by child processes.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>state</i>
parameter should contain a newline−separated list of
variable assignments, similar in style to an environment
block. A trailing newline is implied if none is specified.
The string may contain any kind of variable assignments, but
see the next section for a list of assignments understood by
the service manager.</p>
<p style="margin-left:9%; margin-top: 1em">Note that
systemd will accept status data sent from a service only if
the <i>NotifyAccess=</i> option is correctly set in the
service definition file. See <b>systemd.service</b>(5) for
details.</p>
<p style="margin-left:9%; margin-top: 1em">Note that
<b>sd_notify()</b> notifications may be attributed to units
correctly only if either the sending process is still around
at the time PID 1 processes the message, or if the sending
process is explicitly runtime−tracked by the service
manager. The latter is the case if the service manager
originally forked off the process, i.e. on all processes
that match <i>NotifyAccess=</i><b>main</b> or
<i>NotifyAccess=</i><b>exec</b>. Conversely, if an auxiliary
process of the unit sends an <b>sd_notify()</b> message and
immediately exits, the service manager might not be able to
properly attribute the message to the unit, and thus will
ignore it, even if <i>NotifyAccess=</i><b>all</b> is set for
it.</p>
<p style="margin-left:9%; margin-top: 1em">Hence, to
eliminate all race conditions involving lookup of the
client's unit and attribution of notifications to units
correctly, <b>sd_notify_barrier()</b> may be used. This call
acts as a synchronization point and ensures all
notifications sent before this call have been picked up by
the service manager when it returns successfully. Use of
<b>sd_notify_barrier()</b> is needed for clients which are
not invoked by the service manager, otherwise this
synchronization mechanism is unnecessary for attribution of
notifications to the unit.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sd_notifyf()</b>
is similar to <b>sd_notify()</b> but takes a
<b>printf()</b>−like format string plus arguments.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sd_pid_notify()</b>
and <b>sd_pid_notifyf()</b> are similar to
<b>sd_notify()</b> and <b>sd_notifyf()</b> but take a
process ID (PID) to use as originating PID for the message
as first argument. This is useful to send notification
messages on behalf of other processes, provided the
appropriate privileges are available. Effectively, this
means that a privileged invocation of <b>sd_pid_notify()</b>
may circumvent <i>NotifyAccess=main</i> or
<i>NotifyAccess=exec</i> restrictions enforced for a
service. If the PID argument is specified as 0, the process
ID of the calling process is used, in which case the calls
are fully equivalent to <b>sd_notify()</b> and
<b>sd_notifyf()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sd_pid_notify_with_fds()</b>
is similar to <b>sd_pid_notify()</b> but takes an additional
array of file descriptors. These file descriptors are sent
along the notification message to the service manager. This
is particularly useful for sending "FDSTORE=1"
messages, as described above. The additional arguments are a
pointer to the file descriptor array plus the number of file
descriptors in the array. If the number of file descriptors
is passed as 0, the call is fully equivalent to
<b>sd_pid_notify()</b>, i.e. no file descriptors are passed.
Note that file descriptors sent to the service manager on a
message without "FDSTORE=1" are immediately closed
on reception.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sd_pid_notifyf_with_fds()</b>
is a combination of <b>sd_pid_notify_with_fds()</b> and
<b>sd_notifyf()</b>, i.e. it accepts both a PID and a set of
file descriptors as input, and processes a format string to
generate the state string.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sd_notify_barrier()</b>
allows the caller to synchronize against reception of
previously sent notification messages and uses the
<i>BARRIER=1</i> command. It takes a relative <i>timeout</i>
value in microseconds which is passed to <b>ppoll</b>(2). A
value of UINT64_MAX is interpreted as infinite timeout.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sd_pid_notify_barrier()</b>
is just like <b>sd_notify_barrier()</b>, but allows
specifying the originating PID for the notification
message.</p>
<h2>WELL−KNOWN ASSIGNMENTS
<a name="WELL−KNOWN ASSIGNMENTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
assignments have a defined meaning:</p>
<p style="margin-left:9%; margin-top: 1em">READY=1</p>
<p style="margin-left:14%;">Tells the service manager that
service startup is finished, or the service finished
re−loading its configuration. This is only used by
systemd if the service definition file has
<i>Type=notify</i> or <i>Type=notify−reload</i> set.
Since there is little value in signaling
non−readiness, the only value services should send is
"READY=1" (i.e. "READY=0" is not
defined).</p>
<p style="margin-left:9%; margin-top: 1em">RELOADING=1</p>
<p style="margin-left:14%;">Tells the service manager that
the service is beginning to reload its configuration. This
is useful to allow the service manager to track the
service's internal state, and present it to the user. Note
that a service that sends this notification must also send a
"READY=1" notification when it completed reloading
its configuration. Reloads the service manager is notified
about with this mechanisms are propagated in the same way as
they are when originally initiated through the service
manager. This message is particularly relevant for
<i>Type=notify−reload</i> services, to inform the
service manager that the request to reload the service has
been received and is now being processed.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 217.</p>
<p style="margin-left:9%; margin-top: 1em">STOPPING=1</p>
<p style="margin-left:14%;">Tells the service manager that
the service is beginning its shutdown. This is useful to
allow the service manager to track the service's internal
state, and present it to the user.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 217.</p>
<p style="margin-left:9%; margin-top: 1em">MONOTONIC_USEC=...</p>
<p style="margin-left:14%;">A field carrying the monotonic
timestamp (as per <b>CLOCK_MONOTONIC</b>) formatted in
decimal in μs, when the notification message was
generated by the client. This is typically used in
combination with "RELOADING=1", to allow the
service manager to properly synchronize reload cycles. See
<b>systemd.service</b>(5) for details, specifically
"Type=notify−reload".</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 253.</p>
<p style="margin-left:9%; margin-top: 1em">STATUS=...</p>
<p style="margin-left:14%;">Passes a single−line
UTF−8 status string back to the service manager that
describes the service state. This is free−form and can
be used for various purposes: general state feedback,
fsck−like programs could pass completion percentages
and failing programs could pass a human−readable error
message. Example: "STATUS=Completed 66% of file system
check..."</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 233.</p>
<p style="margin-left:9%; margin-top: 1em">NOTIFYACCESS=...</p>
<p style="margin-left:14%;">Reset the access to the service
status notification socket during runtime, overriding
<i>NotifyAccess=</i> setting in the service unit file. See
<b>systemd.service</b>(5) for details, specifically
"NotifyAccess=" for a list of accepted values.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 254.</p>
<p style="margin-left:9%; margin-top: 1em">ERRNO=...</p>
<p style="margin-left:14%;">If a service fails, the
errno−style error code, formatted as string. Example:
"ERRNO=2" for ENOENT.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 233.</p>
<p style="margin-left:9%; margin-top: 1em">BUSERROR=...</p>
<p style="margin-left:14%;">If a service fails, the
D−Bus error−style error code. Example:
"BUSERROR=org.freedesktop.DBus.Error.TimedOut".
Note that this assignment is currently not used by
<b>systemd</b>.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 233.</p>
<p style="margin-left:9%; margin-top: 1em">EXIT_STATUS=...</p>
<p style="margin-left:14%;">The exit status of a service or
the manager itself. Note that <b>systemd</b> currently does
not consume this value when sent by services, so this
assignment is only informational. The manager will send this
notification to <i>its</i> notification socket, which may be
used to collect an exit status from the system (a container
or VM) as it shuts down. For example, <b>mkosi</b>(1) makes
use of this. The value to return may be set via the
<b>systemctl</b>(1) <b>exit</b> verb.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 254.</p>
<p style="margin-left:9%; margin-top: 1em">MAINPID=...</p>
<p style="margin-left:14%;">The main process ID (PID) of
the service, in case the service manager did not fork off
the process itself. Example: "MAINPID=4711".</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 233.</p>
<p style="margin-left:9%; margin-top: 1em">WATCHDOG=1</p>
<p style="margin-left:14%;">Tells the service manager to
update the watchdog timestamp. This is the keep−alive
ping that services need to issue in regular intervals if
<i>WatchdogSec=</i> is enabled for it. See
<b>systemd.service</b>(5) for information how to enable this
functionality and <b>sd_watchdog_enabled</b>(3) for the
details of how the service can check whether the watchdog is
enabled.</p>
<p style="margin-left:9%; margin-top: 1em">WATCHDOG=trigger</p>
<p style="margin-left:14%;">Tells the service manager that
the service detected an internal error that should be
handled by the configured watchdog options. This will
trigger the same behaviour as if <i>WatchdogSec=</i> is
enabled and the service did not send "WATCHDOG=1"
in time. Note that <i>WatchdogSec=</i> does not need to be
enabled for "WATCHDOG=trigger" to trigger the
watchdog action. See <b>systemd.service</b>(5) for
information about the watchdog behavior.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 243.</p>
<p style="margin-left:9%; margin-top: 1em">WATCHDOG_USEC=...</p>
<p style="margin-left:14%;">Reset <i>watchdog_usec</i>
value during runtime. Notice that this is not available when
using <b>sd_event_set_watchdog()</b> or
<b>sd_watchdog_enabled()</b>. Example :
"WATCHDOG_USEC=20000000"</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 233.</p>
<p style="margin-left:9%; margin-top: 1em">EXTEND_TIMEOUT_USEC=...</p>
<p style="margin-left:14%;">Tells the service manager to
extend the startup, runtime or shutdown service timeout
corresponding the current state. The value specified is a
time in microseconds during which the service must send a
new message. A service timeout will occur if the message
isn't received, but only if the runtime of the current state
is beyond the original maximum times of
<i>TimeoutStartSec=</i>, <i>RuntimeMaxSec=</i>, and
<i>TimeoutStopSec=</i>. See <b>systemd.service</b>(5) for
effects on the service timeouts.</p>
<p style="margin-left:14%; margin-top: 1em">Added in
version 236.</p>
<p style="margin-left:9%; margin-top: 1em">FDSTORE=1</p>
<p style="margin-left:14%;">Store file descriptors in the
service manager. File descriptors sent this way will be held
for the service by the service manager and will later be
handed back using the usual file descriptor passing logic at
the next start or restart of the service, see
<b>sd_listen_fds</b>(3). Any open sockets and other file
descriptors which should not be closed during a restart may
be stored this way. When a service is stopped, its file
descriptor store is discarded and all file descriptors in it
are closed, except when overridden with
<i>FileDescriptorStorePreserve=</i>, see
<b>systemd.service</b>(5).</p>
<p style="margin-left:14%; margin-top: 1em">The service
manager will accept messages for a service only if its
<i>FileDescriptorStoreMax=</i> setting is non−zero
(defaults to zero, see <b>systemd.service</b>(5)). The
service manager will set the <i>$FDSTORE</i> environment
variable for services that have the file descriptor store
enabled, see <b>systemd.exec</b>(5).</p>
<p style="margin-left:14%; margin-top: 1em">If
<i>FDPOLL=0</i> is not set and the file descriptors are
pollable (see <b>epoll_ctl</b>(2)), then any <b>EPOLLHUP</b>
or <b>EPOLLERR</b> event seen on them will result in their
automatic removal from the store.</p>
<p style="margin-left:14%; margin-top: 1em">Multiple sets
of file descriptors may be sent in separate messages, in
which case the sets are combined. The service manager
removes duplicate file descriptors (those pointing to the
same object) before passing them to the service.</p>
<p style="margin-left:14%; margin-top: 1em">This
functionality should be used to implement services that can
restart after an explicit request or a crash without losing
state. Application state can either be serialized to a file
in /run/, or better, stored in a <b>memfd_create</b>(2)
memory file descriptor. Use <b>sd_pid_notify_with_fds()</b>
to send messages with "FDSTORE=1". It is
recommended to combine <i>FDSTORE=</i> with <i>FDNAME=</i>
to make it easier to manage the stored file descriptors.</p>
<p style="margin-left:14%; margin-top: 1em">For further
information on the file descriptor store see the
<b><font color="#0000FF">File Descriptor Store</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">overview.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Added
in version 219.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">FDSTOREREMOVE=1</font></p>
<p style="margin-left:14%;"><font color="#000000">Removes
file descriptors from the file descriptor store. This field
needs to be combined with <i>FDNAME=</i> to specify the name
of the file descriptors to remove.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Added
in version 236.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">FDNAME=...</font></p>
<p style="margin-left:14%;"><font color="#000000">When used
in combination with <i>FDSTORE=1</i>, specifies a name for
the submitted file descriptors. When used with
<i>FDSTOREREMOVE=1</i>, specifies the name for the file
descriptors to remove. This name is passed to the service
during activation, and may be queried using
<b>sd_listen_fds_with_names</b>(3). File descriptors
submitted without this field will be called
"stored".</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">The
name may consist of arbitrary ASCII characters except
control characters or ":". It may not be longer
than 255 characters. If a submitted name does not follow
these restrictions, it is ignored.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Note
that if multiple file descriptors are submitted in a single
message, the specified name will be used for all of them. In
order to assign different names to submitted file
descriptors, submit them in separate messages.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Added
in version 233.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">FDPOLL=0</font></p>
<p style="margin-left:14%;"><font color="#000000">When used
in combination with <i>FDSTORE=1</i>, disables polling of
the submitted file descriptors regardless of whether or not
they are pollable. As this option disables automatic cleanup
of the submitted file descriptors on EPOLLERR and EPOLLHUP,
care must be taken to ensure proper manual cleanup. Use of
this option is not generally recommended except for when
automatic cleanup has unwanted behavior such as prematurely
discarding file descriptors from the store.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Added
in version 246.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">BARRIER=1</font></p>
<p style="margin-left:14%;"><font color="#000000">Tells the
service manager that the client is explicitly requesting
synchronization by means of closing the file descriptor sent
with this command. The service manager guarantees that the
processing of a <i>BARRIER=1</i> command will only happen
after all previous notification messages sent before this
command have been processed. Hence, this command accompanied
with a single file descriptor can be used to synchronize
against reception of all previous status messages. Note that
this command cannot be mixed with other notifications, and
has to be sent in a separate message to the service manager,
otherwise all assignments will be ignored. Note that sending
0 or more than 1 file descriptor with this command is a
violation of the protocol.</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">Added
in version 246.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
notification messages sent by services are interpreted by
the service manager. Unknown assignments are ignored. Thus,
it is safe (but often without effect) to send assignments
which are not in this list. The protocol is extensible, but
care should be taken to ensure private extensions are
recognizable as such. Specifically, it is recommend to
prefix them with "X_" followed by some namespace
identifier. The service manager also sends some messages to
<i>its</i> notification socket, which may then consumed by a
supervising machine or container manager further up the
stack. The service manager sends a number of extension
fields, for example <i>X_SYSTEMD_UNIT_ACTIVE=</i>, for
details see <b>systemd</b>(1).</font></p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">On
failure, these calls return a negative errno−style
error code. If <i>$NOTIFY_SOCKET</i> was not set and hence
no status message could be sent, 0 is returned. If the
status was sent, these functions return a positive value. In
order to support both service managers that implement this
scheme and those which do not, it is generally recommended
to ignore the return value of this call. Note that the
return value simply indicates whether the notification
message was enqueued properly, it does not reflect whether
the message could be processed successfully. Specifically,
no error is returned when a file descriptor is attempted to
be stored using <i>FDSTORE=1</i> but the service is not
actually configured to permit storing of file descriptors
(see above).</font></p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Functions
described here are available as a shared library, which can
be compiled against and linked to with the
<b>libsystemd pkg-config</b>(1) file.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
code described here uses <b>getenv</b>(3), which is declared
to be not multi−thread−safe. This means that the
code calling the functions described here must not call
<b>setenv</b>(3) from a parallel thread. It is recommended
to only do calls to <b>setenv()</b> from an early phase of
the program when no other threads have been
started.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">These
functions send a single datagram with the state string as
payload to the socket referenced in the
<i>$NOTIFY_SOCKET</i> environment variable. If the first
character of <i>$NOTIFY_SOCKET</i> is "/" or
"@", the string is understood as an <b>AF_UNIX</b>
or Linux abstract namespace socket (respectively), and in
both cases the datagram is accompanied by the process
credentials of the sending service, using SCM_CREDENTIALS.
If the string starts with "vsock:" then the string
is understood as an <b>AF_VSOCK</b> address, which is useful
for hypervisors/VMMs or other processes on the host to
receive a notification when a virtual machine has finished
booting. Note that in case the hypervisor does not support
<b>SOCK_DGRAM</b> over <b>AF_VSOCK</b>,
<b>SOCK_SEQPACKET</b> will be used instead.
"vsock−stream",
"vsock−dgram" and
"vsock−seqpacket" can be used instead of
"vsock" to force usage of the corresponding socket
type. The address should be in the form:
"vsock:CID:PORT". Note that unlike other uses of
vsock, the CID is mandatory and cannot be
"VMADDR_CID_ANY". Note that PID1 will send the
VSOCK packets from a privileged port (i.e.: lower than
1024), as an attempt to address concerns that unprivileged
processes in the guest might try to send malicious
notifications to the host, driving it to make destructive
decisions based on them.</font></p>
<h3>Standalone Implementations
<a name="Standalone Implementations"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Note
that, while using this library should be preferred in order
to avoid code duplication, it is also possible to
reimplement the simple readiness notification protocol
without external dependencies, as demonstrated in the
following self−contained examples from several
languages:</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b><big>C</big></b></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
SPDX−License−Identifier: MIT−0
*/</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Implement the systemd notify protocol without external
dependencies. <br/>
* Supports both readiness notification on startup and on
reloading, <br/>
* according to the protocol defined at: <br/>
*
https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html
<br/>
* This protocol is guaranteed to be stable as per: <br/>
* https://systemd.io/PORTABILITY_AND_STABILITY/
*/</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>#define
_GNU_SOURCE 1 <br/>
#include &lt;errno.h&gt; <br/>
#include &lt;inttypes.h&gt; <br/>
#include &lt;signal.h&gt; <br/>
#include &lt;stdbool.h&gt; <br/>
#include &lt;stddef.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;sys/socket.h&gt; <br/>
#include &lt;sys/un.h&gt; <br/>
#include &lt;time.h&gt; <br/>
#include &lt;unistd.h&gt;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>#define
_cleanup_(f) __attribute__((cleanup(f)))</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
void closep(int *fd) { <br/>
if (!fd || *fd &lt; 0) <br/>
return;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>close(*fd);
<br/>
*fd = −1; <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
int notify(const char *message) { <br/>
union sockaddr_union { <br/>
struct sockaddr sa; <br/>
struct sockaddr_un sun; <br/>
} socket_addr = { <br/>
.sun.sun_family = AF_UNIX, <br/>
}; <br/>
size_t path_length, message_length; <br/>
_cleanup_(closep) int fd = −1; <br/>
const char *socket_path;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Verify the argument first */ <br/>
if (!message) <br/>
return −EINVAL;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>message_length
= strlen(message); <br/>
if (message_length == 0) <br/>
return −EINVAL;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
If the variable is not set, the protocol is a noop */ <br/>
socket_path = getenv("NOTIFY_SOCKET"); <br/>
if (!socket_path) <br/>
return 0; /* Not set? Nothing to do */</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Only AF_UNIX is supported, with path or abstract sockets */
<br/>
if (socket_path[0] != '/' &amp;&amp; socket_path[0] != '@')
<br/>
return −EAFNOSUPPORT;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>path_length
= strlen(socket_path); <br/>
/* Ensure there is room for NUL byte */ <br/>
if (path_length &gt;= sizeof(socket_addr.sun.sun_path)) <br/>
return −E2BIG;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>memcpy(socket_addr.sun.sun_path,
socket_path, path_length);</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Support for abstract socket */ <br/>
if (socket_addr.sun.sun_path[0] == '@') <br/>
socket_addr.sun.sun_path[0] = 0;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>fd
= socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0); <br/>
if (fd &lt; 0) <br/>
return −errno;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>if
(connect(fd, &amp;socket_addr.sa, offsetof(struct
sockaddr_un, sun_path) + path_length) != 0) <br/>
return −errno;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>ssize_t
written = write(fd, message, message_length); <br/>
if (written != (ssize_t) message_length) <br/>
return written &lt; 0 ? −errno :
−EPROTO;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>return
1; /* Notified! */ <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
int notify_ready(void) { <br/>
return notify("READY=1"); <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
int notify_reloading(void) { <br/>
/* A buffer with length sufficient to format the maximum
UINT64 value. */ <br/>
char
reload_message[sizeof("RELOADING=1\nMONOTONIC_USEC=18446744073709551615")];
<br/>
struct timespec ts; <br/>
uint64_t now;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Notify systemd that we are reloading, including a
CLOCK_MONOTONIC timestamp in usec <br/>
* so that the program is compatible with a
Type=notify−reload service. */</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>if
(clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0) <br/>
return −errno;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>if
(ts.tv_sec &lt; 0 || ts.tv_nsec &lt; 0 || <br/>
(uint64_t) ts.tv_sec &gt; (UINT64_MAX − (ts.tv_nsec /
1000ULL)) / 1000000ULL) <br/>
return −EINVAL;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>now
= (uint64_t) ts.tv_sec * 1000000ULL + (uint64_t) ts.tv_nsec
/ 1000ULL;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>if
(snprintf(reload_message, sizeof(reload_message),
"RELOADING=1\nMONOTONIC_USEC=%" PRIu64, now) &lt;
0) <br/>
return −EINVAL;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>return
notify(reload_message); <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
int notify_stopping(void) { <br/>
return notify("STOPPING=1"); <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
volatile sig_atomic_t reloading = 0; <br/>
static volatile sig_atomic_t terminating =
0;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>static
void signal_handler(int sig) { <br/>
if (sig == SIGHUP) <br/>
reloading = 1; <br/>
else if (sig == SIGINT || sig == SIGTERM) <br/>
terminating = 1; <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>int
main(int argc, char **argv) { <br/>
struct sigaction sa = { <br/>
.sa_handler = signal_handler, <br/>
.sa_flags = SA_RESTART, <br/>
}; <br/>
int r;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Setup signal handlers */ <br/>
sigemptyset(&amp;sa.sa_mask); <br/>
sigaction(SIGHUP, &amp;sa, NULL); <br/>
sigaction(SIGINT, &amp;sa, NULL); <br/>
sigaction(SIGTERM, &amp;sa, NULL);</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Do more service initialization work here ...
*/</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Now that all the preparations steps are done, signal
readiness */</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>r
= notify_ready(); <br/>
if (r &lt; 0) { <br/>
fprintf(stderr, "Failed to notify readiness to
$NOTIFY_SOCKET: %s\n", strerror(−r)); <br/>
return EXIT_FAILURE; <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>while
(!terminating) { <br/>
if (reloading) { <br/>
reloading = false;</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
As a separate but related feature, we can also notify the
manager <br/>
* when reloading configuration. This allows accurate
state−tracking, <br/>
* and also automated hook−in of 'systemctl reload'
without having to <br/>
* specify manually an ExecReload= line in the unit file.
*/</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>r
= notify_reloading(); <br/>
if (r &lt; 0) { <br/>
fprintf(stderr, "Failed to notify reloading to
$NOTIFY_SOCKET: %s\n", strerror(−r)); <br/>
return EXIT_FAILURE; <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Do some reconfiguration work here ... */</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>r
= notify_ready(); <br/>
if (r &lt; 0) { <br/>
fprintf(stderr, "Failed to notify readiness to
$NOTIFY_SOCKET: %s\n", strerror(−r)); <br/>
return EXIT_FAILURE; <br/>
} <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Do some daemon work here ... */ <br/>
sleep(5); <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>r
= notify_stopping(); <br/>
if (r &lt; 0) { <br/>
fprintf(stderr, "Failed to report termination to
$NOTIFY_SOCKET: %s\n", strerror(−r)); <br/>
return EXIT_FAILURE; <br/>
}</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>/*
Do some shutdown work here ... */</big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big>return
EXIT_SUCCESS; <br/>
}</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b><big>Python</big></b></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#!/usr/bin/env
python3 <br/>
# SPDX−License−Identifier: MIT−0 <br/>
# <br/>
# Implement the systemd notify protocol without external
dependencies. <br/>
# Supports both readiness notification on startup and on
reloading, <br/>
# according to the protocol defined at: <br/>
#
https://www.freedesktop.org/software/systemd/man/latest/sd_notify.html
<br/>
# This protocol is guaranteed to be stable as per: <br/>
#
https://systemd.io/PORTABILITY_AND_STABILITY/</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>import
errno <br/>
import os <br/>
import signal <br/>
import socket <br/>
import sys <br/>
import time</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>reloading
= False <br/>
terminating = False</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
notify(message): <br/>
if not message: <br/>
raise ValueError("notify() requires a
message")</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>socket_path
= os.environ.get("NOTIFY_SOCKET") <br/>
if not socket_path: <br/>
return</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>if
socket_path[0] not in ("/", "@"): <br/>
raise OSError(errno.EAFNOSUPPORT, "Unsupported socket
type")</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Handle abstract socket. <br/>
if socket_path[0] == "@": <br/>
socket_path = "\0" +
socket_path[1:]</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>with
socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM |
socket.SOCK_CLOEXEC) as sock: <br/>
sock.connect(socket_path) <br/>
sock.sendall(message)</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
notify_ready(): <br/>
notify(b"READY=1")</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
notify_reloading(): <br/>
microsecs = time.clock_gettime_ns(time.CLOCK_MONOTONIC) //
1000 <br/>

notify(f"RELOADING=1\nMONOTONIC_USEC={microsecs}".encode())</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
notify_stopping(): <br/>
notify(b"STOPPING=1")</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
reload(signum, frame): <br/>
global reloading <br/>
reloading = True</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
terminate(signum, frame): <br/>
global terminating <br/>
terminating = True</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>def
main(): <br/>
print("Doing initial setup") <br/>
global reloading, terminating</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Set up signal handlers. <br/>
print("Setting up signal handlers") <br/>
signal.signal(signal.SIGHUP, reload) <br/>
signal.signal(signal.SIGINT, terminate) <br/>
signal.signal(signal.SIGTERM,
terminate)</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Do any other setup work here.</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Once all setup is done, signal readiness. <br/>
print("Done setting up") <br/>
notify_ready()</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>print("Starting
loop") <br/>
while not terminating: <br/>
if reloading: <br/>
print("Reloading") <br/>
reloading = False</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Support notifying the manager when reloading configuration.
<br/>
# This allows accurate state tracking as well as
automatically <br/>
# enabling 'systemctl reload' without needing to manually
<br/>
# specify an ExecReload= line in the unit
file.</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>notify_reloading()</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Do some reconfiguration work here.</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>print("Done
reloading") <br/>
notify_ready()</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>#
Do the real work here ...</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>print("Sleeping
for five seconds") <br/>
time.sleep(5)</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>print("Terminating")
<br/>
notify_stopping()</big></big></font></p>
<p style="margin-left:19%; margin-top: 1em"><font color="#000000"><big><big>if
__name__ == "__main__": <br/>
sys.stdout.reconfigure(line_buffering=True) <br/>
print("Starting app") <br/>
main() <br/>
print("Stopped app")</big></big></font></p>
<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><i>$NOTIFY_SOCKET</i></big></font></p>
<p style="margin-left:14%;"><font color="#000000"><big>Set
by the service manager for supervised processes for status
and start−up completion notification. This environment
variable specifies the socket <b>sd_notify()</b> talks to.
See above for details.</big></font></p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>Example 1. Start−up
Notification</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big>When
a service finished starting up, it might issue the following
call to notify the service manager:</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>sd_notify(0,
"READY=1");</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>Example 2. Extended
Start−up Notification</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big>A
service could send the following after completing
initialization:</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>sd_notifyf(0,
"READY=1\n" <br/>
"STATUS=Processing requests...\n" <br/>
"MAINPID=%lu", <br/>
(unsigned long) getpid());</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>Example 3. Error
Cause Notification</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big>A
service could send the following shortly before exiting, on
failure:</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>sd_notifyf(0,
"STATUS=Failed to start up: %s\n" <br/>
"ERRNO=%i", <br/>
strerror_r(errnum, (char[1024]){}, 1024), <br/>
errnum);</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>Example 4. Store
a File Descriptor in the Service
Manager</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big>To
store an open file descriptor in the service manager, in
order to continue operation after a service restart without
losing state, use "FDSTORE=1":</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>sd_pid_notify_with_fds(0,
0, "FDSTORE=1\nFDNAME=foobar", &amp;fd,
1);</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>Example 5. Eliminating
race conditions</b></big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big>When
the client sending the notifications is not spawned by the
service manager, it may exit too quickly and the service
manager may fail to attribute them correctly to the unit. To
prevent such races, use <b>sd_notify_barrier()</b> to
synchronize against reception of all notifications sent
before this call is made.</big></font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000"><big>sd_notify(0,
"READY=1"); <br/>
/* set timeout to 5 seconds */ <br/>
sd_notify_barrier(0, 5 * 1000000);</big></font></p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>sd_pid_notify()</b>,
<b>sd_pid_notifyf()</b>, and <b>sd_pid_notify_with_fds()</b>
were added in version 219.</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>sd_notify_barrier()</b>
was added in version 246.</big></font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>sd_pid_notifyf_with_fds()</b>
and <b>sd_pid_notify_barrier()</b> were added in version
254.</big></font></p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><big><b>systemd</b>(1),
<b>sd-daemon</b>(3), <b>sd_listen_fds</b>(3),
<b>sd_listen_fds_with_names</b>(3),
<b>sd_watchdog_enabled</b>(3), <b>daemon</b>(7),
<b>systemd.service</b>(5)</big></font></p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="10%"></td>
<td width="3%">
<p style="margin-top: 1em"><font color="#000000"><big>1.</big></font></p> </td>
<td width="1%"></td>
<td width="27%">
<p style="margin-top: 1em"><font color="#000000"><big>File
Descriptor Store</big></font></p></td>
<td width="59%">
</td></tr>
</table>
<p style="margin-left:14%;"><font color="#000000"><big>https://systemd.io/FILE_DESCRIPTOR_STORE</big></font></p>
<hr/>
</body>
</html>
