<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:53:13 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>xcb_change_gc</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">xcb_change_gc</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Request function">Request function</a><br/>
<a href="#REQUEST ARGUMENTS">REQUEST ARGUMENTS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#EXAMPLE">EXAMPLE</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">xcb_change_gc
− change graphics context components</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;xcb/xproto.h&gt;</b></p>
<h3>Request function
<a name="Request function"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">xcb_void_cookie_t
<b>xcb_change_gc</b>(xcb_connection_t *<i>conn</i>,
xcb_gcontext_t <i>gc</i>,
uint32_t <i>value_mask</i>, const
void *<i>value_list</i>);</p> </td></tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<h2>REQUEST ARGUMENTS
<a name="REQUEST ARGUMENTS"></a>
</h2>
<td width="9%"></td>
<td width="5%"></td>
<td width="8%"></td>
<td width="40%">
</td>
<td width="38%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p><i>conn</i></p></td>
<td width="8%"></td>
<td width="40%">
<p>The XCB connection to X11.</p></td>
<td width="38%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p><i>gc</i></p></td>
<td width="8%"></td>
<td width="40%">
<p>The graphics context to change.</p></td>
<td width="38%">
</td></tr>
</table>
<p style="margin-left:9%;"><i>value_mask</i></p>
<p style="margin-left:22%;">One of the following values:
<i><br/>
XCB_GC_FUNCTION</i></p>
<p style="margin-left:35%;">TODO: Refer to GX</p>
<p style="margin-left:22%;"><i>XCB_GC_PLANE_MASK</i></p>
<p style="margin-left:35%;">In graphics operations, given a
source and destination pixel, the result is computed bitwise
on corresponding bits of the pixels; that is, a Boolean
operation is performed in each bit plane. The plane-mask
restricts the operation to a subset of planes, so the result
is:</p>
<p style="margin-left:35%; margin-top: 1em">((src FUNC dst)
AND plane-mask) OR (dst AND (NOT plane-mask))</p>
<p style="margin-left:22%;"><i>XCB_GC_FOREGROUND</i></p>
<p style="margin-left:35%;">Foreground colorpixel.</p>
<p style="margin-left:22%;"><i>XCB_GC_BACKGROUND</i></p>
<p style="margin-left:35%;">Background colorpixel.</p>
<p style="margin-left:22%;"><i>XCB_GC_LINE_WIDTH</i></p>
<p style="margin-left:35%;">The line-width is measured in
pixels and can be greater than or equal to one, a wide line,
or the special value zero, a thin line.</p>
<p style="margin-left:22%;"><i>XCB_GC_LINE_STYLE</i></p>
<p style="margin-left:35%;">The line-style defines which
sections of a line are drawn: Solid The full path of the
line is drawn. DoubleDash The full path of the line is
drawn, but the even dashes are filled differently <br/>
than the odd dashes (see fill-style), with Butt cap-style
used where even and <br/>
odd dashes meet. OnOffDash Only the even dashes are drawn,
and cap-style applies to all internal ends of <br/>
the individual dashes (except NotLast is treated as
Butt).</p>
<p style="margin-left:22%;"><i>XCB_GC_CAP_STYLE</i></p>
<p style="margin-left:35%;">The cap-style defines how the
endpoints of a path are drawn: NotLast The result is
equivalent to Butt, except that for a line-width of zero the
final <br/>
endpoint is not drawn. Butt The result is square at the
endpoint (perpendicular to the slope of the line) <br/>
with no projection beyond. Round The result is a circular
arc with its diameter equal to the line-width, centered <br/>
on the endpoint; it is equivalent to Butt for line-width
zero. Projecting The result is square at the end, but the
path continues beyond the endpoint for <br/>
a distance equal to half the line-width; it is equivalent to
Butt for line-width <br/>
zero.</p>
<p style="margin-left:22%;"><i>XCB_GC_JOIN_STYLE</i></p>
<p style="margin-left:35%;">The join-style defines how
corners are drawn for wide lines: Miter The outer edges of
the two lines extend to meet at an angle. However, if the
<br/>
angle is less than 11 degrees, a Bevel join-style is used
instead. Round The result is a circular arc with a diameter
equal to the line-width, centered <br/>
on the joinpoint. Bevel The result is Butt endpoint styles,
and then the triangular notch is filled.</p>
<p style="margin-left:22%;"><i>XCB_GC_FILL_STYLE</i></p>
<p style="margin-left:35%;">The fill-style defines the
contents of the source for line, text, and fill requests.
For all text and fill requests (for example, PolyText8,
PolyText16, PolyFillRectangle, FillPoly, and PolyFillArc) as
well as for line requests with line-style Solid, (for
example, PolyLine, PolySegment, PolyRectangle, PolyArc) and
for the even dashes for line requests with line-style
OnOffDash or DoubleDash: Solid Foreground Tiled Tile
OpaqueStippled A tile with the same width and height as
stipple but with background <br/>
everywhere stipple has a zero and with foreground everywhere
stipple <br/>
has a one Stippled Foreground masked by stipple For the odd
dashes for line requests with line-style DoubleDash: Solid
Background Tiled Same as for even dashes OpaqueStippled Same
as for even dashes Stippled Background masked by stipple</p>
<p style="margin-left:22%;"><i>XCB_GC_FILL_RULE <br/>
XCB_GC_TILE</i></p>
<p style="margin-left:35%;">The tile/stipple represents an
infinite two-dimensional plane with the tile/stipple
replicated in all dimensions. When that plane is
superimposed on the drawable for use in a graphics
operation, the upper-left corner of some instance of the
tile/stipple is at the coordinates within the drawable
specified by the tile/stipple origin. The tile/stipple and
clip origins are interpreted relative to the origin of
whatever destination drawable is specified in a graphics
request. The tile pixmap must have the same root and depth
as the gcontext (or a Match error results). The stipple
pixmap must have depth one and must have the same root as
the gcontext (or a Match error results). For fill-style
Stippled (but not fill-style OpaqueStippled), the stipple
pattern is tiled in a single plane and acts as an additional
clip mask to be ANDed with the clip-mask. Any size pixmap
can be used for tiling or stippling, although some sizes may
be faster to use than others.</p>
<p style="margin-left:22%;"><i>XCB_GC_STIPPLE</i></p>
<p style="margin-left:35%;">The tile/stipple represents an
infinite two-dimensional plane with the tile/stipple
replicated in all dimensions. When that plane is
superimposed on the drawable for use in a graphics
operation, the upper-left corner of some instance of the
tile/stipple is at the coordinates within the drawable
specified by the tile/stipple origin. The tile/stipple and
clip origins are interpreted relative to the origin of
whatever destination drawable is specified in a graphics
request. The tile pixmap must have the same root and depth
as the gcontext (or a Match error results). The stipple
pixmap must have depth one and must have the same root as
the gcontext (or a Match error results). For fill-style
Stippled (but not fill-style OpaqueStippled), the stipple
pattern is tiled in a single plane and acts as an additional
clip mask to be ANDed with the clip-mask. Any size pixmap
can be used for tiling or stippling, although some sizes may
be faster to use than others.</p>
<p style="margin-left:22%;"><i>XCB_GC_TILE_STIPPLE_ORIGIN_X</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:22%;"><i>XCB_GC_TILE_STIPPLE_ORIGIN_Y</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:22%;"><i>XCB_GC_FONT</i></p>
<p style="margin-left:35%;">Which font to use for the
<i>ImageText8</i> and <i>ImageText16</i> requests.</p>
<p style="margin-left:22%;"><i>XCB_GC_SUBWINDOW_MODE</i></p>
<p style="margin-left:35%;">For ClipByChildren, both source
and destination windows are additionally clipped by all
viewable InputOutput children. For IncludeInferiors, neither
source nor destination window is clipped by inferiors. This
will result in including subwindow contents in the source
and drawing through subwindow boundaries of the destination.
The use of IncludeInferiors with a source or destination
window of one depth with mapped inferiors of differing depth
is not illegal, but the semantics is undefined by the core
protocol.</p>
<p style="margin-left:22%;"><i>XCB_GC_GRAPHICS_EXPOSURES</i></p>
<p style="margin-left:35%;">Whether ExposureEvents should
be generated (1) or not (0).</p>
<p style="margin-left:35%; margin-top: 1em">The default is
1.</p>
<p style="margin-left:22%;"><i>XCB_GC_CLIP_ORIGIN_X</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:22%;"><i>XCB_GC_CLIP_ORIGIN_Y</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:22%;"><i>XCB_GC_CLIP_MASK</i></p>
<p style="margin-left:35%;">The clip-mask restricts writes
to the destination drawable. Only pixels where the clip-mask
has bits set to 1 are drawn. Pixels are not drawn outside
the area covered by the clip-mask or where the clip-mask has
bits set to 0. The clip-mask affects all graphics requests,
but it does not clip sources. The clip-mask origin is
interpreted relative to the origin of whatever destination
drawable is specified in a graphics request. If a pixmap is
specified as the clip-mask, it must have depth 1 and have
the same root as the gcontext (or a Match error results). If
clip-mask is None, then pixels are always drawn, regardless
of the clip origin. The clip-mask can also be set with the
SetClipRectangles request.</p>
<p style="margin-left:22%;"><i>XCB_GC_DASH_OFFSET</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:22%;"><i>XCB_GC_DASH_LIST</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:22%;"><i>XCB_GC_ARC_MODE</i></p>
<p style="margin-left:35%;">TODO</p>
<p style="margin-left:9%;"><i>value_list</i></p>
<p style="margin-left:22%;">Values for each of the
components specified in the bitmask <i>value_mask</i>. The
order has to correspond to the order of possible
<i>value_mask</i> bits. See the example.</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Changes the
components specified by <i>value_mask</i> for the specified
graphics context.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Returns an
<i>xcb_void_cookie_t</i>. Errors (if any) have to be handled
in the event loop.</p>
<p style="margin-left:9%; margin-top: 1em">If you want to
handle errors directly with <i>xcb_request_check</i>
instead, use <i>xcb_change_gc_checked</i>. See
<b>xcb-requests(3)</b> for details.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><i>xcb_alloc_error_t</i></p>
<p style="margin-left:22%;">The X server could not allocate
the requested resources (no memory?).</p>
<p style="margin-left:9%;"><i>xcb_font_error_t</i></p>
<p style="margin-left:22%;">TODO: reasons?</p>
<p style="margin-left:9%;"><i>xcb_g_context_error_t</i></p>
<p style="margin-left:22%;">TODO: reasons?</p>
<p style="margin-left:9%;"><i>xcb_match_error_t</i></p>
<p style="margin-left:22%;">TODO: reasons?</p>
<p style="margin-left:9%;"><i>xcb_pixmap_error_t</i></p>
<p style="margin-left:22%;">TODO: reasons?</p>
<p style="margin-left:9%;"><i>xcb_value_error_t</i></p>
<p style="margin-left:22%;">TODO: reasons?</p>
<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">/* <br/>
* Changes the foreground color component of the specified
graphics context. <br/>
* <br/>
*/ <br/>
void my_example(xcb_connection_t *conn, xcb_gcontext_t gc,
uint32_t fg, uint32_t bg) { <br/>
/* C99 allows us to use a compact way of changing a single
component: */ <br/>
xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, (uint32_t[]){ fg
});</p>
<p style="margin-left:9%; margin-top: 1em">/* The more
explicit way. Beware that the order of values is important!
*/ <br/>
uint32_t mask = 0; <br/>
mask |= XCB_GC_FOREGROUND; <br/>
mask |= XCB_GC_BACKGROUND;</p>
<p style="margin-left:9%; margin-top: 1em">uint32_t
values[] = { <br/>
fg, <br/>
bg <br/>
}; <br/>
xcb_change_gc(conn, gc, mask, values); <br/>
xcb_flush(conn); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>xcb-requests</b>(3),
<b>xcb-examples</b>(3)</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated from
xproto.xml. Contact xcb@lists.freedesktop.org for
corrections and improvements.</p>
<hr/>
</body>
</html>
