<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:47:11 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OSSL_HPKE_CTX_NEW</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">OSSL_HPKE_CTX_NEW</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Data Structures">Data Structures</a><br/>
<a href="#OSSL_HPKE_SUITE Identifiers">OSSL_HPKE_SUITE Identifiers</a><br/>
<a href="#HPKE Modes">HPKE Modes</a><br/>
<a href="#HPKE Roles">HPKE Roles</a><br/>
<a href="#Parameter Size Limits">Parameter Size Limits</a><br/>
<a href="#Context Construct/Free">Context Construct/Free</a><br/>
<a href="#Sender APIs">Sender APIs</a><br/>
<a href="#Recipient APIs">Recipient APIs</a><br/>
<a href="#Exporting Secrets">Exporting Secrets</a><br/>
<a href="#Sender−authenticated HPKE Modes">Sender−authenticated HPKE Modes</a><br/>
<a href="#Pre−Shared Key HPKE modes">Pre−Shared Key HPKE modes</a><br/>
<a href="#Deterministic key generation for senders">Deterministic key generation for senders</a><br/>
<a href="#Re−sequencing">Re−sequencing</a><br/>
<a href="#Protocol Convenience Functions">Protocol Convenience Functions</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#WARNINGS">WARNINGS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">OSSL_HPKE_CTX_new,
OSSL_HPKE_CTX_free, OSSL_HPKE_encap, OSSL_HPKE_decap,
OSSL_HPKE_seal, OSSL_HPKE_open, OSSL_HPKE_export,
OSSL_HPKE_suite_check, OSSL_HPKE_str2suite,
OSSL_HPKE_keygen, OSSL_HPKE_get_grease_value,
OSSL_HPKE_get_ciphertext_size,
OSSL_HPKE_get_public_encap_size,
OSSL_HPKE_get_recommended_ikmelen, OSSL_HPKE_CTX_set1_psk,
OSSL_HPKE_CTX_set1_ikme, OSSL_HPKE_CTX_set1_authpriv,
OSSL_HPKE_CTX_set1_authpub, OSSL_HPKE_CTX_get_seq,
OSSL_HPKE_CTX_set_seq − Hybrid Public Key Encryption
(HPKE) functions</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/hpke.h&gt; <br/>
typedef struct { <br/>
uint16_t kem_id; <br/>
uint16_t kdf_id; <br/>
uint16_t aead_id; <br/>
} OSSL_HPKE_SUITE; <br/>
OSSL_HPKE_CTX *OSSL_HPKE_CTX_new(int mode, OSSL_HPKE_SUITE
suite, int role, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
void OSSL_HPKE_CTX_free(OSSL_HPKE_CTX *ctx); <br/>
int OSSL_HPKE_encap(OSSL_HPKE_CTX *ctx, <br/>
unsigned char *enc, size_t *enclen, <br/>
const unsigned char *pub, size_t publen, <br/>
const unsigned char *info, size_t infolen); <br/>
int OSSL_HPKE_seal(OSSL_HPKE_CTX *ctx, <br/>
unsigned char *ct, size_t *ctlen, <br/>
const unsigned char *aad, size_t aadlen, <br/>
const unsigned char *pt, size_t ptlen); <br/>
int OSSL_HPKE_keygen(OSSL_HPKE_SUITE suite, <br/>
unsigned char *pub, size_t *publen, EVP_PKEY **priv, <br/>
const unsigned char *ikm, size_t ikmlen, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
int OSSL_HPKE_decap(OSSL_HPKE_CTX *ctx, <br/>
const unsigned char *enc, size_t enclen, <br/>
EVP_PKEY *recippriv, <br/>
const unsigned char *info, size_t infolen); <br/>
int OSSL_HPKE_open(OSSL_HPKE_CTX *ctx, <br/>
unsigned char *pt, size_t *ptlen, <br/>
const unsigned char *aad, size_t aadlen, <br/>
const unsigned char *ct, size_t ctlen); <br/>
int OSSL_HPKE_export(OSSL_HPKE_CTX *ctx, <br/>
unsigned char *secret, size_t secretlen, <br/>
const unsigned char *label, size_t labellen); <br/>
int OSSL_HPKE_CTX_set1_authpriv(OSSL_HPKE_CTX *ctx, EVP_PKEY
*priv); <br/>
int OSSL_HPKE_CTX_set1_authpub(OSSL_HPKE_CTX *ctx, <br/>
unsigned char *pub, size_t publen); <br/>
int OSSL_HPKE_CTX_set1_psk(OSSL_HPKE_CTX *ctx, <br/>
const char *pskid, <br/>
const unsigned char *psk, size_t psklen); <br/>
int OSSL_HPKE_CTX_get_seq(OSSL_HPKE_CTX *ctx, uint64_t
*seq); <br/>
int OSSL_HPKE_CTX_set_seq(OSSL_HPKE_CTX *ctx, uint64_t seq);
<br/>
int OSSL_HPKE_CTX_set1_ikme(OSSL_HPKE_CTX *ctx, <br/>
const unsigned char *ikme, size_t ikmelen); <br/>
int OSSL_HPKE_suite_check(OSSL_HPKE_SUITE suite); <br/>
int OSSL_HPKE_get_grease_value(const OSSL_HPKE_SUITE
*suite_in, <br/>
OSSL_HPKE_SUITE *suite, <br/>
unsigned char *enc, size_t *enclen, <br/>
unsigned char *ct, size_t ctlen, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
int OSSL_HPKE_str2suite(const char *str, OSSL_HPKE_SUITE
*suite); <br/>
size_t OSSL_HPKE_get_ciphertext_size(OSSL_HPKE_SUITE suite,
size_t clearlen); <br/>
size_t OSSL_HPKE_get_public_encap_size(OSSL_HPKE_SUITE
suite); <br/>
size_t OSSL_HPKE_get_recommended_ikmelen(OSSL_HPKE_SUITE
suite);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These functions
provide an API for using the form of Hybrid Public Key
Encryption (HPKE) defined in RFC9180. Understanding the HPKE
specification is likely required before using these APIs.
HPKE is used by various other IETF specifications, including
the TLS Encrypted Client Hello (ECH) specification and
others.</p>
<p style="margin-left:9%; margin-top: 1em">HPKE is a
standardised, highly flexible construct for encrypting
"to" a public key that supports combinations of a
key encapsulation method (KEM), a key derivation function
(KDF) and an authenticated encryption with additional data
(AEAD) algorithm, with optional sender authentication.</p>
<p style="margin-left:9%; margin-top: 1em">The sender and a
receiver here will generally be using some application or
protocol making use of HPKE. For example, with ECH, the
sender will be a browser and the receiver will be a web
server.</p>
<h3>Data Structures
<a name="Data Structures"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_SUITE</b>
is a structure that holds identifiers for the algorithms
used for KEM, KDF and AEAD operations.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX</b>
is a context that maintains internal state as HPKE
operations are carried out. Separate <b>OSSL_HPKE_CTX</b>
objects must be used for the sender and receiver. Attempting
to use a single context for both will result in errors.</p>
<h3>OSSL_HPKE_SUITE Identifiers
<a name="OSSL_HPKE_SUITE Identifiers"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The identifiers
used by <b>OSSL_HPKE_SUITE</b> are:</p>
<p style="margin-left:9%; margin-top: 1em">The KEM
identifier <i>kem_id</i> is one of the following: <br/>
0x10 <b>OSSL_HPKE_KEM_ID_P256</b> <br/>
0x11 <b>OSSL_HPKE_KEM_ID_P384</b> <br/>
0x12 <b>OSSL_HPKE_KEM_ID_P521</b> <br/>
0x20 <b>OSSL_HPKE_KEM_ID_X25519</b> <br/>
0x21 <b>OSSL_HPKE_KEM_ID_X448</b></p>
<p style="margin-left:9%; margin-top: 1em">The KDF
identifier <i>kdf_id</i> is one of the following: <br/>
0x01 <b>OSSL_HPKE_KDF_ID_HKDF_SHA256</b> <br/>
0x02 <b>OSSL_HPKE_KDF_ID_HKDF_SHA384</b> <br/>
0x03 <b>OSSL_HPKE_KDF_ID_HKDF_SHA512</b></p>
<p style="margin-left:9%; margin-top: 1em">The AEAD
identifier <i>aead_id</i> is one of the following: <br/>
0x01 <b>OSSL_HPKE_AEAD_ID_AES_GCM_128</b> <br/>
0x02 <b>OSSL_HPKE_AEAD_ID_AES_GCM_256</b> <br/>
0x03 <b>OSSL_HPKE_AEAD_ID_CHACHA_POLY1305</b> <br/>
0xFFFF <b>OSSL_HPKE_AEAD_ID_EXPORTONLY</b></p>
<p style="margin-left:14%;">The last identifier above
indicates that AEAD operations are not needed.
<b>OSSL_HPKE_export()</b> can be used, but
<b>OSSL_HPKE_open()</b> and <b>OSSL_HPKE_seal()</b> will
return an error if called with a context using that AEAD
identifier.</p>
<h3>HPKE Modes
<a name="HPKE Modes"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">HPKE supports
the following variants of Authentication using a mode
Identifier: <b><br/>
OSSL_HPKE_MODE_BASE</b>, 0x00</p>
<p style="margin-left:14%;">Authentication is not used.</p>
<p style="margin-left:9%;"><b>OSSL_HPKE_MODE_PSK</b>,
0x01</p>
<p style="margin-left:14%;">Authenticates possession of a
pre−shared key (PSK).</p>
<p style="margin-left:9%;"><b>OSSL_HPKE_MODE_AUTH</b>,
0x02</p>
<p style="margin-left:14%;">Authenticates possession of a
KEM−based sender private key.</p>
<p style="margin-left:9%;"><b>OSSL_HPKE_MODE_PSKAUTH</b>,
0x03</p>
<p style="margin-left:14%;">A combination of
<b>OSSL_HPKE_MODE_PSK</b> and <b>OSSL_HPKE_MODE_AUTH</b>.
Both the PSK and the senders authentication public/private
must be supplied before the encapsulation/decapsulation
operation will work.</p>
<p style="margin-left:9%; margin-top: 1em">For further
information related to authentication see
"Pre−Shared Key HPKE modes" and
"Sender−authenticated HPKE Modes".</p>
<h3>HPKE Roles
<a name="HPKE Roles"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">HPKE contexts
have a role − either sender or receiver. This is used
to control which functions can be called and so that senders
do not reuse a key and nonce with different plaintexts.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_free()</b>,
<b>OSSL_HPKE_export()</b>, <b>OSSL_HPKE_CTX_set1_psk()</b>,
and <b>OSSL_HPKE_CTX_get_seq()</b> can be called regardless
of role. <b><br/>
OSSL_HPKE_ROLE_SENDER</b>, 0</p>
<p style="margin-left:14%;">An <i>OSSL_HPKE_CTX</i> with
this role can be used with <b>OSSL_HPKE_encap()</b>,
<b>OSSL_HPKE_seal()</b>, <b>OSSL_HPKE_CTX_set1_ikme()</b>
and <b>OSSL_HPKE_CTX_set1_authpriv()</b>.</p>
<p style="margin-left:9%;"><b>OSSL_HPKE_ROLE_RECEIVER</b>,
1</p>
<p style="margin-left:14%;">An <i>OSSL_HPKE_CTX</i> with
this role can be used with <b>OSSL_HPKE_decap()</b>,
<b>OSSL_HPKE_open()</b>, <b>OSSL_HPKE_CTX_set1_authpub()</b>
and <b>OSSL_HPKE_CTX_set_seq()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Calling a
function with an incorrect role set on <i>OSSL_HPKE_CTX</i>
will result in an error.</p>
<h3>Parameter Size Limits
<a name="Parameter Size Limits"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In order to
improve interoperability, RFC9180, section 7.2.1 suggests a
RECOMMENDED maximum size of 64 octets for various input
parameters. In this implementation we apply a limit of 66
octets for the <i>ikmlen</i>, <i>psklen</i>, and
<i>labellen</i> parameters, and for the length of the string
<i>pskid</i> for HPKE functions below. The constant
<i>OSSL_HPKE_MAX_PARMLEN</i> is defined as the limit of this
value. (We chose 66 octets so that we can validate all the
test vectors present in RFC9180, Appendix A.)</p>
<p style="margin-left:9%; margin-top: 1em">In accordance
with RFC9180, section 9.5, we define a constant
<i>OSSL_HPKE_MIN_PSKLEN</i> with a value of 32 for the
minimum length of a pre−shared key, passed in
<i>psklen</i>.</p>
<p style="margin-left:9%; margin-top: 1em">While RFC9180
also RECOMMENDS a 64 octet limit for the <i>infolen</i>
parameter, that is not sufficient for TLS Encrypted
ClientHello (ECH) processing, so we enforce a limit of
<i>OSSL_HPKE_MAX_INFOLEN</i> with a value of 1024 as the
limit for the <i>infolen</i> parameter.</p>
<h3>Context Construct/Free
<a name="Context Construct/Free"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_new()</b>
creates a <b>OSSL_HPKE_CTX</b> context object used for
subsequent HPKE operations, given a <i>mode</i> (See
"HPKE Modes"), <i>suite</i> (see
"OSSL_HPKE_SUITE Identifiers") and a <i>role</i>
(see "HPKE Roles"). The <i>libctx</i> and
<i>propq</i> are used when fetching algorithms from
providers and may be set to NULL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_free()</b>
frees the <i>ctx</i> <b>OSSL_HPKE_CTX</b> that was created
previously by a call to <b>OSSL_HPKE_CTX_new()</b>. If the
argument to <b>OSSL_HPKE_CTX_free()</b> is NULL, nothing is
done.</p>
<h3>Sender APIs
<a name="Sender APIs"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">A sender's goal
is to use HPKE to encrypt using a public key, via use of a
KEM, then a KDF and finally an AEAD. The first step is to
encapsulate (using <b>OSSL_HPKE_encap()</b>) the sender's
public value using the recipient's public key, (<i>pub</i>)
and to internally derive secrets. This produces the
encapsulated public value (<i>enc</i>) to be sent to the
recipient in whatever protocol is using HPKE. Having done
the encapsulation step, the sender can then make one or more
calls to <b>OSSL_HPKE_seal()</b> to encrypt plaintexts using
the secret stored within <i>ctx</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_encap()</b>
uses the HPKE context <i>ctx</i>, the recipient public value
<i>pub</i> of size <i>publen</i>, and an optional
<i>info</i> parameter of size <i>infolen</i>, to produce the
encapsulated public value <i>enc</i>. On input <i>enclen</i>
should contain the maximum size of the <i>enc</i> buffer,
and returns the output size. An error will occur if the
input <i>enclen</i> is smaller than the value returned from
<b>OSSL_HPKE_get_public_encap_size()</b>. <i>info</i> may be
used to bind other protocol or application artefacts such as
identifiers. Generally, the encapsulated public value
<i>enc</i> corresponds to a single−use ephemeral
private value created as part of the encapsulation process.
Only a single call to <b>OSSL_HPKE_encap()</b> is allowed
for a given <b>OSSL_HPKE_CTX</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_seal()</b>
takes the <b>OSSL_HPKE_CTX</b> context <i>ctx</i>, the
plaintext buffer <i>pt</i> of size <i>ptlen</i> and optional
additional authenticated data buffer <i>aad</i> of size
<i>aadlen</i>, and returns the ciphertext <i>ct</i> of size
<i>ctlen</i>. On input <i>ctlen</i> should contain the
maximum size of the <i>ct</i> buffer, and returns the output
size. An error will occur if the input <i>ctlen</i> is
smaller than the value returned from
<b>OSSL_HPKE_get_public_encap_size()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_encap()</b>
must be called before the <b>OSSL_HPKE_seal()</b>.
<b>OSSL_HPKE_seal()</b> may be called multiple times, with
an internal "nonce" being incremented by one after
each call.</p>
<h3>Recipient APIs
<a name="Recipient APIs"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Recipients using
HPKE require a typically less ephemeral private value so
that the public value can be distributed to potential
senders via whatever protocol is using HPKE. For this
reason, recipients will generally first generate a key pair
and will need to manage their private key value using
standard mechanisms outside the scope of this API. Private
keys use normal <b>EVP_PKEY</b>(3) pointers so normal
private key management mechanisms can be used for the
relevant values.</p>
<p style="margin-left:9%; margin-top: 1em">In order to
enable encapsulation, the recipient needs to make it's
public value available to the sender. There is no generic
HPKE format defined for that − the relevant formatting
is intended to be defined by the application/protocols that
makes use of HPKE. ECH for example defines an ECHConfig data
structure that combines the public value with other ECH data
items. Normal library functions must therefore be used to
extract the public value in the required format based on the
<b>EVP_PKEY</b>(3) for the private value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_keygen()</b>
provides a way for recipients to generate a key pair based
on the HPKE <i>suite</i> to be used. It returns a
<b>EVP_PKEY</b>(3) pointer for the private value <i>priv</i>
and a encoded public key <i>pub</i> of size <i>publen</i>.
On input <i>publen</i> should contain the maximum size of
the <i>pub</i> buffer, and returns the output size. An error
will occur if the input <i>publen</i> is too small. The
<i>libctx</i> and <i>propq</i> are used when fetching
algorithms from providers and may be set to NULL. The HPKE
specification also defines a deterministic key generation
scheme where the private value is derived from initial
keying material (IKM), so <b>OSSL_HPKE_keygen()</b> also has
an option to use that scheme, using the <i>ikm</i> parameter
of size <i>ikmlen</i>. If either <i>ikm</i> is NULL or
<i>ikmlen</i> is zero, then a randomly generated key for the
relevant <i>suite</i> will be produced. If required
<i>ikmlen</i> should be greater than or equal to
<b>OSSL_HPKE_get_recommended_ikmelen()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_decap()</b>
takes as input the sender's encapsulated public value
produced by <b>OSSL_HPKE_encap()</b> (<i>enc</i>) and the
recipient's <b>EVP_PKEY</b>(3) pointer (<i>prov</i>), and
then re−generates the internal secret derived by the
sender. As before, an optional <i>info</i> parameter allows
binding that derived secret to other application/protocol
artefacts. Only a single call to <b>OSSL_HPKE_decap()</b> is
allowed for a given <b>OSSL_HPKE_CTX</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_open()</b>
is used by the recipient to decrypt the ciphertext <i>ct</i>
of size <i>ctlen</i> using the <i>ctx</i> and additional
authenticated data <i>aad</i> of size <i>aadlen</i>, to
produce the plaintext <i>pt</i> of size <i>ptlen</i>. On
input <i>ptlen</i> should contain the maximum size of the
<i>pt</i> buffer, and returns the output size. A <i>pt</i>
buffer that is the same size as the <i>ct</i> buffer will
suffice − generally the plaintext output will be a
little smaller than the ciphertext input. An error will
occur if the input <i>ptlen</i> is too small.
<b>OSSL_HPKE_open()</b> may be called multiple times, but as
with <b>OSSL_HPKE_seal()</b> there is an internally
incrementing nonce value so ciphertexts need to be presented
in the same order as used by the <b>OSSL_HPKE_seal()</b>.
See "Re−sequencing" if you need to process
multiple ciphertexts in a different order.</p>
<h3>Exporting Secrets
<a name="Exporting Secrets"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">HPKE defines a
way to produce exported secrets for use by the
application.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_export()</b>
takes as input the <b>OSSL_HPKE_CTX</b>, and an application
supplied label <i>label</i> of size <i>labellen</i>, to
produce a secret <i>secret</i> of size <i>secretlen</i>. The
sender must first call <b>OSSL_HPKE_encap()</b>, and the
receiver must call <b>OSSL_HPKE_decap()</b> in order to
derive the same shared secret.</p>
<p style="margin-left:9%; margin-top: 1em">Multiple calls
to <b>OSSL_HPKE_export()</b> with the same inputs will
produce the same secret. <i>OSSL_HPKE_AEAD_ID_EXPORTONLY</i>
may be used as the <b>OSSL_HPKE_SUITE</b> <i>aead_id</i>
that is passed to <b>OSSL_HPKE_CTX_new()</b> if the user
needs to produce a shared secret, but does not wish to
perform HPKE encryption.</p>
<h3>Sender−authenticated HPKE Modes
<a name="Sender−authenticated HPKE Modes"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">HPKE defines
modes that support KEM−based
sender−authentication <b>OSSL_HPKE_MODE_AUTH</b> and
<b>OSSL_HPKE_MODE_PSKAUTH</b>. This works by binding the
sender's authentication private/public values into the
encapsulation and decapsulation operations. The key used for
such modes must also use the same KEM as used for the
overall exchange. <b>OSSL_HPKE_keygen()</b> can be used to
generate the private value required.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_set1_authpriv()</b>
can be used by the sender to set the senders private
<i>priv</i> <b>EVP_PKEY</b> key into the
<b>OSSL_HPKE_CTX</b> <i>ctx</i> before calling
<b>OSSL_HPKE_encap()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_set1_authpub()</b>
can be used by the receiver to set the senders encoded pub
key <i>pub</i> of size <i>publen</i> into the
<b>OSSL_HPKE_CTX</b> <i>ctx</i> before calling
<b>OSSL_HPKE_decap()</b>.</p>
<h3>Pre−Shared Key HPKE modes
<a name="Pre−Shared Key HPKE modes"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">HPKE also
defines a symmetric equivalent to the authentication
described above using a pre−shared key (PSK) and a PSK
identifier. PSKs can be used with the
<b>OSSL_HPKE_MODE_PSK</b> and <b>OSSL_HPKE_MODE_PSKAUTH</b>
modes.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_set1_psk()</b>
sets the PSK identifier <i>pskid</i> string, and PSK buffer
<i>psk</i> of size <i>psklen</i> into the <i>ctx</i>. If
required this must be called before <b>OSSL_HPKE_encap()</b>
or <b>OSSL_HPKE_decap()</b>. As per RFC9180, if required,
both <i>psk</i> and <i>pskid</i> must be set to
non−NULL values. As PSKs are symmetric the same calls
must happen on both sender and receiver sides.</p>
<h3>Deterministic key generation for senders
<a name="Deterministic key generation for senders"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Normally the
senders ephemeral private key is generated randomly inside
<b>OSSL_HPKE_encap()</b> and remains secret.
<b>OSSL_HPKE_CTX_set1_ikme()</b> allows the user to override
this behaviour by setting a deterministic input key material
<i>ikm</i> of size <i>ikmlen</i> into the
<b>OSSL_HPKE_CTX</b> <i>ctx</i>. If required
<b>OSSL_HPKE_CTX_set1_ikme()</b> can optionally be called
before <b>OSSL_HPKE_encap()</b>. <i>ikmlen</i> should be
greater than or equal to
<b>OSSL_HPKE_get_recommended_ikmelen()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">It is generally
undesirable to use <b>OSSL_HPKE_CTX_set1_ikme()</b>, since
it exposes the relevant secret to the application rather
then preserving it within the library, and is more likely to
result in use of predictable values or values that leak.</p>
<h3>Re−sequencing
<a name="Re−sequencing"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Some protocols
may have to deal with packet loss while still being able to
decrypt arriving packets later. We provide a way to set the
increment used for the nonce to the next subsequent call to
<b>OSSL_HPKE_open()</b> (but not to <b>OSSL_HPKE_seal()</b>
as explained below). The <b>OSSL_HPKE_CTX_set_seq()</b> API
can be used for such purposes with the <i>seq</i> parameter
value resetting the internal nonce increment to be used for
the next call.</p>
<p style="margin-left:9%; margin-top: 1em">A baseline nonce
value is established based on the encapsulation or
decapsulation operation and is then incremented by 1 for
each call to seal or open. (In other words, the first
<i>seq</i> increment defaults to zero.)</p>
<p style="margin-left:9%; margin-top: 1em">If a caller
needs to determine how many calls to seal or open have been
made the <b>OSSL_HPKE_CTX_get_seq()</b> API can be used to
retrieve the increment (in the <i>seq</i> output) that will
be used in the next call to seal or open. That would return
0 before the first call a sender made to
<b>OSSL_HPKE_seal()</b> and 1 after that first call.</p>
<p style="margin-left:9%; margin-top: 1em">Note that reuse
of the same nonce and key with different plaintexts would be
very dangerous and could lead to loss of confidentiality and
integrity. We therefore only support application control
over <i>seq</i> for decryption (i.e.
<b>OSSL_HPKE_open()</b>) operations.</p>
<p style="margin-left:9%; margin-top: 1em">For
compatibility with other implementations these <i>seq</i>
increments are represented as <i>uint64_t</i>.</p>
<h3>Protocol Convenience Functions
<a name="Protocol Convenience Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Additional
convenience APIs allow the caller to access internal details
of local HPKE support and/or algorithms, such as parameter
lengths.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_suite_check()</b>
checks if a specific <b>OSSL_HPKE_SUITE</b> <i>suite</i> is
supported locally.</p>
<p style="margin-left:9%; margin-top: 1em">To assist with
memory allocation, <b>OSSL_HPKE_get_ciphertext_size()</b>
provides a way for the caller to know by how much ciphertext
will be longer than a plaintext of length <i>clearlen</i>.
(AEAD algorithms add a data integrity tag, so there is a
small amount of ciphertext expansion.)</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_get_public_encap_size()</b>
provides a way for senders to know how big the encapsulated
public value will be for a given HPKE <i>suite</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_get_recommended_ikmelen()</b>
returns the recommended Input Key Material size (in bytes)
for a given <i>suite</i>. This is needed in cases where the
same public value needs to be regenerated by a sender before
calling <b>OSSL_HPKE_seal()</b>. <i>ikmlen</i> should be at
least this size.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_get_grease_value()</b>
produces values of the appropriate length for a given
<i>suite_in</i> value (or a random value if <i>suite_in</i>
is NULL) so that a protocol using HPKE can send
so−called GREASE (see RFC8701) values that are harder
to distinguish from a real use of HPKE. The buffer sizes
should be supplied on input. The output <i>enc</i> value
will have an appropriate length for <i>suite_out</i> and a
random value, and the <i>ct</i> output will be a random
value. The relevant sizes for buffers can be found using
<b>OSSL_HPKE_get_ciphertext_size()</b> and
<b>OSSL_HPKE_get_public_encap_size()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_str2suite()</b>
maps input <i>str</i> strings to an <b>OSSL_HPKE_SUITE</b>
object. The input <i>str</i> should be a
comma−separated string with a KEM, KDF and AEAD name
in that order, for example
"x25519,hkdf−sha256,aes128gcm". This can be
used by command line tools that accept string form names for
HPKE codepoints. Valid (case−insensitive) names are:
"p−256", "p−384",
"p−521", "x25519" and
"x448" for KEM, "hkdf−sha256",
"hkdf−sha384" and
"hkdf−sha512" for KDF, and
"aes−gcm−128",
"aes−gcm−256",
"chacha20−poly1305" and "exporter"
for AEAD. String variants of the numbers listed in
"OSSL_HPKE_SUITE Identifiers" can also be
used.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_CTX_new()</b>
returns an OSSL_HPKE_CTX pointer or NULL on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_HPKE_get_ciphertext_size()</b>,
<b>OSSL_HPKE_get_public_encap_size()</b>,
<b>OSSL_HPKE_get_recommended_ikmelen()</b> all return a
size_t with the relevant value or zero on error.</p>
<p style="margin-left:9%; margin-top: 1em">All other
functions return 1 for success or zero for error.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This example
demonstrates a minimal round−trip using HPKE.</p>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;stddef.h&gt; <br/>
#include &lt;string.h&gt; <br/>
#include &lt;openssl/hpke.h&gt; <br/>
#include &lt;openssl/evp.h&gt; <br/>
/* <br/>
* this is big enough for this example, real code would need
different <br/>
* handling <br/>
*/ <br/>
#define LBUFSIZE 48 <br/>
/* Do a round−trip, generating a key, encrypting and
decrypting */ <br/>
int main(int argc, char **argv) <br/>
{ <br/>
int ok = 0; <br/>
int hpke_mode = OSSL_HPKE_MODE_BASE; <br/>
OSSL_HPKE_SUITE hpke_suite = OSSL_HPKE_SUITE_DEFAULT; <br/>
OSSL_HPKE_CTX *sctx = NULL, *rctx = NULL; <br/>
EVP_PKEY *priv = NULL; <br/>
unsigned char pub[LBUFSIZE]; <br/>
size_t publen = sizeof(pub); <br/>
unsigned char enc[LBUFSIZE]; <br/>
size_t enclen = sizeof(enc); <br/>
unsigned char ct[LBUFSIZE]; <br/>
size_t ctlen = sizeof(ct); <br/>
unsigned char clear[LBUFSIZE]; <br/>
size_t clearlen = sizeof(clear); <br/>
const unsigned char *pt = "a message not in a
bottle"; <br/>
size_t ptlen = strlen((char *)pt); <br/>
const unsigned char *info = "Some info"; <br/>
size_t infolen = strlen((char *)info); <br/>
unsigned char aad[] = { 1, 2, 3, 4, 5, 6, 7, 8 }; <br/>
size_t aadlen = sizeof(aad); <br/>
/* <br/>
* Generate receiver's key pair. <br/>
* The receiver gives this public key to the sender. <br/>
*/ <br/>
if (OSSL_HPKE_keygen(hpke_suite, pub, &amp;publen,
&amp;priv, <br/>
NULL, 0, NULL, NULL) != 1) <br/>
goto err; <br/>
/* sender's actions − encrypt data using the receivers
public key */ <br/>
if ((sctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite, <br/>
OSSL_HPKE_ROLE_SENDER, <br/>
NULL, NULL)) == NULL) <br/>
goto err; <br/>
if (OSSL_HPKE_encap(sctx, enc, &amp;enclen, pub, publen,
info, infolen) != 1) <br/>
goto err; <br/>
if (OSSL_HPKE_seal(sctx, ct, &amp;ctlen, aad, aadlen, pt,
ptlen) != 1) <br/>
goto err; <br/>
/* receiver's actions − decrypt data using the
receivers private key */ <br/>
if ((rctx = OSSL_HPKE_CTX_new(hpke_mode, hpke_suite, <br/>
OSSL_HPKE_ROLE_RECEIVER, <br/>
NULL, NULL)) == NULL) <br/>
goto err; <br/>
if (OSSL_HPKE_decap(rctx, enc, enclen, priv, info, infolen)
!= 1) <br/>
goto err; <br/>
if (OSSL_HPKE_open(rctx, clear, &amp;clearlen, aad, aadlen,
ct, ctlen) != 1) <br/>
goto err; <br/>
ok = 1; <br/>
err: <br/>
/* clean up */ <br/>
printf(ok ? "All Good!\n" : "Error!\n");
<br/>
OSSL_HPKE_CTX_free(rctx); <br/>
OSSL_HPKE_CTX_free(sctx); <br/>
EVP_PKEY_free(priv); <br/>
return 0; <br/>
}</p>
<h2>WARNINGS
<a name="WARNINGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Note that the
<b>OSSL_HPKE_CTX_set_seq()</b> API could be dangerous
− if used with GCM that could lead to
nonce−reuse, which is a known danger. So avoid that
entirely, or be very very careful when using that API.</p>
<p style="margin-left:9%; margin-top: 1em">Use of an IKM
value for deterministic key generation (via
<b>OSSL_HPKE_CTX_set1_ikme()</b> or
<b>OSSL_HPKE_keygen()</b>) creates the potential for leaking
keys (or IKM values). Only use that if really needed and if
you understand how keys or IKM values could be abused.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The RFC9180
specification: https://datatracker.ietf.org/doc/rfc9180/</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This
functionality described here was added in OpenSSL 3.2.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2022−2025 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
