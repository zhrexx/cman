<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:51:29 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Storable</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Storable</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#MEMORY STORE">MEMORY STORE</a><br/>
<a href="#ADVISORY LOCKING">ADVISORY LOCKING</a><br/>
<a href="#SPEED">SPEED</a><br/>
<a href="#CANONICAL REPRESENTATION">CANONICAL REPRESENTATION</a><br/>
<a href="#CODE REFERENCES">CODE REFERENCES</a><br/>
<a href="#FORWARD COMPATIBILITY">FORWARD COMPATIBILITY</a><br/>
<a href="#ERROR REPORTING">ERROR REPORTING</a><br/>
<a href="#WIZARDS ONLY">WIZARDS ONLY</a><br/>
<a href="#Hooks">Hooks</a><br/>
<a href="#Predicates">Predicates</a><br/>
<a href="#Recursion">Recursion</a><br/>
<a href="#Deep Cloning">Deep Cloning</a><br/>
<a href="#Storable magic">Storable magic</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SECURITY WARNING">SECURITY WARNING</a><br/>
<a href="#WARNING">WARNING</a><br/>
<a href="#REGULAR EXPRESSIONS">REGULAR EXPRESSIONS</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#64 bit data in perl 5.6.0 and 5.6.1">64 bit data in perl 5.6.0 and 5.6.1</a><br/>
<a href="#CREDITS">CREDITS</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Storable −
persistence for Perl data structures</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use Storable;
<br/>
store \%table, 'file'; <br/>
$hashref = retrieve('file'); <br/>
use Storable qw(nstore store_fd nstore_fd freeze thaw
dclone); <br/>
# Network order <br/>
nstore \%table, 'file'; <br/>
$hashref = retrieve('file'); # There is NO nretrieve() <br/>
# Storing to and retrieving from an already opened file <br/>
store_fd \@array, \*STDOUT; <br/>
nstore_fd \%table, \*STDOUT; <br/>
$aryref = fd_retrieve(\*SOCKET); <br/>
$hashref = fd_retrieve(\*SOCKET); <br/>
# Serializing to memory <br/>
$serialized = freeze \%table; <br/>
%table_clone = %{ thaw($serialized) }; <br/>
# Deep (recursive) cloning <br/>
$cloneref = dclone($ref); <br/>
# Advisory locking <br/>
use Storable qw(lock_store lock_nstore lock_retrieve) <br/>
lock_store \%table, 'file'; <br/>
lock_nstore \%table, 'file'; <br/>
$hashref = lock_retrieve('file');</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The Storable
package brings persistence to your Perl data structures
containing SCALAR, ARRAY, HASH or REF objects, i.e. anything
that can be conveniently stored to disk and retrieved at a
later time.</p>
<p style="margin-left:9%; margin-top: 1em">It can be used
in the regular procedural way by calling "store"
with a reference to the object to be stored, along with the
file name where the image should be written.</p>
<p style="margin-left:9%; margin-top: 1em">The routine
returns "undef" for I/O problems or other internal
error, a true value otherwise. Serious errors are propagated
as a "die" exception.</p>
<p style="margin-left:9%; margin-top: 1em">To retrieve data
stored to disk, use "retrieve" with a file name.
The objects stored into that file are recreated into memory
for you, and a <i>reference</i> to the root object is
returned. In case an I/O error occurs while reading,
"undef" is returned instead. Other serious errors
are propagated via "die".</p>
<p style="margin-left:9%; margin-top: 1em">Since storage is
performed recursively, you might want to stuff references to
objects that share a lot of common data into a single array
or hash table, and then store that object. That way, when
you retrieve back the whole thing, the objects will continue
to share what they originally shared.</p>
<p style="margin-left:9%; margin-top: 1em">At the cost of a
slight header overhead, you may store to an already opened
file descriptor using the "store_fd" routine, and
retrieve from a file via "fd_retrieve". Those
names aren't imported by default, so you will have to do
that explicitly if you need those routines. The file
descriptor you supply must be already opened, for read if
you're going to retrieve and for write if you wish to
store.</p>
<p style="margin-left:9%; margin-top: 1em">store_fd(\%table,
*STDOUT) || die "can't store to stdout\n"; <br/>
$hashref = fd_retrieve(*STDIN);</p>
<p style="margin-left:9%; margin-top: 1em">You can also
store data in network order to allow easy sharing across
multiple platforms, or when storing on a socket known to be
remotely connected. The routines to call have an initial
"n" prefix for <i>network</i>, as in
"nstore" and "nstore_fd". At retrieval
time, your data will be correctly restored so you don't have
to know whether you're restoring from native or network
ordered data. Double values are stored stringified to ensure
portability as well, at the slight risk of loosing some
precision in the last decimals.</p>
<p style="margin-left:9%; margin-top: 1em">When using
"fd_retrieve", objects are retrieved in sequence,
one object (i.e. one recursive tree) per associated
"store_fd".</p>
<p style="margin-left:9%; margin-top: 1em">If you're more
from the object−oriented camp, you can inherit from
Storable and directly store your objects by invoking
"store" as a method. The fact that the root of the
to−be−stored tree is a blessed reference (i.e.
an object) is special−cased so that the retrieve does
not provide a reference to that object but rather the
blessed object reference itself. (Otherwise, you'd get a
reference to that blessed object).</p>
<h2>MEMORY STORE
<a name="MEMORY STORE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The Storable
engine can also store data into a Perl scalar instead, to
later retrieve them. This is mainly used to freeze a complex
structure in some safe compact memory place (where it can
possibly be sent to another process via some IPC, since
freezing the structure also serializes it in effect). Later
on, and maybe somewhere else, you can thaw the Perl scalar
out and recreate the original complex structure in
memory.</p>
<p style="margin-left:9%; margin-top: 1em">Surprisingly,
the routines to be called are named "freeze" and
"thaw". If you wish to send out the frozen scalar
to another machine, use "nfreeze" instead to get a
portable image.</p>
<p style="margin-left:9%; margin-top: 1em">Note that
freezing an object structure and immediately thawing it
actually achieves a deep cloning of that structure:</p>
<p style="margin-left:9%; margin-top: 1em">dclone(.) =
thaw(freeze(.))</p>
<p style="margin-left:9%; margin-top: 1em">Storable
provides you with a "dclone" interface which does
not create that intermediary scalar but instead freezes the
structure in some internal memory space and then immediately
thaws it out.</p>
<h2>ADVISORY LOCKING
<a name="ADVISORY LOCKING"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
"lock_store" and "lock_nstore" routine
are equivalent to "store" and "nstore",
except that they get an exclusive lock on the file before
writing. Likewise, "lock_retrieve" does the same
as "retrieve", but also gets a shared lock on the
file before reading.</p>
<p style="margin-left:9%; margin-top: 1em">As with any
advisory locking scheme, the protection only works if you
systematically use "lock_store" and
"lock_retrieve". If one side of your application
uses "store" whilst the other uses
"lock_retrieve", you will get no protection at
all.</p>
<p style="margin-left:9%; margin-top: 1em">The internal
advisory locking is implemented using Perl's <b>flock()</b>
routine. If your system does not support any form of
<b>flock()</b>, or if you share your files across NFS, you
might wish to use other forms of locking by using modules
such as LockFile::Simple which lock a file using a
filesystem entry, instead of locking the file
descriptor.</p>
<h2>SPEED
<a name="SPEED"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The heart of
Storable is written in C for decent speed. Extra
low−level optimizations have been made when
manipulating perl internals, to sacrifice encapsulation for
the benefit of greater speed.</p>
<h2>CANONICAL REPRESENTATION
<a name="CANONICAL REPRESENTATION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Normally,
Storable stores elements of hashes in the order they are
stored internally by Perl, i.e. pseudo−randomly. If
you set $Storable::canonical to some "TRUE" value,
Storable will store hashes with the elements sorted by their
key. This allows you to compare data structures by comparing
their frozen representations (or even the compressed frozen
representations), which can be useful for creating lookup
tables for complicated queries.</p>
<p style="margin-left:9%; margin-top: 1em">Canonical order
does not imply network order; those are two orthogonal
settings.</p>
<h2>CODE REFERENCES
<a name="CODE REFERENCES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Since Storable
version 2.05, CODE references may be serialized with the
help of B::Deparse. To enable this feature, set
$Storable::Deparse to a true value. To enable
deserialization, $Storable::Eval should be set to a true
value. Be aware that deserialization is done through
"eval", which is dangerous if the Storable file
contains malicious data. You can set $Storable::Eval to a
subroutine reference which would be used instead of
"eval". See below for an example using a Safe
compartment for deserialization of CODE references.</p>
<p style="margin-left:9%; margin-top: 1em">If
$Storable::Deparse and/or $Storable::Eval are set to false
values, then the value of $Storable::forgive_me (see below)
is respected while serializing and deserializing.</p>
<h2>FORWARD COMPATIBILITY
<a name="FORWARD COMPATIBILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This release of
Storable can be used on a newer version of Perl to serialize
data which is not supported by earlier Perls. By default,
Storable will attempt to do the right thing, by croak()ing
if it encounters data that it cannot deserialize. However,
the defaults can be changed as follows: <br/>
utf8 data</p>
<p style="margin-left:14%;">Perl 5.6 added support for
Unicode characters with code points &gt; 255, and Perl 5.8
has full support for Unicode characters in hash keys. Perl
internally encodes strings with these characters using utf8,
and Storable serializes them as utf8. By default, if an
older version of Perl encounters a utf8 value it cannot
represent, it will croak(). To change this behaviour so that
Storable deserializes utf8 encoded values as the string of
bytes (effectively dropping the <i>is_utf8</i> flag) set
$Storable::drop_utf8 to some "TRUE" value. This is
a form of data loss, because with $drop_utf8 true, it
becomes impossible to tell whether the original data was the
Unicode string, or a series of bytes that happen to be valid
utf8.</p>
<p style="margin-left:9%;">restricted hashes</p>
<p style="margin-left:14%;">Perl 5.8 adds support for
restricted hashes, which have keys restricted to a given
set, and can have values locked to be read only. By default,
when Storable encounters a restricted hash on a perl that
doesn't support them, it will deserialize it as a normal
hash, silently discarding any placeholder keys and leaving
the keys and all values unlocked. To make Storable croak()
instead, set $Storable::downgrade_restricted to a
"FALSE" value. To restore the default set it back
to some "TRUE" value.</p>
<p style="margin-left:14%; margin-top: 1em">The cperl
PERL_PERTURB_KEYS_TOP hash strategy has a known problem with
restricted hashes.</p>
<p style="margin-left:9%;">huge objects</p>
<p style="margin-left:14%;">On 64bit systems some data
structures may exceed the 2G (i.e. I32_MAX) limit. On 32bit
systems also strings between I32 and U32 (2G−4G).
Since Storable 3.00 (not in perl5 core) we are able to store
and retrieve these objects, even if perl5 itself is not able
to handle them. These are strings longer then 4G, arrays
with more then 2G elements and hashes with more then 2G
elements. cperl forbids hashes with more than 2G elements,
but this fail in cperl then. perl5 itself at least until
5.26 allows it, but cannot iterate over them. Note that
creating those objects might cause out of memory exceptions
by the operating system before perl has a chance to
abort.</p>
<p style="margin-left:9%;">files from future versions of
Storable</p>
<p style="margin-left:14%;">Earlier versions of Storable
would immediately croak if they encountered a file with a
higher internal version number than the reading Storable
knew about. Internal version numbers are increased each time
new data types (such as restricted hashes) are added to the
vocabulary of the file format. This meant that a newer
Storable module had no way of writing a file readable by an
older Storable, even if the writer didn't store newer data
types.</p>
<p style="margin-left:14%; margin-top: 1em">This version of
Storable will defer croaking until it encounters a data type
in the file that it does not recognize. This means that it
will continue to read files generated by newer Storable
modules which are careful in what they write out, making it
easier to upgrade Storable modules in a mixed
environment.</p>
<p style="margin-left:14%; margin-top: 1em">The old
behaviour of immediate croaking can be re−instated by
setting $Storable::accept_future_minor to some
"FALSE" value.</p>
<p style="margin-left:9%; margin-top: 1em">All these
variables have no effect on a newer Perl which supports the
relevant feature.</p>
<h2>ERROR REPORTING
<a name="ERROR REPORTING"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Storable uses
the "exception" paradigm, in that it does not try
to workaround failures: if something bad happens, an
exception is generated from the caller's perspective (see
Carp and croak()). Use eval {} to trap those exceptions.</p>
<p style="margin-left:9%; margin-top: 1em">When Storable
croaks, it tries to report the error via the logcroak()
routine from the "Log::Agent" package, if it is
available.</p>
<p style="margin-left:9%; margin-top: 1em">Normal errors
are reported by having <b>store()</b> or <b>retrieve()</b>
return "undef". Such errors are usually I/O errors
(or truncated stream errors at retrieval).</p>
<p style="margin-left:9%; margin-top: 1em">When Storable
throws the "Max. recursion depth with nested structures
exceeded" error we are already out of stack space.
Unfortunately on some earlier perl versions cleaning up a
recursive data structure recurses into the free calls, which
will lead to stack overflows in the cleanup. This data
structure is not properly cleaned up then, it will only be
destroyed during global destruction.</p>
<h2>WIZARDS ONLY
<a name="WIZARDS ONLY"></a>
</h2>
<h3>Hooks
<a name="Hooks"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Any class may
define hooks that will be called during the serialization
and deserialization process on objects that are instances of
that class. Those hooks can redefine the way serialization
is performed (and therefore, how the symmetrical
deserialization should be conducted).</p>
<p style="margin-left:9%; margin-top: 1em">Since we said
earlier:</p>
<p style="margin-left:9%; margin-top: 1em">dclone(.) =
thaw(freeze(.))</p>
<p style="margin-left:9%; margin-top: 1em">everything we
say about hooks should also hold for deep cloning. However,
hooks get to know whether the operation is a mere
serialization, or a cloning.</p>
<p style="margin-left:9%; margin-top: 1em">Therefore, when
serializing hooks are involved,</p>
<p style="margin-left:9%; margin-top: 1em">dclone(.)
&lt;&gt; thaw(freeze(.))</p>
<p style="margin-left:9%; margin-top: 1em">Well, you could
keep them in sync, but there's no guarantee it will always
hold on classes somebody else wrote. Besides, there is
little to gain in doing so: a serializing hook could keep
only one attribute of an object, which is probably not what
should happen during a deep cloning of that same object.</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
hooking interface: <br/>
"STORABLE_freeze" <i>obj</i>, <i>cloning</i></p>
<p style="margin-left:14%;">The serializing hook, called on
the object during serialization. It can be inherited, or
defined in the class itself, like any other method.</p>
<p style="margin-left:14%; margin-top: 1em">Arguments:
<i>obj</i> is the object to serialize, <i>cloning</i> is a
flag indicating whether we're in a <b>dclone()</b> or a
regular serialization via <b>store()</b> or
<b>freeze()</b>.</p>
<p style="margin-left:14%; margin-top: 1em">Returned value:
A LIST "($serialized, $ref1, $ref2, ...)" where
$serialized is the serialized form to be used, and the
optional $ref1, $ref2, etc... are extra references that you
wish to let the Storable engine serialize.</p>
<p style="margin-left:14%; margin-top: 1em">At
deserialization time, you will be given back the same LIST,
but all the extra references will be pointing into the
deserialized structure.</p>
<p style="margin-left:14%; margin-top: 1em">The <b>first
time</b> the hook is hit in a serialization flow, you may
have it return an empty list. That will signal the Storable
engine to further discard that hook for this class and to
therefore revert to the default serialization of the
underlying Perl data. The hook will again be normally
processed in the next serialization.</p>
<p style="margin-left:14%; margin-top: 1em">Unless you know
better, serializing hook should always say:</p>
<p style="margin-left:14%; margin-top: 1em">sub
STORABLE_freeze { <br/>
my ($self, $cloning) = @_; <br/>
return if $cloning; # Regular default serialization <br/>
.... <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">in order to
keep reasonable <b>dclone()</b> semantics.</p>
<p style="margin-left:9%;">"STORABLE_thaw"
<i>obj</i>, <i>cloning</i>, <i>serialized</i>, ...</p>
<p style="margin-left:14%;">The deserializing hook called
on the object during deserialization. But wait: if we're
deserializing, there's no object yet... right?</p>
<p style="margin-left:14%; margin-top: 1em">Wrong: the
Storable engine creates an empty one for you. If you know
Eiffel, you can view "STORABLE_thaw" as an
alternate creation routine.</p>
<p style="margin-left:14%; margin-top: 1em">This means the
hook can be inherited like any other method, and that
<i>obj</i> is your blessed reference for this particular
instance.</p>
<p style="margin-left:14%; margin-top: 1em">The other
arguments should look familiar if you know
"STORABLE_freeze": <i>cloning</i> is true when
we're part of a deep clone operation, <i>serialized</i> is
the serialized string you returned to the engine in
"STORABLE_freeze", and there may be an optional
list of references, in the same order you gave them at
serialization time, pointing to the deserialized objects
(which have been processed courtesy of the Storable
engine).</p>
<p style="margin-left:14%; margin-top: 1em">When the
Storable engine does not find any "STORABLE_thaw"
hook routine, it tries to load the class by requiring the
package dynamically (using the blessed package name), and
then re−attempts the lookup. If at that time the hook
cannot be located, the engine croaks. Note that this
mechanism will fail if you define several classes in the
same file, but perlmod warned you.</p>
<p style="margin-left:14%; margin-top: 1em">It is up to you
to use this information to populate <i>obj</i> the way you
want.</p>
<p style="margin-left:14%; margin-top: 1em">Returned value:
none.</p>
<p style="margin-left:9%;">"STORABLE_attach"
<i>class</i>, <i>cloning</i>, <i>serialized</i></p>
<p style="margin-left:14%;">While
"STORABLE_freeze" and "STORABLE_thaw"
are useful for classes where each instance is independent,
this mechanism has difficulty (or is incompatible) with
objects that exist as common process−level or
system−level resources, such as singleton objects,
database pools, caches or memoized objects.</p>
<p style="margin-left:14%; margin-top: 1em">The alternative
"STORABLE_attach" method provides a solution for
these shared objects. Instead of "STORABLE_freeze"
−−&gt; "STORABLE_thaw", you implement
"STORABLE_freeze" −−&gt;
"STORABLE_attach" instead.</p>
<p style="margin-left:14%; margin-top: 1em">Arguments:
<i>class</i> is the class we are attaching to,
<i>cloning</i> is a flag indicating whether we're in a
<b>dclone()</b> or a regular de−serialization via
<b>thaw()</b>, and <i>serialized</i> is the stored string
for the resource object.</p>
<p style="margin-left:14%; margin-top: 1em">Because these
resource objects are considered to be owned by the entire
process/system, and not the "property" of whatever
is being serialized, no references underneath the object
should be included in the serialized string. Thus, in any
class that implements "STORABLE_attach", the
"STORABLE_freeze" method cannot return any
references, and "Storable" will throw an error if
"STORABLE_freeze" tries to return references.</p>
<p style="margin-left:14%; margin-top: 1em">All information
required to "attach" back to the shared resource
object <b>must</b> be contained <b>only</b> in the
"STORABLE_freeze" return string. Otherwise,
"STORABLE_freeze" behaves as normal for
"STORABLE_attach" classes.</p>
<p style="margin-left:14%; margin-top: 1em">Because
"STORABLE_attach" is passed the class (rather than
an object), it also returns the object directly, rather than
modifying the passed object.</p>
<p style="margin-left:14%; margin-top: 1em">Returned value:
object of type "class"</p>
<h3>Predicates
<a name="Predicates"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Predicates are
not exportable. They must be called by explicitly prefixing
them with the Storable package name. <br/>
"Storable::last_op_in_netorder"</p>
<p style="margin-left:14%;">The
Storable::last_op_in_netorder() predicate will tell you
whether network order was used in the last store or retrieve
operation. If you don't know how to use this, just forget
about it.</p>
<p style="margin-left:9%;">"Storable::is_storing"</p>
<p style="margin-left:14%;">Returns true if within a store
operation (via STORABLE_freeze hook).</p>
<p style="margin-left:9%;">"Storable::is_retrieving"</p>
<p style="margin-left:14%;">Returns true if within a
retrieve operation (via STORABLE_thaw hook).</p>
<h3>Recursion
<a name="Recursion"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">With hooks comes
the ability to recurse back to the Storable engine. Indeed,
hooks are regular Perl code, and Storable is convenient when
it comes to serializing and deserializing things, so why not
use it to handle the serialization string?</p>
<p style="margin-left:9%; margin-top: 1em">There are a few
things you need to know, however:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>From Storable 3.05 to 3.13 we probed for the stack
recursion limit for references, arrays and hashes to a
maximal depth of ˜1200−35000, otherwise we might
fall into a stack−overflow. On JSON::XS this limit is
512 btw. With references not immediately referencing each
other there's no such limit yet, so you might fall into such
a stack−overflow segfault.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">This probing
and the checks we performed have some limitations:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="81%">
<p style="margin-top: 1em">the stack size at build time
might be different at run time, eg. the stack size may have
been modified with <b>ulimit</b>(1). If it's larger at run
time Storable may fail the <b>freeze()</b> or <b>thaw()</b>
unnecessarily. If it's larger at build time Storable may
segmentation fault when processing a deep structure at run
time.</p> </td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="81%">
<p>the stack size might be different in a thread.</p></td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="81%">
<p>array and hash recursion limits are checked separately
against the same recursion depth, a frozen structure with a
large sequence of nested arrays within many nested hashes
may exhaust the processor stack without triggering
Storable's recursion protection.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">So these now
have simple defaults rather than probing at
build−time.</p>
<p style="margin-left:14%; margin-top: 1em">You can control
the maximum array and hash recursion depths by modifying
$Storable::recursion_limit and
$Storable::recursion_limit_hash respectively. Either can be
set to −1 to prevent any depth checks, though this
isn't recommended.</p>
<p style="margin-left:14%; margin-top: 1em">If you want to
test what the limits are, the <i>stacksize</i> tool is
included in the "Storable" distribution.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">You can create endless loops if
the things you serialize via <b>freeze()</b> (for instance)
point back to the object we're trying to serialize in the
hook.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Shared references among objects will not stay shared: if
we're serializing the list of object [A, C] where both
object A and C refer to the SAME object B, and if there is a
serializing hook in A that says freeze(B), then when
deserializing, we'll get [A', C'] where A' refers to B', but
C' refers to D, a deep clone of B'. The topology was not
preserved.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>The maximal stack recursion limit for your system is
returned by stack_depth() and stack_depth_hash(). The hash
limit is usually half the size of the array and ref limit,
as the Perl hash API is not optimal.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">That's why
"STORABLE_freeze" lets you provide a list of
references to serialize. The engine guarantees that those
will be serialized in the same context as the other objects,
and therefore that shared objects will stay shared.</p>
<p style="margin-left:9%; margin-top: 1em">In the above [A,
C] example, the "STORABLE_freeze" hook could
return:</p>
<p style="margin-left:9%; margin-top: 1em">("something",
$self−&gt;{B})</p>
<p style="margin-left:9%; margin-top: 1em">and the B part
would be serialized by the engine. In
"STORABLE_thaw", you would get back the reference
to the B' object, deserialized for you.</p>
<p style="margin-left:9%; margin-top: 1em">Therefore,
recursion should normally be avoided, but is nonetheless
supported.</p>
<h3>Deep Cloning
<a name="Deep Cloning"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">There is a Clone
module available on CPAN which implements deep cloning
natively, i.e. without freezing to memory and thawing the
result. It is aimed to replace Storable's <b>dclone()</b>
some day. However, it does not currently support Storable
hooks to redefine the way deep cloning is performed.</p>
<h2>Storable magic
<a name="Storable magic"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Yes, there's a
lot of that :−) But more precisely, in UNIX systems
there's a utility called "file", which recognizes
data files based on their contents (usually their first few
bytes). For this to work, a certain file called <i>magic</i>
needs to taught about the <i>signature</i> of the data.
Where that configuration file lives depends on the UNIX
flavour; often it's something like
<i>/usr/share/misc/magic</i> or <i>/etc/magic</i>. Your
system administrator needs to do the updating of the
<i>magic</i> file. The necessary signature information is
output to STDOUT by invoking
<b>Storable::show_file_magic()</b>. Note that the GNU
implementation of the "file" utility, version 3.38
or later, is expected to contain support for recognising
Storable files out−of−the−box, in addition
to other kinds of Perl files.</p>
<p style="margin-left:9%; margin-top: 1em">You can also use
the following functions to extract the file header
information from Storable images: <br/>
$info = Storable::file_magic( $filename )</p>
<p style="margin-left:14%;">If the given file is a Storable
image return a hash describing it. If the file is readable,
but not a Storable image return "undef". If the
file does not exist or is unreadable then croak.</p>
<p style="margin-left:14%; margin-top: 1em">The hash
returned has the following elements: <br/>
"version"</p>
<p style="margin-left:19%;">This returns the file format
version. It is a string like "2.7".</p>
<p style="margin-left:19%; margin-top: 1em">Note that this
version number is not the same as the version number of the
Storable module itself. For instance Storable v0.7 create
files in format v2.0 and Storable v2.15 create files in
format v2.7. The file format version number only increment
when additional features that would confuse older versions
of the module are added.</p>
<p style="margin-left:19%; margin-top: 1em">Files older
than v2.0 will have the one of the version numbers
"−1", "0" or "1". No
minor number was used at that time.</p>
<p style="margin-left:14%;">"version_nv"</p>
<p style="margin-left:19%;">This returns the file format
version as number. It is a string like "2.007".
This value is suitable for numeric comparisons.</p>
<p style="margin-left:19%; margin-top: 1em">The constant
function "Storable::BIN_VERSION_NV" returns a
comparable number that represents the highest file version
number that this version of Storable fully supports (but see
discussion of $Storable::accept_future_minor above). The
constant "Storable::BIN_WRITE_VERSION_NV" function
returns what file version is written and might be less than
"Storable::BIN_VERSION_NV" in some
configurations.</p>
<p style="margin-left:14%;">"major",
"minor"</p>
<p style="margin-left:19%;">This also returns the file
format version. If the version is "2.7" then major
would be 2 and minor would be 7. The minor element is
missing for when major is less than 2.</p>
<p style="margin-left:14%;">"hdrsize"</p>
<p style="margin-left:19%;">The is the number of bytes that
the Storable header occupies.</p>
<p style="margin-left:14%;">"netorder"</p>
<p style="margin-left:19%;">This is TRUE if the image store
data in network order. This means that it was created with
<b>nstore()</b> or similar.</p>
<p style="margin-left:14%;">"byteorder"</p>
<p style="margin-left:19%;">This is only present when
"netorder" is FALSE. It is the $Config{byteorder}
string of the perl that created this image. It is a string
like "1234" (32 bit little endian) or
"87654321" (64 bit big endian). This must match
the current perl for the image to be readable by
Storable.</p>
<p style="margin-left:14%;">"intsize",
"longsize", "ptrsize",
"nvsize"</p>
<p style="margin-left:19%;">These are only present when
"netorder" is FALSE. These are the sizes of
various C datatypes of the perl that created this image.
These must match the current perl for the image to be
readable by Storable.</p>
<p style="margin-left:19%; margin-top: 1em">The
"nvsize" element is only present for file format
v2.2 and higher.</p>
<p style="margin-left:14%;">"file"</p>
<p style="margin-left:19%;">The name of the file.</p>
<p style="margin-left:9%;">$info = Storable::read_magic(
$buffer ) <br/>
$info = Storable::read_magic( $buffer, $must_be_file )</p>
<p style="margin-left:14%;">The $buffer should be a
Storable image or the first few bytes of it. If $buffer
starts with a Storable header, then a hash describing the
image is returned, otherwise "undef" is
returned.</p>
<p style="margin-left:14%; margin-top: 1em">The hash has
the same structure as the one returned by
<b>Storable::file_magic()</b>. The "file" element
is true if the image is a file image.</p>
<p style="margin-left:14%; margin-top: 1em">If the
$must_be_file argument is provided and is TRUE, then return
"undef" unless the image looks like it belongs to
a file dump.</p>
<p style="margin-left:14%; margin-top: 1em">The maximum
size of a Storable header is currently 21 bytes. If the
provided $buffer is only the first part of a Storable image
it should at least be this long to ensure that
<b>read_magic()</b> will recognize it as such.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Here are some
code samples showing a possible usage of Storable:</p>
<p style="margin-left:9%; margin-top: 1em">use Storable
qw(store retrieve freeze thaw dclone); <br/>
%color = ('Blue' =&gt; 0.1, 'Red' =&gt; 0.8, 'Black' =&gt;
0, 'White' =&gt; 1); <br/>
store(\%color, 'mycolors') or die "Can't store %a in
mycolors!\n"; <br/>
$colref = retrieve('mycolors'); <br/>
die "Unable to retrieve from mycolors!\n" unless
defined $colref; <br/>
printf "Blue is still %lf\n",
$colref−&gt;{'Blue'}; <br/>
$colref2 = dclone(\%color); <br/>
$str = freeze(\%color); <br/>
printf "Serialization of %%color is %d bytes
long.\n", length($str); <br/>
$colref3 = thaw($str);</p>
<p style="margin-left:9%; margin-top: 1em">which prints (on
my machine):</p>
<p style="margin-left:9%; margin-top: 1em">Blue is still
0.100000 <br/>
Serialization of %color is 102 bytes long.</p>
<p style="margin-left:9%; margin-top: 1em">Serialization of
CODE references and deserialization in a safe
compartment:</p>
<p style="margin-left:9%; margin-top: 1em">use Storable
qw(freeze thaw); <br/>
use Safe; <br/>
use strict; <br/>
my $safe = new Safe; <br/>
# because of opcodes used in "use strict": <br/>
$safe−&gt;permit(qw(:default require)); <br/>
local $Storable::Deparse = 1; <br/>
local $Storable::Eval = sub { $safe−&gt;reval($_[0])
}; <br/>
my $serialized = freeze(sub { 42 }); <br/>
my $code = thaw($serialized); <br/>
$code−&gt;() == 42;</p>
<h2>SECURITY WARNING
<a name="SECURITY WARNING"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>Do not accept
Storable documents from untrusted sources!</b> There is
<b>no</b> way to configure Storable so that it can be used
safely to process untrusted data. While there <i>are</i>
various options that can be used to mitigate specific
security issues these options do <i>not</i> comprise a
complete safety net for the user, and processing untrusted
data may result in segmentation faults, remote code
execution, or privilege escalation. The following lists some
known features which represent security issues that should
be considered by users of this module.</p>
<p style="margin-left:9%; margin-top: 1em">Most obviously,
the optional (off by default) CODE reference serialization
feature allows transfer of code to the deserializing
process. Furthermore, any serialized object will cause
Storable to helpfully load the module corresponding to the
class of the object in the deserializing module. For
manipulated module names, this can load almost arbitrary
code. Finally, the deserialized object's destructors will be
invoked when the objects get destroyed in the deserializing
process. Maliciously crafted Storable documents may put such
objects in the value of a hash key that is overridden by
another key/value pair in the same hash, thus causing
immediate destructor execution.</p>
<p style="margin-left:9%; margin-top: 1em">To disable
blessing objects while thawing/retrieving remove the flag
"BLESS_OK" = 2 from $Storable::flags or set the
2nd argument for thaw/retrieve to 0.</p>
<p style="margin-left:9%; margin-top: 1em">To disable
tieing data while thawing/retrieving remove the flag
"TIE_OK" = 4 from $Storable::flags or set the 2nd
argument for thaw/retrieve to 0.</p>
<p style="margin-left:9%; margin-top: 1em">With the default
setting of $Storable::flags = 6, creating or destroying
random objects, even renamed objects can be controlled by an
attacker. See CVE−2015−1592 and its metasploit
module.</p>
<p style="margin-left:9%; margin-top: 1em">If your
application requires accepting data from untrusted sources,
you are best off with a less powerful and more−likely
safe serialization format and implementation. If your data
is sufficiently simple, Cpanel::JSON::XS or
Data::MessagePack are fine alternatives. For more complex
data structures containing various Perl specific data types
like regular expressions or aliased data Sereal is the best
alternative and offers maximum interoperability. Note that
Sereal is unsafe by default, but you can configure the
encoder and decoder to mitigate any security issues.</p>
<h2>WARNING
<a name="WARNING"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">If you're using
references as keys within your hash tables, you're bound to
be disappointed when retrieving your data. Indeed, Perl
stringifies references used as hash table keys. If you later
wish to access the items via another reference
stringification (i.e. using the same reference that was used
for the key originally to record the value into the hash
table), it will work because both references stringify to
the same string.</p>
<p style="margin-left:9%; margin-top: 1em">It won't work
across a sequence of "store" and
"retrieve" operations, however, because the
addresses in the retrieved objects, which are part of the
stringified references, will probably differ from the
original addresses. The topology of your structure is
preserved, but not hidden semantics like those.</p>
<p style="margin-left:9%; margin-top: 1em">On platforms
where it matters, be sure to call binmode() on the
descriptors that you pass to Storable functions.</p>
<p style="margin-left:9%; margin-top: 1em">Storing data
canonically that contains large hashes can be significantly
slower than storing the same data normally, as temporary
arrays to hold the keys for each hash have to be allocated,
populated, sorted and freed. Some tests have shown a halving
of the speed of storing −− the exact penalty
will depend on the complexity of your data. There is no
slowdown on retrieval.</p>
<h2>REGULAR EXPRESSIONS
<a name="REGULAR EXPRESSIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Storable now has
experimental support for storing regular expressions, but
there are significant limitations:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>perl 5.8 or later is required.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>regular expressions with code blocks, ie "/(?{ ...
})/" or "/(??{ ... })/" will throw an
exception when thawed.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>regular expression syntax and flags have changed over
the history of perl, so a regular expression that you freeze
in one version of perl may fail to thaw or behave
differently in another version of perl.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>depending on the version of perl, regular expressions
can change in behaviour depending on the context, but later
perls will bake that behaviour into the regexp.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Storable will
throw an exception if a frozen regular expression cannot be
thawed.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">You can't store
GLOB, FORMLINE, etc.... If you can define semantics for
those operations, feel free to enhance Storable so that it
can deal with them.</p>
<p style="margin-left:9%; margin-top: 1em">The store
functions will "croak" if they run into such
references unless you set $Storable::forgive_me to some
"TRUE" value. In that case, the fatal message is
converted to a warning and some meaningless string is stored
instead.</p>
<p style="margin-left:9%; margin-top: 1em">Setting
$Storable::canonical may not yield frozen strings that
compare equal due to possible stringification of numbers.
When the string version of a scalar exists, it is the form
stored; therefore, if you happen to use your numbers as
strings between two freezing operations on the same data
structures, you will get different results.</p>
<p style="margin-left:9%; margin-top: 1em">When storing
doubles in network order, their value is stored as text.
However, you should also not expect non−numeric
floating−point values such as infinity and "not a
number" to pass successfully through a
<b>nstore()</b>/<b>retrieve()</b> pair.</p>
<p style="margin-left:9%; margin-top: 1em">As Storable
neither knows nor cares about character sets (although it
does know that characters may be more than eight bits wide),
any difference in the interpretation of character codes
between a host and a target system is your problem. In
particular, if host and target use different code points to
represent the characters used in the text representation of
floating−point numbers, you will not be able be able
to exchange floating−point data, even with
<b>nstore()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">"Storable::drop_utf8"
is a blunt tool. There is no facility either to return
<b>all</b> strings as utf8 sequences, or to attempt to
convert utf8 data back to 8 bit and croak() if the
conversion fails.</p>
<p style="margin-left:9%; margin-top: 1em">Prior to
Storable 2.01, no distinction was made between signed and
unsigned integers on storing. By default Storable prefers to
store a scalars string representation (if it has one) so
this would only cause problems when storing large unsigned
integers that had never been converted to string or floating
point. In other words values that had been generated by
integer operations such as logic ops and then not used in
any string or arithmetic context before storing.</p>
<h3>64 bit data in perl 5.6.0 and 5.6.1
<a name="64 bit data in perl 5.6.0 and 5.6.1"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This section
only applies to you if you have existing data written out by
Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or
Linux which has been configured with 64 bit integer support
(not the default) If you got a precompiled perl, rather than
running Configure to build your own perl from source, then
it almost certainly does not affect you, and you can stop
reading now (unless you're curious). If you're using perl on
Windows it does not affect you.</p>
<p style="margin-left:9%; margin-top: 1em">Storable writes
a file header which contains the sizes of various C language
types for the C compiler that built Storable (when not
writing in network order), and will refuse to load files
written by a Storable not on the same (or compatible)
architecture. This check and a check on machine byteorder is
needed because the size of various fields in the file are
given by the sizes of the C language types, and so files
written on different architectures are incompatible. This is
done for increased speed. (When writing in network order,
all fields are written out as standard lengths, which allows
full interworking, but takes longer to read and write)</p>
<p style="margin-left:9%; margin-top: 1em">Perl 5.6.x
introduced the ability to optional configure the perl
interpreter to use C's "long long" type to allow
scalars to store 64 bit integers on 32 bit systems. However,
due to the way the Perl configuration system generated the C
configuration files on non−Windows platforms, and the
way Storable generates its header, nothing in the Storable
file header reflected whether the perl writing was using 32
or 64 bit integers, despite the fact that Storable was
storing some data differently in the file. Hence Storable
running on perl with 64 bit integers will read the header
from a file written by a 32 bit perl, not realise that the
data is actually in a subtly incompatible format, and then
go horribly wrong (possibly crashing) if it encountered a
stored integer. This is a design failure.</p>
<p style="margin-left:9%; margin-top: 1em">Storable has now
been changed to write out and read in a file header with
information about the size of integers. It's impossible to
detect whether an old file being read in was written with 32
or 64 bit integers (they have the same header) so it's
impossible to automatically switch to a correct backwards
compatibility mode. Hence this Storable defaults to the new,
correct behaviour.</p>
<p style="margin-left:9%; margin-top: 1em">What this means
is that if you have data written by Storable 1.x running on
perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix
or Linux then by default this Storable will refuse to read
it, giving the error <i>Byte order is not compatible</i>. If
you have such data then you should set
$Storable::interwork_56_64bit to a true value to make this
Storable read and write files with the old header. You
should also migrate your data, or any older perl you are
communicating with, to this current version of Storable.</p>
<p style="margin-left:9%; margin-top: 1em">If you don't
have data written with specific configuration of perl
described above, then you do not and should not do anything.
Don't set the flag − not only will Storable on an
identically configured perl refuse to load them, but
Storable a differently configured perl will load them
believing them to be correct for it, and then may well fail
or crash part way through reading them.</p>
<h2>CREDITS
<a name="CREDITS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Thank you to (in
chronological order):</p>
<p style="margin-left:9%; margin-top: 1em">Jarkko
Hietaniemi &lt;jhi@iki.fi&gt; <br/>
Ulrich Pfeifer
&lt;pfeifer@charly.informatik.uni−dortmund.de&gt; <br/>
Benjamin A. Holzman &lt;bholzman@earthlink.net&gt; <br/>
Andrew Ford &lt;A.Ford@ford−mason.co.uk&gt; <br/>
Gisle Aas &lt;gisle@aas.no&gt; <br/>
Jeff Gresham &lt;gresham_jeffrey@jpmorgan.com&gt; <br/>
Murray Nesbitt &lt;murray@activestate.com&gt; <br/>
Marc Lehmann &lt;pcg@opengroup.org&gt; <br/>
Justin Banks &lt;justinb@wamnet.com&gt; <br/>
Jarkko Hietaniemi &lt;jhi@iki.fi&gt; (AGAIN, as perl 5.7.0
Pumpkin!) <br/>
Salvador Ortiz Garcia &lt;sog@msg.com.mx&gt; <br/>
Dominic Dunlop &lt;domo@computer.org&gt; <br/>
Erik Haugan &lt;erik@solbors.no&gt; <br/>
Benjamin A. Holzman &lt;ben.holzman@grantstreet.com&gt; <br/>
Reini Urban &lt;rurban@cpan.org&gt; <br/>
Todd Rinaldo &lt;toddr@cpanel.net&gt; <br/>
Aaron Crane &lt;arc@cpan.org&gt;</p>
<p style="margin-left:9%; margin-top: 1em">for their bug
reports, suggestions and contributions.</p>
<p style="margin-left:9%; margin-top: 1em">Benjamin Holzman
contributed the tied variable support, Andrew Ford
contributed the canonical order for hashes, and Gisle Aas
fixed a few misunderstandings of mine regarding the perl
internals, and optimized the emission of "tags" in
the output streams by simply counting the objects instead of
tagging them (leading to a binary incompatibility for the
Storable image starting at version 0.6−−older
images are, of course, still properly understood). Murray
Nesbitt made Storable thread−safe. Marc Lehmann added
overloading and references to tied items support. Benjamin
Holzman added a performance improvement for overloaded
classes; thanks to Grant Street Group for footing the bill.
Reini Urban took over maintenance from p5p, and added
security fixes and huge object support.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Storable was
written by Raphael Manfredi
<i>&lt;Raphael_Manfredi@pobox.com&gt;</i> Maintenance is now
done by cperl &lt;http://perl11.org/cperl&gt;</p>
<p style="margin-left:9%; margin-top: 1em">Please
e−mail us with problems, bug fixes, comments and
complaints, although if you have compliments you should send
them to Raphael. Please don't e−mail Raphael with
problems, as he no longer works on Storable, and your
message will be delayed while he forwards it to us.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Clone.</p>
<hr/>
</body>
</html>
