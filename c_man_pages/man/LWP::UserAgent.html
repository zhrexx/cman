<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:48:17 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>LWP::UserAgent</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">LWP::UserAgent</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#CONSTRUCTOR METHODS">CONSTRUCTOR METHODS</a><br/>
<a href="#clone">clone</a><br/>
<a href="#new">new</a><br/>
<a href="#ATTRIBUTES">ATTRIBUTES</a><br/>
<a href="#agent">agent</a><br/>
<a href="#conn_cache">conn_cache</a><br/>
<a href="#cookie_jar">cookie_jar</a><br/>
<a href="#credentials">credentials</a><br/>
<a href="#default_header">default_header</a><br/>
<a href="#default_headers">default_headers</a><br/>
<a href="#from">from</a><br/>
<a href="#local_address">local_address</a><br/>
<a href="#max_redirect">max_redirect</a><br/>
<a href="#max_size">max_size</a><br/>
<a href="#parse_head">parse_head</a><br/>
<a href="#protocols_allowed">protocols_allowed</a><br/>
<a href="#protocols_forbidden">protocols_forbidden</a><br/>
<a href="#requests_redirectable">requests_redirectable</a><br/>
<a href="#send_te">send_te</a><br/>
<a href="#show_progress">show_progress</a><br/>
<a href="#ssl_opts">ssl_opts</a><br/>
<a href="#timeout">timeout</a><br/>
<a href="#PROXY ATTRIBUTES">PROXY ATTRIBUTES</a><br/>
<a href="#env_proxy">env_proxy</a><br/>
<a href="#no_proxy">no_proxy</a><br/>
<a href="#proxy">proxy</a><br/>
<a href="#HANDLERS">HANDLERS</a><br/>
<a href="#add_handler">add_handler</a><br/>
<a href="#get_my_handler">get_my_handler</a><br/>
<a href="#handlers">handlers</a><br/>
<a href="#remove_handler">remove_handler</a><br/>
<a href="#set_my_handler">set_my_handler</a><br/>
<a href="#REQUEST METHODS">REQUEST METHODS</a><br/>
<a href="#delete">delete</a><br/>
<a href="#get">get</a><br/>
<a href="#head">head</a><br/>
<a href="#is_protocol_supported">is_protocol_supported</a><br/>
<a href="#is_online">is_online</a><br/>
<a href="#mirror">mirror</a><br/>
<a href="#patch">patch</a><br/>
<a href="#post">post</a><br/>
<a href="#put">put</a><br/>
<a href="#request">request</a><br/>
<a href="#simple_request">simple_request</a><br/>
<a href="#CALLBACK METHODS">CALLBACK METHODS</a><br/>
<a href="#get_basic_credentials">get_basic_credentials</a><br/>
<a href="#prepare_request">prepare_request</a><br/>
<a href="#progress">progress</a><br/>
<a href="#redirect_ok">redirect_ok</a><br/>
<a href="#BEST PRACTICES">BEST PRACTICES</a><br/>
<a href="#Handling Cookies">Handling Cookies</a><br/>
<a href="#Managing Protocols">Managing Protocols</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#COPYRIGHT AND LICENSE">COPYRIGHT AND LICENSE</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">LWP::UserAgent
− Web user agent class</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use LWP::UserAgent (); <br/>
my $ua = LWP::UserAgent−&gt;new(timeout =&gt; 10);
<br/>
$ua−&gt;env_proxy; <br/>
my $response = $ua−&gt;get('http://example.com'); <br/>
if ($response−&gt;is_success) { <br/>
print $response−&gt;decoded_content; <br/>
} <br/>
else { <br/>
die $response−&gt;status_line; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Extra layers of
security (note the "cookie_jar" and
"protocols_allowed"):</p>
<p style="margin-left:9%; margin-top: 1em">use strict; <br/>
use warnings; <br/>
use HTTP::CookieJar::LWP (); <br/>
use LWP::UserAgent (); <br/>
my $jar = HTTP::CookieJar::LWP−&gt;new; <br/>
my $ua = LWP::UserAgent−&gt;new( <br/>
cookie_jar =&gt; $jar, <br/>
protocols_allowed =&gt; ['http', 'https'], <br/>
timeout =&gt; 10, <br/>
); <br/>
$ua−&gt;env_proxy; <br/>
my $response = $ua−&gt;get('http://example.com'); <br/>
if ($response−&gt;is_success) { <br/>
print $response−&gt;decoded_content; <br/>
} <br/>
else { <br/>
die $response−&gt;status_line; <br/>
}</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
LWP::UserAgent is a class implementing a web user agent.
LWP::UserAgent objects can be used to dispatch web
requests.</p>
<p style="margin-left:9%; margin-top: 1em">In normal use
the application creates an LWP::UserAgent object, and then
configures it with values for timeouts, proxies, name, etc.
It then creates an instance of HTTP::Request for the request
that needs to be performed. This request is then passed to
one of the request method the UserAgent, which dispatches it
using the relevant protocol, and returns a HTTP::Response
object. There are convenience methods for sending the most
common request types: "get" in LWP::UserAgent,
"head" in LWP::UserAgent, "post" in
LWP::UserAgent, "put" in LWP::UserAgent and
"delete" in LWP::UserAgent. When using these
methods, the creation of the request object is hidden as
shown in the synopsis above.</p>
<p style="margin-left:9%; margin-top: 1em">The basic
approach of the library is to use HTTP−style
communication for all protocol schemes. This means that you
will construct HTTP::Request objects and receive
HTTP::Response objects even for non−HTTP resources
like <i>gopher</i> and <i>ftp</i>. In order to achieve even
more similarity to HTTP−style communications,
<i>gopher</i> menus and file directories are converted to
HTML documents.</p>
<h2>CONSTRUCTOR METHODS
<a name="CONSTRUCTOR METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
constructor methods are available:</p>
<h3>clone
<a name="clone"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $ua2 =
$ua−&gt;clone;</p>
<p style="margin-left:9%; margin-top: 1em">Returns a copy
of the LWP::UserAgent object.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CAVEAT</b>:
Please be aware that the clone method does not copy or clone
your "cookie_jar" attribute. Due to the limited
restrictions on what can be used for your cookie jar, there
is no way to clone the attribute. The "cookie_jar"
attribute will be "undef" in the new object
instance.</p>
<h3>new
<a name="new"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $ua =
LWP::UserAgent−&gt;new( %options )</p>
<p style="margin-left:9%; margin-top: 1em">This method
constructs a new LWP::UserAgent object and returns it.
Key/value pair arguments may be provided to set up the
initial state. The following options correspond to attribute
methods described below:</p>
<p style="margin-left:9%; margin-top: 1em">KEY DEFAULT <br/>

−−−−−−−−−−−
−−−−−−−−−−−−−−−−−−−−
<br/>
agent "libwww−perl/#.###" <br/>
conn_cache undef <br/>
cookie_jar undef <br/>
cookie_jar_class HTTP::Cookies <br/>
default_headers HTTP::Headers−&gt;new <br/>
from undef <br/>
local_address undef <br/>
max_redirect 7 <br/>
max_size undef <br/>
no_proxy [] <br/>
parse_head 1 <br/>
protocols_allowed undef <br/>
protocols_forbidden undef <br/>
proxy {} <br/>
requests_redirectable ['GET', 'HEAD'] <br/>
send_te 1 <br/>
show_progress undef <br/>
ssl_opts { verify_hostname =&gt; 1 } <br/>
timeout 180</p>
<p style="margin-left:9%; margin-top: 1em">The following
additional options are also accepted: If the
"env_proxy" option is passed in with a true value,
then proxy settings are read from environment variables (see
"env_proxy" in LWP::UserAgent). If
"env_proxy" isn't provided, the
"PERL_LWP_ENV_PROXY" environment variable controls
if "env_proxy" in LWP::UserAgent is called during
initialization. If the "keep_alive" option value
is defined and non−zero, then an
"LWP::ConnCache" is set up (see
"conn_cache" in LWP::UserAgent). The
"keep_alive" value is passed on as the
"total_capacity" for the connection cache.</p>
<p style="margin-left:9%; margin-top: 1em">"proxy"
must be set as an arrayref of key/value pairs.
"no_proxy" takes an arrayref of domains.</p>
<h2>ATTRIBUTES
<a name="ATTRIBUTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The settings of
the configuration attributes modify the behaviour of the
LWP::UserAgent when it dispatches requests. Most of these
can also be initialized by options passed to the constructor
method.</p>
<p style="margin-left:9%; margin-top: 1em">The following
attribute methods are provided. The attribute value is left
unchanged if no argument is given. The return value from
each method is the old attribute value.</p>
<h3>agent
<a name="agent"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $agent =
$ua−&gt;agent; <br/>
$ua−&gt;agent('Checkbot/0.4 '); # append the default
to the end <br/>
$ua−&gt;agent('Mozilla/5.0'); <br/>
$ua−&gt;agent(""); # don't identify</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
product token that is used to identify the user agent on the
network. The agent value is sent as the
"User−Agent" header in the requests.</p>
<p style="margin-left:9%; margin-top: 1em">The default is a
string of the form "libwww−perl/#.###",
where "#.###" is substituted with the version
number of this library.</p>
<p style="margin-left:9%; margin-top: 1em">If the provided
string ends with space, the default
"libwww−perl/#.###" string is appended to
it.</p>
<p style="margin-left:9%; margin-top: 1em">The user agent
string should be one or more simple product identifiers with
an optional version number separated by the "/"
character.</p>
<h3>conn_cache
<a name="conn_cache"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $cache_obj =
$ua−&gt;conn_cache; <br/>
$ua−&gt;conn_cache( $cache_obj );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
LWP::ConnCache object to use. See LWP::ConnCache for
details.</p>
<h3>cookie_jar
<a name="cookie_jar"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $jar =
$ua−&gt;cookie_jar; <br/>
$ua−&gt;cookie_jar( $cookie_jar_obj );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
cookie jar object to use. The only requirement is that the
cookie jar object must implement the
extract_cookies($response) and add_cookie_header($request)
methods. These methods will then be invoked by the user
agent as requests are sent and responses are received.
Normally this will be a HTTP::Cookies object or some
subclass. You are, however, encouraged to use
HTTP::CookieJar::LWP instead. See "BEST PRACTICES"
for more information.</p>
<p style="margin-left:9%; margin-top: 1em">use
HTTP::CookieJar::LWP (); <br/>
my $jar = HTTP::CookieJar::LWP−&gt;new; <br/>
my $ua = LWP::UserAgent−&gt;new( cookie_jar =&gt; $jar
); <br/>
# or after object creation <br/>
$ua−&gt;cookie_jar( $cookie_jar );</p>
<p style="margin-left:9%; margin-top: 1em">The default is
to have no cookie jar, i.e. never automatically add
"Cookie" headers to the requests.</p>
<p style="margin-left:9%; margin-top: 1em">If $jar contains
an unblessed hash reference, a new cookie jar object is
created for you automatically. The object is of the class
set with the "cookie_jar_class" constructor
argument, which defaults to HTTP::Cookies.</p>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;cookie_jar({
file =&gt; "$ENV{HOME}/.cookies.txt" });</p>
<p style="margin-left:9%; margin-top: 1em">is really just a
shortcut for:</p>
<p style="margin-left:9%; margin-top: 1em">require
HTTP::Cookies; <br/>
$ua−&gt;cookie_jar(HTTP::Cookies−&gt;new(file
=&gt; "$ENV{HOME}/.cookies.txt"));</p>
<p style="margin-left:9%; margin-top: 1em">As described
above and in "BEST PRACTICES", you should set
"cookie_jar_class" to
"HTTP::CookieJar::LWP" to get a safer cookie
jar.</p>
<p style="margin-left:9%; margin-top: 1em">my $ua =
LWP::UserAgent−&gt;new( cookie_jar_class =&gt;
'HTTP::CookieJar::LWP' ); <br/>
$ua−&gt;cookie_jar({}); # HTTP::CookieJar::LWP takes
no args</p>
<p style="margin-left:9%; margin-top: 1em">These can also
be combined into the constructor, so a jar is created at
instantiation.</p>
<p style="margin-left:9%; margin-top: 1em">my $ua =
LWP::UserAgent−&gt;new( <br/>
cookie_jar_class =&gt; 'HTTP::CookieJar::LWP', <br/>
cookie_jar =&gt; {}, <br/>
);</p>
<h3>credentials
<a name="credentials"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $creds =
$ua−&gt;credentials(); <br/>
$ua−&gt;credentials( $netloc, $realm ); <br/>
$ua−&gt;credentials( $netloc, $realm, $uname, $pass );
<br/>
$ua−&gt;credentials("www.example.com:80",
"Some Realm", "foo",
"secret");</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the user
name and password to be used for a realm.</p>
<p style="margin-left:9%; margin-top: 1em">The $netloc is a
string of the form "&lt;host&gt;:&lt;port&gt;".
The username and password will only be passed to this
server.</p>
<h3>default_header
<a name="default_header"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;default_header(
$field ); <br/>
$ua−&gt;default_header( $field =&gt; $value ); <br/>
$ua−&gt;default_header('Accept−Encoding' =&gt;
scalar HTTP::Message::decodable()); <br/>
$ua−&gt;default_header('Accept−Language' =&gt;
"no, en");</p>
<p style="margin-left:9%; margin-top: 1em">This is just a
shortcut for
"$ua−&gt;default_headers−&gt;header( $field
=&gt; $value )".</p>
<h3>default_headers
<a name="default_headers"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $headers =
$ua−&gt;default_headers; <br/>
$ua−&gt;default_headers( $headers_obj );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
headers object that will provide default header values for
any requests sent. By default this will be an empty
HTTP::Headers object.</p>
<h3>from
<a name="from"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $from =
$ua−&gt;from; <br/>
$ua−&gt;from('foo@bar.com');</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
email address for the human user who controls the requesting
user agent. The address should be machine−usable, as
defined in RFC2822
&lt;https://tools.ietf.org/html/rfc2822&gt;. The
"from" value is sent as the "From"
header in the requests.</p>
<p style="margin-left:9%; margin-top: 1em">The default is
to not send a "From" header. See
"default_headers" in LWP::UserAgent for the more
general interface that allow any header to be defaulted.</p>
<h3>local_address
<a name="local_address"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $address =
$ua−&gt;local_address; <br/>
$ua−&gt;local_address( $address );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
local interface to bind to for network connections. The
interface can be specified as a hostname or an IP address.
This value is passed as the "LocalAddr" argument
to IO::Socket::INET.</p>
<h3>max_redirect
<a name="max_redirect"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $max =
$ua−&gt;max_redirect; <br/>
$ua−&gt;max_redirect( $n );</p>
<p style="margin-left:9%; margin-top: 1em">This reads or
sets the object's limit of how many times it will obey
redirection responses in a given request cycle.</p>
<p style="margin-left:9%; margin-top: 1em">By default, the
value is 7. This means that if you call "request"
in LWP::UserAgent and the response is a redirect elsewhere
which is in turn a redirect, and so on seven times, then LWP
gives up after that seventh request.</p>
<h3>max_size
<a name="max_size"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $size =
$ua−&gt;max_size; <br/>
$ua−&gt;max_size( $bytes );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the size
limit for response content. The default is
"undef", which means that there is no limit. If
the returned response content is only partial, because the
size limit was exceeded, then a
"Client−Aborted" header will be added to the
response. The content might end up longer than
"max_size" as we abort once appending a chunk of
data makes the length exceed the limit. The
"Content−Length" header, if present, will
indicate the length of the full content and will normally
not be the same as length($res−&gt;content).</p>
<h3>parse_head
<a name="parse_head"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $bool =
$ua−&gt;parse_head; <br/>
$ua−&gt;parse_head( $boolean );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set a value
indicating whether we should initialize response headers
from the &lt;head&gt; section of HTML documents. The default
is true. <i>Do not turn this off</i> unless you know what
you are doing.</p>
<h3>protocols_allowed
<a name="protocols_allowed"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $aref =
$ua−&gt;protocols_allowed; # get allowed protocols
<br/>
$ua−&gt;protocols_allowed( \@protocols ); # allow ONLY
these <br/>
$ua−&gt;protocols_allowed(undef); # delete the list
<br/>
$ua−&gt;protocols_allowed(['http',]); # ONLY allow
http</p>
<p style="margin-left:9%; margin-top: 1em">By default, an
object has neither a "protocols_allowed" list, nor
a "protocols_forbidden" in LWP::UserAgent
list.</p>
<p style="margin-left:9%; margin-top: 1em">This reads (or
sets) this user agent's list of protocols that the request
methods will exclusively allow. The protocol names are case
insensitive.</p>
<p style="margin-left:9%; margin-top: 1em">For example:
"$ua−&gt;protocols_allowed( [ 'http', 'https']
);" means that this user agent will <i>allow only</i>
those protocols, and attempts to use this user agent to
access URLs with any other schemes (like
"ftp://...") will result in a 500 error.</p>
<p style="margin-left:9%; margin-top: 1em">Note that having
a "protocols_allowed" list causes any
"protocols_forbidden" in LWP::UserAgent list to be
ignored.</p>
<h3>protocols_forbidden
<a name="protocols_forbidden"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $aref =
$ua−&gt;protocols_forbidden; # get the forbidden list
<br/>
$ua−&gt;protocols_forbidden(\@protocols); # do not
allow these <br/>
$ua−&gt;protocols_forbidden(['http',]); # All http
reqs get a 500 <br/>
$ua−&gt;protocols_forbidden(undef); # delete the
list</p>
<p style="margin-left:9%; margin-top: 1em">This reads (or
sets) this user agent's list of protocols that the request
method will <i>not</i> allow. The protocol names are case
insensitive.</p>
<p style="margin-left:9%; margin-top: 1em">For example:
"$ua−&gt;protocols_forbidden( [ 'file', 'mailto']
);" means that this user agent will <i>not</i> allow
those protocols, and attempts to use this user agent to
access URLs with those schemes will result in a 500
error.</p>
<h3>requests_redirectable
<a name="requests_redirectable"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $aref =
$ua−&gt;requests_redirectable; <br/>
$ua−&gt;requests_redirectable( \@requests ); <br/>
$ua−&gt;requests_redirectable(['GET', 'HEAD',]); # the
default</p>
<p style="margin-left:9%; margin-top: 1em">This reads or
sets the object's list of request names that
"redirect_ok" in LWP::UserAgent will allow
redirection for. By default, this is "['GET',
'HEAD']", as per RFC 2616
&lt;https://tools.ietf.org/html/rfc2616&gt;. To change to
include "POST", consider:</p>
<p style="margin-left:9%; margin-top: 1em">push @{
$ua−&gt;requests_redirectable }, 'POST';</p>
<h3>send_te
<a name="send_te"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $bool =
$ua−&gt;send_te; <br/>
$ua−&gt;send_te( $boolean );</p>
<p style="margin-left:9%; margin-top: 1em">If true, will
send a "TE" header along with the request. The
default is true. Set it to false to disable the
"TE" header for systems who can't handle it.</p>
<h3>show_progress
<a name="show_progress"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $bool =
$ua−&gt;show_progress; <br/>
$ua−&gt;show_progress( $boolean );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set a value
indicating whether a progress bar should be displayed on the
terminal as requests are processed. The default is
false.</p>
<h3>ssl_opts
<a name="ssl_opts"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my @keys =
$ua−&gt;ssl_opts; <br/>
my $val = $ua−&gt;ssl_opts( $key ); <br/>
$ua−&gt;ssl_opts( $key =&gt; $value );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
options for SSL connections. Without argument return the
list of options keys currently set. With a single argument
return the current value for the given option. With 2
arguments set the option value and return the old. Setting
an option to the value "undef" removes this
option.</p>
<p style="margin-left:9%; margin-top: 1em">The options that
LWP relates to are: <br/>
"verify_hostname" =&gt; $bool</p>
<p style="margin-left:14%;">When TRUE LWP will for secure
protocol schemes ensure it connects to servers that have a
valid certificate matching the expected hostname. If FALSE
no checks are made and you can't be sure that you
communicate with the expected peer. The no checks behaviour
was the default for libwww−perl−5.837 and
earlier releases.</p>
<p style="margin-left:14%; margin-top: 1em">This option is
initialized from the
"PERL_LWP_SSL_VERIFY_HOSTNAME" environment
variable. If this environment variable isn't set; then
"verify_hostname" defaults to 1.</p>
<p style="margin-left:14%; margin-top: 1em">Please note
that that recently the overall effect of this option with
regards to SSL handling has changed. As of version 6.11 of
LWP::Protocol::https, which is an external module, SSL
certificate verification was harmonized to behave in sync
with IO::Socket::SSL. With this change, setting this option
no longer disables all SSL certificate verification, only
the hostname checks. To disable all verification, use the
"SSL_verify_mode" option in the
"ssl_opts" attribute. For example:
"$ua−"ssl_opts(SSL_verify_mode =&gt;
IO::Socket::SSL::SSL_VERIFY_NONE);&gt;</p>
<p style="margin-left:9%;">"SSL_ca_file" =&gt;
$path</p>
<p style="margin-left:14%;">The path to a file containing
Certificate Authority certificates. A default setting for
this option is provided by checking the environment
variables "PERL_LWP_SSL_CA_FILE" and
"HTTPS_CA_FILE" in order.</p>
<p style="margin-left:9%;">"SSL_ca_path" =&gt;
$path</p>
<p style="margin-left:14%;">The path to a directory
containing files containing Certificate Authority
certificates. A default setting for this option is provided
by checking the environment variables
"PERL_LWP_SSL_CA_PATH" and
"HTTPS_CA_DIR" in order.</p>
<p style="margin-left:9%; margin-top: 1em">Other options
can be set and are processed directly by the SSL Socket
implementation in use. See IO::Socket::SSL or Net::SSL for
details.</p>
<p style="margin-left:9%; margin-top: 1em">The
libwww−perl core no longer bundles protocol plugins
for SSL. You will need to install LWP::Protocol::https
separately to enable support for processing
https−URLs.</p>
<h3>timeout
<a name="timeout"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $secs =
$ua−&gt;timeout; <br/>
$ua−&gt;timeout( $secs );</p>
<p style="margin-left:9%; margin-top: 1em">Get/set the
timeout value in seconds. The default value is 180 seconds,
i.e. 3 minutes.</p>
<p style="margin-left:9%; margin-top: 1em">The request is
aborted if no activity on the connection to the server is
observed for "timeout" seconds. This means that
the time it takes for the complete transaction and the
"request" in LWP::UserAgent method to actually
return might be longer.</p>
<p style="margin-left:9%; margin-top: 1em">When a request
times out, a response object is still returned. The response
will have a standard HTTP Status Code (500). This response
will have the "Client−Warning" header set to
the value of "Internal response". See the
"get" in LWP::UserAgent method description below
for further details.</p>
<h2>PROXY ATTRIBUTES
<a name="PROXY ATTRIBUTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
methods set up when requests should be passed via a proxy
server.</p>
<h3>env_proxy
<a name="env_proxy"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;env_proxy;</p>
<p style="margin-left:9%; margin-top: 1em">Load proxy
settings from *_proxy environment variables. You might
specify proxies like this (sh−syntax):</p>
<p style="margin-left:9%; margin-top: 1em">gopher_proxy=http://proxy.my.place/
<br/>
wais_proxy=http://proxy.my.place/ <br/>
no_proxy="localhost,example.com" <br/>
export gopher_proxy wais_proxy no_proxy</p>
<p style="margin-left:9%; margin-top: 1em">csh or tcsh
users should use the "setenv" command to define
these environment variables.</p>
<p style="margin-left:9%; margin-top: 1em">On systems with
case insensitive environment variables there exists a name
clash between the CGI environment variables and the
"HTTP_PROXY" environment variable normally picked
up by "env_proxy". Because of this
"HTTP_PROXY" is not honored for CGI scripts. The
"CGI_HTTP_PROXY" environment variable can be used
instead.</p>
<h3>no_proxy
<a name="no_proxy"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;no_proxy(
@domains ); <br/>
$ua−&gt;no_proxy('localhost', 'example.com'); <br/>
$ua−&gt;no_proxy(); # clear the list</p>
<p style="margin-left:9%; margin-top: 1em">Do not proxy
requests to the given domains, including subdomains. Calling
"no_proxy" without any domains clears the list of
domains.</p>
<h3>proxy
<a name="proxy"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;proxy(\@schemes,
$proxy_url) <br/>
$ua−&gt;proxy(['http', 'ftp'],
'http://proxy.sn.no:8001/'); <br/>
# For a single scheme: <br/>
$ua−&gt;proxy($scheme, $proxy_url) <br/>
$ua−&gt;proxy('gopher', 'http://proxy.sn.no:8001/');
<br/>
# To set multiple proxies at once: <br/>
$ua−&gt;proxy([ <br/>
ftp =&gt; 'http://ftp.example.com:8001/', <br/>
[ 'http', 'https' ] =&gt; 'http://http.example.com:8001/',
<br/>
]);</p>
<p style="margin-left:9%; margin-top: 1em">Set/retrieve
proxy URL for a scheme.</p>
<p style="margin-left:9%; margin-top: 1em">The first form
specifies that the URL is to be used as a proxy for access
methods listed in the list in the first method argument,
i.e. "http" and "ftp".</p>
<p style="margin-left:9%; margin-top: 1em">The second form
shows a shorthand form for specifying proxy URL for a single
access scheme.</p>
<p style="margin-left:9%; margin-top: 1em">The third form
demonstrates setting multiple proxies at once. This is also
the only form accepted by the constructor.</p>
<h2>HANDLERS
<a name="HANDLERS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Handlers are
code that injected at various phases during the processing
of requests. The following methods are provided to manage
the active handlers:</p>
<h3>add_handler
<a name="add_handler"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;add_handler(
$phase =&gt; \&amp;cb, %matchspec )</p>
<p style="margin-left:9%; margin-top: 1em">Add handler to
be invoked in the given processing phase. For how to specify
%matchspec see "Matching" in HTTP::Config.</p>
<p style="margin-left:9%; margin-top: 1em">The possible
values $phase and the corresponding callback signatures are
as follows. Note that the handlers are documented in the
order in which they will be run, which is:</p>
<p style="margin-left:9%; margin-top: 1em">request_preprepare
<br/>
request_prepare <br/>
request_send <br/>
response_header <br/>
response_data <br/>
response_done <br/>
response_redirect <br/>
request_preprepare =&gt; sub { my($request, $ua, $handler) =
@_; ... }</p>
<p style="margin-left:14%;">The handler is called before
the "request_prepare" and other standard
initialization of the request. This can be used to set up
headers and attributes that the "request_prepare"
handler depends on. Proxy initialization should take place
here; but in general don't register handlers for this
phase.</p>
<p style="margin-left:9%;">request_prepare =&gt; sub {
my($request, $ua, $handler) = @_; ... }</p>
<p style="margin-left:14%;">The handler is called before
the request is sent and can modify the request any way it
see fit. This can for instance be used to add certain
headers to specific requests.</p>
<p style="margin-left:14%; margin-top: 1em">The method can
assign a new request object to $_[0] to replace the request
that is sent fully.</p>
<p style="margin-left:14%; margin-top: 1em">The return
value from the callback is ignored. If an exception is
raised it will abort the request and make the request method
return a "400 Bad request" response.</p>
<p style="margin-left:9%;">request_send =&gt; sub {
my($request, $ua, $handler) = @_; ... }</p>
<p style="margin-left:14%;">This handler gets a chance of
handling requests before they're sent to the protocol
handlers. It should return an HTTP::Response object if it
wishes to terminate the processing; otherwise it should
return nothing.</p>
<p style="margin-left:14%; margin-top: 1em">The
"response_header" and "response_data"
handlers will not be invoked for this response, but the
"response_done" will be.</p>
<p style="margin-left:9%;">response_header =&gt; sub {
my($response, $ua, $handler) = @_; ... }</p>
<p style="margin-left:14%;">This handler is called right
after the response headers have been received, but before
any content data. The handler might set up handlers for data
and might croak to abort the request.</p>
<p style="margin-left:14%; margin-top: 1em">The handler
might set the
"$response−&gt;{default_add_content}" value
to control if any received data should be added to the
response object directly. This will initially be false if
the "$ua−&gt;request()" method was called
with a $content_file or "$content_cb argument";
otherwise true.</p>
<p style="margin-left:9%;">response_data =&gt; sub {
my($response, $ua, $handler, $data) = @_; ... }</p>
<p style="margin-left:14%;">This handler is called for each
chunk of data received for the response. The handler might
croak to abort the request.</p>
<p style="margin-left:14%; margin-top: 1em">This handler
needs to return a TRUE value to be called again for
subsequent chunks for the same request.</p>
<p style="margin-left:9%;">response_done =&gt; sub {
my($response, $ua, $handler) = @_; ... }</p>
<p style="margin-left:14%;">The handler is called after the
response has been fully received, but before any redirect
handling is attempted. The handler can be used to extract
information or modify the response.</p>
<p style="margin-left:9%;">response_redirect =&gt; sub {
my($response, $ua, $handler) = @_; ... }</p>
<p style="margin-left:14%;">The handler is called in
"$ua−&gt;request" after
"response_done". If the handler returns an
HTTP::Request object we'll start over with processing this
request instead.</p>
<p style="margin-left:9%; margin-top: 1em">For all of
these, $handler is a code reference to the handler that is
currently being run.</p>
<h3>get_my_handler
<a name="get_my_handler"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;get_my_handler(
$phase, %matchspec ); <br/>
$ua−&gt;get_my_handler( $phase, %matchspec, $init
);</p>
<p style="margin-left:9%; margin-top: 1em">Will retrieve
the matching handler as hash ref.</p>
<p style="margin-left:9%; margin-top: 1em">If $init is
passed as a true value, create and add the handler if it's
not found. If $init is a subroutine reference, then it's
called with the created handler hash as argument. This sub
might populate the hash with extra fields; especially the
callback. If $init is a hash reference, merge the
hashes.</p>
<h3>handlers
<a name="handlers"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;handlers(
$phase, $request ) <br/>
$ua−&gt;handlers( $phase, $response )</p>
<p style="margin-left:9%; margin-top: 1em">Returns the
handlers that apply to the given request or response at the
given processing phase.</p>
<h3>remove_handler
<a name="remove_handler"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;remove_handler(
undef, %matchspec ); <br/>
$ua−&gt;remove_handler( $phase, %matchspec ); <br/>
$ua−&gt;remove_handler(); # REMOVE ALL HANDLERS IN ALL
PHASES</p>
<p style="margin-left:9%; margin-top: 1em">Remove handlers
that match the given %matchspec. If $phase is not provided,
remove handlers from all phases.</p>
<p style="margin-left:9%; margin-top: 1em">Be careful as
calling this function with %matchspec that is not specific
enough can remove handlers not owned by you. It's probably
better to use the "set_my_handler" in
LWP::UserAgent method instead.</p>
<p style="margin-left:9%; margin-top: 1em">The removed
handlers are returned.</p>
<h3>set_my_handler
<a name="set_my_handler"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$ua−&gt;set_my_handler(
$phase, $cb, %matchspec ); <br/>
$ua−&gt;set_my_handler($phase, undef); # remove
handler for phase</p>
<p style="margin-left:9%; margin-top: 1em">Set handlers
private to the executing subroutine. Works by defaulting an
"owner" field to the %matchspec that holds the
name of the called subroutine. You might pass an explicit
"owner" to override this.</p>
<p style="margin-left:9%; margin-top: 1em">If $cb is passed
as "undef", remove the handler.</p>
<h2>REQUEST METHODS
<a name="REQUEST METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The methods
described in this section are used to dispatch requests via
the user agent. The following request methods are
provided:</p>
<h3>delete
<a name="delete"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $res =
$ua−&gt;delete( $url ); <br/>
my $res = $ua−&gt;delete( $url, $field_name =&gt;
$value, ... );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch a "DELETE" request on the given URL.
Additional headers and content options are the same as for
the "get" in LWP::UserAgent method.</p>
<p style="margin-left:9%; margin-top: 1em">This method will
use the DELETE() function from HTTP::Request::Common to
build the request. See HTTP::Request::Common for a details
on how to pass form content and other advanced features.</p>
<h3>get
<a name="get"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $res =
$ua−&gt;get( $url ); <br/>
my $res = $ua−&gt;get( $url , $field_name =&gt;
$value, ... );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch a "GET" request on the given URL. Further
arguments can be given to initialize the headers of the
request. These are given as separate name/value pairs. The
return value is a response object. See HTTP::Response for a
description of the interface it provides.</p>
<p style="margin-left:9%; margin-top: 1em">There will still
be a response object returned when LWP can't connect to the
server specified in the URL or when other failures in
protocol handlers occur. These internal responses use the
standard HTTP status codes, so the responses can't be
differentiated by testing the response status code alone.
Error responses that LWP generates internally will have the
"Client−Warning" header set to the value
"Internal response". If you need to differentiate
these internal responses from responses that a remote server
actually generates, you need to test this header value.</p>
<p style="margin-left:9%; margin-top: 1em">Fields names
that start with ":" are special. These will not
initialize headers of the request but will determine how the
response content is treated. The following special field
names are recognized:</p>
<p style="margin-left:9%; margin-top: 1em">':content_file'
=&gt; $filename # or $filehandle <br/>
':content_cb' =&gt; \&amp;callback <br/>
':read_size_hint' =&gt; $bytes</p>
<p style="margin-left:9%; margin-top: 1em">If a $filename
or $filehandle is provided with the
":content_file" option, then the response content
will be saved here instead of in the response object. The
$filehandle may also be an object with an open file
descriptor, such as a File::Temp object. If a callback is
provided with the ":content_cb" option then this
function will be called for each chunk of the response
content as it is received from the server. If neither of
these options are given, then the response content will
accumulate in the response object itself. This might not be
suitable for very large response bodies. Only one of
":content_file" or ":content_cb" can be
specified. The content of unsuccessful responses will always
accumulate in the response object itself, regardless of the
":content_file" or ":content_cb" options
passed in. Note that errors writing to the content file (for
example due to permission denied or the filesystem being
full) will be reported via the
"Client−Aborted" or "X−Died"
response headers, and not the "is_success"
method.</p>
<p style="margin-left:9%; margin-top: 1em">The
":read_size_hint" option is passed to the protocol
module which will try to read data from the server in chunks
of this size. A smaller value for the
":read_size_hint" will result in a higher number
of callback invocations.</p>
<p style="margin-left:9%; margin-top: 1em">The callback
function is called with 3 arguments: a chunk of data, a
reference to the response object, and a reference to the
protocol object. The callback can abort the request by
invoking die(). The exception message will show up as the
"X−Died" header field in the response
returned by the "$ua−&gt;get()" method.</p>
<h3>head
<a name="head"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $res =
$ua−&gt;head( $url ); <br/>
my $res = $ua−&gt;head( $url , $field_name =&gt;
$value, ... );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch a "HEAD" request on the given URL.
Otherwise it works like the "get" in
LWP::UserAgent method described above.</p>
<h3>is_protocol_supported
<a name="is_protocol_supported"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $bool =
$ua−&gt;is_protocol_supported( $scheme );</p>
<p style="margin-left:9%; margin-top: 1em">You can use this
method to test whether this user agent object supports the
specified "scheme". (The "scheme" might
be a string (like "http" or "ftp") or it
might be an URI object reference.)</p>
<p style="margin-left:9%; margin-top: 1em">Whether a scheme
is supported is determined by the user agent's
"protocols_allowed" or
"protocols_forbidden" lists (if any), and by the
capabilities of LWP. I.e., this will return true only if LWP
supports this protocol <i>and</i> it's permitted for this
particular object.</p>
<h3>is_online
<a name="is_online"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $bool =
$ua−&gt;is_online;</p>
<p style="margin-left:9%; margin-top: 1em">Tries to
determine if you have access to the Internet. Returns 1
(true) if the built−in heuristics determine that the
user agent is able to access the Internet (over HTTP) or 0
(false).</p>
<p style="margin-left:9%; margin-top: 1em">See also
LWP::Online.</p>
<h3>mirror
<a name="mirror"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $res =
$ua−&gt;mirror( $url, $filename );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
get the document identified by URL and store it in file
called $filename. If the file already exists, then the
request will contain an
"If−Modified−Since" header matching
the modification time of the file. If the document on the
server has not changed since this time, then nothing
happens. If the document has been updated, it will be
downloaded again. The modification time of the file will be
forced to match that of the server.</p>
<p style="margin-left:9%; margin-top: 1em">Uses
"move" in File::Copy to attempt to atomically
replace the $filename.</p>
<p style="margin-left:9%; margin-top: 1em">The return value
is an HTTP::Response object.</p>
<h3>patch
<a name="patch"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"># Any version of
HTTP::Message works with this form: <br/>
my $res = $ua−&gt;patch( $url, $field_name =&gt;
$value, Content =&gt; $content ); <br/>
# Using hash or array references requires HTTP::Message
&gt;= 6.12 <br/>
use HTTP::Request 6.12; <br/>
my $res = $ua−&gt;patch( $url, \%form ); <br/>
my $res = $ua−&gt;patch( $url, \@form ); <br/>
my $res = $ua−&gt;patch( $url, \%form, $field_name
=&gt; $value, ... ); <br/>
my $res = $ua−&gt;patch( $url, $field_name =&gt;
$value, Content =&gt; \%form ); <br/>
my $res = $ua−&gt;patch( $url, $field_name =&gt;
$value, Content =&gt; \@form );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch a "PATCH" request on the given URL, with
%form or @form providing the key/value pairs for the
fill−in form content. Additional headers and content
options are the same as for the "get" in
LWP::UserAgent method.</p>
<p style="margin-left:9%; margin-top: 1em">CAVEAT:</p>
<p style="margin-left:9%; margin-top: 1em">This method can
only accept content that is in key−value pairs when
using HTTP::Request::Common prior to version 6.12. Any use
of hash or array references will result in an error prior to
version 6.12.</p>
<p style="margin-left:9%; margin-top: 1em">This method will
use the "PATCH" function from
HTTP::Request::Common to build the request. See
HTTP::Request::Common for a details on how to pass form
content and other advanced features.</p>
<h3>post
<a name="post"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $res =
$ua−&gt;post( $url, \%form ); <br/>
my $res = $ua−&gt;post( $url, \@form ); <br/>
my $res = $ua−&gt;post( $url, \%form, $field_name
=&gt; $value, ... ); <br/>
my $res = $ua−&gt;post( $url, $field_name =&gt;
$value, Content =&gt; \%form ); <br/>
my $res = $ua−&gt;post( $url, $field_name =&gt;
$value, Content =&gt; \@form ); <br/>
my $res = $ua−&gt;post( $url, $field_name =&gt;
$value, Content =&gt; $content );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch a "POST" request on the given URL, with
%form or @form providing the key/value pairs for the
fill−in form content. Additional headers and content
options are the same as for the "get" in
LWP::UserAgent method.</p>
<p style="margin-left:9%; margin-top: 1em">This method will
use the "POST" function from HTTP::Request::Common
to build the request. See HTTP::Request::Common for a
details on how to pass form content and other advanced
features.</p>
<h3>put
<a name="put"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"># Any version of
HTTP::Message works with this form: <br/>
my $res = $ua−&gt;put( $url, $field_name =&gt; $value,
Content =&gt; $content ); <br/>
# Using hash or array references requires HTTP::Message
&gt;= 6.07 <br/>
use HTTP::Request 6.07; <br/>
my $res = $ua−&gt;put( $url, \%form ); <br/>
my $res = $ua−&gt;put( $url, \@form ); <br/>
my $res = $ua−&gt;put( $url, \%form, $field_name =&gt;
$value, ... ); <br/>
my $res = $ua−&gt;put( $url, $field_name =&gt; $value,
Content =&gt; \%form ); <br/>
my $res = $ua−&gt;put( $url, $field_name =&gt; $value,
Content =&gt; \@form );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch a "PUT" request on the given URL, with
%form or @form providing the key/value pairs for the
fill−in form content. Additional headers and content
options are the same as for the "get" in
LWP::UserAgent method.</p>
<p style="margin-left:9%; margin-top: 1em">CAVEAT:</p>
<p style="margin-left:9%; margin-top: 1em">This method can
only accept content that is in key−value pairs when
using HTTP::Request::Common prior to version 6.07. Any use
of hash or array references will result in an error prior to
version 6.07.</p>
<p style="margin-left:9%; margin-top: 1em">This method will
use the "PUT" function from HTTP::Request::Common
to build the request. See HTTP::Request::Common for a
details on how to pass form content and other advanced
features.</p>
<h3>request
<a name="request"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $res =
$ua−&gt;request( $request ); <br/>
my $res = $ua−&gt;request( $request, $content_file );
<br/>
my $res = $ua−&gt;request( $request, $content_cb );
<br/>
my $res = $ua−&gt;request( $request, $content_cb,
$read_size_hint );</p>
<p style="margin-left:9%; margin-top: 1em">This method will
dispatch the given $request object. Normally this will be an
instance of the HTTP::Request class, but any object with a
similar interface will do. The return value is an
HTTP::Response object.</p>
<p style="margin-left:9%; margin-top: 1em">The
"request" method will process redirects and
authentication responses transparently. This means that it
may actually send several simple requests via the
"simple_request" in LWP::UserAgent method
described below.</p>
<p style="margin-left:9%; margin-top: 1em">The request
methods described above; "get" in LWP::UserAgent,
"head" in LWP::UserAgent, "post" in
LWP::UserAgent and "mirror" in LWP::UserAgent will
all dispatch the request they build via this method. They
are convenience methods that simply hide the creation of the
request object for you.</p>
<p style="margin-left:9%; margin-top: 1em">The
$content_file, $content_cb and $read_size_hint all
correspond to options described with the "get" in
LWP::UserAgent method above. Note that errors writing to the
content file (for example due to permission denied or the
filesystem being full) will be reported via the
"Client−Aborted" or "X−Died"
response headers, and not the "is_success"
method.</p>
<p style="margin-left:9%; margin-top: 1em">You are allowed
to use a CODE reference as "content" in the
request object passed in. The "content" function
should return the content when called. The content can be
returned in chunks. The content function will be invoked
repeatedly until it return an empty string to signal that
there is no more content.</p>
<h3>simple_request
<a name="simple_request"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $request =
HTTP::Request−&gt;new( ... ); <br/>
my $res = $ua−&gt;simple_request( $request ); <br/>
my $res = $ua−&gt;simple_request( $request,
$content_file ); <br/>
my $res = $ua−&gt;simple_request( $request,
$content_cb ); <br/>
my $res = $ua−&gt;simple_request( $request,
$content_cb, $read_size_hint );</p>
<p style="margin-left:9%; margin-top: 1em">This method
dispatches a single request and returns the response
received. Arguments are the same as for the
"request" in LWP::UserAgent described above.</p>
<p style="margin-left:9%; margin-top: 1em">The difference
from "request" in LWP::UserAgent is that
"simple_request" will not try to handle redirects
or authentication responses. The "request" in
LWP::UserAgent method will, in fact, invoke this method for
each simple request it sends.</p>
<h2>CALLBACK METHODS
<a name="CALLBACK METHODS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
methods will be invoked as requests are processed. These
methods are documented here because subclasses of
LWP::UserAgent might want to override their behaviour.</p>
<h3>get_basic_credentials
<a name="get_basic_credentials"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"># This checks
wantarray and can either return an array: <br/>
my ($user, $pass) = $ua−&gt;get_basic_credentials(
$realm, $uri, $isproxy ); <br/>
# or a string that looks like "user:pass" <br/>
my $creds = $ua−&gt;get_basic_credentials($realm,
$uri, $isproxy);</p>
<p style="margin-left:9%; margin-top: 1em">This is called
by "request" in LWP::UserAgent to retrieve
credentials for documents protected by Basic or Digest
Authentication. The arguments passed in is the $realm
provided by the server, the $uri requested and a
"boolean flag" to indicate if this is
authentication against a proxy server.</p>
<p style="margin-left:9%; margin-top: 1em">The method
should return a username and password. It should return an
empty list to abort the authentication resolution attempt.
Subclasses can override this method to prompt the user for
the information. An example of this can be found in
"lwp−request" program distributed with this
library.</p>
<p style="margin-left:9%; margin-top: 1em">The base
implementation simply checks a set of pre−stored
member variables, set up with the "credentials" in
LWP::UserAgent method.</p>
<h3>prepare_request
<a name="prepare_request"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$request =
$ua−&gt;prepare_request( $request );</p>
<p style="margin-left:9%; margin-top: 1em">This method is
invoked by "simple_request" in LWP::UserAgent. Its
task is to modify the given $request object by setting up
various headers based on the attributes of the user agent.
The return value should normally be the $request object
passed in. If a different request object is returned it will
be the one actually processed.</p>
<p style="margin-left:9%; margin-top: 1em">The headers
affected by the base implementation are;
"User−Agent", "From",
"Range" and "Cookie".</p>
<h3>progress
<a name="progress"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $prog =
$ua−&gt;progress( $status, $request_or_response );</p>
<p style="margin-left:9%; margin-top: 1em">This is called
frequently as the response is received regardless of how the
content is processed. The method is called with $status
"begin" at the start of processing the request and
with $state "end" before the request method
returns. In between these $status will be the fraction of
the response currently received or the string
"tick" if the fraction can't be calculated.</p>
<p style="margin-left:9%; margin-top: 1em">When $status is
"begin" the second argument is the HTTP::Request
object, otherwise it is the HTTP::Response object.</p>
<h3>redirect_ok
<a name="redirect_ok"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">my $bool =
$ua−&gt;redirect_ok( $prospective_request, $response
);</p>
<p style="margin-left:9%; margin-top: 1em">This method is
called by "request" in LWP::UserAgent before it
tries to follow a redirection to the request in $response.
This should return a true value if this redirection is
permissible. The $prospective_request will be the request to
be sent if this method returns true.</p>
<p style="margin-left:9%; margin-top: 1em">The base
implementation will return false unless the method is in the
object's "requests_redirectable" list, false if
the proposed redirection is to a "file://..." URL,
and true otherwise.</p>
<h2>BEST PRACTICES
<a name="BEST PRACTICES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The default
settings can get you up and running quickly, but there are
settings you can change in order to make your life
easier.</p>
<h3>Handling Cookies
<a name="Handling Cookies"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">You are
encouraged to install Mozilla::PublicSuffix and use
HTTP::CookieJar::LWP as your cookie jar.
HTTP::CookieJar::LWP provides a better security model
matching that of current Web browsers when
Mozilla::PublicSuffix is installed.</p>
<p style="margin-left:9%; margin-top: 1em">use
HTTP::CookieJar::LWP (); <br/>
my $jar = HTTP::CookieJar::LWP−&gt;new; <br/>
my $ua = LWP::UserAgent−&gt;new( cookie_jar =&gt; $jar
);</p>
<p style="margin-left:9%; margin-top: 1em">See
"cookie_jar" for more information.</p>
<h3>Managing Protocols
<a name="Managing Protocols"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"protocols_allowed"
gives you the ability to allow arbitrary protocols.</p>
<p style="margin-left:9%; margin-top: 1em">my $ua =
LWP::UserAgent−&gt;new( <br/>
protocols_allowed =&gt; [ 'http', 'https' ] <br/>
);</p>
<p style="margin-left:9%; margin-top: 1em">This will
prevent you from inadvertently following URLs like
"file:///etc/passwd". See
"protocols_allowed".</p>
<p style="margin-left:9%; margin-top: 1em">"protocols_forbidden"
gives you the ability to deny arbitrary protocols.</p>
<p style="margin-left:9%; margin-top: 1em">my $ua =
LWP::UserAgent−&gt;new( <br/>
protocols_forbidden =&gt; [ 'file', 'mailto', 'ssh', ] <br/>
);</p>
<p style="margin-left:9%; margin-top: 1em">This can also
prevent you from inadvertently following URLs like
"file:///etc/passwd". See
"protocols_forbidden".</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See LWP for a
complete overview of libwww−perl5. See lwpcook and the
scripts <i>lwp−request</i> and
<i>lwp−download</i> for examples of usage.</p>
<p style="margin-left:9%; margin-top: 1em">See
HTTP::Request and HTTP::Response for a description of the
message objects dispatched and received. See
HTTP::Request::Common and HTML::Form for other ways to build
request objects.</p>
<p style="margin-left:9%; margin-top: 1em">See
WWW::Mechanize and WWW::Search for examples of more
specialized user agents based on LWP::UserAgent.</p>
<h2>COPYRIGHT AND LICENSE
<a name="COPYRIGHT AND LICENSE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
1995−2009 Gisle Aas.</p>
<p style="margin-left:9%; margin-top: 1em">This library is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<hr/>
</body>
</html>
