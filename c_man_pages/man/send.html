<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:40:57 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>send</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">send</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#The flags argument">The flags argument</a><br/>
<a href="#sendmsg()">sendmsg()</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#VERSIONS">VERSIONS</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">send, sendto,
sendmsg − send a message on a socket</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;sys/socket.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>ssize_t
send(int</b> <i>sockfd</i><b>, const void</b>
<i>buf</i><b>[.</b><i>len</i><b>], size_t</b> <i>len</i><b>,
int</b> <i>flags</i><b>); <br/>
ssize_t sendto(int</b> <i>sockfd</i><b>, const void</b>
<i>buf</i><b>[.</b><i>len</i><b>], size_t</b> <i>len</i><b>,
int</b> <i>flags</i><b>, <br/>
const struct sockaddr *</b><i>dest_addr</i><b>,
socklen_t</b> <i>addrlen</i><b>); <br/>
ssize_t sendmsg(int</b> <i>sockfd</i><b>, const struct
msghdr *</b><i>msg</i><b>, int</b> <i>flags</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The system calls
<b>send</b>(), <b>sendto</b>(), and <b>sendmsg</b>() are
used to transmit a message to another socket.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>send</b>() call may be used only when the socket is in a
<i>connected</i> state (so that the intended recipient is
known). The only difference between <b>send</b>() and
<b>write</b>(2) is the presence of <i>flags</i>. With a zero
<i>flags</i> argument, <b>send</b>() is equivalent to
<b>write</b>(2). Also, the following call</p>
<p style="margin-left:14%; margin-top: 1em">send(sockfd,
buf, len, flags);</p>
<p style="margin-left:9%; margin-top: 1em">is equivalent
to</p>
<p style="margin-left:14%; margin-top: 1em">sendto(sockfd,
buf, len, flags, NULL, 0);</p>
<p style="margin-left:9%; margin-top: 1em">The argument
<i>sockfd</i> is the file descriptor of the sending
socket.</p>
<p style="margin-left:9%; margin-top: 1em">If
<b>sendto</b>() is used on a connection-mode
(<b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>) socket, the
arguments <i>dest_addr</i> and <i>addrlen</i> are ignored
(and the error <b>EISCONN</b> may be returned when they are
not NULL and 0), and the error <b>ENOTCONN</b> is returned
when the socket was not actually connected. Otherwise, the
address of the target is given by <i>dest_addr</i> with
<i>addrlen</i> specifying its size. For <b>sendmsg</b>(),
the address of the target is given by <i>msg.msg_name</i>,
with <i>msg.msg_namelen</i> specifying its size.</p>
<p style="margin-left:9%; margin-top: 1em">For
<b>send</b>() and <b>sendto</b>(), the message is found in
<i>buf</i> and has length <i>len</i>. For <b>sendmsg</b>(),
the message is pointed to by the elements of the array
<i>msg.msg_iov</i>. The <b>sendmsg</b>() call also allows
sending ancillary data (also known as control
information).</p>
<p style="margin-left:9%; margin-top: 1em">If the message
is too long to pass atomically through the underlying
protocol, the error <b>EMSGSIZE</b> is returned, and the
message is not transmitted.</p>
<p style="margin-left:9%; margin-top: 1em">No indication of
failure to deliver is implicit in a <b>send</b>(). Locally
detected errors are indicated by a return value of
−1.</p>
<p style="margin-left:9%; margin-top: 1em">When the message
does not fit into the send buffer of the socket,
<b>send</b>() normally blocks, unless the socket has been
placed in nonblocking I/O mode. In nonblocking mode it would
fail with the error <b>EAGAIN</b> or <b>EWOULDBLOCK</b> in
this case. The <b>select</b>(2) call may be used to
determine when it is possible to send more data.</p>
<h3>The flags argument
<a name="The flags argument"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The <i>flags</i>
argument is the bitwise OR of zero or more of the following
flags. <b><br/>
MSG_CONFIRM</b> (since Linux 2.3.15)</p>
<p style="margin-left:18%;">Tell the link layer that
forward progress happened: you got a successful reply from
the other side. If the link layer doesn’t get this it
will regularly reprobe the neighbor (e.g., via a unicast
ARP). Valid only on <b>SOCK_DGRAM</b> and <b>SOCK_RAW</b>
sockets and currently implemented only for IPv4 and IPv6.
See <b>arp</b>(7) for details.</p>
<p style="margin-left:9%;"><b>MSG_DONTROUTE</b></p>
<p style="margin-left:18%;">Don’t use a gateway to
send out the packet, send to hosts only on directly
connected networks. This is usually used only by diagnostic
or routing programs. This is defined only for protocol
families that route; packet sockets don’t.</p>
<p style="margin-left:9%;"><b>MSG_DONTWAIT</b> (since Linux
2.2)</p>
<p style="margin-left:18%;">Enables nonblocking operation;
if the operation would block, <b>EAGAIN</b> or
<b>EWOULDBLOCK</b> is returned. This provides similar
behavior to setting the <b>O_NONBLOCK</b> flag (via the
<b>fcntl</b>(2) <b>F_SETFL</b> operation), but differs in
that <b>MSG_DONTWAIT</b> is a per-call option, whereas
<b>O_NONBLOCK</b> is a setting on the open file description
(see <b>open</b>(2)), which will affect all threads in the
calling process as well as other processes that hold file
descriptors referring to the same open file description.</p>
<p style="margin-left:9%;"><b>MSG_EOR</b> (since Linux
2.2)</p>
<p style="margin-left:18%;">Terminates a record (when this
notion is supported, as for sockets of type
<b>SOCK_SEQPACKET</b>).</p>
<p style="margin-left:9%;"><b>MSG_MORE</b> (since Linux
2.4.4)</p>
<p style="margin-left:18%;">The caller has more data to
send. This flag is used with TCP sockets to obtain the same
effect as the <b>TCP_CORK</b> socket option (see
<b>tcp</b>(7)), with the difference that this flag can be
set on a per-call basis.</p>
<p style="margin-left:18%; margin-top: 1em">Since Linux
2.6, this flag is also supported for UDP sockets, and
informs the kernel to package all of the data sent in calls
with this flag set into a single datagram which is
transmitted only when a call is performed that does not
specify this flag. (See also the <b>UDP_CORK</b> socket
option described in <b>udp</b>(7).)</p>
<p style="margin-left:9%;"><b>MSG_NOSIGNAL</b> (since Linux
2.2)</p>
<p style="margin-left:18%;">Don’t generate a
<b>SIGPIPE</b> signal if the peer on a stream-oriented
socket has closed the connection. The <b>EPIPE</b> error is
still returned. This provides similar behavior to using
<b>sigaction</b>(2) to ignore <b>SIGPIPE</b>, but, whereas
<b>MSG_NOSIGNAL</b> is a per-call feature, ignoring
<b>SIGPIPE</b> sets a process attribute that affects all
threads in the process.</p>
<p style="margin-left:9%;"><b>MSG_OOB</b></p>
<p style="margin-left:18%;">Sends <i>out-of-band</i> data
on sockets that support this notion (e.g., of type
<b>SOCK_STREAM</b>); the underlying protocol must also
support <i>out-of-band</i> data.</p>
<p style="margin-left:9%;"><b>MSG_FASTOPEN</b> (since Linux
3.7)</p>
<p style="margin-left:18%;">Attempts TCP Fast Open
(RFC7413) and sends data in the SYN like a combination of
<b>connect</b>(2) and <b>write</b>(2), by performing an
implicit <b>connect</b>(2) operation. It blocks until the
data is buffered and the handshake has completed. For a
non-blocking socket, it returns the number of bytes buffered
and sent in the SYN packet. If the cookie is not available
locally, it returns <b>EINPROGRESS</b>, and sends a SYN with
a Fast Open cookie request automatically. The caller needs
to write the data again when the socket is connected. On
errors, it sets the same <i>errno</i> as <b>connect</b>(2)
if the handshake fails. This flag requires enabling TCP Fast
Open client support on sysctl
<i>net.ipv4.tcp_fastopen</i>.</p>
<p style="margin-left:18%; margin-top: 1em">Refer to
<b>TCP_FASTOPEN_CONNECT</b> socket option in <b>tcp</b>(7)
for an alternative approach.</p>
<h3>sendmsg()
<a name="sendmsg()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The definition
of the <i>msghdr</i> structure employed by <b>sendmsg</b>()
is as follows:</p>
<p style="margin-left:14%; margin-top: 1em">struct msghdr {
<br/>
void *msg_name; /* Optional address */ <br/>
socklen_t msg_namelen; /* Size of address */ <br/>
struct iovec *msg_iov; /* Scatter/gather array */ <br/>
size_t msg_iovlen; /* # elements in msg_iov */ <br/>
void *msg_control; /* Ancillary data, see below */ <br/>
size_t msg_controllen; /* Ancillary data buffer len */ <br/>
int msg_flags; /* Flags (unused) */ <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>msg_name</i> field is used on an unconnected socket to
specify the target address for a datagram. It points to a
buffer containing the address; the <i>msg_namelen</i> field
should be set to the size of the address. For a connected
socket, these fields should be specified as NULL and 0,
respectively.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>msg_iov</i> and <i>msg_iovlen</i> fields specify
scatter-gather locations, as for <b>writev</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em">You may send
control information (ancillary data) using the
<i>msg_control</i> and <i>msg_controllen</i> members. The
maximum control buffer length the kernel can process is
limited per socket by the value in
<i>/proc/sys/net/core/optmem_max</i>; see <b>socket</b>(7).
For further information on the use of ancillary data in
various socket domains, see <b>unix</b>(7) and
<b>ip</b>(7).</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>msg_flags</i> field is ignored.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On success,
these calls return the number of bytes sent. On error,
−1 is returned, and <i>errno</i> is set to indicate
the error.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These are some
standard errors generated by the socket layer. Additional
errors may be generated and returned from the underlying
protocol modules; see their respective manual pages.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EACCES</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>(For UNIX domain sockets, which are identified by
pathname) Write permission is denied on the destination
socket file, or search permission is denied for one of the
directories the path prefix. (See
<b>path_resolution</b>(7).)</p> </td></tr>
</table>
<p style="margin-left:18%; margin-top: 1em">(For UDP
sockets) An attempt was made to send to a network/broadcast
address as though it was a unicast address.</p>
<p style="margin-left:9%;"><b>EAGAIN</b> or
<b>EWOULDBLOCK</b></p>
<p style="margin-left:18%;">The socket is marked
nonblocking and the requested operation would block.
POSIX.1-2001 allows either error to be returned for this
case, and does not require these constants to have the same
value, so a portable application should check for both
possibilities.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EAGAIN</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>(Internet domain datagram sockets) The socket referred
to by <i>sockfd</i> had not previously been bound to an
address and, upon attempting to bind it to an ephemeral
port, it was determined that all port numbers in the
ephemeral port range are currently in use. See the
discussion of <i>/proc/sys/net/ipv4/ip_local_port_range</i>
in <b>ip</b>(7).</p></td></tr>
</table>
<p style="margin-left:9%;"><b>EALREADY</b></p>
<p style="margin-left:18%;">Another Fast Open is in
progress.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="6%">
<p><b>EBADF</b></p></td>
<td width="3%"></td>
<td width="55%">
<p><i>sockfd</i> is not a valid open file descriptor.</p></td>
<td width="27%">
</td></tr>
</table>
<p style="margin-left:9%;"><b>ECONNRESET</b></p>
<p style="margin-left:18%;">Connection reset by peer.</p>
<p style="margin-left:9%;"><b>EDESTADDRREQ</b></p>
<p style="margin-left:18%;">The socket is not
connection-mode, and no peer address is set.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EFAULT</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An invalid user space address was specified for an
argument.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINTR</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>A signal occurred before any data was transmitted; see
<b>signal</b>(7).</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>Invalid argument passed.</p></td></tr>
</table>
<p style="margin-left:9%;"><b>EISCONN</b></p>
<p style="margin-left:18%;">The connection-mode socket was
connected already but a recipient was specified. (Now either
this error is returned, or the recipient specification is
ignored.)</p>
<p style="margin-left:9%;"><b>EMSGSIZE</b></p>
<p style="margin-left:18%;">The socket type requires that
message be sent atomically, and the size of the message to
be sent made this impossible.</p>
<p style="margin-left:9%;"><b>ENOBUFS</b></p>
<p style="margin-left:18%;">The output queue for a network
interface was full. This generally indicates that the
interface has stopped sending, but may be caused by
transient congestion. (Normally, this does not occur in
Linux. Packets are just silently dropped when a device queue
overflows.)</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOMEM</b></p></td>
<td width="1%"></td>
<td width="26%">
<p>No memory available.</p></td>
<td width="56%">
</td></tr>
</table>
<p style="margin-left:9%;"><b>ENOTCONN</b></p>
<p style="margin-left:18%;">The socket is not connected,
and no target has been given.</p>
<p style="margin-left:9%;"><b>ENOTSOCK</b></p>
<p style="margin-left:18%;">The file descriptor
<i>sockfd</i> does not refer to a socket.</p>
<p style="margin-left:9%;"><b>EOPNOTSUPP</b></p>
<p style="margin-left:18%;">Some bit in the <i>flags</i>
argument is inappropriate for the socket type.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="6%">
<p><b>EPIPE</b></p></td>
<td width="3%"></td>
<td width="82%">
<p>The local end has been shut down on a connection
oriented socket. In this case, the process will also receive
a <b>SIGPIPE</b> unless <b>MSG_NOSIGNAL</b> is set.</p></td></tr>
</table>
<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">According to
POSIX.1-2001, the <i>msg_controllen</i> field of the
<i>msghdr</i> structure should be typed as <i>socklen_t</i>,
and the <i>msg_iovlen</i> field should be typed as
<i>int</i>, but glibc currently types both as
<i>size_t</i>.</p>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2008.</p>
<p style="margin-left:9%; margin-top: 1em"><b>MSG_CONFIRM</b>
is a Linux extension.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">4.4BSD, SVr4,
POSIX.1-2001. (first appeared in 4.2BSD).</p>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2001
describes only the <b>MSG_OOB</b> and <b>MSG_EOR</b> flags.
POSIX.1-2008 adds a specification of
<b>MSG_NOSIGNAL</b>.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See
<b>sendmmsg</b>(2) for information about a Linux-specific
system call that can be used to transmit multiple datagrams
in a single call.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux may return
<b>EPIPE</b> instead of <b>ENOTCONN</b>.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">An example of
the use of <b>sendto</b>() is shown in
<b>getaddrinfo</b>(3).</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>fcntl</b>(2),
<b>getsockopt</b>(2), <b>recv</b>(2), <b>select</b>(2),
<b>sendfile</b>(2), <b>sendmmsg</b>(2), <b>shutdown</b>(2),
<b>socket</b>(2), <b>write</b>(2), <b>cmsg</b>(3),
<b>ip</b>(7), <b>ipv6</b>(7), <b>socket</b>(7),
<b>tcp</b>(7), <b>udp</b>(7), <b>unix</b>(7)</p>
<hr/>
</body>
</html>
