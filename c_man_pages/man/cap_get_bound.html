<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:41:53 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CAP_GET_PROC</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">CAP_GET_PROC</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#CONFORMING TO">CONFORMING TO</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#capgetp() and capsetp()">capgetp() and capsetp()</a><br/>
<a href="#EXAMPLE">EXAMPLE</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">cap_get_proc,
cap_set_proc, capgetp, cap_get_bound, cap_drop_bound,
cap_get_ambient, cap_set_ambient, cap_reset_ambient,
cap_get_secbits, cap_set_secbits, cap_get_mode,
cap_set_mode, cap_mode_name, cap_get_pid, cap_setuid,
cap_prctl, cap_prctlw, cap_setgroups − capability
manipulation on processes</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;sys/capability.h&gt;</p>
<p style="margin-left:9%; margin-top: 1em">cap_t
cap_get_proc(void); <br/>
int cap_set_proc(cap_t cap_p);</p>
<p style="margin-left:9%; margin-top: 1em">int
cap_get_bound(cap_value_t cap); <br/>
CAP_IS_SUPPORTED(cap_value_t cap);</p>
<p style="margin-left:9%; margin-top: 1em">int
cap_drop_bound(cap_value_t cap); <br/>
int cap_get_ambient(cap_value_t cap); <br/>
int cap_set_ambient(cap_value_t cap, cap_flag_value_t
value); <br/>
int cap_reset_ambient(void); <br/>
CAP_AMBIENT_SUPPORTED();</p>
<p style="margin-left:9%; margin-top: 1em">unsigned
cap_get_secbits(void); <br/>
int cap_set_secbits(unsigned bits); <br/>
cap_mode_t cap_get_mode(void); <br/>
const char *cap_mode_name(cap_mode_t mode); <br/>
int cap_prctl(long int pr_cmd, long int arg1, long int
arg2,</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="6%"></td>
<td width="7%"></td>
<td width="87%">
<p>long int arg3, long int arg4, long int arg5);</p></td></tr>
</table>
<p style="margin-left:9%;">int cap_prctlw(long int pr_cmd,
long int arg1, long int arg2,</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="6%"></td>
<td width="94%">
<p>long int arg3, long int arg4, long int arg5);</p></td></tr>
</table>
<p style="margin-left:9%;">int cap_set_mode(cap_mode_t
mode);</p>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;sys/types.h&gt;</p>
<p style="margin-left:9%; margin-top: 1em">cap_t
cap_get_pid(pid_t pid); <br/>
int cap_setuid(uid_t uid); <br/>
int cap_setgroups(gid_t gid, size_t ngroups, const gid_t
groups);</p>
<p style="margin-left:9%; margin-top: 1em">Link with
<i>−lcap</i>.</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>cap_get_proc</b>()
allocates a capability state in working storage, sets its
state to that of the calling process, and returns a pointer
to this newly created capability state. The caller should
free any releasable memory, when the capability state in
working storage is no longer required, by calling
<b>cap_free</b>() with the <i>cap_t</i> as an argument.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_set_proc</b>()
sets the values for all capability flags for all
capabilities to the capability state identified by
<i>cap_p</i>. The new capability state of the process will
be completely determined by the contents of <i>cap_p</i>
upon successful return from this function. If any flag in
<i>cap_p</i> is set for any capability not currently
permitted for the calling process, the function will fail,
and the capability state of the process will remain
unchanged.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_get_pid</b>()
returns a <i>cap_t</i>, see <b>cap_init</b>(3), with the
process capabilities of the process known to the caller as
<i>pid</i>. If <i>pid</i> is 0, then the calling
process’s capabilities are returned. This information
can also be obtained from the
<i>/proc/&lt;pid&gt;/status</i> file. (The entries in that
file can be translated with the <b>capsh
−−decode=</b><i>XXX</i> command line.) When the
caller is operating within a (<b>CLONE_NEWPID</b>)
namespace, the numerical <i>pid</i> argument is interpreted
in the range of that namespace. As such, the caller’s
idea of the target <i>pid</i> may differ from that of the
target process when they are operating in different pid
namespaces. See <b>pid_namespaces</b>(7) for details.
Further, the returned <i>cap_t</i> value holds the
capabilities that the target <i>pid</i> thinks it has. If
the target is operating in a (<b>CLONE_NEWUSER</b>)
namespace, the system wide privilege of those user namespace
capabilities my be substantially reduced. See
<b>user_namespaces</b>(7) for details.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_get_bound</b>()
with a <i>cap</i> as an argument returns the current value
of this bounding set capability flag in effect for the
calling process. This operation is unprivileged. Note, a
macro function <b>CAP_IS_SUPPORTED(cap_value_t</b>
cap<b>)</b> is provided that evaluates to true (1) if the
system supports the specified capability, <i>cap</i>. If the
system does not support the capability, this function
returns 0. This macro works by testing for an error
condition with <b>cap_get_bound</b>().</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_drop_bound</b>()
can be used to lower the specified bounding set capability,
<b>cap</b>. To complete successfully, the prevailing
<i>effective</i> capability set must have a raised
<b>CAP_SETPCAP</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_get_ambient</b>()
returns the prevailing value of the specified ambient
capability, or -1 if the capability is not supported by the
running kernel. A macro <b>CAP_AMBIENT_SUPPORTED</b>() uses
this function to determine if ambient capabilities are
supported by the kernel.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_set_ambient</b>()
sets the specified ambient capability to a specific value.
To complete successfully, the prevailing <i>effective</i>
capability set must have a raised <b>CAP_SETPCAP</b>.
Further, to raise a specific ambient capability the
<i>inheritable</i> and <i>permitted</i> sets of the calling
process must contain the specified capability, and raised
ambient bits will only be retained as long as this remains
true.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_reset_ambient</b>()
resets all of the ambient capabilities for the calling
process to their lowered value. Note, the ambient set is
intended to operate in a legacy environment where the
application has limited awareness of capabilities in
general. Executing a file, with associated filesystem
capabilities, the kernel will implicitly reset the ambient
set of the process. Further, changes to the inheritable set
by the program code without explicitly fixing up the ambient
set can also drop ambient bits.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_get_secbits</b>()
returns the securebits of the calling process. These bits
affect the way in which the calling process implements
things like setuid-root fixup and ambient capabilities.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_set_secbits</b>()
attempts to modify the securebits of the calling process.
Note <b>CAP_SETPCAP</b> must be in the effective capability
set for this to be effective. Some settings lock the
sub-states of the securebits, so attempts to set values may
be denied by the kernel even when the <b>CAP_SETPCAP</b>
capability is raised.</p>
<p style="margin-left:9%; margin-top: 1em">To help manage
the complexity of the securebits, libcap provides a combined
securebit and capability set concept called a libcap mode.
<b>cap_get_mode</b>() attempts to summarize the prevailing
security environment in the form of a numerical
<b>cap_mode_t</b> value. A text representation of the mode
can be obtained via the <b>cap_mode_name</b>() function. The
vast majority of combinations of these values are not well
defined in terms of a libcap mode, and for these states
<b>cap_get_mode</b>() returns (<b>cap_mode_t</b>)0 which
<b>cap_get_name</b>() identifies as
‘‘<i>UNCERTAIN</i>’’. Supported
modes are: <b>CAP_MODE_NOPRIV</b>,
<b>CAP_MODE_PURE1E_INIT</b> and <b>CAP_MODE_PURE1E</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_prctl</b>()
can be used to read state via the <b>prctl</b><i>()</i>
<b>system call.</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_prctlw</b>()
can be used to write state via the <b>prctl</b><i>()</i>
<b>system call.</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_set_mode</b>()
can be used to set the desired mode. The permitted
capability <b>CAP_SETPCAP</b> is required for this function
to succeed.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_setuid</b>()
is a convenience function for the <b>setuid</b>(2) system
call. Where <b>cap_setuid</b>() arranges for the right
effective capability to be raised in order to perform the
system call, and also arranges to preserve the availability
of permitted capabilities after the uid has changed.
Following this call all effective capabilities are
lowered.</p>
<p style="margin-left:9%; margin-top: 1em"><b>cap_setgroups</b>()
is a convenience function for performing both
<b>setgid</b>(2) and <b>setgroups</b>(2) calls in one call.
The <b>cap_setgroups</b>() call raises the right effective
capability for the duration of the call, and empties the
effective capability set before returning.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The functions
<b>cap_get_proc</b>() and <b>cap_get_pid</b>() return a
non-NULL value on success, and NULL on failure.</p>
<p style="margin-left:9%; margin-top: 1em">The function
<b>cap_get_bound</b>() returns −1 if the requested
capability is unknown, otherwise the return value reflects
the current state of that capability in the prevailing
bounding set. Note, a macro function,</p>
<p style="margin-left:9%; margin-top: 1em">The all of the
setting functions such as <b>cap_set_proc</b>() and
<b>cap_drop_bound</b>() return zero for success, and
−1 on failure.</p>
<p style="margin-left:9%; margin-top: 1em">On failure,
<i>errno</i> is set to <b>EINVAL</b>, <b>EPERM</b>, or
<b>ENOMEM</b>.</p>
<h2>CONFORMING TO
<a name="CONFORMING TO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>cap_set_proc</b>()
and <b>cap_get_proc</b>() are specified in the withdrawn
POSIX.1e draft specification. <b>cap_get_pid</b>() is a
Linux extension.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Neither glibc,
nor the Linux kernel honors POSIX semantics for setting
capabilities and securebits in the presence of pthreads.
That is, changing capability sets, by default, only affect
the running thread. To be meaningfully secure, however, the
capability sets should be mirrored by all threads within a
common program because threads are not memory isolated. As a
workaround for this, <b>libcap</b> is packaged with a
separate POSIX semantics system call library: <b>libpsx</b>.
If your program uses POSIX threads, to achieve meaningful
POSIX semantics capability manipulation, you should link
your program with:</p>
<p style="margin-left:9%; margin-top: 1em"><b>ld ...
−lcap −lpsx −lpthread
−−wrap=pthread_create</b></p>
<p style="margin-left:9%; margin-top: 1em">or,</p>
<p style="margin-left:9%; margin-top: 1em"><b>gcc ...
−lcap −lpsx −lpthread
−Wl,−wrap,pthread_create</b></p>
<p style="margin-left:9%; margin-top: 1em">When linked this
way, due to linker magic, libcap uses <b>psx_syscall</b>(3)
and <b>psx_syscall6</b>(3) to perform state setting system
calls. Notably, this also ensures that
<b>cap_prctlw</b><i>()</i> can be used to ensure process
control bits are shared over all threads of a single
process.</p>
<h3>capgetp() and capsetp()
<a name="capgetp() and capsetp()"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The library also
supports the deprecated functions:</p>
<p style="margin-left:9%; margin-top: 1em"><b>int
capgetp(pid_t</b> <i>pid</i><b>, cap_t</b>
<i>cap_d</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
capsetp(pid_t</b> <i>pid</i><b>, cap_t</b>
<i>cap_d</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>capgetp</b>()
attempts to obtain the capabilities of some other process;
storing the capabilities in a pre-allocated <i>cap_d</i>.
See <b>cap_init</b>() for information on allocating an empty
capability set. This function is deprecated; you should use
<b>cap_get_pid</b>().</p>
<p style="margin-left:9%; margin-top: 1em"><b>capsetp</b>()
attempts to set the capabilities of the calling process or
of some other process(es), <i>pid</i>. Note that setting
capabilities of another process is only possible on older
kernels that do not provide VFS support for setting file
capabilities. See <b>capset</b>(2) for information on which
kernels provide such support.</p>
<p style="margin-left:9%; margin-top: 1em">If <i>pid</i> is
positive it refers to a specific process; if it is zero, it
refers to the calling process; −1 refers to all
processes other than the calling process and process
’1’ (typically <b>init</b>(8)); other negative
values refer to the <i>−pid</i> process group.</p>
<p style="margin-left:9%; margin-top: 1em">In order to use
this function, the kernel must support it and the calling
process must have <b>CAP_SETPCAP</b> raised in its Effective
capability set. The capabilities set in the target
process(es) are those contained in <i>cap_d</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Kernels that
support filesystem capabilities redefine the semantics of
<b>CAP_SETPCAP</b> and on such systems, <b>capsetp</b>()
will always fail for any target not equal to the calling
process. <b>capsetp</b>() returns zero for success, and
−1 on failure.</p>
<p style="margin-left:9%; margin-top: 1em">On kernels where
it is (was) supported, <b>capsetp</b>() should be used with
care. It existed, primarily, to overcome an early lack of
support for capabilities in the filesystems supported by
Linux. Note that on older kernels where <b>capsetp</b>()
could be used to set the capabilities of another process,
the only processes that had <b>CAP_SETPCAP</b> available to
them by default were processes started as kernel threads.
(Typically this includes <b>init</b>(8), kflushd and
kswapd.) A kernel recompilation was needed to modify this
default.</p>
<h2>EXAMPLE
<a name="EXAMPLE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The code segment
below raises the <b>CAP_FOWNER</b> and <b>CAP_SETFCAP</b>
effective capabilities for the caller:</p>
<p style="margin-left:9%; margin-top: 1em">... <br/>
cap_t caps; <br/>
const cap_value_t cap_list[2] = {CAP_FOWNER,
CAP_SETFCAP};</p>
<p style="margin-left:9%; margin-top: 1em">if
(!CAP_IS_SUPPORTED(CAP_SETFCAP)) <br/>
/* handle error */</p>
<p style="margin-left:9%; margin-top: 1em">caps =
cap_get_proc(); <br/>
if (caps == NULL) <br/>
/* handle error */;</p>
<p style="margin-left:9%; margin-top: 1em">if
(cap_set_flag(caps, CAP_EFFECTIVE, 2, cap_list, CAP_SET) ==
−1) <br/>
/* handle error */;</p>
<p style="margin-left:9%; margin-top: 1em">if
(cap_set_proc(caps) == −1) <br/>
/* handle error */;</p>
<p style="margin-left:9%; margin-top: 1em">if
(cap_free(caps) == −1) <br/>
/* handle error */; <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">Alternatively,
to completely drop privilege in a program launched
setuid-root but wanting to run as a specific user ID etc. in
such a way that neither it, nor any of its children can
acquire privilege again:</p>
<p style="margin-left:9%; margin-top: 1em">... <br/>
uid_t nobody = 65534; <br/>
const gid_t groups[] = {65534};</p>
<p style="margin-left:9%; margin-top: 1em">if
(cap_setgroups(groups[0], 1, groups) != 0) <br/>
/* handle error */; <br/>
if (cap_setuid(nobody) != 0) <br/>
/* handle error */;</p>
<p style="margin-left:9%; margin-top: 1em">/* <br/>
* privilege is still available here <br/>
*/</p>
<p style="margin-left:9%; margin-top: 1em">if
(cap_set_mode(CAP_MODE_NOPRIV) != 0) <br/>
/* handle error */ <br/>
...</p>
<p style="margin-left:9%; margin-top: 1em">Note, the above
sequence can be performed by the <b>capsh</b> tool as
follows:</p>
<p style="margin-left:9%; margin-top: 1em"><b>sudo capsh
−−user=nobody −−mode=NOPRIV
−−print</b></p>
<p style="margin-left:9%; margin-top: 1em">where
<b>−−print</b> displays the resulting privilege
state.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>libcap</b>(3),
<b>libpsx</b>(3), <b>capsh</b>(1), <b>cap_clear</b>(3),
<b>cap_copy_ext</b>(3), <b>cap_from_text</b>(3),
<b>cap_get_file</b>(3), <b>cap_init</b>(3),
<b>namespaces</b>(7), <b>pid_namespaces</b>(7),
<b>user_namespaces</b>(7), <b>psx_syscall</b>(3),
<b>capabilities</b>(7).</p>
<hr/>
</body>
</html>
