<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:45:57 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>OPENSSL_LH_COMPFUNC</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">OPENSSL_LH_COMPFUNC</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#NOTE">NOTE</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">LHASH, LHASH_OF,
DEFINE_LHASH_OF_EX, DEFINE_LHASH_OF, OPENSSL_LH_COMPFUNC,
OPENSSL_LH_HASHFUNC, OPENSSL_LH_DOALL_FUNC,
LHASH_DOALL_ARG_FN_TYPE, IMPLEMENT_LHASH_HASH_FN,
IMPLEMENT_LHASH_COMP_FN, lh_TYPE_new, lh_TYPE_free,
lh_TYPE_flush, lh_TYPE_insert, lh_TYPE_delete,
lh_TYPE_retrieve, lh_TYPE_doall, lh_TYPE_doall_arg,
lh_TYPE_num_items, lh_TYPE_get_down_load,
lh_TYPE_set_down_load, lh_TYPE_error, OPENSSL_LH_new,
OPENSSL_LH_free, OPENSSL_LH_flush, OPENSSL_LH_insert,
OPENSSL_LH_delete, OPENSSL_LH_retrieve, OPENSSL_LH_doall,
OPENSSL_LH_doall_arg, OPENSSL_LH_num_items,
OPENSSL_LH_get_down_load, OPENSSL_LH_set_down_load,
OPENSSL_LH_error − dynamic hash table</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/lhash.h&gt; <br/>
LHASH_OF(TYPE) <br/>
DEFINE_LHASH_OF_EX(TYPE); <br/>
LHASH_OF(TYPE) *lh_TYPE_new(OPENSSL_LH_HASHFUNC hash,
OPENSSL_LH_COMPFUNC compare); <br/>
void lh_TYPE_free(LHASH_OF(TYPE) *table); <br/>
void lh_TYPE_flush(LHASH_OF(TYPE) *table); <br/>
TYPE *lh_TYPE_insert(LHASH_OF(TYPE) *table, TYPE *data);
<br/>
TYPE *lh_TYPE_delete(LHASH_OF(TYPE) *table, TYPE *data);
<br/>
TYPE *lh_TYPE_retrieve(LHASH_OF(TYPE) *table, TYPE *data);
<br/>
void lh_TYPE_doall(LHASH_OF(TYPE) *table,
OPENSSL_LH_DOALL_FUNC func); <br/>
void lh_TYPE_doall_arg(LHASH_OF(TYPE) *table,
OPENSSL_LH_DOALL_FUNCARG func, <br/>
TYPE *arg); <br/>
unsigned long lh_TYPE_num_items(OPENSSL_LHASH *lh); <br/>
unsigned long lh_TYPE_get_down_load(OPENSSL_LHASH *lh); <br/>
void lh_TYPE_set_down_load(OPENSSL_LHASH *lh, unsigned long
dl); <br/>
int lh_TYPE_error(LHASH_OF(TYPE) *table); <br/>
typedef int (*OPENSSL_LH_COMPFUNC)(const void *, const void
*); <br/>
typedef unsigned long (*OPENSSL_LH_HASHFUNC)(const void *);
<br/>
typedef void (*OPENSSL_LH_DOALL_FUNC)(const void *); <br/>
typedef void (*LHASH_DOALL_ARG_FN_TYPE)(const void *, const
void *); <br/>
OPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h,
OPENSSL_LH_COMPFUNC c); <br/>
void OPENSSL_LH_free(OPENSSL_LHASH *lh); <br/>
void OPENSSL_LH_flush(OPENSSL_LHASH *lh); <br/>
void *OPENSSL_LH_insert(OPENSSL_LHASH *lh, void *data); <br/>
void *OPENSSL_LH_delete(OPENSSL_LHASH *lh, const void
*data); <br/>
void *OPENSSL_LH_retrieve(OPENSSL_LHASH *lh, const void
*data); <br/>
void OPENSSL_LH_doall(OPENSSL_LHASH *lh,
OPENSSL_LH_DOALL_FUNC func); <br/>
void OPENSSL_LH_doall_arg(OPENSSL_LHASH *lh,
OPENSSL_LH_DOALL_FUNCARG func, void *arg); <br/>
unsigned long OPENSSL_LH_num_items(OPENSSL_LHASH *lh); <br/>
unsigned long OPENSSL_LH_get_down_load(OPENSSL_LHASH *lh);
<br/>
void OPENSSL_LH_set_down_load(OPENSSL_LHASH *lh, unsigned
long dl); <br/>
int OPENSSL_LH_error(OPENSSL_LHASH *lh); <br/>
#define LH_LOAD_MULT /* integer constant */</p>
<p style="margin-left:9%; margin-top: 1em">The following
macro is deprecated:</p>
<p style="margin-left:9%; margin-top: 1em">DEFINE_LHASH_OF(TYPE);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This library
implements type−checked dynamic hash tables. The hash
table entries can be arbitrary structures. Usually they
consist of key and value fields. In the description here,
<b><i>TYPE</i></b> is used a placeholder for any of the
OpenSSL datatypes, such as <i>SSL_SESSION</i>.</p>
<p style="margin-left:9%; margin-top: 1em">To define a new
type−checked dynamic hash table, use
<b>DEFINE_LHASH_OF_EX</b>(). <b>DEFINE_LHASH_OF</b>() was
previously used for this purpose, but is now deprecated. The
<b>DEFINE_LHASH_OF_EX</b>() macro provides all functionality
of <b>DEFINE_LHASH_OF</b>() except for certain deprecated
statistics functions (see <b>OPENSSL_LH_stats</b>(3)).</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_new</b>()
creates a new <b>LHASH_OF</b>(<b><i>TYPE</i></b>) structure
to store arbitrary data entries, and specifies the 'hash'
and 'compare' callbacks to be used in organising the table's
entries. The <i>hash</i> callback takes a pointer to a table
entry as its argument and returns an unsigned long hash
value for its key field. The hash value is normally
truncated to a power of 2, so make sure that your hash
function returns well mixed low order bits. The
<i>compare</i> callback takes two arguments (pointers to two
hash table entries), and returns 0 if their keys are equal,
nonzero otherwise.</p>
<p style="margin-left:9%; margin-top: 1em">If your hash
table will contain items of some particular type and the
<i>hash</i> and <i>compare</i> callbacks hash/compare these
types, then the <b>IMPLEMENT_LHASH_HASH_FN</b> and
<b>IMPLEMENT_LHASH_COMP_FN</b> macros can be used to create
callback wrappers of the prototypes required by
<b>lh_</b><b><i>TYPE</i></b><b>_new</b>() as shown in this
example:</p>
<p style="margin-left:9%; margin-top: 1em">/* <br/>
* Implement the hash and compare functions;
"stuff" can be any word. <br/>
*/ <br/>
static unsigned long stuff_hash(const TYPE *a) <br/>
{ <br/>
... <br/>
} <br/>
static int stuff_cmp(const TYPE *a, const TYPE *b) <br/>
{ <br/>
... <br/>
} <br/>
/* <br/>
* Implement the wrapper functions. <br/>
*/ <br/>
static IMPLEMENT_LHASH_HASH_FN(stuff, TYPE) <br/>
static IMPLEMENT_LHASH_COMP_FN(stuff, TYPE)</p>
<p style="margin-left:9%; margin-top: 1em">If the type is
going to be used in several places, the following macros can
be used in a common header file to declare the function
wrappers:</p>
<p style="margin-left:9%; margin-top: 1em">DECLARE_LHASH_HASH_FN(stuff,
TYPE) <br/>
DECLARE_LHASH_COMP_FN(stuff, TYPE)</p>
<p style="margin-left:9%; margin-top: 1em">Then a hash
table of <b><i>TYPE</i></b> objects can be created using
this:</p>
<p style="margin-left:9%; margin-top: 1em">LHASH_OF(TYPE)
*htable; <br/>
htable = B&lt;lh_I&lt;TYPE&gt;_new&gt;(LHASH_HASH_FN(stuff),
LHASH_COMP_FN(stuff));</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_free</b>()
frees the <b>LHASH_OF</b>(<b><i>TYPE</i></b>) structure
<i>table</i>. Allocated hash table entries will not be
freed; consider using
<b>lh_</b><b><i>TYPE</i></b><b>_doall</b>() to deallocate
any remaining entries in the hash table (see below). If the
argument is NULL, nothing is done.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_flush</b>()
empties the <b>LHASH_OF</b>(<b><i>TYPE</i></b>) structure
<i>table</i>. New entries can be added to the flushed table.
Allocated hash table entries will not be freed; consider
using <b>lh_</b><b><i>TYPE</i></b><b>_doall</b>() to
deallocate any remaining entries in the hash table (see
below).</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_insert</b>()
inserts the structure pointed to by <i>data</i> into
<i>table</i>. If there already is an entry with the same
key, the old value is replaced. Note that
<b>lh_</b><b><i>TYPE</i></b><b>_insert</b>() stores
pointers, the data are not copied.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_delete</b>()
deletes an entry from <i>table</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_retrieve</b>()
looks up an entry in <i>table</i>. Normally, <i>data</i> is
a structure with the key field(s) set; the function will
return a pointer to a fully populated structure.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_doall</b>()
will, for every entry in the hash table, call <i>func</i>
with the data item as its parameter. For example:</p>
<p style="margin-left:9%; margin-top: 1em">/* Cleans up
resources belonging to 'a' (this is implemented elsewhere)
*/ <br/>
void TYPE_cleanup_doall(TYPE *a); <br/>
/* Implement a prototype−compatible wrapper for
"TYPE_cleanup" */ <br/>
IMPLEMENT_LHASH_DOALL_FN(TYPE_cleanup, TYPE) <br/>
/* Call "TYPE_cleanup" against all items in a hash
table. */ <br/>
lh_TYPE_doall(hashtable, LHASH_DOALL_FN(TYPE_cleanup)); <br/>
/* Then the hash table itself can be deallocated */ <br/>
lh_TYPE_free(hashtable);</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>()
is the same as <b>lh_</b><b><i>TYPE</i></b><b>_doall</b>()
except that <i>func</i> will be called with <i>arg</i> as
the second argument and <i>func</i> should be of type
<b>LHASH_DOALL_ARG_FN</b>(<b><i>TYPE</i></b>) (a callback
prototype that is passed both the table entry and an extra
argument). As with <b>lh_doall()</b>, you can instead choose
to declare your callback with a prototype matching the types
you are dealing with and use the declare/implement macros to
create compatible wrappers that cast variables before
calling your type−specific callbacks. An example of
this is demonstrated here (printing all hash table entries
to a BIO that is provided by the caller):</p>
<p style="margin-left:9%; margin-top: 1em">/* Prints item
'a' to 'output_bio' (this is implemented elsewhere) */ <br/>
void TYPE_print_doall_arg(const TYPE *a, BIO *output_bio);
<br/>
/* Implement a prototype−compatible wrapper for
"TYPE_print" */ <br/>
static IMPLEMENT_LHASH_DOALL_ARG_FN(TYPE, const TYPE, BIO)
<br/>
/* Print out the entire hashtable to a particular BIO */
<br/>
lh_TYPE_doall_arg(hashtable, LHASH_DOALL_ARG_FN(TYPE_print),
BIO, <br/>
logging_bio);</p>
<p style="margin-left:9%; margin-top: 1em">Note that it is
by default <b>not</b> safe to use
<b>lh_</b><b><i>TYPE</i></b><b>_delete</b>() inside a
callback passed to
<b>lh_</b><b><i>TYPE</i></b><b>_doall</b>() or
<b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>(). The reason
for this is that deleting an item from the hash table may
result in the hash table being contracted to a smaller size
and rehashed. <b>lh_</b><b><i>TYPE</i></b><b>_doall</b>()
and <b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>() are
unsafe and will exhibit undefined behaviour under these
conditions, as these functions assume the hash table size
and bucket pointers do not change during the call.</p>
<p style="margin-left:9%; margin-top: 1em">If it is desired
to use <b>lh_</b><b><i>TYPE</i></b><b>_doall</b>() or
<b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>() with
<b>lh_</b><b><i>TYPE</i></b><b>_delete</b>(), it is
essential that you call
<b>lh_</b><b><i>TYPE</i></b><b>_set_down_load</b>() with a
<i>down_load</i> argument of 0 first. This disables hash
table contraction and guarantees that it will be safe to
delete items from a hash table during a call to
<b>lh_</b><b><i>TYPE</i></b><b>_doall</b>() or
<b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>().</p>
<p style="margin-left:9%; margin-top: 1em">It is never safe
to call <b>lh_</b><b><i>TYPE</i></b><b>_insert</b>() during
a call to <b>lh_</b><b><i>TYPE</i></b><b>_doall</b>() or
<b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>().</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_error</b>()
can be used to determine if an error occurred in the last
operation.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_num_items</b>()
returns the number of items in the hash table.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_get_down_load</b>()
and <b>lh_</b><b><i>TYPE</i></b><b>_set_down_load</b>() get
and set the factor used to determine when the hash table is
contracted. The factor is the load factor at or below which
hash table contraction will occur, multiplied by
<b>LH_LOAD_MULT</b>, where the load factor is the number of
items divided by the number of nodes. Setting this value to
0 disables hash table contraction.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OPENSSL_LH_new()</b>
is the same as the <b>lh_</b><b><i>TYPE</i></b><b>_new</b>()
except that it is not type specific. So instead of returning
an <b>LHASH_OF(</b><b><i>TYPE</i></b><b>)</b> value it
returns a <b>void *</b>. In the same way the functions
<b>OPENSSL_LH_free()</b>, <b>OPENSSL_LH_flush()</b>,
<b>OPENSSL_LH_insert()</b>, <b>OPENSSL_LH_delete()</b>,
<b>OPENSSL_LH_retrieve()</b>, <b>OPENSSL_LH_doall()</b>,
<b>OPENSSL_LH_doall_arg()</b>,
<b>OPENSSL_LH_num_items()</b>,
<b>OPENSSL_LH_get_down_load()</b>,
<b>OPENSSL_LH_set_down_load()</b> and
<b>OPENSSL_LH_error()</b> are equivalent to the similarly
named <b>lh_</b><b><i>TYPE</i></b> functions except that
they return or use a <b>void *</b> where the equivalent
<b>lh_</b><b><i>TYPE</i></b> function returns or uses a
<b><i>TYPE</i></b> <b>*</b> or
<b>LHASH_OF(</b><b><i>TYPE</i></b><b>) *</b>.
<b>lh_</b><b><i>TYPE</i></b> functions are implemented as
type checked wrappers around the <b>OPENSSL_LH</b>
functions. Most applications should not call the
<b>OPENSSL_LH</b> functions directly.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_new</b>()
and <b>OPENSSL_LH_new()</b> return NULL on error, otherwise
a pointer to the new <b>LHASH</b> structure.</p>
<p style="margin-left:9%; margin-top: 1em">When a hash
table entry is replaced,
<b>lh_</b><b><i>TYPE</i></b><b>_insert</b>() or
<b>OPENSSL_LH_insert()</b> return the value being replaced.
NULL is returned on normal operation and on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_delete</b>()
and <b>OPENSSL_LH_delete()</b> return the entry being
deleted. NULL is returned if there is no such value in the
hash table.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_retrieve</b>()
and <b>OPENSSL_LH_retrieve()</b> return the hash table entry
if it has been found, NULL otherwise.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_error</b>()
and <b>OPENSSL_LH_error()</b> return 1 if an error occurred
in the last operation, 0 otherwise. It's meaningful only
after non−retrieve operations.</p>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_free</b>(),
<b>OPENSSL_LH_free()</b>,
<b>lh_</b><b><i>TYPE</i></b><b>_flush</b>(),
<b>OPENSSL_LH_flush()</b>,
<b>lh_</b><b><i>TYPE</i></b><b>_doall</b>()
<b>OPENSSL_LH_doall()</b>,
<b>lh_</b><b><i>TYPE</i></b><b>_doall_arg</b>() and
<b>OPENSSL_LH_doall_arg()</b> return no values.</p>
<h2>NOTE
<a name="NOTE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The LHASH code
is not thread safe. All updating operations, as well as
<b>lh_</b><b><i>TYPE</i></b><b>_error</b>() or
<b>OPENSSL_LH_error()</b> calls must be performed under a
write lock. All retrieve operations should be performed
under a read lock, <i>unless</i> accurate usage statistics
are desired. In which case, a write lock should be used for
retrieve operations as well. For output of the usage
statistics, using the functions from
<b>OPENSSL_LH_stats</b>(3), a read lock suffices.</p>
<p style="margin-left:9%; margin-top: 1em">The LHASH code
regards table entries as constant data. As such, it
internally represents <b>lh_insert()</b>'d items with a
"const void *" pointer type. This is why callbacks
such as those used by <b>lh_doall()</b> and
<b>lh_doall_arg()</b> declare their prototypes with
"const", even for the parameters that pass back
the table items' data pointers − for consistency,
user−provided data is "const" at all times
as far as the LHASH code is concerned. However, as callers
are themselves providing these pointers, they can choose
whether they too should be treating all such parameters as
constant.</p>
<p style="margin-left:9%; margin-top: 1em">As an example, a
hash table may be maintained by code that, for reasons of
encapsulation, has only "const" access to the data
being indexed in the hash table (i.e. it is returned as
"const" from elsewhere in their code) − in
this case the LHASH prototypes are appropriate as−is.
Conversely, if the caller is responsible for the
life−time of the data in question, then they may well
wish to make modifications to table item passed back in the
<b>lh_doall()</b> or <b>lh_doall_arg()</b> callbacks (see
the "TYPE_cleanup" example above). If so, the
caller can either cast the "const" away (if
they're providing the raw callbacks themselves) or use the
macros to declare/implement the wrapper functions without
"const" types.</p>
<p style="margin-left:9%; margin-top: 1em">Callers that
only have "const" access to data they're indexing
in a table, yet declare callbacks without constant types (or
cast the "const" away themselves), are therefore
creating their own risks/bugs without being encouraged to do
so by the API. On a related note, those auditing code should
pay special attention to any instances of
DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide
types without any "const" qualifiers.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>lh_</b><b><i>TYPE</i></b><b>_insert</b>()
and <b>OPENSSL_LH_insert()</b> return NULL both for success
and error.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>OPENSSL_LH_stats</b>(3)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">In OpenSSL
1.0.0, the lhash interface was revamped for better type
checking.</p>
<p style="margin-left:9%; margin-top: 1em">In OpenSSL 3.1,
<b>DEFINE_LHASH_OF_EX</b>() was introduced and
<b>DEFINE_LHASH_OF</b>() was deprecated.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2000−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
