<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:39:34 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>B</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">B</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#OVERVIEW">OVERVIEW</a><br/>
<a href="#Utility Functions">Utility Functions</a><br/>
<a href='#Functions Returning "B::SV", "B::AV", "B::HV", and "B::CV" objects'>Functions Returning "B::SV", "B::AV", "B::HV", and "B::CV" objects</a><br/>
<a href="#Functions for Examining the Symbol Table">Functions for Examining the Symbol Table</a><br/>
<a href='#Functions Returning "B::OP" objects or for walking op trees'>Functions Returning "B::OP" objects or for walking op trees</a><br/>
<a href="#Miscellaneous Utility Functions">Miscellaneous Utility Functions</a><br/>
<a href="#Exported utility variables">Exported utility variables</a><br/>
<a href="#OVERVIEW OF CLASSES">OVERVIEW OF CLASSES</a><br/>
<a href="#SV-RELATED CLASSES">SV-RELATED CLASSES</a><br/>
<a href="#B::SV Methods">B::SV Methods</a><br/>
<a href="#B::IV Methods">B::IV Methods</a><br/>
<a href="#B::NV Methods">B::NV Methods</a><br/>
<a href="#B::RV Methods">B::RV Methods</a><br/>
<a href="#B::PV Methods">B::PV Methods</a><br/>
<a href="#B::PVMG Methods">B::PVMG Methods</a><br/>
<a href="#B::MAGIC Methods">B::MAGIC Methods</a><br/>
<a href="#B::INVLIST Methods">B::INVLIST Methods</a><br/>
<a href="#B::PVLV Methods">B::PVLV Methods</a><br/>
<a href="#B::BM Methods">B::BM Methods</a><br/>
<a href="#B::REGEXP Methods">B::REGEXP Methods</a><br/>
<a href="#B::GV Methods">B::GV Methods</a><br/>
<a href="#B::IO Methods">B::IO Methods</a><br/>
<a href="#B::AV Methods">B::AV Methods</a><br/>
<a href="#B::CV Methods">B::CV Methods</a><br/>
<a href="#B::HV Methods">B::HV Methods</a><br/>
<a href="#OP-RELATED CLASSES">OP-RELATED CLASSES</a><br/>
<a href="#B::OP Methods">B::OP Methods</a><br/>
<a href="#B::UNOP Method">B::UNOP Method</a><br/>
<a href="#B::UNOP_AUX Methods (since 5.22)">B::UNOP_AUX Methods (since 5.22)</a><br/>
<a href="#B::BINOP Method">B::BINOP Method</a><br/>
<a href="#B::LOGOP Method">B::LOGOP Method</a><br/>
<a href="#B::LISTOP Method">B::LISTOP Method</a><br/>
<a href="#B::PMOP Methods">B::PMOP Methods</a><br/>
<a href="#B::SVOP Methods">B::SVOP Methods</a><br/>
<a href="#B::PADOP Method">B::PADOP Method</a><br/>
<a href="#B::PVOP Method">B::PVOP Method</a><br/>
<a href="#B::LOOP Methods">B::LOOP Methods</a><br/>
<a href="#B::COP Methods">B::COP Methods</a><br/>
<a href="#B::METHOP Methods (Since Perl 5.22)">B::METHOP Methods (Since Perl 5.22)</a><br/>
<a href="#PAD-RELATED CLASSES">PAD-RELATED CLASSES</a><br/>
<a href="#B::PADLIST Methods">B::PADLIST Methods</a><br/>
<a href="#B::PADNAMELIST Methods">B::PADNAMELIST Methods</a><br/>
<a href="#B::PADNAME Methods">B::PADNAME Methods</a><br/>
<a href="#$B::overlay">$B::overlay</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">B − The
Perl Compiler Backend</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use B;</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
"B" module supplies classes which allow a Perl
program to delve into its own innards. It is the module used
to implement the "backends" of the Perl compiler.
Usage of the compiler does not require knowledge of this
module: see the O module for the user-visible part. The
"B" module is of use to those who want to write
new compiler backends. This documentation assumes that the
reader knows a fair amount about perl’s internals
including such things as SVs, OPs and the internal symbol
table and syntax tree of a program.</p>
<h2>OVERVIEW
<a name="OVERVIEW"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
"B" module contains a set of utility functions for
querying the current state of the Perl interpreter;
typically these functions return objects from the B::SV and
B::OP classes, or their derived classes. These classes in
turn define methods for querying the resulting objects about
their own internal state.</p>
<h2>Utility Functions
<a name="Utility Functions"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
"B" module exports a variety of functions: some
are simple utility functions, others provide a Perl program
with a way to get an initial "handle" on an
internal object.</p>
<h3>Functions Returning "B::SV", "B::AV", "B::HV", and "B::CV" objects
<a name='Functions Returning "B::SV", "B::AV", "B::HV", and "B::CV" objects'></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">For descriptions
of the class hierarchy of these objects and the methods that
can be called on them, see below, "OVERVIEW OF
CLASSES" and "SV-RELATED CLASSES". <br/>
sv_undef</p>
<p style="margin-left:14%;">Returns the SV object
corresponding to the C variable "sv_undef".</p>
<p style="margin-left:9%;">sv_yes</p>
<p style="margin-left:14%;">Returns the SV object
corresponding to the C variable "sv_yes".</p>
<p style="margin-left:9%;">sv_no</p>
<p style="margin-left:14%;">Returns the SV object
corresponding to the C variable "sv_no".</p>
<p style="margin-left:9%;">svref_2object(SVREF)</p>
<p style="margin-left:14%;">Takes a reference to any Perl
value, and turns the referred-to value into an object in the
appropriate B::OP−derived or B::SV−derived
class. Apart from functions such as "main_root",
this is the primary way to get an initial "handle"
on an internal perl data structure which can then be
followed with the other access methods.</p>
<p style="margin-left:14%; margin-top: 1em">The returned
object will only be valid as long as the underlying OPs and
SVs continue to exist. Do not attempt to use the object
after the underlying structures are freed.</p>
<p style="margin-left:9%;">amagic_generation</p>
<p style="margin-left:14%;">Returns the SV object
corresponding to the C variable
"amagic_generation". As of Perl 5.18, this is just
an alias to "PL_na", so its value is
meaningless.</p>
<p style="margin-left:9%;">init_av</p>
<p style="margin-left:14%;">Returns the AV object (i.e. in
class B::AV) representing INIT blocks.</p>
<p style="margin-left:9%;">check_av</p>
<p style="margin-left:14%;">Returns the AV object (i.e. in
class B::AV) representing CHECK blocks.</p>
<p style="margin-left:9%;">unitcheck_av</p>
<p style="margin-left:14%;">Returns the AV object (i.e. in
class B::AV) representing UNITCHECK blocks.</p>
<p style="margin-left:9%;">begin_av</p>
<p style="margin-left:14%;">Returns the AV object (i.e. in
class B::AV) representing BEGIN blocks.</p>
<p style="margin-left:9%;">end_av</p>
<p style="margin-left:14%;">Returns the AV object (i.e. in
class B::AV) representing END blocks.</p>
<p style="margin-left:9%;">comppadlist</p>
<p style="margin-left:14%;">Returns the PADLIST object
(i.e. in class B::PADLIST) of the global comppadlist. In
Perl 5.16 and earlier it returns an AV object (class
B::AV).</p>
<p style="margin-left:9%;">regex_padav</p>
<p style="margin-left:14%;">Only when perl was compiled
with ithreads.</p>
<p style="margin-left:9%;">main_cv</p>
<p style="margin-left:14%;">Return the (faked) CV
corresponding to the main part of the Perl program.</p>
<h3>Functions for Examining the Symbol Table
<a name="Functions for Examining the Symbol Table"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">walksymtable(SYMREF,
METHOD, RECURSE, PREFIX)</p>
<p style="margin-left:14%;">Walk the symbol table starting
at SYMREF and call METHOD on each symbol (a B::GV object)
visited. When the walk reaches package symbols (such as
"Foo::") it invokes RECURSE, passing in the symbol
name, and only recurses into the package if that sub returns
true.</p>
<p style="margin-left:14%; margin-top: 1em">PREFIX is the
name of the SYMREF you’re walking.</p>
<p style="margin-left:14%; margin-top: 1em">For
example:</p>
<p style="margin-left:14%; margin-top: 1em"># Walk CGI's
symbol table calling print_subs on each symbol. <br/>
# Recurse only into CGI::Util:: <br/>
walksymtable(\%CGI::, 'print_subs', <br/>
sub { $_[0] eq 'CGI::Util::' }, 'CGI::');</p>
<p style="margin-left:14%; margin-top: 1em"><b>print_subs()</b>
is a B::GV method you have declared. Also see "B::GV
Methods", below.</p>
<h3>Functions Returning "B::OP" objects or for walking op trees
<a name='Functions Returning "B::OP" objects or for walking op trees'></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">For descriptions
of the class hierarchy of these objects and the methods that
can be called on them, see below, "OVERVIEW OF
CLASSES" and "OP-RELATED CLASSES". <br/>
main_root</p>
<p style="margin-left:14%;">Returns the root op (i.e. an
object in the appropriate B::OP−derived class) of the
main part of the Perl program.</p>
<p style="margin-left:9%;">main_start</p>
<p style="margin-left:14%;">Returns the starting op of the
main part of the Perl program.</p>
<p style="margin-left:9%;">walkoptree(OP, METHOD)</p>
<p style="margin-left:14%;">Does a tree-walk of the syntax
tree based at OP and calls METHOD on each op it visits. Each
node is visited before its children. If
"walkoptree_debug" (see below) has been called to
turn debugging on then the method
"walkoptree_debug" is called on each op before
METHOD is called.</p>
<p style="margin-left:9%;">walkoptree_debug(DEBUG)</p>
<p style="margin-left:14%;">Returns the current debugging
flag for "walkoptree". If the optional DEBUG
argument is non-zero, it sets the debugging flag to that.
See the description of "walkoptree" above for what
the debugging flag does.</p>
<h3>Miscellaneous Utility Functions
<a name="Miscellaneous Utility Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">ppname(OPNUM)</p>
<p style="margin-left:14%;">Return the PP function name
(e.g. "pp_add") of op number OPNUM.</p>
<p style="margin-left:9%;">hash(STR)</p>
<p style="margin-left:14%;">Returns a string in the form
"0x..." representing the value of the internal
hash function used by perl on string STR.</p>
<p style="margin-left:9%;">cast_I32(I)</p>
<p style="margin-left:14%;">Casts I to the internal I32
type used by that perl.</p>
<p style="margin-left:9%;">minus_c</p>
<p style="margin-left:14%;">Does the equivalent of the
"−c" command-line option. Obviously, this is
only useful in a BEGIN block or else the flag is set too
late.</p>
<p style="margin-left:9%;">cstring(STR)</p>
<p style="margin-left:14%;">Returns a
double-quote-surrounded escaped version of STR which can be
used as a string in C source code.</p>
<p style="margin-left:9%;">perlstring(STR)</p>
<p style="margin-left:14%;">Returns a
double-quote-surrounded escaped version of STR which can be
used as a string in Perl source code.</p>
<p style="margin-left:9%;">safename(STR)</p>
<p style="margin-left:14%;">This function returns the
string with the first character modified if it is a control
character. It converts it to ˆX format first, so that
"\cG" becomes "ˆG". This is used
internally by B::GV::SAFENAME, but you can call it
directly.</p>
<p style="margin-left:9%;">class(OBJ)</p>
<p style="margin-left:14%;">Returns the class of an object
without the part of the classname preceding the first
"::". This is used to turn "B::UNOP"
into "UNOP" for example.</p>
<p style="margin-left:9%;">threadsv_names</p>
<p style="margin-left:14%;">This used to provide support
for the old 5.005 threading module. It now does nothing.</p>
<h3>Exported utility variables
<a name="Exported utility variables"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">@optype</p>
<p style="margin-left:14%;">my $op_type =
$optype[$op_type_num];</p>
<p style="margin-left:14%; margin-top: 1em">A simple
mapping of the op type number to its type (like
’COP’ or ’BINOP’).</p>
<p style="margin-left:9%;">@specialsv_name</p>
<p style="margin-left:14%;">my $sv_name =
$specialsv_name[$sv_index];</p>
<p style="margin-left:14%; margin-top: 1em">Certain SV
types are considered ’special’. They’re
represented by B::SPECIAL and are referred to by a number
from the specialsv_list. This array maps that number back to
the name of the SV (like ’Nullsv’ or
’&amp;PL_sv_undef’).</p>
<h2>OVERVIEW OF CLASSES
<a name="OVERVIEW OF CLASSES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The C structures
used by Perl’s internals to hold SV and OP information
(PVIV, AV, HV, ..., OP, SVOP, UNOP, ...) are modelled on a
class hierarchy and the "B" module gives access to
them via a true object hierarchy. Structure fields which
point to other objects (whether types of SV or types of OP)
are represented by the "B" module as Perl objects
of the appropriate class.</p>
<p style="margin-left:9%; margin-top: 1em">The bulk of the
"B" module is the methods for accessing fields of
these structures.</p>
<p style="margin-left:9%; margin-top: 1em">Note that all
access is read-only. You cannot modify the internals by
using this module. Also, note that the B::OP and B::SV
objects created by this module are only valid for as long as
the underlying objects exist; their creation doesn’t
increase the reference counts of the underlying objects.
Trying to access the fields of a freed object will give
incomprehensible results, or worse.</p>
<h3>SV-RELATED CLASSES
<a name="SV-RELATED CLASSES"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">B::IV, B::NV,
B::PV, B::PVIV, B::PVNV, B::PVMG, B::PVLV, B::AV, B::HV,
B::CV, B::GV, B::FM, B::IO. These classes correspond in the
obvious way to the underlying C structures of similar names.
The inheritance hierarchy mimics the underlying C
"inheritance":</p>
<p style="margin-left:9%; margin-top: 1em">B::SV <br/>
| <br/>

+−−−−−−−−−−−−+−−−−−−−−−−−−+
<br/>
| | | <br/>
B::PV B::IV B::NV <br/>
/ \ / / <br/>
/ \ / / <br/>
B::INVLIST B::PVIV / <br/>
\ / <br/>
\ / <br/>
\ / <br/>
B::PVNV <br/>
| <br/>
| <br/>
B::PVMG <br/>
| <br/>

+−−−−−−−+−−−−−−−+−−−+−−−+−−−−−−−+−−−−−−−+
<br/>
| | | | | | <br/>
B::AV B::GV B::HV B::CV B::IO B::REGEXP <br/>
| | <br/>
| | <br/>
B::PVLV B::FM</p>
<p style="margin-left:9%; margin-top: 1em">Access methods
correspond to the underlying C macros for field access,
usually with the leading "class indication" prefix
removed (Sv, Av, Hv, ...). The leading prefix is only left
in cases where its removal would cause a clash in method
name. For example, "GvREFCNT" stays as-is since
its abbreviation would clash with the "superclass"
method "REFCNT" (corresponding to the C function
"SvREFCNT").</p>
<h3>B::SV Methods
<a name="B::SV Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">REFCNT <br/>
FLAGS <br/>
IsBOOL</p>
<p style="margin-left:14%;">Returns true if the SV is a
boolean (true or false). You can then use "TRUE"
to check if the value is true or false.</p>
<p style="margin-left:14%; margin-top: 1em">my $something =
( 1 == 1 ) # boolean true <br/>
|| ( 1 == 0 ) # boolean false <br/>
|| 42 # IV true <br/>
|| 0; # IV false <br/>
my $sv = B::svref_2object(\$something); <br/>
say q[Not a boolean value] <br/>
if ! $sv−&gt;IsBOOL; <br/>
say q[This is a boolean with value: true] <br/>
if $sv−&gt;IsBOOL &amp;&amp; $sv−&gt;TRUE_nomg;
<br/>
say q[This is a boolean with value: false] <br/>
if $sv−&gt;IsBOOL &amp;&amp; !
$sv−&gt;TRUE_nomg;</p>
<p style="margin-left:9%;">object_2svref</p>
<p style="margin-left:14%;">Returns a reference to the
regular scalar corresponding to this B::SV object. In other
words, this method is the inverse operation to the
<b>svref_2object()</b> subroutine. This scalar and other
data it points at should be considered read-only: modifying
them is neither safe nor guaranteed to have a sensible
effect.</p>
<p style="margin-left:9%;">TRUE</p>
<p style="margin-left:14%;">Returns a boolean indicating
hether Perl would evaluate the SV as true or false.</p>
<p style="margin-left:14%; margin-top: 1em"><b>Warning</b>
this call performs ’get’ magic. If you only want
to check the nature of this SV use "TRUE_nomg"
helper.</p>
<p style="margin-left:14%; margin-top: 1em">This is an
alias for SvTRUE($sv).</p>
<p style="margin-left:9%;">TRUE_nomg</p>
<p style="margin-left:14%;">Check if the value is true (do
not perform ’get’ magic). Returns a boolean
indicating whether Perl would evaluate the SV as true or
false.</p>
<p style="margin-left:14%; margin-top: 1em">This is an
alias for SvTRUE_nomg($sv).</p>
<h3>B::IV Methods
<a name="B::IV Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">IV</p></td>
<td width="1%"></td>
<td width="86%">
<p style="margin-top: 1em">Returns the value of the IV,
<i>interpreted as a signed integer</i>. This will be
misleading if "FLAGS &amp; SVf_IVisUV". Perhaps
you want the "int_value" method instead?</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>IVX</p></td>
<td width="1%"></td>
<td width="86%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>UVX</p></td>
<td width="1%"></td>
<td width="86%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">int_value</p>
<p style="margin-left:14%;">This method returns the value
of the IV as an integer. It differs from "IV" in
that it returns the correct value regardless of whether
it’s stored signed or unsigned.</p>
<p style="margin-left:9%;">needs64bits <br/>
packiv</p>
<h3>B::NV Methods
<a name="B::NV Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">NV</p></td>
<td width="87%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>NVX</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">COP_SEQ_RANGE_LOW
<br/>
COP_SEQ_RANGE_HIGH</p>
<p style="margin-left:14%;">These last two are only valid
for pad name SVs. They only existed in the B::NV class
before Perl 5.22. In 5.22 they were moved to the B::PADNAME
class.</p>
<h3>B::RV Methods
<a name="B::RV Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em">RV</p></td>
<td width="88%">
</td></tr>
</table>
<h3>B::PV Methods
<a name="B::PV Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">PV</p></td>
<td width="1%"></td>
<td width="86%">
<p style="margin-top: 1em">This method is the one you
usually want. It constructs a string using the length and
offset information in the struct: for ordinary scalars it
will return the string that you’d see from Perl, even
if it contains null characters.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>RV</p></td>
<td width="1%"></td>
<td width="86%">
<p>Same as B::RV::RV, except that it will <b>die()</b> if
the PV isn’t a reference.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>PVX</p></td>
<td width="1%"></td>
<td width="86%">
<p>This method is less often useful. It assumes that the
string stored in the struct is null-terminated, and
disregards the length information.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">It is the
appropriate method to use if you need to get the name of a
lexical variable from a padname array. Lexical variable
names are always stored with a null terminator, and the
length field (CUR) is overloaded for other purposes and
can’t be relied on here.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">CUR</p></td>
<td width="1%"></td>
<td width="86%">
<p style="margin-top: 1em">This method returns the internal
length field, which consists of the number of internal
bytes, not necessarily the number of logical characters.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>LEN</p></td>
<td width="1%"></td>
<td width="86%">
<p>This method returns the number of bytes allocated (via
malloc) for storing the string. This is 0 if the scalar does
not "own" the string.</p></td></tr>
</table>
<h3>B::PVMG Methods
<a name="B::PVMG Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">MAGIC <br/>
SvSTASH</p>
<h3>B::MAGIC Methods
<a name="B::MAGIC Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">MOREMAGIC <br/>
precomp</p>
<p style="margin-left:14%;">Only valid on r−magic,
returns the string that generated the regexp.</p>
<p style="margin-left:9%;">PRIVATE <br/>
TYPE <br/>
FLAGS</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>OBJ</p></td>
<td width="1%"></td>
<td width="41%">
<p>Will <b>die()</b> if called on r−magic.</p></td>
<td width="45%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>PTR</p></td>
<td width="1%"></td>
<td width="41%"></td>
<td width="45%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">REGEX</p>
<p style="margin-left:14%;">Only valid on r−magic,
returns the integer value of the REGEX stored in the
MAGIC.</p>
<h3>B::INVLIST Methods
<a name="B::INVLIST Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">prev_index</p>
<p style="margin-left:14%;">Returns the cache result of
previous <b>invlist_search()</b> (internal usage)</p>
<p style="margin-left:9%;">is_offset</p>
<p style="margin-left:14%;">Returns a boolean value (0 or
1) to know if the invlist is using an offset. When false the
list begins with the code point U+0000. When true the list
begins with the following elements.</p>
<p style="margin-left:9%;">array_len</p>
<p style="margin-left:14%;">Returns an integer with the
size of the array used to define the invlist.</p>
<p style="margin-left:9%;">get_invlist_array</p>
<p style="margin-left:14%;">This method returns a list of
integers representing the array used by the invlist. Note:
this cannot be used while in middle of iterating on an
invlist and croaks.</p>
<h3>B::PVLV Methods
<a name="B::PVLV Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">TARGOFF <br/>
TARGLEN <br/>
TYPE <br/>
TARG</p>
<h3>B::BM Methods
<a name="B::BM Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">USEFUL <br/>
PREVIOUS <br/>
RARE <br/>
TABLE</p>
<h3>B::REGEXP Methods
<a name="B::REGEXP Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">REGEX <br/>
precomp <br/>
qr_anoncv <br/>
compflags</p>
<p style="margin-left:14%;">The last two were added in Perl
5.22.</p>
<h3>B::GV Methods
<a name="B::GV Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">is_empty</p>
<p style="margin-left:14%;">This method returns TRUE if the
GP field of the GV is NULL.</p>
<p style="margin-left:9%;">NAME <br/>
SAFENAME</p>
<p style="margin-left:14%;">This method returns the name of
the glob, but if the first character of the name is a
control character, then it converts it to ˆX first, so
that *ˆG would return "ˆG" rather than
"\cG".</p>
<p style="margin-left:14%; margin-top: 1em">It’s
useful if you want to print out the name of a variable. If
you restrict yourself to globs which exist at compile-time
then the result ought to be unambiguous, because code like
"${"ˆG"} = 1" is compiled as two
ops − a constant string and a dereference (rv2gv)
− so that the glob is created at runtime.</p>
<p style="margin-left:14%; margin-top: 1em">If you’re
working with globs at runtime, and need to disambiguate
*ˆG from *{"ˆG"}, then you should use
the raw NAME method.</p>
<p style="margin-left:9%;">STASH</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>SV</p></td>
<td width="88%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>IO</p></td>
<td width="88%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">FORM</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>AV</p></td>
<td width="87%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>HV</p></td>
<td width="87%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>EGV</p></td>
<td width="87%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>CV</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">CVGEN <br/>
LINE <br/>
FILE <br/>
FILEGV <br/>
GvREFCNT <br/>
FLAGS <br/>
GPFLAGS</p>
<p style="margin-left:14%;">This last one is present only
in perl 5.22.0 and higher.</p>
<h3>B::IO Methods
<a name="B::IO Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">B::IO objects
derive from IO objects and you will get more information
from the IO object itself.</p>
<p style="margin-left:9%; margin-top: 1em">For example:</p>
<p style="margin-left:9%; margin-top: 1em">$gvio =
B::svref_2object(\*main::stdin)−&gt;IO; <br/>
$IO = $gvio−&gt;object_2svref(); <br/>
$fd = $IO−&gt;fileno(); <br/>
LINES <br/>
PAGE <br/>
PAGE_LEN <br/>
LINES_LEFT <br/>
TOP_NAME <br/>
TOP_GV <br/>
FMT_NAME <br/>
FMT_GV <br/>
BOTTOM_NAME <br/>
BOTTOM_GV <br/>
SUBPROCESS <br/>
IoTYPE</p>
<p style="margin-left:14%;">A character symbolizing the
type of IO Handle.</p>
<p style="margin-left:14%; margin-top: 1em">−
STDIN/OUT <br/>
I STDIN/OUT/ERR <br/>
&lt; read−only <br/>
&gt; write−only <br/>
a append <br/>
+ read and write <br/>
s socket <br/>
| pipe <br/>
I IMPLICIT <br/>
# NUMERIC <br/>
space closed handle <br/>
\0 closed internal handle</p>
<p style="margin-left:9%;">IoFLAGS <br/>
IsSTD</p>
<p style="margin-left:14%;">Takes one argument (
’stdin’ | ’stdout’ |
’stderr’ ) and returns true if the IoIFP of the
object is equal to the handle whose name was passed as
argument; i.e., $io−&gt;IsSTD(’stderr’) is
true if IoIFP($io) == <b>PerlIO_stderr()</b>.</p>
<h3>B::AV Methods
<a name="B::AV Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">FILL</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>MAX</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">ARRAY <br/>
ARRAYelt</p>
<p style="margin-left:14%;">Like "ARRAY", but
takes an index as an argument to get only one element,
rather than a list of all of them.</p>
<h3>B::CV Methods
<a name="B::CV Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">STASH <br/>
START <br/>
ROOT</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>GV</p></td>
<td width="88%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">FILE <br/>
DEPTH <br/>
PADLIST</p>
<p style="margin-left:14%;">Returns a B::PADLIST
object.</p>
<p style="margin-left:9%;">OUTSIDE <br/>
OUTSIDE_SEQ <br/>
XSUB <br/>
XSUBANY</p>
<p style="margin-left:14%;">For constant subroutines,
returns the constant SV returned by the subroutine.</p>
<p style="margin-left:9%;">CvFLAGS <br/>
const_sv <br/>
NAME_HEK</p>
<p style="margin-left:14%;">Returns the name of a lexical
sub, otherwise "undef".</p>
<h3>B::HV Methods
<a name="B::HV Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">FILL</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>MAX</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">KEYS <br/>
RITER <br/>
NAME <br/>
ARRAY</p>
<h3>OP-RELATED CLASSES
<a name="OP-RELATED CLASSES"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"B::OP",
"B::UNOP", "B::UNOP_AUX",
"B::BINOP", "B::LOGOP",
"B::LISTOP", "B::PMOP",
"B::SVOP", "B::PADOP",
"B::PVOP", "B::LOOP",
"B::COP", "B::METHOP".</p>
<p style="margin-left:9%; margin-top: 1em">These classes
correspond in the obvious way to the underlying C structures
of similar names. The inheritance hierarchy mimics the
underlying C "inheritance":</p>
<p style="margin-left:9%; margin-top: 1em">B::OP <br/>
| <br/>

+−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−−−+
<br/>
| | | | | | <br/>
B::UNOP B::SVOP B::PADOP B::COP B::PVOP B::METHOP <br/>
| <br/>

+−−−+−−−+−−−−−−−−−+
<br/>
| | | <br/>
B::BINOP B::LOGOP B::UNOP_AUX <br/>
| <br/>
| <br/>
B::LISTOP <br/>
| <br/>
+−−−+−−−+ <br/>
| | <br/>
B::LOOP B::PMOP</p>
<p style="margin-left:9%; margin-top: 1em">Access methods
correspond to the underlying C structure field names, with
the leading "class indication" prefix
("op_") removed.</p>
<h3>B::OP Methods
<a name="B::OP Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">These methods
get the values of similarly named fields within the OP data
structure. See top of "op.h" for more info. <br/>
next <br/>
sibling <br/>
parent</p>
<p style="margin-left:14%;">Returns the OP’s parent.
If it has no parent, or if your perl wasn’t built with
"−DPERL_OP_PARENT", returns NULL.</p>
<p style="margin-left:14%; margin-top: 1em">Note that the
global variable $B::OP::does_parent is undefined on older
perls that don’t support the "parent"
method, is defined but false on perls that support the
method but were built without
"−DPERL_OP_PARENT", and is true
otherwise.</p>
<p style="margin-left:9%;">name</p>
<p style="margin-left:14%;">This returns the op name as a
string (e.g. "add", "rv2av").</p>
<p style="margin-left:9%;">ppaddr</p>
<p style="margin-left:14%;">This returns the function name
as a string (e.g. "PL_ppaddr[OP_ADD]",
"PL_ppaddr[OP_RV2AV]").</p>
<p style="margin-left:9%;">desc</p>
<p style="margin-left:14%;">This returns the op description
from the global C PL_op_desc array (e.g.
"addition" "array deref").</p>
<p style="margin-left:9%;">targ <br/>
type</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>opt</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">flags <br/>
private <br/>
spare</p>
<h3>B::UNOP Method
<a name="B::UNOP Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">first</p>
<h3>B::UNOP_AUX Methods (since 5.22)
<a name="B::UNOP_AUX Methods (since 5.22)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">aux_list(cv)</p>
<p style="margin-left:14%;">This returns a list of the
elements of the op’s aux data structure, or a null
list if there is no aux. What will be returned depends on
the object’s type, but will typically be a collection
of "B::IV", "B::GV", etc. objects.
"cv" is the "B::CV" object representing
the sub that the op is contained within.</p>
<p style="margin-left:9%;">string(cv)</p>
<p style="margin-left:14%;">This returns a textual
representation of the object (likely to b useful for
deparsing and debugging), or an empty string if the op type
doesn’t support this. "cv" is the
"B::CV" object representing the sub that the op is
contained within.</p>
<h3>B::BINOP Method
<a name="B::BINOP Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">last</p>
<h3>B::LOGOP Method
<a name="B::LOGOP Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">other</p>
<h3>B::LISTOP Method
<a name="B::LISTOP Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">children</p>
<h3>B::PMOP Methods
<a name="B::PMOP Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">pmreplroot <br/>
pmreplstart <br/>
pmflags <br/>
precomp <br/>
pmoffset</p>
<p style="margin-left:14%;">Only when perl was compiled
with ithreads.</p>
<p style="margin-left:9%;">code_list</p>
<p style="margin-left:14%;">Since perl 5.17.1</p>
<p style="margin-left:9%;">pmregexp</p>
<p style="margin-left:14%;">Added in perl 5.22, this method
returns the B::REGEXP associated with the op. While PMOPs do
not actually have "pmregexp" fields under threaded
builds, this method returns the regexp under threads
nonetheless, for convenience.</p>
<h3>B::SVOP Methods
<a name="B::SVOP Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em">sv</p></td>
<td width="88%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>gv</p></td>
<td width="88%">
</td></tr>
</table>
<h3>B::PADOP Method
<a name="B::PADOP Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">padix</p>
<h3>B::PVOP Method
<a name="B::PVOP Method"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em">pv</p></td>
<td width="88%">
</td></tr>
</table>
<h3>B::LOOP Methods
<a name="B::LOOP Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">redoop <br/>
nextop <br/>
lastop</p>
<h3>B::COP Methods
<a name="B::COP Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
"B::COP" class is used for "nextstate"
and "dbstate" ops. As of Perl 5.22, it is also
used for "null" ops that started out as COPs. <br/>
label <br/>
stash <br/>
stashpv <br/>
stashoff (threaded only) <br/>
file <br/>
cop_seq <br/>
line <br/>
warnings</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>io</p></td>
<td width="88%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">hints <br/>
hints_hash</p>
<h3>B::METHOP Methods (Since Perl 5.22)
<a name="B::METHOP Methods (Since Perl 5.22)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">first <br/>
meth_sv</p>
<h3>PAD-RELATED CLASSES
<a name="PAD-RELATED CLASSES"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Perl 5.18
introduced a new class, B::PADLIST, returned by
B::CV’s "PADLIST" method.</p>
<p style="margin-left:9%; margin-top: 1em">Perl 5.22
introduced the B::PADNAMELIST and B::PADNAME classes.</p>
<h3>B::PADLIST Methods
<a name="B::PADLIST Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">MAX</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">ARRAY</p>
<p style="margin-left:14%;">A list of pads. The first one
is a B::PADNAMELIST containing the names. The rest are
currently B::AV objects, but that could change in future
versions.</p>
<p style="margin-left:9%;">ARRAYelt</p>
<p style="margin-left:14%;">Like "ARRAY", but
takes an index as an argument to get only one element,
rather than a list of all of them.</p>
<p style="margin-left:9%;">NAMES</p>
<p style="margin-left:14%;">This method, introduced in
5.22, returns the B::PADNAMELIST. It is equivalent to
"ARRAYelt" with a 0 argument.</p>
<p style="margin-left:9%;">REFCNT</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>id</p></td>
<td width="2%"></td>
<td width="86%">
<p>This method, introduced in 5.22, returns an ID shared by
clones of the same padlist.</p></td></tr>
</table>
<p style="margin-left:9%;">outid</p>
<p style="margin-left:14%;">This method, also added in
5.22, returns the ID of the outer padlist.</p>
<h3>B::PADNAMELIST Methods
<a name="B::PADNAMELIST Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">MAX</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">ARRAY <br/>
ARRAYelt</p>
<p style="margin-left:14%;">These two methods return the
pad names, using B::SPECIAL objects for null pointers and
B::PADNAME objects otherwise.</p>
<p style="margin-left:9%;">REFCNT</p>
<h3>B::PADNAME Methods
<a name="B::PADNAME Methods"></a>
</h3>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p style="margin-top: 1em">PV</p></td>
<td width="87%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>PVX</p></td>
<td width="87%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>LEN</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">REFCNT</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>GEN</p></td>
<td width="87%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">FLAGS</p>
<p style="margin-left:14%;">For backward-compatibility, if
the PADNAMEt_OUTER flag is set, the FLAGS method adds the
SVf_FAKE flag, too.</p>
<p style="margin-left:9%;">TYPE</p>
<p style="margin-left:14%;">A B::HV object representing the
stash for a typed lexical.</p>
<p style="margin-left:9%;">SvSTASH</p>
<p style="margin-left:14%;">A backward-compatibility alias
for TYPE.</p>
<p style="margin-left:9%;">OURSTASH</p>
<p style="margin-left:14%;">A B::HV object representing the
stash for ’our’ variables.</p>
<p style="margin-left:9%;">PROTOCV</p>
<p style="margin-left:14%;">The prototype CV for a
’my’ sub.</p>
<p style="margin-left:9%;">COP_SEQ_RANGE_LOW <br/>
COP_SEQ_RANGE_HIGH</p>
<p style="margin-left:14%;">Sequence numbers representing
the scope within which a lexical is visible. Meaningless if
PADNAMEt_OUTER is set.</p>
<p style="margin-left:9%;">PARENT_PAD_INDEX</p>
<p style="margin-left:14%;">Only meaningful if
PADNAMEt_OUTER is set.</p>
<p style="margin-left:9%;">PARENT_FAKELEX_FLAGS</p>
<p style="margin-left:14%;">Only meaningful if
PADNAMEt_OUTER is set.</p>
<p style="margin-left:9%;">IsUndef</p>
<p style="margin-left:14%;">Returns a boolean value to
check if the padname is PL_padname_undef.</p>
<h3>$B::overlay
<a name="$B::overlay"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Although the
optree is read-only, there is an overlay facility that
allows you to override what values the various B::*OP
methods return for a particular op. $B::overlay should be
set to reference a two-deep hash: indexed by OP address,
then method name. Whenever a an op method is called, the
value in the hash is returned if it exists. This facility is
used by B::Deparse to "undo" some optimisations.
For example:</p>
<p style="margin-left:9%; margin-top: 1em">local
$B::overlay = {}; <br/>
... <br/>
if ($op−&gt;name eq "foo") { <br/>
$B::overlay−&gt;{$$op} = { <br/>
name =&gt; 'bar', <br/>
next =&gt; $op−&gt;next−&gt;next, <br/>
}; <br/>
} <br/>
... <br/>
$op−&gt;name # returns "bar" <br/>
$op−&gt;next # returns the next op but one</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Malcolm Beattie,
"mbeattie@sable.ox.ac.uk"</p>
<hr/>
</body>
</html>
