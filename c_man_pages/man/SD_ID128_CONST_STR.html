<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:48:52 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>SD−ID128</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">SD−ID128</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#NOTES">NOTES</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">sd-id128,
SD_ID128_ALLF, SD_ID128_CONST_STR, SD_ID128_FORMAT_STR,
SD_ID128_FORMAT_VAL, SD_ID128_MAKE, SD_ID128_MAKE_STR,
SD_ID128_MAKE_UUID_STR, SD_ID128_NULL,
SD_ID128_UUID_FORMAT_STR, sd_id128_equal,
sd_id128_string_equal, sd_id128_in_set,
sd_id128_in_set_sentinel, sd_id128_in_setv,
sd_id128_is_allf, sd_id128_is_null, sd_id128_t − APIs
for processing 128−bit IDs</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;systemd/sd−id128.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_ALLF</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_NULL</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_CONST_STR(</b><i>id</i><b>)</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_FORMAT_STR</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_FORMAT_VAL(</b><i>id</i><b>)</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_MAKE(</b><i>v0</i><b>,</b>
<i>v1</i><b>,</b> <i>v2</i><b>,</b> <i>v3</i><b>,</b>
<i>v4</i><b>,</b> <i>v5</i><b>,</b> <i>v6</i><b>,</b>
<i>v7</i><b>,</b> <i>v8</i><b>,</b> <i>v9</i><b>,</b>
<i>vA</i><b>,</b> <i>vB</i><b>,</b> <i>vC</i><b>,</b>
<i>vD</i><b>,</b> <i>vE</i><b>,</b> <i>vF</i><b>)</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_MAKE_STR(</b><i>v0</i><b>,</b>
<i>v1</i><b>,</b> <i>v2</i><b>,</b> <i>v3</i><b>,</b>
<i>v4</i><b>,</b> <i>v5</i><b>,</b> <i>v6</i><b>,</b>
<i>v7</i><b>,</b> <i>v8</i><b>,</b> <i>v9</i><b>,</b>
<i>vA</i><b>,</b> <i>vB</i><b>,</b> <i>vC</i><b>,</b>
<i>vD</i><b>,</b> <i>vE</i><b>,</b> <i>vF</i><b>)</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_MAKE_UUID_STR(</b><i>v0</i><b>,</b>
<i>v1</i><b>,</b> <i>v2</i><b>,</b> <i>v3</i><b>,</b>
<i>v4</i><b>,</b> <i>v5</i><b>,</b> <i>v6</i><b>,</b>
<i>v7</i><b>,</b> <i>v8</i><b>,</b> <i>v9</i><b>,</b>
<i>vA</i><b>,</b> <i>vB</i><b>,</b> <i>vC</i><b>,</b>
<i>vD</i><b>,</b> <i>vE</i><b>,</b> <i>vF</i><b>)</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>SD_ID128_UUID_FORMAT_STR</b></p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_equal(sd_id128_t </b><i>a</i><b>,
sd_id128_t </b><i>b</i><b>);</b></p> </td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_string_equal(const char *</b><i>a</i><b>,
sd_id128_t </b><i>b</i><b>);</b></p> </td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_is_null(sd_id128_t </b><i>id</i><b>);</b></p> </td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_is_allf(sd_id128_t </b><i>id</i><b>);</b></p> </td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_in_setv(sd_id128_t </b><i>id</i><b>,
va_list </b><i>ap</i><b>);</b></p> </td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_in_set_sentinel(sd_id128_t </b><i>id</i><b>,
..., SD_ID128_NULL);</b></p></td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>int
sd_id128_in_set(sd_id128_t </b><i>id</i><b>,
...);</b></p> </td>
<td width="9%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="82%">
<p style="margin-top: 1em"><b>pkg−config
−−cflags −−libs libsystemd</b></p></td>
<td width="9%">
</td></tr>
</table>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">sd−id128.h
is part of <b>libsystemd</b>(3) and provides APIs to
generate, convert, and compare 128−bit ID values. The
128−bit ID values processed and generated by these
APIs are a generalization of OSF UUIDs as defined by
<b><font color="#0000FF">RFC 4122</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">but use a simpler string format. These
functions impose no structure on the used IDs, much unlike
OSF UUIDs or Microsoft GUIDs, but are mostly compatible with
those types of IDs.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">A
128−bit ID is implemented as the following union
type:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">typedef
union sd_id128 { <br/>
uint8_t bytes[16]; <br/>
uint64_t qwords[2]; <br/>
} sd_id128_t;</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">This
union type allows accessing the 128−bit ID as 16
separate bytes or two 64−bit words. It is generally
safer to access the ID components by their 8−bit array
to avoid endianness issues. This union is intended to be
passed by value (as opposed to
pass−by−reference) and may be directly
manipulated by clients.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">A
couple of macros are defined to denote and decode
128−bit IDs:</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_MAKE()</b>
is used to write a constant ID in source code. A commonly
used idiom is to assign a name to an ID using this
macro:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">#define
SD_MESSAGE_COREDUMP
SD_ID128_MAKE(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_NULL</b>
defines an ID consisting of only <b>NUL</b> bytes (i.e. all
bits off).</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_ALLF</b>
defines an ID consisting of only <b>0xFF</b> bytes (i.e. all
bits on).</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_MAKE_STR()</b>
is similar to <b>SD_ID128_MAKE()</b>, but creates a <b>const
char*</b> expression that can be conveniently used in
message formats and such:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">#include
&lt;stdio.h&gt; <br/>
#define SD_MESSAGE_COREDUMP_STR
SD_ID128_MAKE_STR(fc,2e,22,bc,6e,e6,47,b6,b9,07,29,ab,34,a2,50,b1)</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">int
main(int argc, char **argv) { <br/>
puts("Match for coredumps: MESSAGE_ID="
SD_MESSAGE_COREDUMP_STR); <br/>
}</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_CONST_STR()</b>
converts constant IDs into constant strings for output. The
following example code will output the string
"fc2e22bc6ee647b6b90729ab34a250b1":</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br/>
puts("Match for coredumps: %s",
SD_ID128_CONST_STR(SD_MESSAGE_COREDUMP)); <br/>
}</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_FORMAT_STR</b>
and <b>SD_ID128_FORMAT_VAL()</b> is used to format an ID in
a <b>printf</b>(3) format string, as shown in the following
example:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br/>
sd_id128_t id; <br/>
id =
SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
<br/>
printf("The ID encoded in this C file is "
SD_ID128_FORMAT_STR ".\n",
SD_ID128_FORMAT_VAL(id)); <br/>
return 0; <br/>
}</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>SD_ID128_UUID_FORMAT_STR</b>
and <b>SD_ID128_MAKE_UUID_STR()</b> are similar to
<b>SD_ID128_FORMAT_STR</b> and <b>SD_ID128_MAKE_STR()</b>,
but include separating hyphens to conform to the
"</font><b><font color="#0000FF">UUID canonical
representation</font></b>
<small><font color="#000000">[2]</font></small>
<font color="#000000">". They format the string based
on</font> <b><font color="#0000FF">RFC4122</font></b>
<small><font color="#000000">[1]</font></small>
<font color="#000000">Variant 1 rules, i.e. converting from
Big Endian byte order. This matches behaviour of most other
Linux userspace infrastructure. It's probably best to avoid
UUIDs of other variants, in order to avoid unnecessary
ambiguities. All 128−bit IDs generated by the
sd−id128 APIs strictly conform to Variant 1 Version 4
UUIDs, as per RFC 4122.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_equal()</b>
compares two 128−bit IDs:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br/>
sd_id128_t a, b, c; <br/>
a =
SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
<br/>
b =
SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e);
<br/>
c = a; <br/>
assert(sd_id128_equal(a, c)); <br/>
assert(!sd_id128_equal(a, b)); <br/>
return 0; <br/>
}</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_string_equal()</b>
is similar to <b>sd_id128_equal()</b>, but the first ID is
formatted as <b>const char*</b>. The same restrictions apply
as to the first argument of
<b>sd_id128_from_string()</b>.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_is_null()</b>
checks if an ID consists of only <b>NUL</b>
bytes:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">assert(sd_id128_is_null(SD_ID128_NULL));</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Similarly,
<b>sd_id128_is_allf()</b> checks if an ID consists of only
<b>0xFF</b> bytes (all bits on):</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">assert(sd_id128_is_allf(SD_ID128_ALLF));</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_set_sentinel()</b>
takes a list of IDs and returns true if the first argument
is equal to any of the subsequent arguments. The argument
list is terminated by an <b>SD_ID128_NULL</b> sentinel,
which must be present.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_set()</b>
is a convenience function that takes a list of IDs and
returns true if the first argument is equal to any of the
subsequent arguments:</font></p>
<p style="margin-left:14%; margin-top: 1em"><font color="#000000">int
main(int argc, char *argv[]) { <br/>
sd_id12_t a =
SD_ID128_MAKE(ee,89,be,71,bd,6e,43,d6,91,e6,c5,5d,eb,03,02,07);
<br/>
assert(sd_id128_in_set(a, a)); <br/>
assert(sd_id128_in_set(a, a, a)); <br/>
assert(!sd_id128_in_set(a)); <br/>
assert(!sd_id128_in_set(a, <br/>

SD_ID128_MAKE(f2,28,88,9c,5f,09,44,15,9d,d7,04,77,58,cb,e7,3e)
<br/>

SD_ID128_MAKE(2f,88,28,5f,9c,44,09,9d,d7,15,77,04,bc,85,7e,e3)
<br/>
SD_ID128_ALLF)); <br/>
return 0; <br/>
}</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_set()</b>
is defined as a macro over
<b>sd_id128_in_set_sentinel()</b>, adding the
<b>SD_ID128_NULL</b> sentinel automatically. Since
<b>sd_id128_in_set_sentinel()</b> uses <b>SD_ID128_NULL</b>
as the sentinel, <b>SD_ID128_NULL</b> cannot be otherwise
placed in the argument list.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_in_setv()</b>
is similar to <b>sd_id128_in_set_sentinel()</b>, but takes a
struct varargs argument.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">New
randomized IDs may be generated with
<b>systemd-id128</b>(1)'s <b>new</b> command.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">See
<b>sd_id128_to_string</b>(3), <b>sd_id128_randomize</b>(3)
and <b>sd_id128_get_machine</b>(3) for information about
other implemented functions.</font></p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">Functions
described here are available as a shared library, which can
be compiled against and linked to with the
<b>libsystemd pkg-config</b>(1) file.</font></p>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000">The
code described here uses <b>getenv</b>(3), which is declared
to be not multi−thread−safe. This means that the
code calling the functions described here must not call
<b>setenv</b>(3) from a parallel thread. It is recommended
to only do calls to <b>setenv()</b> from an early phase of
the program when no other threads have been
started.</font></p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>sd_id128_equal()</b>,
<b>sd_id128_string_equal()</b>, <b>sd_id128_is_null()</b>,
<b>sd_id128_is_allf()</b>, <b>sd_id128_in_setv()</b>,
<b>sd_id128_in_set_sentinel()</b>, and
<b>sd_id128_in_set()</b> were added in version
252.</font></p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><font color="#000000"><b>systemd</b>(1),
<b>sd_id128_to_string</b>(3), <b>sd_id128_randomize</b>(3),
<b>sd_id128_get_machine</b>(3), <b>printf</b>(3),
<b>journalctl</b>(1), <b>sd-journal</b>(3),
<b>pkg-config</b>(1), <b>machine-id</b>(5)</font></p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="10%"></td>
<td width="3%">
<p style="margin-top: 1em"><font color="#000000">1.</font></p> </td>
<td width="1%"></td>
<td width="10%">
<p style="margin-top: 1em"><font color="#000000">RFC
4122</font></p> </td>
<td width="76%">
</td></tr>
</table>
<p style="margin-left:14%;"><font color="#000000">https://tools.ietf.org/html/rfc4122</font></p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="10%"></td>
<td width="3%">
<p style="margin-top: 1em"><font color="#000000">2.</font></p> </td>
<td width="1%"></td>
<td width="37%">
<p style="margin-top: 1em"><font color="#000000">UUID
canonical representation</font></p></td>
<td width="49%">
</td></tr>
</table>
<p style="margin-left:14%;"><font color="#000000">https://en.wikipedia.org/wiki/Universally_unique_identifier#Format</font></p>
<hr/>
</body>
</html>
