<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:40:39 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>bpf</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">bpf</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Extended BPF Design/Architecture">Extended BPF Design/Architecture</a><br/>
<a href="#Arguments">Arguments</a><br/>
<a href="#eBPF maps">eBPF maps</a><br/>
<a href="#eBPF map types">eBPF map types</a><br/>
<a href="#eBPF programs">eBPF programs</a><br/>
<a href="#eBPF program types">eBPF program types</a><br/>
<a href="#Events">Events</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">bpf −
perform a command on an extended BPF map or program</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;linux/bpf.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
bpf(int</b> <i>cmd</i><b>, union bpf_attr
*</b><i>attr</i><b>, unsigned int</b>
<i>size</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The <b>bpf</b>()
system call performs a range of operations related to
extended Berkeley Packet Filters. Extended BPF (or eBPF) is
similar to the original ("classic") BPF (cBPF)
used to filter network packets. For both cBPF and eBPF
programs, the kernel statically analyzes the programs before
loading them, in order to ensure that they cannot harm the
running system.</p>
<p style="margin-left:9%; margin-top: 1em">eBPF extends
cBPF in multiple ways, including the ability to call a fixed
set of in-kernel helper functions (via the <b>BPF_CALL</b>
opcode extension provided by eBPF) and access shared data
structures such as eBPF maps.</p>
<h3>Extended BPF Design/Architecture
<a name="Extended BPF Design/Architecture"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">eBPF maps are a
generic data structure for storage of different data types.
Data types are generally treated as binary blobs, so a user
just specifies the size of the key and the size of the value
at map-creation time. In other words, a key/value for a
given map can have an arbitrary structure.</p>
<p style="margin-left:9%; margin-top: 1em">A user process
can create multiple maps (with key/value-pairs being opaque
bytes of data) and access them via file descriptors.
Different eBPF programs can access the same maps in
parallel. It’s up to the user process and eBPF program
to decide what they store inside maps.</p>
<p style="margin-left:9%; margin-top: 1em">There’s
one special map type, called a program array. This type of
map stores file descriptors referring to other eBPF
programs. When a lookup in the map is performed, the program
flow is redirected in-place to the beginning of another eBPF
program and does not return back to the calling program. The
level of nesting has a fixed limit of 32, so that infinite
loops cannot be crafted. At run time, the program file
descriptors stored in the map can be modified, so program
functionality can be altered based on specific requirements.
All programs referred to in a program-array map must have
been previously loaded into the kernel via <b>bpf</b>(). If
a map lookup fails, the current program continues its
execution. See <b>BPF_MAP_TYPE_PROG_ARRAY</b> below for
further details.</p>
<p style="margin-left:9%; margin-top: 1em">Generally, eBPF
programs are loaded by the user process and automatically
unloaded when the process exits. In some cases, for example,
<b>tc−bpf</b>(8), the program will continue to stay
alive inside the kernel even after the process that loaded
the program exits. In that case, the tc subsystem holds a
reference to the eBPF program after the file descriptor has
been closed by the user-space program. Thus, whether a
specific program continues to live inside the kernel depends
on how it is further attached to a given kernel subsystem
after it was loaded via <b>bpf</b>().</p>
<p style="margin-left:9%; margin-top: 1em">Each eBPF
program is a set of instructions that is safe to run until
its completion. An in-kernel verifier statically determines
that the eBPF program terminates and is safe to execute.
During verification, the kernel increments reference counts
for each of the maps that the eBPF program uses, so that the
attached maps can’t be removed until the program is
unloaded.</p>
<p style="margin-left:9%; margin-top: 1em">eBPF programs
can be attached to different events. These events can be the
arrival of network packets, tracing events, classification
events by network queueing disciplines (for eBPF programs
attached to a <b>tc</b>(8) classifier), and other types that
may be added in the future. A new event triggers execution
of the eBPF program, which may store information about the
event in eBPF maps. Beyond storing data, eBPF programs may
call a fixed set of in-kernel helper functions.</p>
<p style="margin-left:9%; margin-top: 1em">The same eBPF
program can be attached to multiple events and different
eBPF programs can access the same map:</p>
<p style="margin-left:14%; margin-top: 1em">tracing tracing
tracing packet packet packet <br/>
event A event B event C on eth0 on eth1 on eth2 <br/>
| | | | | ^ <br/>
| | | | v | <br/>
−−&gt; tracing &lt;−− tracing socket
tc ingress tc egress <br/>
prog_1 prog_2 prog_3 classifier action <br/>
| | | | prog_4 prog_5 <br/>
|−−− −−−−−|
|−−−−−−| map_3 | | <br/>
map_1 map_2 −−| map_4 |−−</p>
<h3>Arguments
<a name="Arguments"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The operation to
be performed by the <b>bpf</b>() system call is determined
by the <i>cmd</i> argument. Each operation takes an
accompanying argument, provided via <i>attr</i>, which is a
pointer to a union of type <i>bpf_attr</i> (see below). The
unused fields and padding must be zeroed out before the
call. The <i>size</i> argument is the size of the union
pointed to by <i>attr</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The value
provided in <i>cmd</i> is one of the following: <b><br/>
BPF_MAP_CREATE</b></p>
<p style="margin-left:18%;">Create a map and return a file
descriptor that refers to the map. The close-on-exec file
descriptor flag (see <b>fcntl</b>(2)) is automatically
enabled for the new file descriptor.</p>
<p style="margin-left:9%;"><b>BPF_MAP_LOOKUP_ELEM</b></p>
<p style="margin-left:18%;">Look up an element by key in a
specified map and return its value.</p>
<p style="margin-left:9%;"><b>BPF_MAP_UPDATE_ELEM</b></p>
<p style="margin-left:18%;">Create or update an element
(key/value pair) in a specified map.</p>
<p style="margin-left:9%;"><b>BPF_MAP_DELETE_ELEM</b></p>
<p style="margin-left:18%;">Look up and delete an element
by key in a specified map.</p>
<p style="margin-left:9%;"><b>BPF_MAP_GET_NEXT_KEY</b></p>
<p style="margin-left:18%;">Look up an element by key in a
specified map and return the key of the next element.</p>
<p style="margin-left:9%;"><b>BPF_PROG_LOAD</b></p>
<p style="margin-left:18%;">Verify and load an eBPF
program, returning a new file descriptor associated with the
program. The close-on-exec file descriptor flag (see
<b>fcntl</b>(2)) is automatically enabled for the new file
descriptor.</p>
<p style="margin-left:18%; margin-top: 1em">The
<i>bpf_attr</i> union consists of various anonymous
structures that are used by different <b>bpf</b>()
commands:</p>
<p style="margin-left:14%; margin-top: 1em">union bpf_attr
{ <br/>
struct { /* Used by BPF_MAP_CREATE */ <br/>
__u32 map_type; <br/>
__u32 key_size; /* size of key in bytes */ <br/>
__u32 value_size; /* size of value in bytes */ <br/>
__u32 max_entries; /* maximum number of entries <br/>
in a map */ <br/>
}; <br/>
struct { /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY
<br/>
commands */ <br/>
__u32 map_fd; <br/>
__aligned_u64 key; <br/>
union { <br/>
__aligned_u64 value; <br/>
__aligned_u64 next_key; <br/>
}; <br/>
__u64 flags; <br/>
}; <br/>
struct { /* Used by BPF_PROG_LOAD */ <br/>
__u32 prog_type; <br/>
__u32 insn_cnt; <br/>
__aligned_u64 insns; /* 'const struct bpf_insn *' */ <br/>
__aligned_u64 license; /* 'const char *' */ <br/>
__u32 log_level; /* verbosity level of verifier */ <br/>
__u32 log_size; /* size of user buffer */ <br/>
__aligned_u64 log_buf; /* user supplied 'char *' <br/>
buffer */ <br/>
__u32 kern_version; <br/>
/* checked when prog_type=kprobe <br/>
(since Linux 4.1) */ <br/>
}; <br/>
} __attribute__((aligned(8)));</p>
<h3>eBPF maps
<a name="eBPF maps"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Maps are a
generic data structure for storage of different types of
data. They allow sharing of data between eBPF kernel
programs, and also between kernel and user-space
applications.</p>
<p style="margin-left:9%; margin-top: 1em">Each map type
has the following attributes:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="33%">
<p>type</p></td>
<td width="54%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="33%">
<p>maximum number of elements</p></td>
<td width="54%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="33%">
<p>key size in bytes</p></td>
<td width="54%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="33%">
<p>value size in bytes</p></td>
<td width="54%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The following
wrapper functions demonstrate how various <b>bpf</b>()
commands can be used to access the maps. The functions use
the <i>cmd</i> argument to invoke different operations.
<b><br/>
BPF_MAP_CREATE</b></p>
<p style="margin-left:18%;">The <b>BPF_MAP_CREATE</b>
command creates a new map, returning a new file descriptor
that refers to the map.</p>
<p style="margin-left:23%; margin-top: 1em">int <br/>
bpf_create_map(enum bpf_map_type map_type, <br/>
unsigned int key_size, <br/>
unsigned int value_size, <br/>
unsigned int max_entries) <br/>
{ <br/>
union bpf_attr attr = { <br/>
.map_type = map_type, <br/>
.key_size = key_size, <br/>
.value_size = value_size, <br/>
.max_entries = max_entries <br/>
}; <br/>
return bpf(BPF_MAP_CREATE, &amp;attr, sizeof(attr)); <br/>
}</p>
<p style="margin-left:18%; margin-top: 1em">The new map has
the type specified by <i>map_type</i>, and attributes as
specified in <i>key_size</i>, <i>value_size</i>, and
<i>max_entries</i>. On success, this operation returns a
file descriptor. On error, −1 is returned and
<i>errno</i> is set to <b>EINVAL</b>, <b>EPERM</b>, or
<b>ENOMEM</b>.</p>
<p style="margin-left:18%; margin-top: 1em">The
<i>key_size</i> and <i>value_size</i> attributes will be
used by the verifier during program loading to check that
the program is calling <b>bpf_map_*_elem</b>() helper
functions with a correctly initialized <i>key</i> and to
check that the program doesn’t access the map element
<i>value</i> beyond the specified <i>value_size</i>. For
example, when a map is created with a <i>key_size</i> of 8
and the eBPF program calls</p>
<p style="margin-left:23%; margin-top: 1em">bpf_map_lookup_elem(map_fd,
fp − 4)</p>
<p style="margin-left:18%; margin-top: 1em">the program
will be rejected, since the in-kernel helper function</p>
<p style="margin-left:23%; margin-top: 1em">bpf_map_lookup_elem(map_fd,
void *key)</p>
<p style="margin-left:18%; margin-top: 1em">expects to read
8 bytes from the location pointed to by <i>key</i>, but the
<i>fp − 4</i> (where <i>fp</i> is the top of
the stack) starting address will cause out-of-bounds stack
access.</p>
<p style="margin-left:18%; margin-top: 1em">Similarly, when
a map is created with a <i>value_size</i> of 1 and the eBPF
program contains</p>
<p style="margin-left:23%; margin-top: 1em">value =
bpf_map_lookup_elem(...); <br/>
*(u32 *) value = 1;</p>
<p style="margin-left:18%; margin-top: 1em">the program
will be rejected, since it accesses the <i>value</i> pointer
beyond the specified 1 byte <i>value_size</i> limit.</p>
<p style="margin-left:18%; margin-top: 1em">Currently, the
following values are supported for <i>map_type</i>:</p>
<p style="margin-left:23%; margin-top: 1em">enum
bpf_map_type { <br/>
BPF_MAP_TYPE_UNSPEC, /* Reserve 0 as invalid map type */
<br/>
BPF_MAP_TYPE_HASH, <br/>
BPF_MAP_TYPE_ARRAY, <br/>
BPF_MAP_TYPE_PROG_ARRAY, <br/>
BPF_MAP_TYPE_PERF_EVENT_ARRAY, <br/>
BPF_MAP_TYPE_PERCPU_HASH, <br/>
BPF_MAP_TYPE_PERCPU_ARRAY, <br/>
BPF_MAP_TYPE_STACK_TRACE, <br/>
BPF_MAP_TYPE_CGROUP_ARRAY, <br/>
BPF_MAP_TYPE_LRU_HASH, <br/>
BPF_MAP_TYPE_LRU_PERCPU_HASH, <br/>
BPF_MAP_TYPE_LPM_TRIE, <br/>
BPF_MAP_TYPE_ARRAY_OF_MAPS, <br/>
BPF_MAP_TYPE_HASH_OF_MAPS, <br/>
BPF_MAP_TYPE_DEVMAP, <br/>
BPF_MAP_TYPE_SOCKMAP, <br/>
BPF_MAP_TYPE_CPUMAP, <br/>
BPF_MAP_TYPE_XSKMAP, <br/>
BPF_MAP_TYPE_SOCKHASH, <br/>
BPF_MAP_TYPE_CGROUP_STORAGE, <br/>
BPF_MAP_TYPE_REUSEPORT_SOCKARRAY, <br/>
BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE, <br/>
BPF_MAP_TYPE_QUEUE, <br/>
BPF_MAP_TYPE_STACK, <br/>
/* See /usr/include/linux/bpf.h for the full list. */ <br/>
};</p>
<p style="margin-left:18%; margin-top: 1em"><i>map_type</i>
selects one of the available map implementations in the
kernel. For all map types, eBPF programs access maps with
the same <b>bpf_map_lookup_elem</b>() and
<b>bpf_map_update_elem</b>() helper functions. Further
details of the various map types are given below.</p>
<p style="margin-left:9%;"><b>BPF_MAP_LOOKUP_ELEM</b></p>
<p style="margin-left:18%;">The <b>BPF_MAP_LOOKUP_ELEM</b>
command looks up an element with a given <i>key</i> in the
map referred to by the file descriptor <i>fd</i>.</p>
<p style="margin-left:23%; margin-top: 1em">int <br/>
bpf_lookup_elem(int fd, const void *key, void *value) <br/>
{ <br/>
union bpf_attr attr = { <br/>
.map_fd = fd, <br/>
.key = ptr_to_u64(key), <br/>
.value = ptr_to_u64(value), <br/>
}; <br/>
return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));
<br/>
}</p>
<p style="margin-left:18%; margin-top: 1em">If an element
is found, the operation returns zero and stores the
element’s value into <i>value</i>, which must point to
a buffer of <i>value_size</i> bytes.</p>
<p style="margin-left:18%; margin-top: 1em">If no element
is found, the operation returns −1 and sets
<i>errno</i> to <b>ENOENT</b>.</p>
<p style="margin-left:9%;"><b>BPF_MAP_UPDATE_ELEM</b></p>
<p style="margin-left:18%;">The <b>BPF_MAP_UPDATE_ELEM</b>
command creates or updates an element with a given
<i>key/value</i> in the map referred to by the file
descriptor <i>fd</i>.</p>
<p style="margin-left:23%; margin-top: 1em">int <br/>
bpf_update_elem(int fd, const void *key, const void *value,
<br/>
uint64_t flags) <br/>
{ <br/>
union bpf_attr attr = { <br/>
.map_fd = fd, <br/>
.key = ptr_to_u64(key), <br/>
.value = ptr_to_u64(value), <br/>
.flags = flags, <br/>
}; <br/>
return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));
<br/>
}</p>
<p style="margin-left:18%; margin-top: 1em">The
<i>flags</i> argument should be specified as one of the
following: <b><br/>
BPF_ANY</b></p>
<p style="margin-left:27%;">Create a new element or update
an existing element.</p>
<p style="margin-left:18%;"><b>BPF_NOEXIST</b></p>
<p style="margin-left:27%;">Create a new element only if it
did not exist.</p>
<p style="margin-left:18%;"><b>BPF_EXIST</b></p>
<p style="margin-left:27%;">Update an existing element.</p>
<p style="margin-left:18%; margin-top: 1em">On success, the
operation returns zero. On error, −1 is returned and
<i>errno</i> is set to <b>EINVAL</b>, <b>EPERM</b>,
<b>ENOMEM</b>, or <b>E2BIG</b>. <b>E2BIG</b> indicates that
the number of elements in the map reached the
<i>max_entries</i> limit specified at map creation time.
<b>EEXIST</b> will be returned if <i>flags</i> specifies
<b>BPF_NOEXIST</b> and the element with <i>key</i> already
exists in the map. <b>ENOENT</b> will be returned if
<i>flags</i> specifies <b>BPF_EXIST</b> and the element with
<i>key</i> doesn’t exist in the map.</p>
<p style="margin-left:9%;"><b>BPF_MAP_DELETE_ELEM</b></p>
<p style="margin-left:18%;">The <b>BPF_MAP_DELETE_ELEM</b>
command deletes the element whose key is <i>key</i> from the
map referred to by the file descriptor <i>fd</i>.</p>
<p style="margin-left:23%; margin-top: 1em">int <br/>
bpf_delete_elem(int fd, const void *key) <br/>
{ <br/>
union bpf_attr attr = { <br/>
.map_fd = fd, <br/>
.key = ptr_to_u64(key), <br/>
}; <br/>
return bpf(BPF_MAP_DELETE_ELEM, &amp;attr, sizeof(attr));
<br/>
}</p>
<p style="margin-left:18%; margin-top: 1em">On success,
zero is returned. If the element is not found, −1 is
returned and <i>errno</i> is set to <b>ENOENT</b>.</p>
<p style="margin-left:9%;"><b>BPF_MAP_GET_NEXT_KEY</b></p>
<p style="margin-left:18%;">The <b>BPF_MAP_GET_NEXT_KEY</b>
command looks up an element by <i>key</i> in the map
referred to by the file descriptor <i>fd</i> and sets the
<i>next_key</i> pointer to the key of the next element.</p>
<p style="margin-left:23%; margin-top: 1em">int <br/>
bpf_get_next_key(int fd, const void *key, void *next_key)
<br/>
{ <br/>
union bpf_attr attr = { <br/>
.map_fd = fd, <br/>
.key = ptr_to_u64(key), <br/>
.next_key = ptr_to_u64(next_key), <br/>
}; <br/>
return bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr, sizeof(attr));
<br/>
}</p>
<p style="margin-left:18%; margin-top: 1em">If <i>key</i>
is found, the operation returns zero and sets the
<i>next_key</i> pointer to the key of the next element. If
<i>key</i> is not found, the operation returns zero and sets
the <i>next_key</i> pointer to the key of the first element.
If <i>key</i> is the last element, −1 is returned and
<i>errno</i> is set to <b>ENOENT</b>. Other possible
<i>errno</i> values are <b>ENOMEM</b>, <b>EFAULT</b>,
<b>EPERM</b>, and <b>EINVAL</b>. This method can be used to
iterate over all elements in the map.</p>
<p style="margin-left:9%;"><b>close(map_fd)</b></p>
<p style="margin-left:18%;">Delete the map referred to by
the file descriptor <i>map_fd</i>. When the user-space
program that created a map exits, all maps will be deleted
automatically (but see NOTES).</p>
<h3>eBPF map types
<a name="eBPF map types"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The following
map types are supported: <b><br/>
BPF_MAP_TYPE_HASH</b></p>
<p style="margin-left:18%;">Hash-table maps have the
following characteristics:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>Maps are created and destroyed by user-space programs.
Both user-space and eBPF programs can perform lookup,
update, and delete operations.</p></td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>The kernel takes care of allocating and freeing
key/value pairs.</p></td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>The <b>map_update_elem</b>() helper will fail to insert
new element when the <i>max_entries</i> limit is reached.
(This ensures that eBPF programs cannot exhaust memory.)</p></td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p><b>map_update_elem</b>() replaces existing elements
atomically.</p> </td></tr>
</table>
<p style="margin-left:18%; margin-top: 1em">Hash-table maps
are optimized for speed of lookup.</p>
<p style="margin-left:9%;"><b>BPF_MAP_TYPE_ARRAY</b></p>
<p style="margin-left:18%;">Array maps have the following
characteristics:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>Optimized for fastest possible lookup. In the future the
verifier/JIT compiler may recognize lookup() operations that
employ a constant key and optimize it into constant pointer.
It is possible to optimize a non-constant key into direct
pointer arithmetic as well, since pointers and
<i>value_size</i> are constant for the life of the eBPF
program. In other words, <b>array_map_lookup_elem</b>() may
be ’inlined’ by the verifier/JIT compiler while
preserving concurrent access to this map from user
space.</p> </td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>All array elements pre-allocated and zero initialized at
init time</p></td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>The key is an array index, and must be exactly four
bytes.</p> </td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p><b>map_delete_elem</b>() fails with the error
<b>EINVAL</b>, since elements cannot be deleted.</p></td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p><b>map_update_elem</b>() replaces elements in a
<b>nonatomic</b> fashion; for atomic updates, a hash-table
map should be used instead. There is however one special
case that can also be used with arrays: the atomic built-in
<b>__sync_fetch_and_add()</b> can be used on 32 and 64 bit
atomic counters. For example, it can be applied on the whole
value itself if it represents a single counter, or in case
of a structure containing multiple counters, it could be
used on individual counters. This is quite often useful for
aggregation and accounting of events.</p></td></tr>
</table>
<p style="margin-left:18%; margin-top: 1em">Among the uses
for array maps are the following:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="78%">
<p style="margin-top: 1em">As "global" eBPF
variables: an array of 1 element whose key is (index) 0 and
where the value is a collection of ’global’
variables which eBPF programs can use to keep state between
events.</p> </td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>Aggregation of tracing events into a fixed set of
buckets.</p> </td></tr>
<tr align="left" valign="top">
<td width="18%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="78%">
<p>Accounting of networking events, for example, number of
packets and packet sizes.</p></td></tr>
</table>
<p style="margin-left:9%;"><b>BPF_MAP_TYPE_PROG_ARRAY</b>
(since Linux 4.2)</p>
<p style="margin-left:18%;">A program array map is a
special kind of array map whose map values contain only file
descriptors referring to other eBPF programs. Thus, both the
<i>key_size</i> and <i>value_size</i> must be exactly four
bytes. This map is used in conjunction with the
<b>bpf_tail_call</b>() helper.</p>
<p style="margin-left:18%; margin-top: 1em">This means that
an eBPF program with a program array map attached to it can
call from kernel side into</p>
<p style="margin-left:23%; margin-top: 1em">void
bpf_tail_call(void *context, void *prog_map, <br/>
unsigned int index);</p>
<p style="margin-left:18%; margin-top: 1em">and therefore
replace its own program flow with the one from the program
at the given program array slot, if present. This can be
regarded as kind of a jump table to a different eBPF
program. The invoked program will then reuse the same stack.
When a jump into the new program has been performed, it
won’t return to the old program anymore.</p>
<p style="margin-left:18%; margin-top: 1em">If no eBPF
program is found at the given index of the program array
(because the map slot doesn’t contain a valid program
file descriptor, the specified lookup index/key is out of
bounds, or the limit of 32 nested calls has been exceed),
execution continues with the current eBPF program. This can
be used as a fall-through for default cases.</p>
<p style="margin-left:18%; margin-top: 1em">A program array
map is useful, for example, in tracing or networking, to
handle individual system calls or protocols in their own
subprograms and use their identifiers as an individual map
index. This approach may result in performance benefits, and
also makes it possible to overcome the maximum instruction
limit of a single eBPF program. In dynamic environments, a
user-space daemon might atomically replace individual
subprograms at run-time with newer versions to alter overall
program behavior, for instance, if global policies
change.</p>
<h3>eBPF programs
<a name="eBPF programs"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>BPF_PROG_LOAD</b> command is used to load an eBPF program
into the kernel. The return value for this command is a new
file descriptor associated with this eBPF program.</p>
<p style="margin-left:14%; margin-top: 1em">char
bpf_log_buf[LOG_BUF_SIZE]; <br/>
int <br/>
bpf_prog_load(enum bpf_prog_type type, <br/>
const struct bpf_insn *insns, int insn_cnt, <br/>
const char *license) <br/>
{ <br/>
union bpf_attr attr = { <br/>
.prog_type = type, <br/>
.insns = ptr_to_u64(insns), <br/>
.insn_cnt = insn_cnt, <br/>
.license = ptr_to_u64(license), <br/>
.log_buf = ptr_to_u64(bpf_log_buf), <br/>
.log_size = LOG_BUF_SIZE, <br/>
.log_level = 1, <br/>
}; <br/>
return bpf(BPF_PROG_LOAD, &amp;attr, sizeof(attr)); <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em"><i>prog_type</i>
is one of the available program types:</p>
<p style="margin-left:23%; margin-top: 1em">enum
bpf_prog_type { <br/>
BPF_PROG_TYPE_UNSPEC, /* Reserve 0 as invalid <br/>
program type */ <br/>
BPF_PROG_TYPE_SOCKET_FILTER, <br/>
BPF_PROG_TYPE_KPROBE, <br/>
BPF_PROG_TYPE_SCHED_CLS, <br/>
BPF_PROG_TYPE_SCHED_ACT, <br/>
BPF_PROG_TYPE_TRACEPOINT, <br/>
BPF_PROG_TYPE_XDP, <br/>
BPF_PROG_TYPE_PERF_EVENT, <br/>
BPF_PROG_TYPE_CGROUP_SKB, <br/>
BPF_PROG_TYPE_CGROUP_SOCK, <br/>
BPF_PROG_TYPE_LWT_IN, <br/>
BPF_PROG_TYPE_LWT_OUT, <br/>
BPF_PROG_TYPE_LWT_XMIT, <br/>
BPF_PROG_TYPE_SOCK_OPS, <br/>
BPF_PROG_TYPE_SK_SKB, <br/>
BPF_PROG_TYPE_CGROUP_DEVICE, <br/>
BPF_PROG_TYPE_SK_MSG, <br/>
BPF_PROG_TYPE_RAW_TRACEPOINT, <br/>
BPF_PROG_TYPE_CGROUP_SOCK_ADDR, <br/>
BPF_PROG_TYPE_LWT_SEG6LOCAL, <br/>
BPF_PROG_TYPE_LIRC_MODE2, <br/>
BPF_PROG_TYPE_SK_REUSEPORT, <br/>
BPF_PROG_TYPE_FLOW_DISSECTOR, <br/>
/* See /usr/include/linux/bpf.h for the full list. */ <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">For further
details of eBPF program types, see below.</p>
<p style="margin-left:9%; margin-top: 1em">The remaining
fields of <i>bpf_attr</i> are set as follows:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>insns</i> is an array of <i>struct bpf_insn</i>
instructions.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>insn_cnt</i> is the number of instructions in the
program referred to by <i>insns</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>license</i> is a license string, which must be GPL
compatible to call helper functions marked <i>gpl_only</i>.
(The licensing rules are the same as for kernel modules, so
that also dual licenses, such as "Dual BSD/GPL",
may be used.)</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>log_buf</i> is a pointer to a caller-allocated buffer
in which the in-kernel verifier can store the verification
log. This log is a multi-line string that can be checked by
the program author in order to understand how the verifier
came to the conclusion that the eBPF program is unsafe. The
format of the output can change at any time as the verifier
evolves.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>log_size</i> size of the buffer pointed to by
<i>log_buf</i>. If the size of the buffer is not large
enough to store all verifier messages, −1 is returned
and <i>errno</i> is set to <b>ENOSPC</b>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><i>log_level</i> verbosity level of the verifier. A
value of zero means that the verifier will not provide a
log; in this case, <i>log_buf</i> must be a null pointer,
and <i>log_size</i> must be zero.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Applying
<b>close</b>(2) to the file descriptor returned by
<b>BPF_PROG_LOAD</b> will unload the eBPF program (but see
NOTES).</p>
<p style="margin-left:9%; margin-top: 1em">Maps are
accessible from eBPF programs and are used to exchange data
between eBPF programs and between eBPF programs and
user-space programs. For example, eBPF programs can process
various events (like kprobe, packets) and store their data
into a map, and user-space programs can then fetch data from
the map. Conversely, user-space programs can use a map as a
configuration mechanism, populating the map with values
checked by the eBPF program, which then modifies its
behavior on the fly according to those values.</p>
<h3>eBPF program types
<a name="eBPF program types"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The eBPF program
type (<i>prog_type</i>) determines the subset of kernel
helper functions that the program may call. The program type
also determines the program input (context)—the format
of <i>struct bpf_context</i> (which is the data blob passed
into the eBPF program as the first argument).</p>
<p style="margin-left:9%; margin-top: 1em">For example, a
tracing program does not have the exact same subset of
helper functions as a socket filter program (though they may
have some helpers in common). Similarly, the input (context)
for a tracing program is a set of register values, while for
a socket filter it is a network packet.</p>
<p style="margin-left:9%; margin-top: 1em">The set of
functions available to eBPF programs of a given type may
increase in the future.</p>
<p style="margin-left:9%; margin-top: 1em">The following
program types are supported: <b><br/>
BPF_PROG_TYPE_SOCKET_FILTER</b> (since Linux 3.19)</p>
<p style="margin-left:18%;">Currently, the set of functions
for <b>BPF_PROG_TYPE_SOCKET_FILTER</b> is:</p>
<p style="margin-left:23%; margin-top: 1em">bpf_map_lookup_elem(map_fd,
void *key) <br/>
/* look up key in a map_fd */ <br/>
bpf_map_update_elem(map_fd, void *key, void *value) <br/>
/* update key/value */ <br/>
bpf_map_delete_elem(map_fd, void *key) <br/>
/* delete key in a map_fd */</p>
<p style="margin-left:18%; margin-top: 1em">The
<i>bpf_context</i> argument is a pointer to a <i>struct
__sk_buff</i>.</p>
<p style="margin-left:9%;"><b>BPF_PROG_TYPE_KPROBE</b>
(since Linux 4.1)</p>
<p style="margin-left:18%;">[To be documented]</p>
<p style="margin-left:9%;"><b>BPF_PROG_TYPE_SCHED_CLS</b>
(since Linux 4.1)</p>
<p style="margin-left:18%;">[To be documented]</p>
<p style="margin-left:9%;"><b>BPF_PROG_TYPE_SCHED_ACT</b>
(since Linux 4.1)</p>
<p style="margin-left:18%;">[To be documented]</p>
<h3>Events
<a name="Events"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Once a program
is loaded, it can be attached to an event. Various kernel
subsystems have different ways to do so.</p>
<p style="margin-left:9%; margin-top: 1em">Since Linux
3.19, the following call will attach the program
<i>prog_fd</i> to the socket <i>sockfd</i>, which was
created by an earlier call to <b>socket</b>(2):</p>
<p style="margin-left:14%; margin-top: 1em">setsockopt(sockfd,
SOL_SOCKET, SO_ATTACH_BPF, <br/>
&amp;prog_fd, sizeof(prog_fd));</p>
<p style="margin-left:9%; margin-top: 1em">Since Linux 4.1,
the following call may be used to attach the eBPF program
referred to by the file descriptor <i>prog_fd</i> to a perf
event file descriptor, <i>event_fd</i>, that was created by
a previous call to <b>perf_event_open</b>(2):</p>
<p style="margin-left:14%; margin-top: 1em">ioctl(event_fd,
PERF_EVENT_IOC_SET_BPF, prog_fd);</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">For a successful
call, the return value depends on the operation: <b><br/>
BPF_MAP_CREATE</b></p>
<p style="margin-left:18%;">The new file descriptor
associated with the eBPF map.</p>
<p style="margin-left:9%;"><b>BPF_PROG_LOAD</b></p>
<p style="margin-left:18%;">The new file descriptor
associated with the eBPF program.</p>
<p style="margin-left:9%;">All other commands</p>
<p style="margin-left:18%;">Zero.</p>
<p style="margin-left:9%; margin-top: 1em">On error,
−1 is returned, and <i>errno</i> is set to indicate
the error.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><b>E2BIG</b></p></td>
<td width="1%"></td>
<td width="82%">
<p style="margin-top: 1em">The eBPF program is too large or
a map reached the <i>max_entries</i> limit (maximum number
of elements).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EACCES</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>For <b>BPF_PROG_LOAD</b>, even though all program
instructions are valid, the program has been rejected
because it was deemed unsafe. This may be because it may
have accessed a disallowed memory region or an uninitialized
stack/register or because the function constraints
don’t match the actual types or because there was a
misaligned memory access. In this case, it is recommended to
call <b>bpf</b>() again with <i>log_level = 1</i> and
examine <i>log_buf</i> for the specific reason provided by
the verifier.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EAGAIN</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>For <b>BPF_PROG_LOAD</b>, indicates that needed
resources are blocked. This happens when the verifier
detects pending signals while it is checking the validity of
the bpf program. In this case, just call <b>bpf</b>() again
with the same parameters.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EBADF</b></p></td>
<td width="1%"></td>
<td width="82%">
<p><i>fd</i> is not an open file descriptor.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EFAULT</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>One of the pointers (<i>key</i> or <i>value</i> or
<i>log_buf</i> or <i>insns</i>) is outside the accessible
address space.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The value specified in <i>cmd</i> is not recognized by
this kernel.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>For <b>BPF_MAP_CREATE</b>, either <i>map_type</i> or
attributes are invalid.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>For <b>BPF_MAP_*_ELEM</b> commands, some of the fields
of <i>union bpf_attr</i> that are not used by this command
are not set to zero.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>For <b>BPF_PROG_LOAD</b>, indicates an attempt to load
an invalid program. eBPF programs can be deemed invalid due
to unrecognized instructions, the use of reserved fields,
jumps out of range, infinite loops or calls of unknown
functions.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOENT</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>For <b>BPF_MAP_LOOKUP_ELEM</b> or
<b>BPF_MAP_DELETE_ELEM</b>, indicates that the element with
the given <i>key</i> was not found.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>ENOMEM</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>Cannot allocate sufficient memory.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EPERM</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>The call was made without sufficient privilege (without
the <b>CAP_SYS_ADMIN</b> capability).</p></td></tr>
</table>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Linux 3.18.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Prior to Linux
4.4, all <b>bpf</b>() commands require the caller to have
the <b>CAP_SYS_ADMIN</b> capability. From Linux 4.4 onwards,
an unprivileged user may create limited programs of type
<b>BPF_PROG_TYPE_SOCKET_FILTER</b> and associated maps.
However they may not store kernel pointers within the maps
and are presently limited to the following helper
functions:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="25%">
<p style="margin-top: 1em">get_random</p></td>
<td width="62%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="25%">
<p>get_smp_processor_id</p></td>
<td width="62%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="25%">
<p>tail_call</p></td>
<td width="62%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="25%">
<p>ktime_get_ns</p></td>
<td width="62%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Unprivileged
access may be blocked by writing the value 1 to the file
<i>/proc/sys/kernel/unprivileged_bpf_disabled</i>.</p>
<p style="margin-left:9%; margin-top: 1em">eBPF objects
(maps and programs) can be shared between processes. For
example, after <b>fork</b>(2), the child inherits file
descriptors referring to the same eBPF objects. In addition,
file descriptors referring to eBPF objects can be
transferred over UNIX domain sockets. File descriptors
referring to eBPF objects can be duplicated in the usual
way, using <b>dup</b>(2) and similar calls. An eBPF object
is deallocated only after all file descriptors referring to
the object have been closed.</p>
<p style="margin-left:9%; margin-top: 1em">eBPF programs
can be written in a restricted C that is compiled (using the
<b>clang</b> compiler) into eBPF bytecode. Various features
are omitted from this restricted C, such as loops, global
variables, variadic functions, floating-point numbers, and
passing structures as function arguments. Some examples can
be found in the <i>samples/bpf/*_kern.c</i> files in the
kernel source tree.</p>
<p style="margin-left:9%; margin-top: 1em">The kernel
contains a just-in-time (JIT) compiler that translates eBPF
bytecode into native machine code for better performance.
Before Linux 4.15, the JIT compiler is disabled by default,
but its operation can be controlled by writing one of the
following integer strings to the file
<i>/proc/sys/net/core/bpf_jit_enable</i>:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em"><b>0</b></p></td>
<td width="8%"></td>
<td width="82%">
<p style="margin-top: 1em">Disable JIT compilation
(default).</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>1</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Normal compilation.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p><b>2</b></p></td>
<td width="8%"></td>
<td width="82%">
<p>Debugging mode. The generated opcodes are dumped in
hexadecimal into the kernel log. These opcodes can then be
disassembled using the program
<i>tools/net/bpf_jit_disasm.c</i> provided in the kernel
source tree.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Since Linux
4.15, the kernel may be configured with the
<b>CONFIG_BPF_JIT_ALWAYS_ON</b> option. In this case, the
JIT compiler is always enabled, and the
<i>bpf_jit_enable</i> is initialized to 1 and is immutable.
(This kernel configuration option was provided as a
mitigation for one of the Spectre attacks against the BPF
interpreter.)</p>
<p style="margin-left:9%; margin-top: 1em">The JIT compiler
for eBPF is currently available for the following
architectures:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="65%">
<p style="margin-top: 1em">x86-64 (since Linux 3.18; cBPF
since Linux 3.0);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>ARM32 (since Linux 3.18; cBPF since Linux 3.4);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>SPARC 32 (since Linux 3.18; cBPF since Linux 3.5);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>ARM-64 (since Linux 3.18);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>s390 (since Linux 4.1; cBPF since Linux 3.7);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>PowerPC 64 (since Linux 4.8; cBPF since Linux 3.1);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>SPARC 64 (since Linux 4.12);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>x86-32 (since Linux 4.18);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>MIPS 64 (since Linux 4.18; cBPF since Linux 3.16);</p></td>
<td width="22%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="65%">
<p>riscv (since Linux 5.1).</p></td>
<td width="22%">
</td></tr>
</table>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">/* bpf+sockets
example: <br/>
* 1. create array map of 256 elements <br/>
* 2. load program that counts number of packets received
<br/>
* r0 = skb−&gt;data[ETH_HLEN + offsetof(struct iphdr,
protocol)] <br/>
* map[r0]++ <br/>
* 3. attach prog_fd to raw socket via setsockopt() <br/>
* 4. print number of received TCP/UDP packets every second
<br/>
*/ <br/>
int <br/>
main(int argc, char *argv[]) <br/>
{ <br/>
int sock, map_fd, prog_fd, key; <br/>
long long value = 0, tcp_cnt, udp_cnt; <br/>
map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),
<br/>
sizeof(value), 256); <br/>
if (map_fd &lt; 0) { <br/>
printf("failed to create map '%s'\n",
strerror(errno)); <br/>
/* likely not run as root */ <br/>
return 1; <br/>
} <br/>
struct bpf_insn prog[] = { <br/>
BPF_MOV64_REG(BPF_REG_6, BPF_REG_1), /* r6 = r1 */ <br/>
BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr,
protocol)), <br/>
/* r0 = ip−&gt;proto */ <br/>
BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, −4), <br/>
/* *(u32 *)(fp − 4) = r0 */ <br/>
BPF_MOV64_REG(BPF_REG_2, BPF_REG_10), /* r2 = fp */ <br/>
BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, −4), /* r2 = r2
− 4 */ <br/>
BPF_LD_MAP_FD(BPF_REG_1, map_fd), /* r1 = map_fd */ <br/>
BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem), <br/>
/* r0 = map_lookup(r1, r2) */ <br/>
BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2), <br/>
/* if (r0 == 0) goto pc+2 */ <br/>
BPF_MOV64_IMM(BPF_REG_1, 1), /* r1 = 1 */ <br/>
BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0), <br/>
/* lock *(u64 *) r0 += r1 */ <br/>
BPF_MOV64_IMM(BPF_REG_0, 0), /* r0 = 0 */ <br/>
BPF_EXIT_INSN(), /* return r0 */ <br/>
}; <br/>
prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,
<br/>
sizeof(prog) / sizeof(prog[0]), "GPL"); <br/>
sock = open_raw_sock("lo"); <br/>
assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF,
&amp;prog_fd, <br/>
sizeof(prog_fd)) == 0); <br/>
for (;;) { <br/>
key = IPPROTO_TCP; <br/>
assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) ==
0); <br/>
key = IPPROTO_UDP; <br/>
assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) ==
0); <br/>
printf("TCP %lld UDP %lld packets\n", tcp_cnt,
udp_cnt); <br/>
sleep(1); <br/>
} <br/>
return 0; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Some complete
working code can be found in the <i>samples/bpf</i>
directory in the kernel source tree.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>seccomp</b>(2),
<b>bpf−helpers</b>(7), <b>socket</b>(7), <b>tc</b>(8),
<b>tc−bpf</b>(8)</p>
<p style="margin-left:9%; margin-top: 1em">Both classic and
extended BPF are explained in the kernel source file
<i>Documentation/networking/filter.txt</i>.</p>
<hr/>
</body>
</html>
