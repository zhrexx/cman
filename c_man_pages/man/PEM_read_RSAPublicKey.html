<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:49:45 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>PEM_READ_BIO_PRIVATEKEY</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">PEM_READ_BIO_PRIVATEKEY</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#PEM FUNCTION ARGUMENTS">PEM FUNCTION ARGUMENTS</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#PEM ENCRYPTION FORMAT">PEM ENCRYPTION FORMAT</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">pem_password_cb,
PEM_read_bio_PrivateKey_ex, PEM_read_bio_PrivateKey,
PEM_read_PrivateKey_ex, PEM_read_PrivateKey,
PEM_write_bio_PrivateKey_ex, PEM_write_bio_PrivateKey,
PEM_write_bio_PrivateKey_traditional,
PEM_write_PrivateKey_ex, PEM_write_PrivateKey,
PEM_write_bio_PKCS8PrivateKey, PEM_write_PKCS8PrivateKey,
PEM_write_bio_PKCS8PrivateKey_nid,
PEM_write_PKCS8PrivateKey_nid, PEM_read_bio_PUBKEY_ex,
PEM_read_bio_PUBKEY, PEM_read_PUBKEY_ex, PEM_read_PUBKEY,
PEM_write_bio_PUBKEY_ex, PEM_write_bio_PUBKEY,
PEM_write_PUBKEY_ex, PEM_write_PUBKEY,
PEM_read_bio_RSAPrivateKey, PEM_read_RSAPrivateKey,
PEM_write_bio_RSAPrivateKey, PEM_write_RSAPrivateKey,
PEM_read_bio_RSAPublicKey, PEM_read_RSAPublicKey,
PEM_write_bio_RSAPublicKey, PEM_write_RSAPublicKey,
PEM_read_bio_RSA_PUBKEY, PEM_read_RSA_PUBKEY,
PEM_write_bio_RSA_PUBKEY, PEM_write_RSA_PUBKEY,
PEM_read_bio_DSAPrivateKey, PEM_read_DSAPrivateKey,
PEM_write_bio_DSAPrivateKey, PEM_write_DSAPrivateKey,
PEM_read_bio_DSA_PUBKEY, PEM_read_DSA_PUBKEY,
PEM_write_bio_DSA_PUBKEY, PEM_write_DSA_PUBKEY,
PEM_read_bio_Parameters_ex, PEM_read_bio_Parameters,
PEM_write_bio_Parameters, PEM_read_bio_DSAparams,
PEM_read_DSAparams, PEM_write_bio_DSAparams,
PEM_write_DSAparams, PEM_read_bio_DHparams,
PEM_read_DHparams, PEM_write_bio_DHparams,
PEM_write_DHparams, PEM_read_bio_X509, PEM_read_X509,
PEM_write_bio_X509, PEM_write_X509, PEM_read_bio_X509_AUX,
PEM_read_X509_AUX, PEM_write_bio_X509_AUX,
PEM_write_X509_AUX, PEM_read_bio_X509_REQ,
PEM_read_X509_REQ, PEM_write_bio_X509_REQ,
PEM_write_X509_REQ, PEM_write_bio_X509_REQ_NEW,
PEM_write_X509_REQ_NEW, PEM_read_bio_X509_CRL,
PEM_read_X509_CRL, PEM_write_bio_X509_CRL,
PEM_write_X509_CRL, PEM_read_bio_PKCS7, PEM_read_PKCS7,
PEM_write_bio_PKCS7, PEM_write_PKCS7 − PEM
routines</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/pem.h&gt; <br/>
typedef int pem_password_cb(char *buf, int size, int rwflag,
void *u); <br/>
EVP_PKEY *PEM_read_bio_PrivateKey_ex(BIO *bp, EVP_PKEY **x,
<br/>
pem_password_cb *cb, void *u, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x,
<br/>
pem_password_cb *cb, void *u); <br/>
EVP_PKEY *PEM_read_PrivateKey_ex(FILE *fp, EVP_PKEY **x,
pem_password_cb *cb, <br/>
void *u, OSSL_LIB_CTX *libctx, <br/>
const char *propq); <br/>
EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_PrivateKey_ex(BIO *bp, const EVP_PKEY *x,
<br/>
const EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
int PEM_write_bio_PrivateKey(BIO *bp, const EVP_PKEY *x,
const EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_PrivateKey_traditional(BIO *bp, EVP_PKEY
*x, <br/>
const EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_PrivateKey_ex(FILE *fp, EVP_PKEY *x, const
EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const
EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x,
const EVP_CIPHER *enc, <br/>
char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const
EVP_CIPHER *enc, <br/>
char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, const
EVP_PKEY *x, int nid, <br/>
char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_PKCS8PrivateKey_nid(FILE *fp, const EVP_PKEY
*x, int nid, <br/>
char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
EVP_PKEY *PEM_read_bio_PUBKEY_ex(BIO *bp, EVP_PKEY **x, <br/>
pem_password_cb *cb, void *u, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, <br/>
pem_password_cb *cb, void *u); <br/>
EVP_PKEY *PEM_read_PUBKEY_ex(FILE *fp, EVP_PKEY **x, <br/>
pem_password_cb *cb, void *u, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_PUBKEY_ex(BIO *bp, EVP_PKEY *x, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x); <br/>
int PEM_write_PUBKEY_ex(FILE *fp, EVP_PKEY *x, <br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x); <br/>
EVP_PKEY *PEM_read_bio_Parameters_ex(BIO *bp, EVP_PKEY **x,
<br/>
OSSL_LIB_CTX *libctx, const char *propq); <br/>
EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
<br/>
int PEM_write_bio_Parameters(BIO *bp, const EVP_PKEY *x);
<br/>
X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb
*cb, void *u); <br/>
X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb,
void *u); <br/>
int PEM_write_bio_X509(BIO *bp, X509 *x); <br/>
int PEM_write_X509(FILE *fp, X509 *x); <br/>
X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x,
pem_password_cb *cb, void *u); <br/>
X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb
*cb, void *u); <br/>
int PEM_write_bio_X509_AUX(BIO *bp, X509 *x); <br/>
int PEM_write_X509_AUX(FILE *fp, X509 *x); <br/>
X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, <br/>
pem_password_cb *cb, void *u); <br/>
X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x); <br/>
int PEM_write_X509_REQ(FILE *fp, X509_REQ *x); <br/>
int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x); <br/>
int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x); <br/>
X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x, <br/>
pem_password_cb *cb, void *u); <br/>
X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x); <br/>
int PEM_write_X509_CRL(FILE *fp, X509_CRL *x); <br/>
PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x,
pem_password_cb *cb, void *u); <br/>
PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb
*cb, void *u); <br/>
int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x); <br/>
int PEM_write_PKCS7(FILE *fp, PKCS7 *x);</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining <b>OPENSSL_API_COMPAT</b> with a
suitable version value, see
<b>openssl_user_macros</b>(7):</p>
<p style="margin-left:9%; margin-top: 1em">RSA
*PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const
EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const
EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_RSAPublicKey(BIO *bp, RSA *x); <br/>
int PEM_write_RSAPublicKey(FILE *fp, RSA *x); <br/>
RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x); <br/>
int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x); <br/>
DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const
EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const
EVP_CIPHER *enc, <br/>
unsigned char *kstr, int klen, <br/>
pem_password_cb *cb, void *u); <br/>
DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x, <br/>
pem_password_cb *cb, void *u); <br/>
int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x); <br/>
int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x); <br/>
DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x,
pem_password_cb *cb, void *u); <br/>
DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb
*cb, void *u); <br/>
int PEM_write_bio_DSAparams(BIO *bp, DSA *x); <br/>
int PEM_write_DSAparams(FILE *fp, DSA *x); <br/>
DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb
*cb, void *u); <br/>
DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb,
void *u); <br/>
int PEM_write_bio_DHparams(BIO *bp, DH *x); <br/>
int PEM_write_DHparams(FILE *fp, DH *x);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All of the
functions described on this page that have a <i>TYPE</i> of
<b>DH</b>, <b>DSA</b> and <b>RSA</b> are deprecated.
Applications should use <b>OSSL_ENCODER_to_bio</b>(3) and
<b>OSSL_DECODER_from_bio</b>(3) instead.</p>
<p style="margin-left:9%; margin-top: 1em">The PEM
functions read or write structures in PEM format. In this
sense PEM format is simply base64 encoded data surrounded by
header lines.</p>
<p style="margin-left:9%; margin-top: 1em">For more details
about the meaning of arguments see the <b>PEM FUNCTION
ARGUMENTS</b> section.</p>
<p style="margin-left:9%; margin-top: 1em">Each operation
has four functions associated with it. For brevity the term
"<b><i>TYPE</i></b> functions" will be used below
to collectively refer to the
<b>PEM_read_bio_</b><b><i>TYPE</i></b>(),
<b>PEM_read_</b><b><i>TYPE</i></b>(),
<b>PEM_write_bio_</b><b><i>TYPE</i></b>(), and
<b>PEM_write_</b><b><i>TYPE</i></b>() functions.</p>
<p style="margin-left:9%; margin-top: 1em">Some operations
have additional variants that take a library context
<i>libctx</i> and a property query string <i>propq</i>. The
<b>X509</b>, <b>X509_REQ</b> and <b>X509_CRL</b> objects may
have an associated library context or property query string
but there are no variants of these functions that take a
library context or property query string parameter. In this
case it is possible to set the appropriate library context
or property query string by creating an empty <b>X509</b>,
<b>X509_REQ</b> or <b>X509_CRL</b> object using
<b>X509_new_ex</b>(3), <b>X509_REQ_new_ex</b>(3) or
<b>X509_CRL_new_ex</b>(3) respectively. Then pass the empty
object as a parameter to the relevant PEM function. See the
"EXAMPLES" section below.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>PrivateKey</b> functions read or write a private key in
PEM format using an EVP_PKEY structure. The write routines
use PKCS#8 private key format and are equivalent to
<b>PEM_write_bio_PKCS8PrivateKey()</b>. The read functions
transparently handle traditional and PKCS#8 format encrypted
and unencrypted keys.</p>
<p style="margin-left:9%; margin-top: 1em"><b>PEM_write_bio_PrivateKey_traditional()</b>
writes out a private key in the "traditional"
format with a simple private key marker and should only be
used for compatibility with legacy programs.</p>
<p style="margin-left:9%; margin-top: 1em"><b>PEM_write_bio_PKCS8PrivateKey()</b>
and <b>PEM_write_PKCS8PrivateKey()</b> write a private key
in an EVP_PKEY structure in PKCS#8 EncryptedPrivateKeyInfo
format using PKCS#5 v2.0 password based encryption
algorithms. The <i>cipher</i> argument specifies the
encryption algorithm to use: unlike some other PEM routines
the encryption is applied at the PKCS#8 level and not in the
PEM headers. If <i>cipher</i> is NULL then no encryption is
used and a PKCS#8 PrivateKeyInfo structure is used
instead.</p>
<p style="margin-left:9%; margin-top: 1em"><b>PEM_write_bio_PKCS8PrivateKey_nid()</b>
and <b>PEM_write_PKCS8PrivateKey_nid()</b> also write out a
private key as a PKCS#8 EncryptedPrivateKeyInfo however it
uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead.
The algorithm to use is specified in the <i>nid</i>
parameter and should be the NID of the corresponding OBJECT
IDENTIFIER (see NOTES section).</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>PUBKEY</b> functions process a public key using an
EVP_PKEY structure. The public key is encoded as a
SubjectPublicKeyInfo structure.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>RSAPrivateKey</b> functions process an RSA private key
using an RSA structure. The write routines uses traditional
format. The read routines handles the same formats as the
<b>PrivateKey</b> functions but an error occurs if the
private key is not RSA.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>RSAPublicKey</b> functions process an RSA public key
using an RSA structure. The public key is encoded using a
PKCS#1 RSAPublicKey structure.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>RSA_PUBKEY</b> functions also process an RSA public key
using an RSA structure. However, the public key is encoded
using a SubjectPublicKeyInfo structure and an error occurs
if the public key is not RSA.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>DSAPrivateKey</b> functions process a DSA private key
using a DSA structure. The write routines uses traditional
format. The read routines handles the same formats as the
<b>PrivateKey</b> functions but an error occurs if the
private key is not DSA.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>DSA_PUBKEY</b> functions process a DSA public key using a
DSA structure. The public key is encoded using a
SubjectPublicKeyInfo structure and an error occurs if the
public key is not DSA.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>Parameters</b> functions read or write key parameters in
PEM format using an EVP_PKEY structure. The encoding depends
on the type of key; for DSA key parameters, it will be a
Dss−Parms structure as defined in RFC2459, and for DH
key parameters, it will be a PKCS#3 DHparameter structure.
<i>These functions only exist for the</i> <b><i>BIO</i></b>
<i>type</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>DSAparams</b> functions process DSA parameters using a
DSA structure. The parameters are encoded using a
Dss−Parms structure as defined in RFC2459.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>DHparams</b> functions process DH parameters using a DH
structure. The parameters are encoded using a PKCS#3
DHparameter structure.</p>
<p style="margin-left:9%; margin-top: 1em">The <b>X509</b>
functions process an X509 certificate using an X509
structure. They will also process a trusted X509 certificate
but any trust settings are discarded.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>X509_AUX</b> functions process a trusted X509 certificate
using an X509 structure.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>X509_REQ</b> and <b>X509_REQ_NEW</b> functions process a
PKCS#10 certificate request using an X509_REQ structure. The
<b>X509_REQ</b> write functions use <b>CERTIFICATE
REQUEST</b> in the header whereas the <b>X509_REQ_NEW</b>
functions use <b>NEW CERTIFICATE REQUEST</b> (as required by
some CAs). The <b>X509_REQ</b> read functions will handle
either form so there are no <b>X509_REQ_NEW</b> read
functions.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>X509_CRL</b> functions process an X509 CRL using an
X509_CRL structure.</p>
<p style="margin-left:9%; margin-top: 1em">The <b>PKCS7</b>
functions process a PKCS#7 ContentInfo using a PKCS7
structure.</p>
<h2>PEM FUNCTION ARGUMENTS
<a name="PEM FUNCTION ARGUMENTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The PEM
functions have many common arguments.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>bp</i>
BIO parameter (if present) specifies the BIO to read from or
write to.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>fp</i>
FILE parameter (if present) specifies the FILE pointer to
read from or write to.</p>
<p style="margin-left:9%; margin-top: 1em">The PEM read
functions all take an argument <b><i>TYPE</i></b> <i>**x</i>
and return a <b><i>TYPE</i></b> <i>*</i> pointer. Where
<b><i>TYPE</i></b> is whatever structure the function uses.
If <i>x</i> is NULL then the parameter is ignored. If
<i>x</i> is not NULL but <i>*x</i> is NULL then the
structure returned will be written to <i>*x</i>. If neither
<i>x</i> nor <i>*x</i> is NULL then an attempt is made to
reuse the structure at <i>*x</i> (but see BUGS and EXAMPLES
sections). Irrespective of the value of <i>x</i> a pointer
to the structure is always returned (or NULL if an error
occurred). The caller retains ownership of the returned
object and needs to free it when it is no longer needed,
e.g. using <b>X509_free()</b> for X509 objects or
<b>EVP_PKEY_free()</b> for EVP_PKEY objects.</p>
<p style="margin-left:9%; margin-top: 1em">The PEM
functions which write private keys take an <i>enc</i>
parameter which specifies the encryption algorithm to use,
encryption is done at the PEM level. If this parameter is
set to NULL then the private key is written in unencrypted
form.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>cb</i>
argument is the callback to use when querying for the pass
phrase used for encrypted PEM structures (normally only
private keys).</p>
<p style="margin-left:9%; margin-top: 1em">For the PEM
write routines if the <i>kstr</i> parameter is not NULL then
<i>klen</i> bytes at <i>kstr</i> are used as the passphrase
and <i>cb</i> is ignored.</p>
<p style="margin-left:9%; margin-top: 1em">If the <i>cb</i>
parameters is set to NULL and the <i>u</i> parameter is not
NULL then the <i>u</i> parameter is interpreted as a NUL
terminated string to use as the passphrase. If both
<i>cb</i> and <i>u</i> are NULL then the default callback
routine is used which will typically prompt for the
passphrase on the current terminal with echoing turned
off.</p>
<p style="margin-left:9%; margin-top: 1em">The default
passphrase callback is sometimes inappropriate (for example
in a GUI application) so an alternative can be supplied. The
callback routine has the following form:</p>
<p style="margin-left:9%; margin-top: 1em">int cb(char
*buf, int size, int rwflag, void *u);</p>
<p style="margin-left:9%; margin-top: 1em"><i>buf</i> is
the buffer to write the passphrase to. <i>size</i> is the
maximum length of the passphrase (i.e. the size of buf).
<i>rwflag</i> is a flag which is set to 0 when reading and 1
when writing. A typical routine will ask the user to verify
the passphrase (for example by prompting for it twice) if
<i>rwflag</i> is 1. The <i>u</i> parameter has the same
value as the <i>u</i> parameter passed to the PEM routine.
It allows arbitrary data to be passed to the callback by the
application (for example a window handle in a GUI
application). The callback <i>must</i> return the number of
characters in the passphrase or −1 if an error
occurred. The passphrase can be arbitrary data; in the case
where it is a string, it is not NUL terminated. See the
"EXAMPLES" section below.</p>
<p style="margin-left:9%; margin-top: 1em">Some
implementations may need to use cryptographic algorithms
during their operation. If this is the case and
<i>libctx</i> and <i>propq</i> parameters have been passed
then any algorithm fetches will use that library context and
property query string. Otherwise the default library context
and property query string will be used.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The PEM reading
functions will skip any extraneous content or PEM data of a
different type than they expect. This allows for example
having a certificate (or multiple certificates) and a key in
the PEM format in a single file.</p>
<p style="margin-left:9%; margin-top: 1em">The old
<b>PrivateKey</b> write routines are retained for
compatibility. New applications should write private keys
using the <b>PEM_write_bio_PKCS8PrivateKey()</b> or
<b>PEM_write_PKCS8PrivateKey()</b> routines because they are
more secure (they use an iteration count of 2048 whereas the
traditional routines use a count of 1) unless compatibility
with older versions of OpenSSL is important.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>PrivateKey</b> read routines can be used in all
applications because they handle all formats
transparently.</p>
<p style="margin-left:9%; margin-top: 1em">A frequent cause
of problems is attempting to use the PEM routines like
this:</p>
<p style="margin-left:9%; margin-top: 1em">X509 *x; <br/>
PEM_read_bio_X509(bp, &amp;x, 0, NULL);</p>
<p style="margin-left:9%; margin-top: 1em">this is a bug
because an attempt will be made to reuse the data at
<i>x</i> which is an uninitialised pointer.</p>
<p style="margin-left:9%; margin-top: 1em">These functions
make no assumption regarding the pass phrase received from
the password callback. It will simply be treated as a byte
sequence.</p>
<h2>PEM ENCRYPTION FORMAT
<a name="PEM ENCRYPTION FORMAT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These old
<b>PrivateKey</b> routines use a non standard technique for
encryption.</p>
<p style="margin-left:9%; margin-top: 1em">The private key
(or other data) takes the following form:</p>
<p style="margin-left:9%; margin-top: 1em">−−−−−BEGIN
RSA PRIVATE KEY−−−−− <br/>
Proc−Type: 4,ENCRYPTED <br/>
DEK−Info: DES−EDE3−CBC,3F17F5316E2BAC89
<br/>
...base64 encoded data... <br/>
−−−−−END RSA PRIVATE
KEY−−−−−</p>
<p style="margin-left:9%; margin-top: 1em">The line
beginning with <i>Proc−Type</i> contains the version
and the protection on the encapsulated data. The line
beginning <i>DEK−Info</i> contains two comma separated
values: the encryption algorithm name as used by
<b>EVP_get_cipherbyname()</b> and an initialization vector
used by the cipher encoded as a set of hexadecimal digits.
After those two lines is the base64−encoded encrypted
data.</p>
<p style="margin-left:9%; margin-top: 1em">The encryption
key is derived using <b>EVP_BytesToKey()</b>. The cipher's
initialization vector is passed to <b>EVP_BytesToKey()</b>
as the <i>salt</i> parameter. Internally,
<b>PKCS5_SALT_LEN</b> bytes of the salt are used (regardless
of the size of the initialization vector). The user's
password is passed to <b>EVP_BytesToKey()</b> using the
<i>data</i> and <i>datal</i> parameters. Finally, the
library uses an iteration count of 1 for
<b>EVP_BytesToKey()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The <i>key</i>
derived by <b>EVP_BytesToKey()</b> along with the original
initialization vector is then used to decrypt the encrypted
data. The <i>iv</i> produced by <b>EVP_BytesToKey()</b> is
not utilized or needed, and NULL should be passed to the
function.</p>
<p style="margin-left:9%; margin-top: 1em">The pseudo code
to derive the key would look similar to:</p>
<p style="margin-left:9%; margin-top: 1em">EVP_CIPHER*
cipher = EVP_des_ede3_cbc(); <br/>
EVP_MD* md = EVP_md5(); <br/>
unsigned int nkey = EVP_CIPHER_get_key_length(cipher); <br/>
unsigned int niv = EVP_CIPHER_get_iv_length(cipher); <br/>
unsigned char key[nkey]; <br/>
unsigned char iv[niv]; <br/>
memcpy(iv, HexToBin("3F17F5316E2BAC89"), niv);
<br/>
rc = EVP_BytesToKey(cipher, md, iv /*salt*/, pword, plen, 1,
key, NULL /*iv*/); <br/>
if (rc != nkey) <br/>
/* Error */ <br/>
/* On success, use key and iv to initialize the cipher
*/</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The PEM read
routines in some versions of OpenSSL will not correctly
reuse an existing structure. Therefore, the following:</p>
<p style="margin-left:9%; margin-top: 1em">PEM_read_bio_X509(bp,
&amp;x, 0, NULL);</p>
<p style="margin-left:9%; margin-top: 1em">where <i>x</i>
already contains a valid certificate, may not work,
whereas:</p>
<p style="margin-left:9%; margin-top: 1em">X509_free(x);
<br/>
x = PEM_read_bio_X509(bp, NULL, 0, NULL);</p>
<p style="margin-left:9%; margin-top: 1em">is guaranteed to
work. It is always acceptable for <i>x</i> to contain a
newly allocated, empty <b>X509</b> object (for example
allocated via <b>X509_new_ex</b>(3)).</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The read
routines return either a pointer to the structure read or
NULL if an error occurred.</p>
<p style="margin-left:9%; margin-top: 1em">The write
routines return 1 for success or 0 for failure.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Although the PEM
routines take several arguments in almost all applications
most of them are set to 0 or NULL.</p>
<p style="margin-left:9%; margin-top: 1em">To read a
certificate with a library context in PEM format from a
BIO:</p>
<p style="margin-left:9%; margin-top: 1em">X509 *x =
X509_new_ex(libctx, NULL); <br/>
if (x == NULL) <br/>
/* Error */ <br/>
if (PEM_read_bio_X509(bp, &amp;x, 0, NULL) == NULL) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Read a
certificate in PEM format from a BIO:</p>
<p style="margin-left:9%; margin-top: 1em">X509 *x; <br/>
x = PEM_read_bio_X509(bp, NULL, 0, NULL); <br/>
if (x == NULL) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Alternative
method:</p>
<p style="margin-left:9%; margin-top: 1em">X509 *x = NULL;
<br/>
if (!PEM_read_bio_X509(bp, &amp;x, 0, NULL)) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Write a
certificate to a BIO:</p>
<p style="margin-left:9%; margin-top: 1em">if
(!PEM_write_bio_X509(bp, x)) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Write a private
key (using traditional format) to a BIO using triple DES
encryption, the pass phrase is prompted for:</p>
<p style="margin-left:9%; margin-top: 1em">if
(!PEM_write_bio_PrivateKey(bp, key, EVP_des_ede3_cbc(),
NULL, 0, 0, NULL)) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Write a private
key (using PKCS#8 format) to a BIO using triple DES
encryption, using the pass phrase "hello":</p>
<p style="margin-left:9%; margin-top: 1em">if
(!PEM_write_bio_PKCS8PrivateKey(bp, key, EVP_des_ede3_cbc(),
<br/>
NULL, 0, 0, "hello")) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Read a private
key from a BIO using a pass phrase callback:</p>
<p style="margin-left:9%; margin-top: 1em">key =
PEM_read_bio_PrivateKey(bp, NULL, pass_cb, "My Private
Key"); <br/>
if (key == NULL) <br/>
/* Error */</p>
<p style="margin-left:9%; margin-top: 1em">Skeleton pass
phrase callback:</p>
<p style="margin-left:9%; margin-top: 1em">int pass_cb(char
*buf, int size, int rwflag, void *u) <br/>
{ <br/>
/* We'd probably do something else if 'rwflag' is 1 */ <br/>
printf("Enter pass phrase for \"%s\"\n",
(char *)u); <br/>
/* get pass phrase, length 'len' into 'tmp' */ <br/>
char *tmp = "hello"; <br/>
if (tmp == NULL) /* An error occurred */ <br/>
return −1; <br/>
size_t len = strlen(tmp); <br/>
if (len &gt; size) <br/>
len = size; <br/>
memcpy(buf, tmp, len); <br/>
return len; <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_EncryptInit</b>(3),
<b>EVP_BytesToKey</b>(3),
<b>passphrase−encoding</b>(7)</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The old Netscape
certificate sequences were no longer documented in OpenSSL
1.1.0; applications should use the PKCS7 standard instead as
they will be formally deprecated in a future releases.</p>
<p style="margin-left:9%; margin-top: 1em"><b>PEM_read_bio_PrivateKey_ex()</b>,
<b>PEM_read_PrivateKey_ex()</b>,
<b>PEM_read_bio_PUBKEY_ex()</b>, <b>PEM_read_PUBKEY_ex()</b>
and <b>PEM_read_bio_Parameters_ex()</b> were introduced in
OpenSSL 3.0.</p>
<p style="margin-left:9%; margin-top: 1em">The functions
<b>PEM_read_bio_RSAPrivateKey()</b>,
<b>PEM_read_RSAPrivateKey()</b>,
<b>PEM_write_bio_RSAPrivateKey()</b>,
<b>PEM_write_RSAPrivateKey()</b>,
<b>PEM_read_bio_RSAPublicKey()</b>,
<b>PEM_read_RSAPublicKey()</b>,
<b>PEM_write_bio_RSAPublicKey()</b>,
<b>PEM_write_RSAPublicKey()</b>,
<b>PEM_read_bio_RSA_PUBKEY()</b>,
<b>PEM_read_RSA_PUBKEY()</b>,
<b>PEM_write_bio_RSA_PUBKEY()</b>,
<b>PEM_write_RSA_PUBKEY()</b>,
<b>PEM_read_bio_DSAPrivateKey()</b>,
<b>PEM_read_DSAPrivateKey()</b>,
<b>PEM_write_bio_DSAPrivateKey()</b>,
<b>PEM_write_DSAPrivateKey()</b>,
<b>PEM_read_bio_DSA_PUBKEY()</b>,
<b>PEM_read_DSA_PUBKEY()</b>,
<b>PEM_write_bio_DSA_PUBKEY()</b>,
<b>PEM_write_DSA_PUBKEY()</b>;
<b>PEM_read_bio_DSAparams()</b>,
<b>PEM_read_DSAparams()</b>,
<b>PEM_write_bio_DSAparams()</b>,
<b>PEM_write_DSAparams()</b>,
<b>PEM_read_bio_DHparams()</b>, <b>PEM_read_DHparams()</b>,
<b>PEM_write_bio_DHparams()</b> and
<b>PEM_write_DHparams()</b> were deprecated in 3.0.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2001−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
