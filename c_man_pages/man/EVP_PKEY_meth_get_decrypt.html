<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:42:48 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>EVP_PKEY_METH_NEW</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">EVP_PKEY_METH_NEW</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Methods">Methods</a><br/>
<a href="#Functions">Functions</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">EVP_PKEY_meth_new,
EVP_PKEY_meth_free, EVP_PKEY_meth_copy, EVP_PKEY_meth_find,
EVP_PKEY_meth_add0, EVP_PKEY_METHOD, EVP_PKEY_meth_set_init,
EVP_PKEY_meth_set_copy, EVP_PKEY_meth_set_cleanup,
EVP_PKEY_meth_set_paramgen, EVP_PKEY_meth_set_keygen,
EVP_PKEY_meth_set_sign, EVP_PKEY_meth_set_verify,
EVP_PKEY_meth_set_verify_recover, EVP_PKEY_meth_set_signctx,
EVP_PKEY_meth_set_verifyctx, EVP_PKEY_meth_set_encrypt,
EVP_PKEY_meth_set_decrypt, EVP_PKEY_meth_set_derive,
EVP_PKEY_meth_set_ctrl, EVP_PKEY_meth_set_digestsign,
EVP_PKEY_meth_set_digestverify, EVP_PKEY_meth_set_check,
EVP_PKEY_meth_set_public_check,
EVP_PKEY_meth_set_param_check,
EVP_PKEY_meth_set_digest_custom, EVP_PKEY_meth_get_init,
EVP_PKEY_meth_get_copy, EVP_PKEY_meth_get_cleanup,
EVP_PKEY_meth_get_paramgen, EVP_PKEY_meth_get_keygen,
EVP_PKEY_meth_get_sign, EVP_PKEY_meth_get_verify,
EVP_PKEY_meth_get_verify_recover, EVP_PKEY_meth_get_signctx,
EVP_PKEY_meth_get_verifyctx, EVP_PKEY_meth_get_encrypt,
EVP_PKEY_meth_get_decrypt, EVP_PKEY_meth_get_derive,
EVP_PKEY_meth_get_ctrl, EVP_PKEY_meth_get_digestsign,
EVP_PKEY_meth_get_digestverify, EVP_PKEY_meth_get_check,
EVP_PKEY_meth_get_public_check,
EVP_PKEY_meth_get_param_check,
EVP_PKEY_meth_get_digest_custom, EVP_PKEY_meth_remove
− manipulating EVP_PKEY_METHOD structure</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/evp.h&gt;</p>
<p style="margin-left:9%; margin-top: 1em">The following
functions have been deprecated since OpenSSL 3.0, and can be
hidden entirely by defining <b>OPENSSL_API_COMPAT</b> with a
suitable version value, see
<b>openssl_user_macros</b>(7):</p>
<p style="margin-left:9%; margin-top: 1em">typedef struct
evp_pkey_method_st EVP_PKEY_METHOD; <br/>
EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags); <br/>
void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth); <br/>
void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const
EVP_PKEY_METHOD *src); <br/>
const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type); <br/>
int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth); <br/>
int EVP_PKEY_meth_remove(const EVP_PKEY_METHOD *pmeth); <br/>
void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth, <br/>
int (*init) (EVP_PKEY_CTX *ctx)); <br/>
void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth, <br/>
int (*copy) (EVP_PKEY_CTX *dst, <br/>
const EVP_PKEY_CTX *src)); <br/>
void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth, <br/>
void (*cleanup) (EVP_PKEY_CTX *ctx)); <br/>
void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth, <br/>
int (*paramgen_init) (EVP_PKEY_CTX *ctx), <br/>
int (*paramgen) (EVP_PKEY_CTX *ctx, <br/>
EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth, <br/>
int (*keygen_init) (EVP_PKEY_CTX *ctx), <br/>
int (*keygen) (EVP_PKEY_CTX *ctx, <br/>
EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth, <br/>
int (*sign_init) (EVP_PKEY_CTX *ctx), <br/>
int (*sign) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *sig, size_t *siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth, <br/>
int (*verify_init) (EVP_PKEY_CTX *ctx), <br/>
int (*verify) (EVP_PKEY_CTX *ctx, <br/>
const unsigned char *sig, <br/>
size_t siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD
*pmeth, <br/>
int (*verify_recover_init) (EVP_PKEY_CTX <br/>
*ctx), <br/>
int (*verify_recover) (EVP_PKEY_CTX <br/>
*ctx, <br/>
unsigned char <br/>
*sig, <br/>
size_t *siglen, <br/>
const unsigned <br/>
char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth, <br/>
int (*signctx_init) (EVP_PKEY_CTX *ctx, <br/>
EVP_MD_CTX *mctx), <br/>
int (*signctx) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *sig, <br/>
size_t *siglen, <br/>
EVP_MD_CTX *mctx)); <br/>
void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
<br/>
int (*verifyctx_init) (EVP_PKEY_CTX *ctx, <br/>
EVP_MD_CTX *mctx), <br/>
int (*verifyctx) (EVP_PKEY_CTX *ctx, <br/>
const unsigned char *sig, <br/>
int siglen, <br/>
EVP_MD_CTX *mctx)); <br/>
void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth, <br/>
int (*encrypt_init) (EVP_PKEY_CTX *ctx), <br/>
int (*encryptfn) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *out, <br/>
size_t *outlen, <br/>
const unsigned char *in, <br/>
size_t inlen)); <br/>
void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth, <br/>
int (*decrypt_init) (EVP_PKEY_CTX *ctx), <br/>
int (*decrypt) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *out, <br/>
size_t *outlen, <br/>
const unsigned char *in, <br/>
size_t inlen)); <br/>
void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth, <br/>
int (*derive_init) (EVP_PKEY_CTX *ctx), <br/>
int (*derive) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *key, <br/>
size_t *keylen)); <br/>
void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth, <br/>
int (*ctrl) (EVP_PKEY_CTX *ctx, int type, int p1, <br/>
void *p2), <br/>
int (*ctrl_str) (EVP_PKEY_CTX *ctx, <br/>
const char *type, <br/>
const char *value)); <br/>
void EVP_PKEY_meth_set_digestsign(EVP_PKEY_METHOD *pmeth,
<br/>
int (*digestsign) (EVP_MD_CTX *ctx, <br/>
unsigned char *sig, <br/>
size_t *siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_set_digestverify(EVP_PKEY_METHOD *pmeth,
<br/>
int (*digestverify) (EVP_MD_CTX *ctx, <br/>
const unsigned char *sig, <br/>
size_t siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_set_check(EVP_PKEY_METHOD *pmeth, <br/>
int (*check) (EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_set_public_check(EVP_PKEY_METHOD *pmeth,
<br/>
int (*check) (EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_set_param_check(EVP_PKEY_METHOD *pmeth,
<br/>
int (*check) (EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_set_digest_custom(EVP_PKEY_METHOD *pmeth,
<br/>
int (*digest_custom) (EVP_PKEY_CTX *ctx, <br/>
EVP_MD_CTX *mctx)); <br/>
void EVP_PKEY_meth_get_init(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pinit) (EVP_PKEY_CTX *ctx)); <br/>
void EVP_PKEY_meth_get_copy(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pcopy) (EVP_PKEY_CTX *dst, <br/>
EVP_PKEY_CTX *src)); <br/>
void EVP_PKEY_meth_get_cleanup(const EVP_PKEY_METHOD *pmeth,
<br/>
void (**pcleanup) (EVP_PKEY_CTX *ctx)); <br/>
void EVP_PKEY_meth_get_paramgen(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**pparamgen_init) (EVP_PKEY_CTX *ctx), <br/>
int (**pparamgen) (EVP_PKEY_CTX *ctx, <br/>
EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_get_keygen(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pkeygen_init) (EVP_PKEY_CTX *ctx), <br/>
int (**pkeygen) (EVP_PKEY_CTX *ctx, <br/>
EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_get_sign(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**psign_init) (EVP_PKEY_CTX *ctx), <br/>
int (**psign) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *sig, size_t *siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_get_verify(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pverify_init) (EVP_PKEY_CTX *ctx), <br/>
int (**pverify) (EVP_PKEY_CTX *ctx, <br/>
const unsigned char *sig, <br/>
size_t siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_get_verify_recover(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**pverify_recover_init) (EVP_PKEY_CTX <br/>
*ctx), <br/>
int (**pverify_recover) (EVP_PKEY_CTX <br/>
*ctx, <br/>
unsigned char <br/>
*sig, <br/>
size_t *siglen, <br/>
const unsigned <br/>
char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_get_signctx(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**psignctx_init) (EVP_PKEY_CTX *ctx, <br/>
EVP_MD_CTX *mctx), <br/>
int (**psignctx) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *sig, <br/>
size_t *siglen, <br/>
EVP_MD_CTX *mctx)); <br/>
void EVP_PKEY_meth_get_verifyctx(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**pverifyctx_init) (EVP_PKEY_CTX *ctx, <br/>
EVP_MD_CTX *mctx), <br/>
int (**pverifyctx) (EVP_PKEY_CTX *ctx, <br/>
const unsigned char *sig, <br/>
int siglen, <br/>
EVP_MD_CTX *mctx)); <br/>
void EVP_PKEY_meth_get_encrypt(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pencrypt_init) (EVP_PKEY_CTX *ctx), <br/>
int (**pencryptfn) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *out, <br/>
size_t *outlen, <br/>
const unsigned char *in, <br/>
size_t inlen)); <br/>
void EVP_PKEY_meth_get_decrypt(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pdecrypt_init) (EVP_PKEY_CTX *ctx), <br/>
int (**pdecrypt) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *out, <br/>
size_t *outlen, <br/>
const unsigned char *in, <br/>
size_t inlen)); <br/>
void EVP_PKEY_meth_get_derive(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pderive_init) (EVP_PKEY_CTX *ctx), <br/>
int (**pderive) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *key, <br/>
size_t *keylen)); <br/>
void EVP_PKEY_meth_get_ctrl(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pctrl) (EVP_PKEY_CTX *ctx, int type, int p1, <br/>
void *p2), <br/>
int (**pctrl_str) (EVP_PKEY_CTX *ctx, <br/>
const char *type, <br/>
const char *value)); <br/>
void EVP_PKEY_meth_get_digestsign(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**digestsign) (EVP_MD_CTX *ctx, <br/>
unsigned char *sig, <br/>
size_t *siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_get_digestverify(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**digestverify) (EVP_MD_CTX *ctx, <br/>
const unsigned char *sig, <br/>
size_t siglen, <br/>
const unsigned char *tbs, <br/>
size_t tbslen)); <br/>
void EVP_PKEY_meth_get_check(const EVP_PKEY_METHOD *pmeth,
<br/>
int (**pcheck) (EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_get_public_check(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**pcheck) (EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_get_param_check(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**pcheck) (EVP_PKEY *pkey)); <br/>
void EVP_PKEY_meth_get_digest_custom(const EVP_PKEY_METHOD
*pmeth, <br/>
int (**pdigest_custom) (EVP_PKEY_CTX *ctx, <br/>
EVP_MD_CTX *mctx));</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All of the
functions described on this page are deprecated.
Applications should instead use the OSSL_PROVIDER APIs.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_METHOD</b>
is a structure which holds a set of methods for a specific
public key cryptographic algorithm. Those methods are
usually used to perform different jobs, such as generating a
key, signing or verifying, encrypting or decrypting,
etc.</p>
<p style="margin-left:9%; margin-top: 1em">There are two
places where the <b>EVP_PKEY_METHOD</b> objects are stored:
one is a built−in static array representing the
standard methods for different algorithms, and the other one
is a stack of user−defined application−specific
methods, which can be manipulated by using
<b>EVP_PKEY_meth_add0</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>EVP_PKEY_METHOD</b> objects are usually referenced by
<b>EVP_PKEY_CTX</b> objects.</p>
<h3>Methods
<a name="Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The methods are
the underlying implementations of a particular public key
algorithm present by the <b>EVP_PKEY_CTX</b> object.</p>
<p style="margin-left:9%; margin-top: 1em">int (*init)
(EVP_PKEY_CTX *ctx); <br/>
int (*copy) (EVP_PKEY_CTX *dst, const EVP_PKEY_CTX *src);
<br/>
void (*cleanup) (EVP_PKEY_CTX *ctx);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>init()</b> method is called to initialize
algorithm−specific data when a new <b>EVP_PKEY_CTX</b>
is created. As opposed to <b>init()</b>, the
<b>cleanup()</b> method is called when an
<b>EVP_PKEY_CTX</b> is freed. The <b>copy()</b> method is
called when an <b>EVP_PKEY_CTX</b> is being duplicated.
Refer to <b>EVP_PKEY_CTX_new</b>(3),
<b>EVP_PKEY_CTX_new_id</b>(3), <b>EVP_PKEY_CTX_free</b>(3)
and <b>EVP_PKEY_CTX_dup</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int
(*paramgen_init) (EVP_PKEY_CTX *ctx); <br/>
int (*paramgen) (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>paramgen_init()</b> and <b>paramgen()</b> methods deal
with key parameter generation. They are called by
<b>EVP_PKEY_paramgen_init</b>(3) and
<b>EVP_PKEY_paramgen</b>(3) to handle the parameter
generation process.</p>
<p style="margin-left:9%; margin-top: 1em">int
(*keygen_init) (EVP_PKEY_CTX *ctx); <br/>
int (*keygen) (EVP_PKEY_CTX *ctx, EVP_PKEY *pkey);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>keygen_init()</b> and <b>keygen()</b> methods are used to
generate the actual key for the specified algorithm. They
are called by <b>EVP_PKEY_keygen_init</b>(3) and
<b>EVP_PKEY_keygen</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int (*sign_init)
(EVP_PKEY_CTX *ctx); <br/>
int (*sign) (EVP_PKEY_CTX *ctx, unsigned char *sig, size_t
*siglen, <br/>
const unsigned char *tbs, size_t tbslen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>sign_init()</b> and <b>sign()</b> methods are used to
generate the signature of a piece of data using a private
key. They are called by <b>EVP_PKEY_sign_init</b>(3) and
<b>EVP_PKEY_sign</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int
(*verify_init) (EVP_PKEY_CTX *ctx); <br/>
int (*verify) (EVP_PKEY_CTX *ctx, <br/>
const unsigned char *sig, size_t siglen, <br/>
const unsigned char *tbs, size_t tbslen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>verify_init()</b> and <b>verify()</b> methods are used to
verify whether a signature is valid. They are called by
<b>EVP_PKEY_verify_init</b>(3) and
<b>EVP_PKEY_verify</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int
(*verify_recover_init) (EVP_PKEY_CTX *ctx); <br/>
int (*verify_recover) (EVP_PKEY_CTX *ctx, <br/>
unsigned char *rout, size_t *routlen, <br/>
const unsigned char *sig, size_t siglen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>verify_recover_init()</b> and <b>verify_recover()</b>
methods are used to verify a signature and then recover the
digest from the signature (for instance, a signature that
was generated by RSA signing algorithm). They are called by
<b>EVP_PKEY_verify_recover_init</b>(3) and
<b>EVP_PKEY_verify_recover</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int
(*signctx_init) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx); <br/>
int (*signctx) (EVP_PKEY_CTX *ctx, unsigned char *sig,
size_t *siglen, <br/>
EVP_MD_CTX *mctx);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>signctx_init()</b> and <b>signctx()</b> methods are used
to sign a digest present by a <b>EVP_MD_CTX</b> object. They
are called by the EVP_DigestSign functions. See
<b>EVP_DigestSignInit</b>(3) for details.</p>
<p style="margin-left:9%; margin-top: 1em">int
(*verifyctx_init) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);
<br/>
int (*verifyctx) (EVP_PKEY_CTX *ctx, const unsigned char
*sig, int siglen, <br/>
EVP_MD_CTX *mctx);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>verifyctx_init()</b> and <b>verifyctx()</b> methods are
used to verify a signature against the data in a
<b>EVP_MD_CTX</b> object. They are called by the various
EVP_DigestVerify functions. See
<b>EVP_DigestVerifyInit</b>(3) for details.</p>
<p style="margin-left:9%; margin-top: 1em">int
(*encrypt_init) (EVP_PKEY_CTX *ctx); <br/>
int (*encrypt) (EVP_PKEY_CTX *ctx, unsigned char *out,
size_t *outlen, <br/>
const unsigned char *in, size_t inlen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>encrypt_init()</b> and <b>encrypt()</b> methods are used
to encrypt a piece of data. They are called by
<b>EVP_PKEY_encrypt_init</b>(3) and
<b>EVP_PKEY_encrypt</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int
(*decrypt_init) (EVP_PKEY_CTX *ctx); <br/>
int (*decrypt) (EVP_PKEY_CTX *ctx, unsigned char *out,
size_t *outlen, <br/>
const unsigned char *in, size_t inlen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>decrypt_init()</b> and <b>decrypt()</b> methods are used
to decrypt a piece of data. They are called by
<b>EVP_PKEY_decrypt_init</b>(3) and
<b>EVP_PKEY_decrypt</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int
(*derive_init) (EVP_PKEY_CTX *ctx); <br/>
int (*derive) (EVP_PKEY_CTX *ctx, unsigned char *key, size_t
*keylen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>derive_init()</b> and <b>derive()</b> methods are used to
derive the shared secret from a public key algorithm (for
instance, the DH algorithm). They are called by
<b>EVP_PKEY_derive_init</b>(3) and
<b>EVP_PKEY_derive</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int (*ctrl)
(EVP_PKEY_CTX *ctx, int type, int p1, void *p2); <br/>
int (*ctrl_str) (EVP_PKEY_CTX *ctx, const char *type, const
char *value);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>ctrl()</b> and <b>ctrl_str()</b> methods are used to
adjust algorithm−specific settings. See
<b>EVP_PKEY_CTX_ctrl</b>(3) and related functions for
details.</p>
<p style="margin-left:9%; margin-top: 1em">int
(*digestsign) (EVP_MD_CTX *ctx, unsigned char *sig, size_t
*siglen, <br/>
const unsigned char *tbs, size_t tbslen); <br/>
int (*digestverify) (EVP_MD_CTX *ctx, const unsigned char
*sig, <br/>
size_t siglen, const unsigned char *tbs, <br/>
size_t tbslen);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>digestsign()</b> and <b>digestverify()</b> methods are
used to generate or verify a signature in a one−shot
mode. They could be called by <b>EVP_DigestSign</b>(3) and
<b>EVP_DigestVerify</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">int (*check)
(EVP_PKEY *pkey); <br/>
int (*public_check) (EVP_PKEY *pkey); <br/>
int (*param_check) (EVP_PKEY *pkey);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>check()</b>, <b>public_check()</b> and
<b>param_check()</b> methods are used to validate a
key−pair, the public component and parameters
respectively for a given <b>pkey</b>. They could be called
by <b>EVP_PKEY_check</b>(3), <b>EVP_PKEY_public_check</b>(3)
and <b>EVP_PKEY_param_check</b>(3) respectively.</p>
<p style="margin-left:9%; margin-top: 1em">int
(*digest_custom) (EVP_PKEY_CTX *ctx, EVP_MD_CTX *mctx);</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>digest_custom()</b> method is used to generate customized
digest content before the real message is passed to
functions like <b>EVP_DigestSignUpdate</b>(3) or
<b>EVP_DigestVerifyInit</b>(3). This is usually required by
some public key signature algorithms like SM2 which requires
a hashed prefix to the message to be signed. The
<b>digest_custom()</b> function will be called by
<b>EVP_DigestSignInit</b>(3) and
<b>EVP_DigestVerifyInit</b>(3).</p>
<h3>Functions
<a name="Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_new()</b>
creates and returns a new <b>EVP_PKEY_METHOD</b> object, and
associates the given <b>id</b> and <b>flags</b>. The
following flags are supported:</p>
<p style="margin-left:9%; margin-top: 1em">EVP_PKEY_FLAG_AUTOARGLEN
<br/>
EVP_PKEY_FLAG_SIGCTX_CUSTOM</p>
<p style="margin-left:9%; margin-top: 1em">If an
<b>EVP_PKEY_METHOD</b> is set with the
<b>EVP_PKEY_FLAG_AUTOARGLEN</b> flag, the maximum size of
the output buffer will be automatically calculated or
checked in corresponding EVP methods by the EVP framework.
Thus the implementations of these methods don't need to care
about handling the case of returning output buffer size by
themselves. For details on the output buffer size, refer to
<b>EVP_PKEY_sign</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>EVP_PKEY_FLAG_SIGCTX_CUSTOM</b> is used to indicate the
<b>signctx()</b> method of an <b>EVP_PKEY_METHOD</b> is
always called by the EVP framework while doing a digest
signing operation by calling
<b>EVP_DigestSignFinal</b>(3).</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_free()</b>
frees an existing <b>EVP_PKEY_METHOD</b> pointed by
<b>pmeth</b>. If the argument is NULL, nothing is done.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_copy()</b>
copies an <b>EVP_PKEY_METHOD</b> object from <b>src</b> to
<b>dst</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_find()</b>
finds an <b>EVP_PKEY_METHOD</b> object with the <b>id</b>.
This function first searches through the user−defined
method objects and then the built−in objects.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_add0()</b>
adds <b>pmeth</b> to the user defined stack of methods.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_remove()</b>
removes an <b>EVP_PKEY_METHOD</b> object added by
<b>EVP_PKEY_meth_add0()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The
EVP_PKEY_meth_set functions set the corresponding fields of
<b>EVP_PKEY_METHOD</b> structure with the arguments
passed.</p>
<p style="margin-left:9%; margin-top: 1em">The
EVP_PKEY_meth_get functions get the corresponding fields of
<b>EVP_PKEY_METHOD</b> structure to the arguments
provided.</p>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_new()</b>
returns a pointer to a new <b>EVP_PKEY_METHOD</b> object or
returns NULL on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_free()</b>
and <b>EVP_PKEY_meth_copy()</b> do not return values.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_find()</b>
returns a pointer to the found <b>EVP_PKEY_METHOD</b> object
or returns NULL if not found.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_add0()</b>
returns 1 if method is added successfully or 0 if an error
occurred.</p>
<p style="margin-left:9%; margin-top: 1em"><b>EVP_PKEY_meth_remove()</b>
returns 1 if method is removed successfully or 0 if an error
occurred.</p>
<p style="margin-left:9%; margin-top: 1em">All
EVP_PKEY_meth_set and EVP_PKEY_meth_get functions have no
return values. For the 'get' functions, function pointers
are returned by arguments.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All of these
functions were deprecated in OpenSSL 3.0.</p>
<p style="margin-left:9%; margin-top: 1em">The signature of
the <i>copy</i> functional argument of
<b>EVP_PKEY_meth_set_copy()</b> has changed in OpenSSL 3.0
so its <i>src</i> parameter is now constified.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2017−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
