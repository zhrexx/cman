<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:44:15 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>GLFEEDBACKBUFFER</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">GLFEEDBACKBUFFER</h1>
<a href="#NAME">NAME</a><br/>
<a href="#C SPECIFICATION">C SPECIFICATION</a><br/>
<a href="#PARAMETERS">PARAMETERS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#ASSOCIATED GETS">ASSOCIATED GETS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glFeedbackBuffer</b>
− controls feedback mode</p>
<h2>C SPECIFICATION
<a name="C SPECIFICATION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">void
<b>glFeedbackBuffer</b>( GLsizei <i>size</i>,</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="29%"></td>
<td width="71%">
<p>GLenum <i>type</i>,</p></td></tr>
<tr align="left" valign="top">
<td width="29%"></td>
<td width="71%">
<p>GLfloat <i>*buffer</i> )</p></td></tr>
</table>
<h2>PARAMETERS
<a name="PARAMETERS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><i>size</i></p></td>
<td width="2%"></td>
<td width="81%">
<p style="margin-top: 1em">Specifies the maximum number of
values that can be written into <i>buffer</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><i>type</i></p></td>
<td width="2%"></td>
<td width="81%">
<p>Specifies a symbolic constant that describes the
information that will be returned for each vertex.
<b>GL_2D</b>, <b>GL_3D</b>, <b>GL_3D_COLOR</b>,
<b>GL_3D_COLOR_TEXTURE</b>, and <b>GL_4D_COLOR_TEXTURE</b>
are accepted.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><i>buffer</i></p></td>
<td width="2%"></td>
<td width="81%">
<p>Returns the feedback data.</p></td></tr>
</table>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>glFeedbackBuffer</b> function controls feedback.
Feedback, like selection, is a GL mode. The mode is selected
by calling <b>glRenderMode</b> with <b>GL_FEEDBACK</b>. When
the GL is in feedback mode, no pixels are produced by
rasterization. Instead, information about primitives that
would have been rasterized is fed back to the application
using the GL.</p>
<p style="margin-left:9%; margin-top: 1em"><b>glFeedbackBuffer</b>
has three arguments: <i>buffer</i> is a pointer to an array
of floating-point values into which feedback information is
placed. <i>size</i> indicates the size of the array.
<i>type</i> is a symbolic constant describing the
information that is fed back for each vertex.
<b>glFeedbackBuffer</b> must be issued before feedback mode
is enabled (by calling <b>glRenderMode</b> with argument
<b>GL_FEEDBACK</b>). Setting <b>GL_FEEDBACK</b> without
establishing the feedback buffer, or calling
<b>glFeedbackBuffer</b> while the GL is in feedback mode, is
an error.</p>
<p style="margin-left:9%; margin-top: 1em">When
<b>glRenderMode</b> is called while in feedback mode, it
returns the number of entries placed in the feedback array,
and resets the feedback array pointer to the base of the
feedback buffer. The returned value never exceeds
<i>size</i>. If the feedback data required more room than
was available in <i>buffer</i>, <b>glRenderMode</b> returns
a negative value. To take the GL out of feedback mode, call
<b>glRenderMode</b> with a parameter value other than
<b>GL_FEEDBACK</b>.</p>
<p style="margin-left:9%; margin-top: 1em">While in
feedback mode, each primitive, bitmap, or pixel rectangle
that would be rasterized generates a block of values that
are copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is
partially written so as to fill the array (if there is any
room left at all), and an overflow flag is set. Each block
begins with a code indicating the primitive type, followed
by values that describe the primitive’s vertices and
associated data. Entries are also written for bitmaps and
pixel rectangles. Feedback occurs after polygon culling and
<b>glPolygonMode</b> interpretation of polygons has taken
place, so polygons that are culled are not returned in the
feedback buffer. It can also occur after polygons with more
than three edges are broken up into triangles, if the GL
implementation renders polygons by performing this
decomposition.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>glPassThrough</b> command can be used to insert a marker
into the feedback buffer. See <b>glPassThrough</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Following is the
grammar for the blocks of values written into the feedback
buffer. Each primitive is indicated with a unique
identifying value followed by some number of vertices.
Polygon entries include an integer value indicating how many
vertices follow. A vertex is fed back as some number of
floating-point values, as determined by <i>type</i>. Colors
are fed back as four values in RGBA mode and one value in
color index mode.</p>
<p style="margin-left:18%; margin-top: 1em">feedbackList
← feedbackItem feedbackList | feedbackItem</p>
<p style="margin-left:18%; margin-top: 1em">feedbackItem
← point | lineSegment | polygon | bitmap |
pixelRectangle | passThru</p>
<p style="margin-left:18%; margin-top: 1em">point ←
<b>GL_POINT_TOKEN</b> vertex</p>
<p style="margin-left:18%; margin-top: 1em">lineSegment
← <b>GL_LINE_TOKEN</b> vertex vertex |
<b>GL_LINE_RESET_TOKEN</b> vertex vertex</p>
<p style="margin-left:18%; margin-top: 1em">polygon ←
<b>GL_POLYGON_TOKEN</b> n polySpec</p>
<p style="margin-left:18%; margin-top: 1em">polySpec ←
polySpec vertex | vertex vertex vertex</p>
<p style="margin-left:18%; margin-top: 1em">bitmap ←
<b>GL_BITMAP_TOKEN</b> vertex</p>
<p style="margin-left:18%; margin-top: 1em">pixelRectangle
← <b>GL_DRAW_PIXEL_TOKEN</b> vertex |
<b>GL_COPY_PIXEL_TOKEN</b> vertex</p>
<p style="margin-left:18%; margin-top: 1em">passThru ←
<b>GL_PASS_THROUGH_TOKEN</b> value</p>
<p style="margin-left:18%; margin-top: 1em">vertex ←
2d | 3d | 3dColor | 3dColorTexture | 4dColorTexture</p>
<p style="margin-left:18%; margin-top: 1em">2d ← value
value</p>
<p style="margin-left:18%; margin-top: 1em">3d ← value
value value</p>
<p style="margin-left:18%; margin-top: 1em">3dColor ←
value value value color</p>
<p style="margin-left:18%; margin-top: 1em">3dColorTexture
← value value value color tex</p>
<p style="margin-left:18%; margin-top: 1em">4dColorTexture
← value value value value color tex</p>
<p style="margin-left:18%; margin-top: 1em">color ←
rgba | index</p>
<p style="margin-left:18%; margin-top: 1em">rgba ←
value value value value</p>
<p style="margin-left:18%; margin-top: 1em">index ←
value</p>
<p style="margin-left:18%; margin-top: 1em">tex ←
value value value value</p>
<p style="margin-left:9%; margin-top: 1em"><i>value</i> is
a floating-point number, and <i>n</i> is a floating-point
integer giving the number of vertices in the polygon.
<b>GL_POINT_TOKEN</b>, <b>GL_LINE_TOKEN</b>,
<b>GL_LINE_RESET_TOKEN</b>, <b>GL_POLYGON_TOKEN</b>,
<b>GL_BITMAP_TOKEN</b>, <b>GL_DRAW_PIXEL_TOKEN</b>,
<b>GL_COPY_PIXEL_TOKEN</b> and <b>GL_PASS_THROUGH_TOKEN</b>
are symbolic floating-point constants.
<b>GL_LINE_RESET_TOKEN</b> is returned whenever the line
stipple pattern is reset. The data returned as a vertex
depends on the feedback <i>type</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The following
table gives the correspondence between <i>type</i> and the
number of values per vertex. <i>k</i> is 1 in color index
mode and 4 in RGBA mode.</p>
<p style="margin-left:9%; margin-top: 1em">Feedback vertex
coordinates are in window coordinates, except <i>w</i>,
which is in clip coordinates. Feedback colors are lighted,
if lighting is enabled. Feedback texture coordinates are
generated, if texture coordinate generation is enabled. They
are always transformed by the texture matrix.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glFeedbackBuffer</b>,
when used in a display list, is not compiled into the
display list but is executed immediately.</p>
<p style="margin-left:9%; margin-top: 1em">When the
<b>GL_ARB_multitexture</b> extension is supported,
<b>glFeedbackBuffer</b> returns only the texture coordinates
of texture unit <b>GL_TEXTURE0_ARB</b>.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_ENUM</b>
is generated if <i>type</i> is not an accepted value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_VALUE</b>
is generated if <i>size</i> is negative.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <b>glFeedbackBuffer</b> is called while the
render mode is <b>GL_FEEDBACK</b>, or if <b>glRenderMode</b>
is called with argument <b>GL_FEEDBACK</b> before
<b>glFeedbackBuffer</b> is called at least once.</p>
<p style="margin-left:9%; margin-top: 1em"><b>GL_INVALID_OPERATION</b>
is generated if <b>glFeedbackBuffer</b> is executed between
the execution of <b>glBegin</b> and the corresponding
execution of <b>glEnd</b>.</p>
<h2>ASSOCIATED GETS
<a name="ASSOCIATED GETS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glGet</b>
with argument <b>GL_RENDER_MODE <br/>
glGet</b> with argument <b>GL_FEEDBACK_BUFFER_POINTER <br/>
glGet</b> with argument <b>GL_FEEDBACK_BUFFER_SIZE <br/>
glGet</b> with argument <b>GL_FEEDBACK_BUFFER_TYPE</b></p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>glBegin(3G)</b>,
<b>glLineStipple(3G)</b>, <b>glPassThrough(3G)</b>,
<b>glPolygonMode(3G)</b>, <b>glRenderMode(3G)</b>,
<b>glSelectBuffer(3G)</b></p>
<hr/>
</body>
</html>
