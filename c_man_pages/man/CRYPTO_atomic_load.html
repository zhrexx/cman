<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:40:25 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>CRYPTO_THREAD_RUN_ONCE</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">CRYPTO_THREAD_RUN_ONCE</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUES">RETURN VALUES</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">CRYPTO_THREAD_run_once,
CRYPTO_THREAD_lock_new, CRYPTO_THREAD_read_lock,
CRYPTO_THREAD_write_lock, CRYPTO_THREAD_unlock,
CRYPTO_THREAD_lock_free, CRYPTO_atomic_add,
CRYPTO_atomic_or, CRYPTO_atomic_load,
CRYPTO_atomic_load_int, OSSL_set_max_threads,
OSSL_get_max_threads, OSSL_get_thread_support_flags,
OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL,
OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN − OpenSSL
thread support</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/crypto.h&gt; <br/>
CRYPTO_ONCE CRYPTO_ONCE_STATIC_INIT; <br/>
int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void
(*init)(void)); <br/>
CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void); <br/>
int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock); <br/>
int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock); <br/>
int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock); <br/>
void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock); <br/>
int CRYPTO_atomic_add(int *val, int amount, int *ret,
CRYPTO_RWLOCK *lock); <br/>
int CRYPTO_atomic_or(uint64_t *val, uint64_t op, uint64_t
*ret, <br/>
CRYPTO_RWLOCK *lock); <br/>
int CRYPTO_atomic_load(uint64_t *val, uint64_t *ret,
CRYPTO_RWLOCK *lock); <br/>
int CRYPTO_atomic_load_int(int *val, int *ret, CRYPTO_RWLOCK
*lock); <br/>
int OSSL_set_max_threads(OSSL_LIB_CTX *ctx, uint64_t
max_threads); <br/>
uint64_t OSSL_get_max_threads(OSSL_LIB_CTX *ctx); <br/>
uint32_t OSSL_get_thread_support_flags(void); <br/>
#define OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL <br/>
#define OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">OpenSSL can be
safely used in multi−threaded applications provided
that support for the underlying OS threading API is
built−in. Currently, OpenSSL supports the pthread and
Windows APIs. OpenSSL can also be built without any
multi−threading support, for example on platforms that
don't provide any threading support or that provide a
threading API that is not yet supported by OpenSSL.</p>
<p style="margin-left:9%; margin-top: 1em">The following
multi−threading function are provided:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_THREAD_run_once()</b> can be used to perform
one−time initialization. The <i>once</i> argument must
be a pointer to a static object of type <b>CRYPTO_ONCE</b>
that was statically initialized to the value
<b>CRYPTO_ONCE_STATIC_INIT</b>. The <i>init</i> argument is
a pointer to a function that performs the desired exactly
once initialization. In particular, this can be used to
allocate locks in a thread−safe manner, which can then
be used with the locking functions below.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_THREAD_lock_new()</b> allocates, initializes
and returns a new read/write lock.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_THREAD_read_lock()</b> locks the provided
<i>lock</i> for reading.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_THREAD_write_lock()</b> locks the provided
<i>lock</i> for writing.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_THREAD_unlock()</b> unlocks the previously
locked <i>lock</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_THREAD_lock_free()</b> frees the provided
<i>lock</i>. If the argument is NULL, nothing is done.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_atomic_add()</b> atomically adds <i>amount</i>
to <i>*val</i> and returns the result of the operation in
<i>*ret</i>. <i>lock</i> will be locked, unless atomic
operations are supported on the specific platform. Because
of this, if a variable is modified by
<b>CRYPTO_atomic_add()</b> then <b>CRYPTO_atomic_add()</b>
must be the only way that the variable is modified. If
atomic operations are not supported and <i>lock</i> is NULL,
then the function will fail.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_atomic_or()</b> performs an atomic bitwise or
of <i>op</i> and <i>*val</i> and stores the result back in
<i>*val</i>. It also returns the result of the operation in
<i>*ret</i>. <i>lock</i> will be locked, unless atomic
operations are supported on the specific platform. Because
of this, if a variable is modified by
<b>CRYPTO_atomic_or()</b> or read by
<b>CRYPTO_atomic_load()</b> then <b>CRYPTO_atomic_or()</b>
must be the only way that the variable is modified. If
atomic operations are not supported and <i>lock</i> is NULL,
then the function will fail.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_atomic_load()</b> atomically loads the
contents of <i>*val</i> into <i>*ret</i>. <i>lock</i> will
be locked, unless atomic operations are supported on the
specific platform. Because of this, if a variable is
modified by <b>CRYPTO_atomic_or()</b> or read by
<b>CRYPTO_atomic_load()</b> then <b>CRYPTO_atomic_load()</b>
must be the only way that the variable is read. If atomic
operations are not supported and <i>lock</i> is NULL, then
the function will fail.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>CRYPTO_atomic_load_int()</b> works identically to
<b>CRYPTO_atomic_load()</b> but operates on an <i>int</i>
value instead of a <i>uint64_t</i> value.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>OSSL_set_max_threads()</b> sets the maximum number of
threads to be used by the thread pool. If the argument is 0,
thread pooling is disabled. OpenSSL will not create any
threads and existing threads in the thread pool will be torn
down. The maximum thread count is a limit, not a target.
Threads will not be spawned unless (and until) there is
demand. Thread polling is disabled by default. To enable
threading you must call <b>OSSL_set_max_threads()</b>
explicitly. Under no circumstances is this done for you.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="2%"></td>
<td width="88%">
<p><b>OSSL_get_thread_support_flags()</b> determines what
thread pool functionality OpenSSL is compiled with and is
able to support in the current run time environment.
<b>OSSL_THREAD_SUPPORT_FLAG_THREAD_POOL</b> indicates that
the base thread pool functionality is available, and
<b>OSSL_THREAD_SUPPORT_FLAG_DEFAULT_SPAWN</b> indicates that
the default thread pool model is available. The default
thread pool model is currently the only model available,
therefore both of these flags must be set for thread pool
functionality to be used.</p></td></tr>
</table>
<h2>RETURN VALUES
<a name="RETURN VALUES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>CRYPTO_THREAD_run_once()</b>
returns 1 on success, or 0 on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CRYPTO_THREAD_lock_new()</b>
returns the allocated lock, or NULL on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>CRYPTO_THREAD_lock_free()</b>
returns no value.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_set_max_threads()</b>
returns 1 on success and 0 on failure. Returns failure if
OpenSSL−managed thread pooling is not supported (for
example, if it is not supported on the current platform, or
because OpenSSL is not built with the necessary
support).</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_get_max_threads()</b>
returns the maximum number of threads currently allowed to
be used by the thread pool. If thread pooling is disabled or
not available, returns 0.</p>
<p style="margin-left:9%; margin-top: 1em"><b>OSSL_get_thread_support_flags()</b>
returns zero or more <b>OSSL_THREAD_SUPPORT_FLAG</b>
values.</p>
<p style="margin-left:9%; margin-top: 1em">The other
functions return 1 on success, or 0 on error.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">On Windows
platforms the CRYPTO_THREAD_* types and functions in the
<i>&lt;openssl/crypto.h&gt;</i> header are dependent on some
of the types customarily made available by including
<i>&lt;windows.h&gt;</i>. The application developer is
likely to require control over when the latter is included,
commonly as one of the first included headers. Therefore, it
is defined as an application developer's responsibility to
include <i>&lt;windows.h&gt;</i> prior to
<i>&lt;openssl/crypto.h&gt;</i> where use of CRYPTO_THREAD_*
types and functions is required.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">You can find out
if OpenSSL was configured with thread support:</p>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;openssl/opensslconf.h&gt; <br/>
#if defined(OPENSSL_THREADS) <br/>
/* thread support enabled */ <br/>
#else <br/>
/* no thread support */ <br/>
#endif</p>
<p style="margin-left:9%; margin-top: 1em">This example
safely initializes and uses a lock.</p>
<p style="margin-left:9%; margin-top: 1em">#ifdef _WIN32
<br/>
# include &lt;windows.h&gt; <br/>
#endif <br/>
#include &lt;openssl/crypto.h&gt; <br/>
static CRYPTO_ONCE once = CRYPTO_ONCE_STATIC_INIT; <br/>
static CRYPTO_RWLOCK *lock; <br/>
static void myinit(void) <br/>
{ <br/>
lock = CRYPTO_THREAD_lock_new(); <br/>
} <br/>
static int mylock(void) <br/>
{ <br/>
if (!CRYPTO_THREAD_run_once(&amp;once, void init) || lock ==
NULL) <br/>
return 0; <br/>
return CRYPTO_THREAD_write_lock(lock); <br/>
} <br/>
static int myunlock(void) <br/>
{ <br/>
return CRYPTO_THREAD_unlock(lock); <br/>
} <br/>
int serialized(void) <br/>
{ <br/>
int ret = 0; <br/>
if (!mylock()) { <br/>
/* Do not unlock unless the lock was successfully acquired.
*/ <br/>
return 0; <br/>
} <br/>
/* Your code here, do not return without releasing the lock!
*/ <br/>
ret = ... ; <br/>
myunlock(); <br/>
return ret; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Finalization of
locks is an advanced topic, not covered in this example.
This can only be done at process exit or when a dynamically
loaded library is no longer in use and is unloaded. The
simplest solution is to just "leak" the lock in
applications and not repeatedly load/unload shared libraries
that allocate locks.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>crypto</b>(7),
<b>openssl−threads</b>(7).</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright
2000−2024 The OpenSSL Project Authors. All Rights
Reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Licensed under
the Apache License 2.0 (the "License"). You may
not use this file except in compliance with the License. You
can obtain a copy in the file LICENSE in the source
distribution or at
&lt;https://www.openssl.org/source/license.html&gt;.</p>
<hr/>
</body>
</html>
