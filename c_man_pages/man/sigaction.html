<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:39:01 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>sigaction</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">sigaction</h1>
<a href="#NAME">NAME</a><br/>
<a href="#LIBRARY">LIBRARY</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#The siginfo_t argument to a SA_SIGINFO handler">The siginfo_t argument to a SA_SIGINFO handler</a><br/>
<a href="#The si_code field">The si_code field</a><br/>
<a href="#Dynamically probing for flag bit support">Dynamically probing for flag bit support</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#ERRORS">ERRORS</a><br/>
<a href="#VERSIONS">VERSIONS</a><br/>
<a href="#C library/kernel differences">C library/kernel differences</a><br/>
<a href="#STANDARDS">STANDARDS</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#Undocumented">Undocumented</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#EXAMPLES">EXAMPLES</a><br/>
<a href="#Probing for flag support">Probing for flag support</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">sigaction,
rt_sigaction − examine and change a signal action</p>
<h2>LIBRARY
<a name="LIBRARY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Standard C
library (<i>libc</i>, <i>−lc</i>)</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;signal.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
sigaction(int</b> <i>signum</i><b>, <br/>
const struct sigaction *_Nullable restrict</b>
<i>act</i><b>, <br/>
struct sigaction *_Nullable restrict</b>
<i>oldact</i><b>);</b></p>
<p style="margin-left:4%; margin-top: 1em">Feature Test
Macro Requirements for glibc (see
<b>feature_test_macros</b>(7)):</p>
<p style="margin-left:9%; margin-top: 1em"><b>sigaction</b>():
<br/>
_POSIX_C_SOURCE</p>
<p style="margin-left:9%; margin-top: 1em"><i>siginfo_t</i>:
<br/>
_POSIX_C_SOURCE &gt;= 199309L</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>sigaction</b>() system call is used to change the action
taken by a process on receipt of a specific signal. (See
<b>signal</b>(7) for an overview of signals.)</p>
<p style="margin-left:9%; margin-top: 1em"><i>signum</i>
specifies the signal and can be any valid signal except
<b>SIGKILL</b> and <b>SIGSTOP</b>.</p>
<p style="margin-left:9%; margin-top: 1em">If <i>act</i> is
non-NULL, the new action for signal <i>signum</i> is
installed from <i>act</i>. If <i>oldact</i> is non-NULL, the
previous action is saved in <i>oldact</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>sigaction</i> structure is defined as something like:</p>
<p style="margin-left:14%; margin-top: 1em">struct
sigaction { <br/>
void (*sa_handler)(int); <br/>
void (*sa_sigaction)(int, siginfo_t *, void *); <br/>
sigset_t sa_mask; <br/>
int sa_flags; <br/>
void (*sa_restorer)(void); <br/>
};</p>
<p style="margin-left:9%; margin-top: 1em">On some
architectures a union is involved: do not assign to both
<i>sa_handler</i> and <i>sa_sigaction</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>sa_restorer</i> field is not intended for application
use. (POSIX does not specify a <i>sa_restorer</i> field.)
Some further details of the purpose of this field can be
found in <b>sigreturn</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em"><i>sa_handler</i>
specifies the action to be associated with <i>signum</i> and
can be one of the following:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><b>SIG_DFL</b> for the default action.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><b>SIG_IGN</b> to ignore this signal.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>A pointer to a signal handling function. This function
receives the signal number as its only argument.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">If
<b>SA_SIGINFO</b> is specified in <i>sa_flags</i>, then
<i>sa_sigaction</i> (instead of <i>sa_handler</i>) specifies
the signal-handling function for <i>signum</i>. This
function receives three arguments, as described below.</p>
<p style="margin-left:9%; margin-top: 1em"><i>sa_mask</i>
specifies a mask of signals which should be blocked (i.e.,
added to the signal mask of the thread in which the signal
handler is invoked) during execution of the signal handler.
In addition, the signal which triggered the handler will be
blocked, unless the <b>SA_NODEFER</b> flag is used.</p>
<p style="margin-left:9%; margin-top: 1em"><i>sa_flags</i>
specifies a set of flags which modify the behavior of the
signal. It is formed by the bitwise OR of zero or more of
the following: <b><br/>
SA_NOCLDSTOP</b></p>
<p style="margin-left:18%;">If <i>signum</i> is
<b>SIGCHLD</b>, do not receive notification when child
processes stop (i.e., when they receive one of
<b>SIGSTOP</b>, <b>SIGTSTP</b>, <b>SIGTTIN</b>, or
<b>SIGTTOU</b>) or resume (i.e., they receive
<b>SIGCONT</b>) (see <b>wait</b>(2)). This flag is
meaningful only when establishing a handler for
<b>SIGCHLD</b>.</p>
<p style="margin-left:9%;"><b>SA_NOCLDWAIT</b> (since Linux
2.6)</p>
<p style="margin-left:18%;">If <i>signum</i> is
<b>SIGCHLD</b>, do not transform children into zombies when
they terminate. See also <b>waitpid</b>(2). This flag is
meaningful only when establishing a handler for
<b>SIGCHLD</b>, or when setting that signal’s
disposition to <b>SIG_DFL</b>.</p>
<p style="margin-left:18%; margin-top: 1em">If the
<b>SA_NOCLDWAIT</b> flag is set when establishing a handler
for <b>SIGCHLD</b>, POSIX.1 leaves it unspecified whether a
<b>SIGCHLD</b> signal is generated when a child process
terminates. On Linux, a <b>SIGCHLD</b> signal is generated
in this case; on some other implementations, it is not.</p>
<p style="margin-left:9%;"><b>SA_NODEFER</b></p>
<p style="margin-left:18%;">Do not add the signal to the
thread’s signal mask while the handler is executing,
unless the signal is specified in <i>act.sa_mask</i>.
Consequently, a further instance of the signal may be
delivered to the thread while it is executing the handler.
This flag is meaningful only when establishing a signal
handler.</p>
<p style="margin-left:18%; margin-top: 1em"><b>SA_NOMASK</b>
is an obsolete, nonstandard synonym for this flag.</p>
<p style="margin-left:9%;"><b>SA_ONSTACK</b></p>
<p style="margin-left:18%;">Call the signal handler on an
alternate signal stack provided by <b>sigaltstack</b>(2). If
an alternate stack is not available, the default stack will
be used. This flag is meaningful only when establishing a
signal handler.</p>
<p style="margin-left:9%;"><b>SA_RESETHAND</b></p>
<p style="margin-left:18%;">Restore the signal action to
the default upon entry to the signal handler. This flag is
meaningful only when establishing a signal handler.</p>
<p style="margin-left:18%; margin-top: 1em"><b>SA_ONESHOT</b>
is an obsolete, nonstandard synonym for this flag.</p>
<p style="margin-left:9%;"><b>SA_RESTART</b></p>
<p style="margin-left:18%;">Provide behavior compatible
with BSD signal semantics by making certain system calls
restartable across signals. This flag is meaningful only
when establishing a signal handler. See <b>signal</b>(7) for
a discussion of system call restarting.</p>
<p style="margin-left:9%;"><b>SA_RESTORER</b></p>
<p style="margin-left:18%;"><i>Not intended for application
use</i>. This flag is used by C libraries to indicate that
the <i>sa_restorer</i> field contains the address of a
"signal trampoline". See <b>sigreturn</b>(2) for
more details.</p>
<p style="margin-left:9%;"><b>SA_SIGINFO</b> (since Linux
2.2)</p>
<p style="margin-left:18%;">The signal handler takes three
arguments, not one. In this case, <i>sa_sigaction</i> should
be set instead of <i>sa_handler</i>. This flag is meaningful
only when establishing a signal handler.</p>
<p style="margin-left:9%;"><b>SA_UNSUPPORTED</b> (since
Linux 5.11)</p>
<p style="margin-left:18%;">Used to dynamically probe for
flag bit support.</p>
<p style="margin-left:18%; margin-top: 1em">If an attempt
to register a handler succeeds with this flag set in
<i>act−&gt;sa_flags</i> alongside other flags that are
potentially unsupported by the kernel, and an immediately
subsequent <b>sigaction</b>() call specifying the same
signal number and with a non-NULL <i>oldact</i> argument
yields <b>SA_UNSUPPORTED</b> <i>clear</i> in
<i>oldact−&gt;sa_flags</i>, then
<i>oldact−&gt;sa_flags</i> may be used as a bitmask
describing which of the potentially unsupported flags are,
in fact, supported. See the section "Dynamically
probing for flag bit support" below for more
details.</p>
<p style="margin-left:9%;"><b>SA_EXPOSE_TAGBITS</b> (since
Linux 5.11)</p>
<p style="margin-left:18%;">Normally, when delivering a
signal, an architecture-specific set of tag bits are cleared
from the <i>si_addr</i> field of <i>siginfo_t</i>. If this
flag is set, an architecture-specific subset of the tag bits
will be preserved in <i>si_addr</i>.</p>
<p style="margin-left:18%; margin-top: 1em">Programs that
need to be compatible with Linux versions older than 5.11
must use <b>SA_UNSUPPORTED</b> to probe for support.</p>
<h3>The siginfo_t argument to a SA_SIGINFO handler
<a name="The siginfo_t argument to a SA_SIGINFO handler"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When the
<b>SA_SIGINFO</b> flag is specified in <i>act.sa_flags</i>,
the signal handler address is passed via the
<i>act.sa_sigaction</i> field. This handler takes three
arguments, as follows:</p>
<p style="margin-left:14%; margin-top: 1em">void <br/>
handler(int sig, siginfo_t *info, void *ucontext) <br/>
{ <br/>
... <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">These three
arguments are as follows</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p><i>sig</i></p></td>
<td width="4%"></td>
<td width="82%">
<p>The number of the signal that caused invocation of the
handler.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="5%">
<p><i>info</i></p></td>
<td width="4%"></td>
<td width="82%">
<p>A pointer to a <i>siginfo_t</i>, which is a structure
containing further information about the signal, as
described below.</p></td></tr>
</table>
<p style="margin-left:9%;"><i>ucontext</i></p>
<p style="margin-left:18%;">This is a pointer to a
<i>ucontext_t</i> structure, cast to <i>void *</i>. The
structure pointed to by this field contains signal context
information that was saved on the user-space stack by the
kernel; for details, see <b>sigreturn</b>(2). Further
information about the <i>ucontext_t</i> structure can be
found in <b>getcontext</b>(3) and <b>signal</b>(7).
Commonly, the handler function doesn’t make any use of
the third argument.</p>
<p style="margin-left:9%; margin-top: 1em">The
<i>siginfo_t</i> data type is a structure with the following
fields:</p>
<p style="margin-left:14%; margin-top: 1em">siginfo_t {
<br/>
int si_signo; /* Signal number */ <br/>
int si_errno; /* An errno value */ <br/>
int si_code; /* Signal code */ <br/>
int si_trapno; /* Trap number that caused <br/>
hardware−generated signal <br/>
(unused on most architectures) */ <br/>
pid_t si_pid; /* Sending process ID */ <br/>
uid_t si_uid; /* Real user ID of sending process */ <br/>
int si_status; /* Exit value or signal */ <br/>
clock_t si_utime; /* User time consumed */ <br/>
clock_t si_stime; /* System time consumed */ <br/>
union sigval si_value; /* Signal value */ <br/>
int si_int; /* POSIX.1b signal */ <br/>
void *si_ptr; /* POSIX.1b signal */ <br/>
int si_overrun; /* Timer overrun count; <br/>
POSIX.1b timers */ <br/>
int si_timerid; /* Timer ID; POSIX.1b timers */ <br/>
void *si_addr; /* Memory location which caused fault */ <br/>
long si_band; /* Band event (was <i>int</i> in <br/>
glibc 2.3.2 and earlier) */ <br/>
int si_fd; /* File descriptor */ <br/>
short si_addr_lsb; /* Least significant bit of address <br/>
(since Linux 2.6.32) */ <br/>
void *si_lower; /* Lower bound when address violation <br/>
occurred (since Linux 3.19) */ <br/>
void *si_upper; /* Upper bound when address violation <br/>
occurred (since Linux 3.19) */ <br/>
int si_pkey; /* Protection key on PTE that caused <br/>
fault (since Linux 4.6) */ <br/>
void *si_call_addr; /* Address of system call instruction
<br/>
(since Linux 3.5) */ <br/>
int si_syscall; /* Number of attempted system call <br/>
(since Linux 3.5) */ <br/>
unsigned int si_arch; /* Architecture of attempted system
call <br/>
(since Linux 3.5) */ <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em"><i>si_signo</i>,
<i>si_errno</i> and <i>si_code</i> are defined for all
signals. (<i>si_errno</i> is generally unused on Linux.) The
rest of the struct may be a union, so that one should read
only the fields that are meaningful for the given
signal:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Signals sent with <b>kill</b>(2) and <b>sigqueue</b>(3)
fill in <i>si_pid</i> and <i>si_uid</i>. In addition,
signals sent with <b>sigqueue</b>(3) fill in <i>si_int</i>
and <i>si_ptr</i> with the values specified by the sender of
the signal; see <b>sigqueue</b>(3) for more details.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Signals sent by POSIX.1b timers (since Linux 2.6) fill
in <i>si_overrun</i> and <i>si_timerid</i>. The
<i>si_timerid</i> field is an internal ID used by the kernel
to identify the timer; it is not the same as the timer ID
returned by <b>timer_create</b>(2). The <i>si_overrun</i>
field is the timer overrun count; this is the same
information as is obtained by a call to
<b>timer_getoverrun</b>(2). These fields are nonstandard
Linux extensions.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p>Signals sent for message queue notification (see the
description of <b>SIGEV_SIGNAL</b> in <b>mq_notify</b>(3))
fill in <i>si_int</i>/<i>si_ptr</i>, with the
<i>sigev_value</i> supplied to <b>mq_notify</b>(3);
<i>si_pid</i>, with the process ID of the message sender;
and <i>si_uid</i>, with the real user ID of the message
sender.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><b>SIGCHLD</b> fills in <i>si_pid</i>, <i>si_uid</i>,
<i>si_status</i>, <i>si_utime</i>, and <i>si_stime</i>,
providing information about the child. The <i>si_pid</i>
field is the process ID of the child; <i>si_uid</i> is the
child’s real user ID. The <i>si_status</i> field
contains the exit status of the child (if <i>si_code</i> is
<b>CLD_EXITED</b>), or the signal number that caused the
process to change state. The <i>si_utime</i> and
<i>si_stime</i> contain the user and system CPU time used by
the child process; these fields do not include the times
used by waited-for children (unlike <b>getrusage</b>(2) and
<b>times</b>(2)). Up to Linux 2.6, and since Linux 2.6.27,
these fields report CPU time in units of
<i>sysconf(_SC_CLK_TCK)</i>. In Linux 2.6 kernels before
Linux 2.6.27, a bug meant that these fields reported time in
units of the (configurable) system jiffy (see
<b>time</b>(7)).</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><b>SIGILL</b>, <b>SIGFPE</b>, <b>SIGSEGV</b>,
<b>SIGBUS</b>, and <b>SIGTRAP</b> fill in <i>si_addr</i>
with the address of the fault. On some architectures, these
signals also fill in the <i>si_trapno</i> field.</p></td></tr>
</table>
<p style="margin-left:13%; margin-top: 1em">Some suberrors
of <b>SIGBUS</b>, in particular <b>BUS_MCEERR_AO</b> and
<b>BUS_MCEERR_AR</b>, also fill in <i>si_addr_lsb</i>. This
field indicates the least significant bit of the reported
address and therefore the extent of the corruption. For
example, if a full page was corrupted, <i>si_addr_lsb</i>
contains <i>log2(sysconf(_SC_PAGESIZE))</i>. When
<b>SIGTRAP</b> is delivered in response to a
<b>ptrace</b>(2) event (PTRACE_EVENT_foo), <i>si_addr</i> is
not populated, but <i>si_pid</i> and <i>si_uid</i> are
populated with the respective process ID and user ID
responsible for delivering the trap. In the case of
<b>seccomp</b>(2), the tracee will be shown as delivering
the event. <b>BUS_MCEERR_*</b> and <i>si_addr_lsb</i> are
Linux-specific extensions.</p>
<p style="margin-left:13%; margin-top: 1em">The
<b>SEGV_BNDERR</b> suberror of <b>SIGSEGV</b> populates
<i>si_lower</i> and <i>si_upper</i>.</p>
<p style="margin-left:13%; margin-top: 1em">The
<b>SEGV_PKUERR</b> suberror of <b>SIGSEGV</b> populates
<i>si_pkey</i>.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="87%">
<p style="margin-top: 1em"><b>SIGIO</b>/<b>SIGPOLL</b> (the
two names are synonyms on Linux) fills in <i>si_band</i> and
<i>si_fd</i>. The <i>si_band</i> event is a bit mask
containing the same values as are filled in the
<i>revents</i> field by <b>poll</b>(2). The <i>si_fd</i>
field indicates the file descriptor for which the I/O event
occurred; for further details, see the description of
<b>F_SETSIG</b> in <b>fcntl</b>(2).</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="87%">
<p><b>SIGSYS</b>, generated (since Linux 3.5) when a
seccomp filter returns <b>SECCOMP_RET_TRAP</b>, fills in
<i>si_call_addr</i>, <i>si_syscall</i>, <i>si_arch</i>,
<i>si_errno</i>, and other fields as described in
<b>seccomp</b>(2).</p> </td></tr>
</table>
<h3>The si_code field
<a name="The si_code field"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<i>si_code</i> field inside the <i>siginfo_t</i> argument
that is passed to a <b>SA_SIGINFO</b> signal handler is a
value (not a bit mask) indicating why this signal was sent.
For a <b>ptrace</b>(2) event, <i>si_code</i> will contain
<b>SIGTRAP</b> and have the ptrace event in the high
byte:</p>
<p style="margin-left:14%; margin-top: 1em">(SIGTRAP |
PTRACE_EVENT_foo &lt;&lt; 8).</p>
<p style="margin-left:9%; margin-top: 1em">For a
non-<b>ptrace</b>(2) event, the values that can appear in
<i>si_code</i> are described in the remainder of this
section. Since glibc 2.20, the definitions of most of these
symbols are obtained from <i>&lt;signal.h&gt;</i> by
defining feature test macros (before including <i>any</i>
header file) as follows:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="3%"></td>
<td width="64%">
<p style="margin-top: 1em"><b>_XOPEN_SOURCE</b> with the
value 500 or greater;</p></td>
<td width="23%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="64%">
<p><b>_XOPEN_SOURCE</b> and <b>_XOPEN_SOURCE_EXTENDED</b>;
or</p> </td>
<td width="23%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="3%"></td>
<td width="64%">
<p><b>_POSIX_C_SOURCE</b> with the value 200809L or
greater.</p> </td>
<td width="23%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">For the
<b>TRAP_*</b> constants, the symbol definitions are provided
only in the first two cases. Before glibc 2.20, no feature
test macros were required to obtain these symbols.</p>
<p style="margin-left:9%; margin-top: 1em">For a regular
signal, the following list shows the values which can be
placed in <i>si_code</i> for any signal, along with the
reason that the signal was generated.</p>
<p style="margin-left:14%;"><b>SI_USER</b></p>
<p style="margin-left:23%;"><b>kill</b>(2).</p>
<p style="margin-left:14%;"><b>SI_KERNEL</b></p>
<p style="margin-left:23%;">Sent by the kernel.</p>
<p style="margin-left:14%;"><b>SI_QUEUE</b></p>
<p style="margin-left:23%;"><b>sigqueue</b>(3).</p>
<p style="margin-left:14%;"><b>SI_TIMER</b></p>
<p style="margin-left:23%;">POSIX timer expired.</p>
<p style="margin-left:14%;"><b>SI_MESGQ</b> (since Linux
2.6.6)</p>
<p style="margin-left:23%;">POSIX message queue state
changed; see <b>mq_notify</b>(3).</p>
<p style="margin-left:14%;"><b>SI_ASYNCIO</b></p>
<p style="margin-left:23%;">AIO completed.</p>
<p style="margin-left:14%;"><b>SI_SIGIO</b></p>
<p style="margin-left:23%;">Queued <b>SIGIO</b> (only up to
Linux 2.2; from Linux 2.4 onward <b>SIGIO</b>/<b>SIGPOLL</b>
fills in <i>si_code</i> as described below).</p>
<p style="margin-left:14%;"><b>SI_TKILL</b> (since Linux
2.4.19)</p>
<p style="margin-left:23%;"><b>tkill</b>(2) or
<b>tgkill</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a <b>SIGILL</b>
signal:</p>
<p style="margin-left:14%;"><b>ILL_ILLOPC</b></p>
<p style="margin-left:23%;">Illegal opcode.</p>
<p style="margin-left:14%;"><b>ILL_ILLOPN</b></p>
<p style="margin-left:23%;">Illegal operand.</p>
<p style="margin-left:14%;"><b>ILL_ILLADR</b></p>
<p style="margin-left:23%;">Illegal addressing mode.</p>
<p style="margin-left:14%;"><b>ILL_ILLTRP</b></p>
<p style="margin-left:23%;">Illegal trap.</p>
<p style="margin-left:14%;"><b>ILL_PRVOPC</b></p>
<p style="margin-left:23%;">Privileged opcode.</p>
<p style="margin-left:14%;"><b>ILL_PRVREG</b></p>
<p style="margin-left:23%;">Privileged register.</p>
<p style="margin-left:14%;"><b>ILL_COPROC</b></p>
<p style="margin-left:23%;">Coprocessor error.</p>
<p style="margin-left:14%;"><b>ILL_BADSTK</b></p>
<p style="margin-left:23%;">Internal stack error.</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a <b>SIGFPE</b>
signal:</p>
<p style="margin-left:14%;"><b>FPE_INTDIV</b></p>
<p style="margin-left:23%;">Integer divide by zero.</p>
<p style="margin-left:14%;"><b>FPE_INTOVF</b></p>
<p style="margin-left:23%;">Integer overflow.</p>
<p style="margin-left:14%;"><b>FPE_FLTDIV</b></p>
<p style="margin-left:23%;">Floating-point divide by
zero.</p>
<p style="margin-left:14%;"><b>FPE_FLTOVF</b></p>
<p style="margin-left:23%;">Floating-point overflow.</p>
<p style="margin-left:14%;"><b>FPE_FLTUND</b></p>
<p style="margin-left:23%;">Floating-point underflow.</p>
<p style="margin-left:14%;"><b>FPE_FLTRES</b></p>
<p style="margin-left:23%;">Floating-point inexact
result.</p>
<p style="margin-left:14%;"><b>FPE_FLTINV</b></p>
<p style="margin-left:23%;">Floating-point invalid
operation.</p>
<p style="margin-left:14%;"><b>FPE_FLTSUB</b></p>
<p style="margin-left:23%;">Subscript out of range.</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a <b>SIGSEGV</b>
signal:</p>
<p style="margin-left:14%;"><b>SEGV_MAPERR</b></p>
<p style="margin-left:23%;">Address not mapped to
object.</p>
<p style="margin-left:14%;"><b>SEGV_ACCERR</b></p>
<p style="margin-left:23%;">Invalid permissions for mapped
object.</p>
<p style="margin-left:14%;"><b>SEGV_BNDERR</b> (since Linux
3.19)</p>
<p style="margin-left:23%;">Failed address bound
checks.</p>
<p style="margin-left:14%;"><b>SEGV_PKUERR</b> (since Linux
4.6)</p>
<p style="margin-left:23%;">Access was denied by memory
protection keys. See <b>pkeys</b>(7). The protection key
which applied to this access is available via
<i>si_pkey</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a <b>SIGBUS</b>
signal:</p>
<p style="margin-left:14%;"><b>BUS_ADRALN</b></p>
<p style="margin-left:23%;">Invalid address alignment.</p>
<p style="margin-left:14%;"><b>BUS_ADRERR</b></p>
<p style="margin-left:23%;">Nonexistent physical
address.</p>
<p style="margin-left:14%;"><b>BUS_OBJERR</b></p>
<p style="margin-left:23%;">Object-specific hardware
error.</p>
<p style="margin-left:14%;"><b>BUS_MCEERR_AR</b> (since
Linux 2.6.32)</p>
<p style="margin-left:23%;">Hardware memory error consumed
on a machine check; action required.</p>
<p style="margin-left:14%;"><b>BUS_MCEERR_AO</b> (since
Linux 2.6.32)</p>
<p style="margin-left:23%;">Hardware memory error detected
in process but not consumed; action optional.</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a <b>SIGTRAP</b>
signal:</p>
<p style="margin-left:14%;"><b>TRAP_BRKPT</b></p>
<p style="margin-left:23%;">Process breakpoint.</p>
<p style="margin-left:14%;"><b>TRAP_TRACE</b></p>
<p style="margin-left:23%;">Process trace trap.</p>
<p style="margin-left:14%;"><b>TRAP_BRANCH</b> (since Linux
2.4, IA64 only)</p>
<p style="margin-left:23%;">Process taken branch trap.</p>
<p style="margin-left:14%;"><b>TRAP_HWBKPT</b> (since Linux
2.4, IA64 only)</p>
<p style="margin-left:23%;">Hardware
breakpoint/watchpoint.</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a <b>SIGCHLD</b>
signal:</p>
<p style="margin-left:14%;"><b>CLD_EXITED</b></p>
<p style="margin-left:23%;">Child has exited.</p>
<p style="margin-left:14%;"><b>CLD_KILLED</b></p>
<p style="margin-left:23%;">Child was killed.</p>
<p style="margin-left:14%;"><b>CLD_DUMPED</b></p>
<p style="margin-left:23%;">Child terminated
abnormally.</p>
<p style="margin-left:14%;"><b>CLD_TRAPPED</b></p>
<p style="margin-left:23%;">Traced child has trapped.</p>
<p style="margin-left:14%;"><b>CLD_STOPPED</b></p>
<p style="margin-left:23%;">Child has stopped.</p>
<p style="margin-left:14%;"><b>CLD_CONTINUED</b> (since
Linux 2.6.9)</p>
<p style="margin-left:23%;">Stopped child has
continued.</p>
<p style="margin-left:9%; margin-top: 1em">The following
values can be placed in <i>si_code</i> for a
<b>SIGIO</b>/<b>SIGPOLL</b> signal:</p>
<p style="margin-left:14%;"><b>POLL_IN</b></p>
<p style="margin-left:23%;">Data input available.</p>
<p style="margin-left:14%;"><b>POLL_OUT</b></p>
<p style="margin-left:23%;">Output buffers available.</p>
<p style="margin-left:14%;"><b>POLL_MSG</b></p>
<p style="margin-left:23%;">Input message available.</p>
<p style="margin-left:14%;"><b>POLL_ERR</b></p>
<p style="margin-left:23%;">I/O error.</p>
<p style="margin-left:14%;"><b>POLL_PRI</b></p>
<p style="margin-left:23%;">High priority input
available.</p>
<p style="margin-left:14%;"><b>POLL_HUP</b></p>
<p style="margin-left:23%;">Device disconnected.</p>
<p style="margin-left:9%; margin-top: 1em">The following
value can be placed in <i>si_code</i> for a <b>SIGSYS</b>
signal:</p>
<p style="margin-left:14%;"><b>SYS_SECCOMP</b> (since Linux
3.5)</p>
<p style="margin-left:23%;">Triggered by a
<b>seccomp</b>(2) filter rule.</p>
<h3>Dynamically probing for flag bit support
<a name="Dynamically probing for flag bit support"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
<b>sigaction</b>() call on Linux accepts unknown bits set in
<i>act−&gt;sa_flags</i> without error. The behavior of
the kernel starting with Linux 5.11 is that a second
<b>sigaction</b>() will clear unknown bits from
<i>oldact−&gt;sa_flags</i>. However, historically, a
second <b>sigaction</b>() call would typically leave those
bits set in <i>oldact−&gt;sa_flags</i>.</p>
<p style="margin-left:9%; margin-top: 1em">This means that
support for new flags cannot be detected simply by testing
for a flag in <i>sa_flags</i>, and a program must test that
<b>SA_UNSUPPORTED</b> has been cleared before relying on the
contents of <i>sa_flags</i>.</p>
<p style="margin-left:9%; margin-top: 1em">Since the
behavior of the signal handler cannot be guaranteed unless
the check passes, it is wise to either block the affected
signal while registering the handler and performing the
check in this case, or where this is not possible, for
example if the signal is synchronous, to issue the second
<b>sigaction</b>() in the signal handler itself.</p>
<p style="margin-left:9%; margin-top: 1em">In kernels that
do not support a specific flag, the kernel’s behavior
is as if the flag was not set, even if the flag was set in
<i>act−&gt;sa_flags</i>.</p>
<p style="margin-left:9%; margin-top: 1em">The flags
<b>SA_NOCLDSTOP</b>, <b>SA_NOCLDWAIT</b>, <b>SA_SIGINFO</b>,
<b>SA_ONSTACK</b>, <b>SA_RESTART</b>, <b>SA_NODEFER</b>,
<b>SA_RESETHAND</b>, and, if defined by the architecture,
<b>SA_RESTORER</b> may not be reliably probed for using this
mechanism, because they were introduced before Linux 5.11.
However, in general, programs may assume that these flags
are supported, since they have all been supported since
Linux 2.6, which was released in the year 2003.</p>
<p style="margin-left:9%; margin-top: 1em">See EXAMPLES
below for a demonstration of the use of
<b>SA_UNSUPPORTED</b>.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>sigaction</b>()
returns 0 on success; on error, −1 is returned, and
<i>errno</i> is set to indicate the error.</p>
<h2>ERRORS
<a name="ERRORS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p style="margin-top: 1em"><b>EFAULT</b></p></td>
<td width="1%"></td>
<td width="82%">
<p style="margin-top: 1em"><i>act</i> or <i>oldact</i>
points to memory which is not a valid part of the process
address space.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="8%">
<p><b>EINVAL</b></p></td>
<td width="1%"></td>
<td width="82%">
<p>An invalid signal was specified. This will also be
generated if an attempt is made to change the action for
<b>SIGKILL</b> or <b>SIGSTOP</b>, which cannot be caught or
ignored.</p> </td></tr>
</table>
<h2>VERSIONS
<a name="VERSIONS"></a>
</h2>
<h3>C library/kernel differences
<a name="C library/kernel differences"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The glibc
wrapper function for <b>sigaction</b>() gives an error
(<b>EINVAL</b>) on attempts to change the disposition of the
two real-time signals used internally by the NPTL threading
implementation. See <b>nptl</b>(7) for details.</p>
<p style="margin-left:9%; margin-top: 1em">On architectures
where the signal trampoline resides in the C library, the
glibc wrapper function for <b>sigaction</b>() places the
address of the trampoline code in the <i>act.sa_restorer</i>
field and sets the <b>SA_RESTORER</b> flag in the
<i>act.sa_flags</i> field. See <b>sigreturn</b>(2).</p>
<p style="margin-left:9%; margin-top: 1em">The original
Linux system call was named <b>sigaction</b>(). However,
with the addition of real-time signals in Linux 2.2, the
fixed-size, 32-bit <i>sigset_t</i> type supported by that
system call was no longer fit for purpose. Consequently, a
new system call, <b>rt_sigaction</b>(), was added to support
an enlarged <i>sigset_t</i> type. The new system call takes
a fourth argument, <i>size_t sigsetsize</i>, which specifies
the size in bytes of the signal sets in <i>act.sa_mask</i>
and <i>oldact.sa_mask</i>. This argument is currently
required to have the value <i>sizeof(sigset_t)</i> (or the
error <b>EINVAL</b> results). The glibc <b>sigaction</b>()
wrapper function hides these details from us, transparently
calling <b>rt_sigaction</b>() when the kernel provides
it.</p>
<h2>STANDARDS
<a name="STANDARDS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2008.</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-2001,
SVr4.</p>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-1990
disallowed setting the action for <b>SIGCHLD</b> to
<b>SIG_IGN</b>. POSIX.1-2001 and later allow this
possibility, so that ignoring <b>SIGCHLD</b> can be used to
prevent the creation of zombies (see <b>wait</b>(2)).
Nevertheless, the historical BSD and System V behaviors
for ignoring <b>SIGCHLD</b> differ, so that the only
completely portable method of ensuring that terminated
children do not become zombies is to catch the
<b>SIGCHLD</b> signal and perform a <b>wait</b>(2) or
similar.</p>
<p style="margin-left:9%; margin-top: 1em">POSIX.1-1990
specified only <b>SA_NOCLDSTOP</b>. POSIX.1-2001 added
<b>SA_NOCLDWAIT</b>, <b>SA_NODEFER</b>, <b>SA_ONSTACK</b>,
<b>SA_RESETHAND</b>, <b>SA_RESTART</b>, and
<b>SA_SIGINFO</b> as XSI extensions. POSIX.1-2008 moved
<b>SA_NODEFER</b>, <b>SA_RESETHAND</b>, <b>SA_RESTART</b>,
and <b>SA_SIGINFO</b> to the base specifications. Use of
these latter values in <i>sa_flags</i> may be less portable
in applications intended for older UNIX implementations.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>SA_RESETHAND</b> flag is compatible with the SVr4 flag of
the same name.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>SA_NODEFER</b> flag is compatible with the SVr4 flag of
the same name under kernels 1.3.9 and later. On older
kernels the Linux implementation allowed the receipt of any
signal, not just the one we are installing (effectively
overriding any <i>sa_mask</i> settings).</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">A child created
via <b>fork</b>(2) inherits a copy of its parent’s
signal dispositions. During an <b>execve</b>(2), the
dispositions of handled signals are reset to the default;
the dispositions of ignored signals are left unchanged.</p>
<p style="margin-left:9%; margin-top: 1em">According to
POSIX, the behavior of a process is undefined after it
ignores a <b>SIGFPE</b>, <b>SIGILL</b>, or <b>SIGSEGV</b>
signal that was not generated by <b>kill</b>(2) or
<b>raise</b>(3). Integer division by zero has undefined
result. On some architectures it will generate a
<b>SIGFPE</b> signal. (Also dividing the most negative
integer by −1 may generate <b>SIGFPE</b>.) Ignoring
this signal might lead to an endless loop.</p>
<p style="margin-left:9%; margin-top: 1em"><b>sigaction</b>()
can be called with a NULL second argument to query the
current signal handler. It can also be used to check whether
a given signal is valid for the current machine by calling
it with NULL second and third arguments.</p>
<p style="margin-left:9%; margin-top: 1em">It is not
possible to block <b>SIGKILL</b> or <b>SIGSTOP</b> (by
specifying them in <i>sa_mask</i>). Attempts to do so are
silently ignored.</p>
<p style="margin-left:9%; margin-top: 1em">See
<b>sigsetops</b>(3) for details on manipulating signal
sets.</p>
<p style="margin-left:9%; margin-top: 1em">See
<b>signal−safety</b>(7) for a list of the
async-signal-safe functions that can be safely called inside
from inside a signal handler.</p>
<h3>Undocumented
<a name="Undocumented"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Before the
introduction of <b>SA_SIGINFO</b>, it was also possible to
get some additional information about the signal. This was
done by providing an <i>sa_handler</i> signal handler with a
second argument of type <i>struct sigcontext</i>, which is
the same structure as the one that is passed in the
<i>uc_mcontext</i> field of the <i>ucontext</i> structure
that is passed (via a pointer) in the third argument of the
<i>sa_sigaction</i> handler. See the relevant Linux kernel
sources for details. This use is obsolete now.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">When delivering
a signal with a <b>SA_SIGINFO</b> handler, the kernel does
not always provide meaningful values for all of the fields
of the <i>siginfo_t</i> that are relevant for that
signal.</p>
<p style="margin-left:9%; margin-top: 1em">Up to and
including Linux 2.6.13, specifying <b>SA_NODEFER</b> in
<i>sa_flags</i> prevents not only the delivered signal from
being masked during execution of the handler, but also the
signals specified in <i>sa_mask</i>. This bug was fixed in
Linux 2.6.14.</p>
<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See
<b>mprotect</b>(2).</p>
<h3>Probing for flag support
<a name="Probing for flag support"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The following
example program exits with status <b>EXIT_SUCCESS</b> if
<b>SA_EXPOSE_TAGBITS</b> is determined to be supported, and
<b>EXIT_FAILURE</b> otherwise.</p>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;signal.h&gt; <br/>
#include &lt;stdio.h&gt; <br/>
#include &lt;stdlib.h&gt; <br/>
#include &lt;unistd.h&gt; <br/>
void <br/>
handler(int signo, siginfo_t *info, void *context) <br/>
{ <br/>
struct sigaction oldact; <br/>
if (sigaction(SIGSEGV, NULL, &amp;oldact) == −1 <br/>
|| (oldact.sa_flags &amp; SA_UNSUPPORTED) <br/>
|| !(oldact.sa_flags &amp; SA_EXPOSE_TAGBITS)) <br/>
{ <br/>
_exit(EXIT_FAILURE); <br/>
} <br/>
_exit(EXIT_SUCCESS); <br/>
} <br/>
int <br/>
main(void) <br/>
{ <br/>
struct sigaction act = { 0 }; <br/>
act.sa_flags = SA_SIGINFO | SA_UNSUPPORTED |
SA_EXPOSE_TAGBITS; <br/>
act.sa_sigaction = &amp;handler; <br/>
if (sigaction(SIGSEGV, &amp;act, NULL) == −1) { <br/>
perror("sigaction"); <br/>
exit(EXIT_FAILURE); <br/>
} <br/>
raise(SIGSEGV); <br/>
}</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>kill</b>(1),
<b>kill</b>(2), <b>pause</b>(2),
<b>pidfd_send_signal</b>(2), <b>restart_syscall</b>(2),
<b>seccomp</b>(2), <b>sigaltstack</b>(2), <b>signal</b>(2),
<b>signalfd</b>(2), <b>sigpending</b>(2),
<b>sigprocmask</b>(2), <b>sigreturn</b>(2),
<b>sigsuspend</b>(2), <b>wait</b>(2), <b>killpg</b>(3),
<b>raise</b>(3), <b>siginterrupt</b>(3), <b>sigqueue</b>(3),
<b>sigsetops</b>(3), <b>sigvec</b>(3), <b>core</b>(5),
<b>signal</b>(7)</p>
<hr/>
</body>
</html>
