<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:56:01 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XCreateGC</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">XCreateGC</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNTAX">SYNTAX</a><br/>
<a href="#ARGUMENTS">ARGUMENTS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#STRUCTURES">STRUCTURES</a><br/>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">XCreateGC,
XCopyGC, XChangeGC, XGetGCValues, XFreeGC, XGContextFromGC,
XGCValues − create or free graphics contexts and
graphics context structure</p>
<h2>SYNTAX
<a name="SYNTAX"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">GC XCreateGC(Display
*<i>display</i>, Drawable <i>d</i>, unsigned long
<i>valuemask</i>, XGCValues *<i>values</i>);</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">int XCopyGC(Display
*<i>display</i>, GC <i>src</i>, unsigned long
<i>valuemask</i>, GC <i>dest</i>);</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">int XChangeGC(Display
*<i>display</i>, GC <i>gc</i>, unsigned long
<i>valuemask</i>, XGCValues *<i>values</i>);</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">Status XGetGCValues(Display
*<i>display</i>, GC <i>gc</i>, unsigned long
<i>valuemask</i>, XGCValues *<i>values_return</i>);</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">int XFreeGC(Display
*<i>display</i>, GC <i>gc</i>);</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="91%">
<p style="margin-top: 1em">GContext XGContextFromGC(GC
<i>gc</i>);</p> </td></tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<h2>ARGUMENTS
<a name="ARGUMENTS"></a>
</h2>
<td width="9%"></td>
<td width="12%"></td>
<td width="1%"></td>
<td width="78%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>d</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies the drawable.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>dest</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies the destination GC.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>display</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies the connection to the X server.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>gc</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies the GC.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>src</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies the components of the source GC.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>valuemask</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies which components in the GC are to be set,
copied, changed, or returned. This argument is the bitwise
inclusive OR of zero or more of the valid GC component mask
bits.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><i>values</i></p></td>
<td width="1%"></td>
<td width="78%">
<p>Specifies any values as specified by the valuemask.</p></td></tr>
</table>
<p style="margin-left:9%;"><i>values_return</i></p>
<p style="margin-left:22%;">Returns the GC values in the
specified <b>XGCValues</b> structure.</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>XCreateGC</b> function creates a graphics context and
returns a GC. The GC can be used with any destination
drawable having the same root and depth as the specified
drawable. Use with other drawables results in a
<b>BadMatch</b> error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>XCreateGC</b>
can generate <b>BadAlloc</b>, <b>BadDrawable</b>,
<b>BadFont</b>, <b>BadMatch</b>, <b>BadPixmap</b>, and
<b>BadValue</b> errors.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>XCopyGC</b> function copies the specified components from
the source GC to the destination GC. The source and
destination GCs must have the same root and depth, or a
<b>BadMatch</b> error results. The valuemask specifies which
component to copy, as for <b>XCreateGC</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>XCopyGC</b>
can generate <b>BadAlloc</b>, <b>BadGC</b>, and
<b>BadMatch</b> errors.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>XChangeGC</b> function changes the components specified
by valuemask for the specified GC. The values argument
contains the values to be set. The values and restrictions
are the same as for <b>XCreateGC</b>. Changing the clip-mask
overrides any previous <b>XSetClipRectangles</b> request on
the context. Changing the dash-offset or dash-list overrides
any previous <b>XSetDashes</b> request on the context. The
order in which components are verified and altered is server
dependent. If an error is generated, a subset of the
components may have been altered.</p>
<p style="margin-left:9%; margin-top: 1em"><b>XChangeGC</b>
can generate <b>BadAlloc</b>, <b>BadFont</b>, <b>BadGC</b>,
<b>BadMatch</b>, <b>BadPixmap</b>, and <b>BadValue</b>
errors.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>XGetGCValues</b> function returns the components
specified by valuemask for the specified GC. If the
valuemask contains a valid set of GC mask bits
(<b>GCFunction</b>, <b>GCPlaneMask</b>, <b>GCForeground</b>,
<b>GCBackground</b>, <b>GCLineWidth</b>, <b>GCLineStyle</b>,
<b>GCCapStyle</b>, <b>GCJoinStyle</b>, <b>GCFillStyle</b>,
<b>GCFillRule</b>, <b>GCTile</b>, <b>GCStipple</b>,
<b>GCTileStipXOrigin</b>, <b>GCTileStipYOrigin</b>,
<b>GCFont</b>, <b>GCSubwindowMode</b>,
<b>GCGraphicsExposures</b>, <b>GCClipXOrigin</b>,
<b>GCClipYOrigin</b>, <b>GCDashOffset</b>, or
<b>GCArcMode</b>) and no error occurs, <b>XGetGCValues</b>
sets the requested components in values_return and returns a
nonzero status. Otherwise, it returns a zero status. Note
that the clip-mask and dash-list (represented by the
<b>GCClipMask</b> and <b>GCDashList</b> bits, respectively,
in the valuemask) cannot be requested. Also note that an
invalid resource ID (with one or more of the three most
significant bits set to 1) will be returned for
<b>GCFont</b>, <b>GCTile</b>, and <b>GCStipple</b> if the
component has never been explicitly set by the client.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>XFreeGC</b> function destroys the specified GC as well as
all the associated storage.</p>
<p style="margin-left:9%; margin-top: 1em"><b>XFreeGC</b>
can generate a <b>BadGC</b> error.</p>
<h2>STRUCTURES
<a name="STRUCTURES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The
<b>XGCValues</b> structure contains:</p>
<p style="margin-left:9%; margin-top: 1em">/* GC attribute
value mask bits */</p>
<p style="margin-left:9%; margin-top: 1em">/* Values */</p>
<p style="margin-left:9%; margin-top: 1em">typedef struct {
<br/>
int function; /* logical operation */ <br/>
unsigned long plane_mask; /* plane mask */ <br/>
unsigned long foreground; /* foreground pixel */ <br/>
unsigned long background; /* background pixel */ <br/>
int line_width; /* line width (in pixels) */ <br/>
int line_style; /* LineSolid, LineOnOffDash, LineDoubleDash
*/ <br/>
int cap_style; /* CapNotLast, CapButt, CapRound,
CapProjecting */ <br/>
int join_style; /* JoinMiter, JoinRound, JoinBevel */ <br/>
int fill_style; /* FillSolid, FillTiled, FillStippled
FillOpaqueStippled*/ <br/>
int fill_rule; /* EvenOddRule, WindingRule */ <br/>
int arc_mode; /* ArcChord, ArcPieSlice */ <br/>
Pixmap tile; /* tile pixmap for tiling operations */ <br/>
Pixmap stipple; /* stipple 1 plane pixmap for stippling */
<br/>
int ts_x_origin; /* offset for tile or stipple operations */
<br/>
int ts_y_origin; <br/>
Font font; /* default text font for text operations */ <br/>
int subwindow_mode; /* ClipByChildren, IncludeInferiors */
<br/>
Bool graphics_exposures; /* boolean, should exposures be
generated */ <br/>
int clip_x_origin; /* origin for clipping */ <br/>
int clip_y_origin; <br/>
Pixmap clip_mask; /* bitmap clipping; other calls for rects
*/ <br/>
int dash_offset; /* patterned/dashed line information */
<br/>
char dashes; <br/>
} XGCValues;</p>
<p style="margin-left:9%; margin-top: 1em">The function
attributes of a GC are used when you update a section of a
drawable (the destination) with bits from somewhere else
(the source). The function in a GC defines how the new
destination bits are to be computed from the source bits and
the old destination bits. <b>GXcopy</b> is typically the
most useful because it will work on a color display, but
special applications may use other functions, particularly
in concert with particular planes of a color display. The 16
GC functions, defined in <b>X11/X.h</b>, are:</p>
<p style="margin-left:9%; margin-top: 1em">Many graphics
operations depend on either pixel values or planes in a GC.
The planes attribute is of type long, and it specifies which
planes of the destination are to be modified, one bit per
plane. A monochrome display has only one plane and will be
the least significant bit of the word. As planes are added
to the display hardware, they will occupy more significant
bits in the plane mask.</p>
<p style="margin-left:9%; margin-top: 1em">In graphics
operations, given a source and destination pixel, the result
is computed bitwise on corresponding bits of the pixels.
That is, a Boolean operation is performed in each bit plane.
The plane_mask restricts the operation to a subset of
planes. A macro constant <b>AllPlanes</b> can be used to
refer to all planes of the screen simultaneously. The result
is computed by the following:</p>
<p style="margin-left:9%; margin-top: 1em">((src FUNC dst)
AND plane-mask) OR (dst AND (NOT plane-mask))</p>
<p style="margin-left:9%; margin-top: 1em">Range checking
is not performed on the values for foreground, background,
or plane_mask. They are simply truncated to the appropriate
number of bits. The line-width is measured in pixels and
either can be greater than or equal to one (wide line) or
can be the special value zero (thin line).</p>
<p style="margin-left:9%; margin-top: 1em">Wide lines are
drawn centered on the path described by the graphics
request. Unless otherwise specified by the join-style or
cap-style, the bounding box of a wide line with endpoints
[x1, y1], [x2, y2] and width w is a rectangle with vertices
at the following real coordinates:</p>
<p style="margin-left:9%; margin-top: 1em">[x1-(w*sn/2),
y1+(w*cs/2)], [x1+(w*sn/2), y1-(w*cs/2)], <br/>
[x2-(w*sn/2), y2+(w*cs/2)], [x2+(w*sn/2), y2-(w*cs/2)]</p>
<p style="margin-left:9%; margin-top: 1em">Here sn is the
sine of the angle of the line, and cs is the cosine of the
angle of the line. A pixel is part of the line and so is
drawn if the center of the pixel is fully inside the
bounding box (which is viewed as having infinitely thin
edges). If the center of the pixel is exactly on the
bounding box, it is part of the line if and only if the
interior is immediately to its right (x increasing
direction). Pixels with centers on a horizontal edge are a
special case and are part of the line if and only if the
interior or the boundary is immediately below (y increasing
direction) and the interior or the boundary is immediately
to the right (x increasing direction).</p>
<p style="margin-left:9%; margin-top: 1em">Thin lines (zero
line-width) are one-pixel-wide lines drawn using an
unspecified, device-dependent algorithm. There are only two
constraints on this algorithm.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="85%">
<p>If a line is drawn unclipped from [x1,y1] to [x2,y2] and
if another line is drawn unclipped from [x1+dx,y1+dy] to
[x2+dx,y2+dy], a point [x,y] is touched by drawing the first
line if and only if the point [x+dx,y+dy] is touched by
drawing the second line.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="3%"></td>
<td width="85%">
<p>The effective set of points comprising a line cannot be
affected by clipping. That is, a point is touched in a
clipped line if and only if the point lies inside the
clipping region and the point would be touched by the line
when drawn unclipped.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">A wide line
drawn from [x1,y1] to [x2,y2] always draws the same pixels
as a wide line drawn from [x2,y2] to [x1,y1], not counting
cap-style and join-style. It is recommended that this
property be true for thin lines, but this is not required. A
line-width of zero may differ from a line-width of one in
which pixels are drawn. This permits the use of many
manufacturers’ line drawing hardware, which may run
many times faster than the more precisely specified wide
lines.</p>
<p style="margin-left:9%; margin-top: 1em">In general,
drawing a thin line will be faster than drawing a wide line
of width one. However, because of their different drawing
algorithms, thin lines may not mix well aesthetically with
wide lines. If it is desirable to obtain precise and uniform
results across all displays, a client should always use a
line-width of one rather than a line-width of zero.</p>
<p style="margin-left:9%; margin-top: 1em">The line-style
defines which sections of a line are drawn:</p>
<p style="margin-left:9%; margin-top: 1em">The cap-style
defines how the endpoints of a path are drawn:</p>
<p style="margin-left:9%; margin-top: 1em">The join-style
defines how corners are drawn for wide lines:</p>
<p style="margin-left:9%; margin-top: 1em">For a line with
coincident endpoints (x1=x2, y1=y2), when the cap-style is
applied to both endpoints, the semantics depends on the
line-width and the cap-style:</p>
<p style="margin-left:9%; margin-top: 1em">For a line with
coincident endpoints (x1=x2, y1=y2), when the join-style is
applied at one or both endpoints, the effect is as if the
line was removed from the overall path. However, if the
total path consists of or is reduced to a single point
joined with itself, the effect is the same as when the
cap-style is applied at both endpoints.</p>
<p style="margin-left:9%; margin-top: 1em">The tile/stipple
represents an infinite two-dimensional plane, with the
tile/stipple replicated in all dimensions. When that plane
is superimposed on the drawable for use in a graphics
operation, the upper-left corner of some instance of the
tile/stipple is at the coordinates within the drawable
specified by the tile/stipple origin. The tile/stipple and
clip origins are interpreted relative to the origin of
whatever destination drawable is specified in a graphics
request. The tile pixmap must have the same root and depth
as the GC, or a <b>BadMatch</b> error results. The stipple
pixmap must have depth one and must have the same root as
the GC, or a <b>BadMatch</b> error results. For stipple
operations where the fill-style is <b>FillStippled</b> but
not <b>FillOpaqueStippled</b>, the stipple pattern is tiled
in a single plane and acts as an additional clip mask to be
ANDed with the clip-mask. Although some sizes may be faster
to use than others, any size pixmap can be used for tiling
or stippling.</p>
<p style="margin-left:9%; margin-top: 1em">The fill-style
defines the contents of the source for line, text, and fill
requests. For all text and fill requests (for example,
<b>XDrawText</b>, <b>XDrawText16</b>, <b>XFillRectangle</b>,
<b>XFillPolygon</b>, and <b>XFillArc</b>); for line requests
with line-style <b>LineSolid</b> (for example,
<b>XDrawLine</b>, <b>XDrawSegments</b>,
<b>XDrawRectangle</b>, <b>XDrawArc</b>); and for the even
dashes for line requests with line-style
<b>LineOnOffDash</b> or <b>LineDoubleDash</b>, the following
apply:</p>
<p style="margin-left:9%; margin-top: 1em">When drawing
lines with line-style <b>LineDoubleDash</b>, the odd dashes
are controlled by the fill-style in the following
manner:</p>
<p style="margin-left:9%; margin-top: 1em">Storing a pixmap
in a GC might or might not result in a copy being made. If
the pixmap is later used as the destination for a graphics
request, the change might or might not be reflected in the
GC. If the pixmap is used simultaneously in a graphics
request both as a destination and as a tile or stipple, the
results are undefined.</p>
<p style="margin-left:9%; margin-top: 1em">For optimum
performance, you should draw as much as possible with the
same GC (without changing its components). The costs of
changing GC components relative to using different GCs
depend on the display hardware and the server
implementation. It is quite likely that some amount of GC
information will be cached in display hardware and that such
hardware can only cache a small number of GCs.</p>
<p style="margin-left:9%; margin-top: 1em">The dashes value
is actually a simplified form of the more general patterns
that can be set with <b>XSetDashes</b>. Specifying a value
of N is equivalent to specifying the two-element list [N, N]
in <b>XSetDashes</b>. The value must be nonzero, or a
<b>BadValue</b> error results.</p>
<p style="margin-left:9%; margin-top: 1em">The clip-mask
restricts writes to the destination drawable. If the
clip-mask is set to a pixmap, it must have depth one and
have the same root as the GC, or a <b>BadMatch</b> error
results. If clip-mask is set to <b>None</b>, the pixels are
always drawn regardless of the clip origin. The clip-mask
also can be set by calling the <b>XSetClipRectangles</b> or
<b>XSetRegion</b> functions. Only pixels where the clip-mask
has a bit set to 1 are drawn. Pixels are not drawn outside
the area covered by the clip-mask or where the clip-mask has
a bit set to 0. The clip-mask affects all graphics requests.
The clip-mask does not clip sources. The clip-mask origin is
interpreted relative to the origin of whatever destination
drawable is specified in a graphics request.</p>
<p style="margin-left:9%; margin-top: 1em">You can set the
subwindow-mode to <b>ClipByChildren</b> or
<b>IncludeInferiors</b>. For <b>ClipByChildren</b>, both
source and destination windows are additionally clipped by
all viewable <b>InputOutput</b> children. For
<b>IncludeInferiors</b>, neither source nor destination
window is clipped by inferiors. This will result in
including subwindow contents in the source and drawing
through subwindow boundaries of the destination. The use of
<b>IncludeInferiors</b> on a window of one depth with mapped
inferiors of differing depth is not illegal, but the
semantics are undefined by the core protocol.</p>
<p style="margin-left:9%; margin-top: 1em">The fill-rule
defines what pixels are inside (drawn) for paths given in
<b>XFillPolygon</b> requests and can be set to
<b>EvenOddRule</b> or <b>WindingRule</b>. For
<b>EvenOddRule</b>, a point is inside if an infinite ray
with the point as origin crosses the path an odd number of
times. For <b>WindingRule</b>, a point is inside if an
infinite ray with the point as origin crosses an unequal
number of clockwise and counterclockwise directed path
segments. A clockwise directed path segment is one that
crosses the ray from left to right as observed from the
point. A counterclockwise segment is one that crosses the
ray from right to left as observed from the point. The case
where a directed line segment is coincident with the ray is
uninteresting because you can simply choose a different ray
that is not coincident with a segment.</p>
<p style="margin-left:9%; margin-top: 1em">For both
<b>EvenOddRule</b> and <b>WindingRule</b>, a point is
infinitely small, and the path is an infinitely thin line. A
pixel is inside if the center point of the pixel is inside
and the center point is not on the boundary. If the center
point is on the boundary, the pixel is inside if and only if
the polygon interior is immediately to its right (x
increasing direction). Pixels with centers on a horizontal
edge are a special case and are inside if and only if the
polygon interior is immediately below (y increasing
direction).</p>
<p style="margin-left:9%; margin-top: 1em">The arc-mode
controls filling in the <b>XFillArcs</b> function and can be
set to <b>ArcPieSlice</b> or <b>ArcChord</b>. For
<b>ArcPieSlice</b>, the arcs are pie-slice filled. For
<b>ArcChord</b>, the arcs are chord filled.</p>
<p style="margin-left:9%; margin-top: 1em">The
graphics-exposure flag controls <b>GraphicsExpose</b> event
generation for <b>XCopyArea</b> and <b>XCopyPlane</b>
requests (and any similar requests defined by
extensions).</p>
<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="10%">
<p style="margin-top: 1em"><b>BadAlloc</b></p></td>
<td width="3%"></td>
<td width="78%">
<p style="margin-top: 1em">The server failed to allocate
the requested resource or server memory.</p></td></tr>
</table>
<p style="margin-left:9%;"><b>BadDrawable</b></p>
<p style="margin-left:22%;">A value for a Drawable argument
does not name a defined Window or Pixmap.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><b>BadFont</b></p></td>
<td width="1%"></td>
<td width="78%">
<p>A value for a Font or GContext argument does not name a
defined Font.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><b>BadGC</b></p></td>
<td width="1%"></td>
<td width="78%">
<p>A value for a GContext argument does not name a defined
GContext.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><b>BadMatch</b></p></td>
<td width="1%"></td>
<td width="78%">
<p>An <b>InputOnly</b> window is used as a Drawable.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><b>BadMatch</b></p></td>
<td width="1%"></td>
<td width="78%">
<p>Some argument or pair of arguments has the correct type
and range but fails to match in some other way required by
the request.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><b>BadPixmap</b></p></td>
<td width="1%"></td>
<td width="78%">
<p>A value for a Pixmap argument does not name a defined
Pixmap.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="12%">
<p><b>BadValue</b></p></td>
<td width="1%"></td>
<td width="78%">
<p>Some numeric value falls outside the range of values
accepted by the request. Unless a specific range is
specified for an argument, the full range defined by the
argument’s type is accepted. Any argument defined as a
set of alternatives can generate this error.</p></td></tr>
</table>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">AllPlanes(3),
XCopyArea(3), XCreateRegion(3), XDrawArc(3), XDrawLine(3),
XDrawRectangle(3), XDrawText(3), XFillRectangle(3),
XQueryBestSize(3), XSetArcMode(3), XSetClipOrigin(3),
XSetFillStyle(3), XSetFont(3), XSetLineAttributes(3),
XSetState(3), XSetTile(3) <i><br/>
Xlib − C Language X Interface</i></p>
<hr/>
</body>
</html>
