<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:46:29 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>curs_getstr</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">curs_getstr</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#RETURN VALUE">RETURN VALUE</a><br/>
<a href="#NOTES">NOTES</a><br/>
<a href="#EXTENSIONS">EXTENSIONS</a><br/>
<a href="#PORTABILITY">PORTABILITY</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>getstr</b>,
<b>getnstr</b>, <b>wgetstr</b>, <b>wgetnstr</b>,
<b>mvgetstr</b>, <b>mvgetnstr</b>, <b>mvwgetstr</b>,
<b>mvwgetnstr</b> − accept character strings from
<i>curses</i> terminal keyboard</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>#include
&lt;curses.h&gt;</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
getstr(char *</b> <i>str</i><b>); <br/>
int wgetstr(WINDOW *</b> <i>win</i><b>, char *</b>
<i>str</i><b>); <br/>
int mvgetstr(int</b> <i>y</i><b>, int</b> <i>x</i><b>, char
*</b> <i>str</i><b>); <br/>
int mvwgetstr(WINDOW *</b> <i>win</i><b>, int</b>
<i>y</i><b>, int</b> <i>x</i><b>, char *</b>
<i>str</i><b>);</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>int
getnstr(char *</b> <i>str</i><b>, int</b> <i>n</i><b>); <br/>
int wgetnstr(WINDOW *</b> <i>win</i><b>, char *</b>
<i>str</i><b>, int</b> <i>n</i><b>); <br/>
int mvgetnstr(int</b> <i>y</i><b>, int</b> <i>x</i><b>, char
*</b> <i>str</i><b>, int</b> <i>n</i><b>); <br/>
int mvwgetnstr(WINDOW *</b> <i>win</i><b>, int</b>
<i>y</i><b>, int</b> <i>x</i><b>, char *</b> <i>str</i><b>,
int</b> <i>n</i><b>);</b></p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>wgetstr</b>
populates a user-supplied string buffer <i>str</i> by
repeatedly calling <b>wgetch</b>(3X) with the <i>win</i>
argument until a line feed or carriage return character is
input. The function</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>does not copy the terminating character to
<i>str</i>;</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>always terminates <i>str</i> with a null character;</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>interprets the screen’s erase and kill characters
(see <b>erasechar</b>(3X) and <b>killchar</b>(3X));</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>recognizes function keys only if the screen’s
keypad option is enabled (see <b>keypad</b>(3X));</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>treats the function keys <b>KEY_LEFT</b> and
<b>KEY_BACKSPACE</b> the same as the erase character;
and</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>discards function key inputs other than those treated as
the erase character, calling <b>beep</b>(3X).</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">The erase
character replaces the character at the end of the buffer
with a null character, while the kill character does the
same for the entire buffer.</p>
<p style="margin-left:9%; margin-top: 1em">If the
screen’s echo option is enabled (see <b>echo</b>(3X)),
<b>wgetstr</b> updates <i>win</i> with <b>wechochar</b>(3X).
Further,</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">the erase character and its
function key synonyms move the cursor to the left, and</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>the kill character returns the cursor to where it was
located when <b>wgetstr</b> was called.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em"><b>wgetnstr</b>
is similar, but reads at most <i>n</i> characters, aiding
the application to avoid overrunning the buffer to which
<i>str</i> points. An attempt to input more than <i>n</i>
characters (other than the terminating line feed or carriage
return) is ignored with a beep.</p>
<p style="margin-left:9%; margin-top: 1em"><b>ncurses</b>(3X)
describes the variants of these functions.</p>
<h2>RETURN VALUE
<a name="RETURN VALUE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">These functions
return <b>OK</b> on success and <b>ERR</b> on failure.</p>
<p style="margin-left:9%; margin-top: 1em">In
<i>ncurses</i>, they return <b>ERR</b> if</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="42%">
<p style="margin-top: 1em"><i>win</i> is <b>NULL</b>,
or</p> </td>
<td width="44%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="42%">
<p>if an internal <b>wgetch</b> call fails.</p></td>
<td width="44%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Further, in
<i>ncurses</i>, these functions return <b>KEY_RESIZE</b> if
a <b>SIGWINCH</b> event interrupts the function.</p>
<p style="margin-left:9%; margin-top: 1em">Functions
prefixed with “mv” first perform cursor movement
and fail if the position (<i>y</i>, <i>x</i>) is outside the
window boundaries.</p>
<h2>NOTES
<a name="NOTES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">All of these
functions except <b>wgetnstr</b> may be implemented as
macros.</p>
<p style="margin-left:9%; margin-top: 1em">Use of
<b>getstr</b>, <b>mvgetstr</b>, <b>mvwgetstr</b>, or
<b>wgetstr</b> to read input that overruns the buffer
pointed to by <i>str</i> causes undefined results. Use their
<b>n</b>-infixed counterpart functions instead.</p>
<p style="margin-left:9%; margin-top: 1em">While
<b>wgetnstr</b> is conceptually a series of calls to
<b>wgetch</b>, it also temporarily changes properties of the
<i>curses</i> screen to permit simple editing of the input
buffer. It saves the screen’s state and then calls
<b>nl</b>(3X) and, if the screen was in normal
(“cooked”) mode, <b>cbreak</b>(3X). Before
returning, it restores the saved screen state. Other
implementations differ in detail, affecting which control
characters they can accept in the buffer; see section
“PORTABILITY” below.</p>
<h2>EXTENSIONS
<a name="EXTENSIONS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The return value
<b>KEY_RESIZE</b> is an <i>ncurses</i> extension.</p>
<h2>PORTABILITY
<a name="PORTABILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Applications
employing <i>ncurses</i> extensions should condition their
use on the visibility of the <b>NCURSES_VERSION</b>
preprocessor macro.</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses
Issue 4 describes these functions. It specifies no error
conditions for them, but indicates that <i>wgetnstr</i> and
its variants read “the entire multi-byte sequence
associated with a character” and “fail” if
<i>n</i> and <i>str</i> together do not describe a buffer
“large enough to contain any complete
characters”. In <i>ncurses</i>, however, <i>wgetch</i>
reads only single-byte characters, so this scenario does not
arise.</p>
<p style="margin-left:9%; margin-top: 1em">SVr4
<i>curses</i> describes a successful return value only as
“an integer value other than <b>ERR</b>”.</p>
<p style="margin-left:9%; margin-top: 1em">SVr3 and early
SVr4 <i>curses</i> implementations did not reject function
keys; the SVr4 documentation asserted that, like the
screen’s erase and kill characters, they were</p>
<p style="margin-left:18%; margin-top: 1em">interpreted, as
well as any special keys (such as function keys,
“home” key, “clear” key,
<i>etc.</i>)</p>
<p style="margin-left:9%; margin-top: 1em">without further
detail. It lied. In fact, the “character” value
appended to the string by those implementations was
predictable but not useful — being, in fact, the
low-order eight bits of the key code’s <b>KEY_</b>
constant value. (The same language, unchanged except for
styling, survived into X/Open Curses Issue 4, but
disappeared from Issue 7.)</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses
Issue 5 (2007) stated that these functions “read at
most <i>n</i> bytes” but did not state whether the
terminating null character counted toward that limit. X/Open
Curses Issue 7 (2009) changed that to say they “read
at most <i>n</i>−1 bytes” to allow for the
terminating null character. As of 2018, some implementations
count it, some do not.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em"><i>ncurses</i> 6.1 and
<i>PDCurses</i> do not count the null character toward the
limit, while Solaris and NetBSD <i>curses</i> do.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Solaris <i>xcurses</i> offers both behaviors: its
wide-character <i>wgetn_wstr</i> reserves room for a wide
null character, but its non-wide <i>wgetnstr</i> does not
consistently count a null character toward the limit.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">In SVr4
<i>curses</i>, a negative <i>n</i> tells <i>wgetnstr</i> to
assume that the caller’s buffer is large enough to
hold the result; that is, the function then acts like
<i>wgetstr</i>. X/Open Curses does not mention this behavior
(or anything related to nonpositive <i>n</i> values),
however most <i>curses</i> libraries implement it. Most
implementations nevertheless enforce an upper limit on the
count of bytes they write to the destination buffer
<i>str</i>.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">BSD <i>curses</i> lacked
<i>wgetnstr</i>, and its <i>wgetstr</i> wrote to <i>str</i>
unboundedly, as did that in SVr2.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p><i>PDCurses</i>, and SVr3.1, SVr4, and Solaris
<i>curses</i> limit both functions to writing 256 bytes.
Other System V-based platforms likely use the same
limit.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Solaris <i>xcurses</i> limits the write to
<b>LINE_MAX</b> bytes.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>NetBSD 7 <i>curses</i> imposes no particular limit on
the length of the write, but does validate <i>n</i> to
ensure that it is greater than zero. A comment in
NetBSD’s source code asserts that SUSv2 specifies
this.</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p><i>ncurses</i> prior to 6.2 (2020) imposes no limit on
the length of the write, and treats <i>wgetnstr</i>’s
<i>n</i> parameter as SVr4 <i>curses</i> does.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p><i>ncurses</i> 6.2 uses <b>LINE_MAX</b> or a larger
(system-dependent) value provided by <i>sysconf</i>(3). If
neither <b>LINE_MAX</b> nor <i>sysconf</i> is available,
<i>ncurses</i> uses the POSIX minimum value for
<b>LINE_MAX</b> (2048). In either case, it reserves a byte
for the terminating null character.</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Implementations
vary in their handling of input control characters.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">While they may enable the
screen’s echo option, some do not take it out of raw
mode, and may take cbreak mode into account when deciding
whether to handle echoing within <i>wgetnstr</i> or to rely
on it as a side effect of calling <i>wgetch</i>.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="86%">
<p>Originally, <i>ncurses</i>, like its progenitor
<i>pcurses</i>, had its <i>wgetnstr</i> call <i>noraw</i>
and <i>cbreak</i> before accepting input. That may have been
done to make function keys work; it is not necessary with
modern <i>ncurses</i>.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Since 1995,
<i>ncurses</i> has provided handlers for <b>SIGINTR</b> and
<b>SIGQUIT</b> events, which are typically generated at the
keyboard with <b>^C</b> and <b>^\</b> respectively. In
cbreak mode, those handlers catch a signal and stop the
program, whereas other implementations write those
characters into the buffer.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="4%"></td>
<td width="86%">
<p style="margin-top: 1em">Starting with <i>ncurses</i> 6.3
(2021), <i>wgetnstr</i> preserves raw mode if the screen was
already in that state, allowing one to enter the characters
the terminal interprets as interrupt and quit events into
the buffer, for better compatibility with SVr4
<i>curses</i>.</p> </td></tr>
</table>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">4BSD (1980)
<i>curses</i> introduced <i>wgetstr</i> along with its
variants.</p>
<p style="margin-left:9%; margin-top: 1em">SVr3.1 (1987)
added <i>wgetnstr</i>, but none of its variants.</p>
<p style="margin-left:9%; margin-top: 1em">X/Open Curses
Issue 4 (1995) specified <i>getnstr</i>, <i>mvwgetnstr</i>,
and <i>mvgetnstr</i>.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>curs_get_wstr</b>(3X)
describes comparable functions of the <i>ncurses</i> library
in its wide-character configuration (<i>ncursesw</i>).</p>
<p style="margin-left:9%; margin-top: 1em"><b>curses</b>(3X),
<b>curs_addch</b>(3X), <b>curs_getch</b>(3X),
<b>curs_inopts</b>(3X), <b>curs_termattrs</b>(3X),</p>
<hr/>
</body>
</html>
