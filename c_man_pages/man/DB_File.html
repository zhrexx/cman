<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:41:14 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>DB_File</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">DB_File</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#Using DB_File with Berkeley DB version 2 or greater">Using DB_File with Berkeley DB version 2 or greater</a><br/>
<a href="#Interface to Berkeley DB">Interface to Berkeley DB</a><br/>
<a href="#Opening a Berkeley DB Database File">Opening a Berkeley DB Database File</a><br/>
<a href="#Default Parameters">Default Parameters</a><br/>
<a href="#In Memory Databases">In Memory Databases</a><br/>
<a href="#DB_HASH">DB_HASH</a><br/>
<a href="#A Simple Example">A Simple Example</a><br/>
<a href="#DB_BTREE">DB_BTREE</a><br/>
<a href="#Changing the BTREE sort order">Changing the BTREE sort order</a><br/>
<a href="#Handling Duplicate Keys">Handling Duplicate Keys</a><br/>
<a href="#The get_dup() Method">The get_dup() Method</a><br/>
<a href="#The find_dup() Method">The find_dup() Method</a><br/>
<a href="#The del_dup() Method">The del_dup() Method</a><br/>
<a href="#Matching Partial Keys">Matching Partial Keys</a><br/>
<a href="#DB_RECNO">DB_RECNO</a><br/>
<a href="#The 'bval' Option">The 'bval' Option</a><br/>
<a href="#A Simple Example">A Simple Example</a><br/>
<a href="#Extra RECNO Methods">Extra RECNO Methods</a><br/>
<a href="#Another Example">Another Example</a><br/>
<a href="#THE API INTERFACE">THE API INTERFACE</a><br/>
<a href="#DBM FILTERS">DBM FILTERS</a><br/>
<a href="#DBM Filter Low−level API">DBM Filter Low−level API</a><br/>
<a href="#The Filter">The Filter</a><br/>
<a href="#An Example −− the NULL termination problem.">An Example −− the NULL termination problem.</a><br/>
<a href="#Another Example −− Key is a C int.">Another Example −− Key is a C int.</a><br/>
<a href="#HINTS AND TIPS">HINTS AND TIPS</a><br/>
<a href="#Locking: The Trouble with fd">Locking: The Trouble with fd</a><br/>
<a href="#Safe ways to lock a database">Safe ways to lock a database</a><br/>
<a href="#Sharing Databases With C Applications">Sharing Databases With C Applications</a><br/>
<a href="#The untie() Gotcha">The untie() Gotcha</a><br/>
<a href="#COMMON QUESTIONS">COMMON QUESTIONS</a><br/>
<a href="#Why is there Perl source in my database?">Why is there Perl source in my database?</a><br/>
<a href="#How do I store complex data structures with DB_File?">How do I store complex data structures with DB_File?</a><br/>
<a href='#What does "wide character in subroutine entry" mean?'>What does "wide character in subroutine entry" mean?</a><br/>
<a href='#What does "Invalid Argument" mean?'>What does "Invalid Argument" mean?</a><br/>
<a href="#What does &quot;Bareword 'DB_File' not allowed&quot; mean?">What does "Bareword 'DB_File' not allowed" mean?</a><br/>
<a href="#REFERENCES">REFERENCES</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<a href="#BUGS">BUGS</a><br/>
<a href="#SUPPORT">SUPPORT</a><br/>
<a href="#AVAILABILITY">AVAILABILITY</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<a href="#SEE ALSO">SEE ALSO</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">DB_File −
Perl5 access to Berkeley DB version 1.x</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use DB_File;
<br/>
[$X =] tie %hash, 'DB_File', [$filename, $flags, $mode,
$DB_HASH] ; <br/>
[$X =] tie %hash, 'DB_File', $filename, $flags, $mode,
$DB_BTREE ; <br/>
[$X =] tie @array, 'DB_File', $filename, $flags, $mode,
$DB_RECNO ; <br/>
$status = $X−&gt;del($key [, $flags]) ; <br/>
$status = $X−&gt;put($key, $value [, $flags]) ; <br/>
$status = $X−&gt;get($key, $value [, $flags]) ; <br/>
$status = $X−&gt;seq($key, $value, $flags) ; <br/>
$status = $X−&gt;sync([$flags]) ; <br/>
$status = $X−&gt;fd ; <br/>
# BTREE only <br/>
$count = $X−&gt;get_dup($key) ; <br/>
@list = $X−&gt;get_dup($key) ; <br/>
%list = $X−&gt;get_dup($key, 1) ; <br/>
$status = $X−&gt;find_dup($key, $value) ; <br/>
$status = $X−&gt;del_dup($key, $value) ; <br/>
# RECNO only <br/>
$a = $X−&gt;length; <br/>
$a = $X−&gt;pop ; <br/>
$X−&gt;push(list); <br/>
$a = $X−&gt;shift; <br/>
$X−&gt;unshift(list); <br/>
@r = $X−&gt;splice(offset, length, elements); <br/>
# DBM Filters <br/>
$old_filter = $db−&gt;filter_store_key ( sub { ... } )
; <br/>
$old_filter = $db−&gt;filter_store_value( sub { ... }
) ; <br/>
$old_filter = $db−&gt;filter_fetch_key ( sub { ... } )
; <br/>
$old_filter = $db−&gt;filter_fetch_value( sub { ... }
) ; <br/>
untie %hash ; <br/>
untie @array ;</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>DB_File</b>
is a module which allows Perl programs to make use of the
facilities provided by Berkeley DB version 1.x (if you have
a newer version of DB, see "Using DB_File with Berkeley
DB version 2 or greater"). It is assumed that you have
a copy of the Berkeley DB manual pages at hand when reading
this documentation. The interface defined here mirrors the
Berkeley DB interface closely.</p>
<p style="margin-left:9%; margin-top: 1em">Berkeley DB is a
C library which provides a consistent interface to a number
of database formats. <b>DB_File</b> provides an interface to
all three of the database types currently supported by
Berkeley DB.</p>
<p style="margin-left:9%; margin-top: 1em">The file types
are: <b><br/>
DB_HASH</b></p>
<p style="margin-left:15%;">This database type allows
arbitrary key/value pairs to be stored in data files. This
is equivalent to the functionality provided by other hashing
packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember
though, the files created using DB_HASH are not compatible
with any of the other packages mentioned.</p>
<p style="margin-left:15%; margin-top: 1em">A default
hashing algorithm, which will be adequate for most
applications, is built into Berkeley DB. If you do need to
use your own hashing algorithm it is possible to write your
own in Perl and have <b>DB_File</b> use it instead.</p>
<p style="margin-left:9%;"><b>DB_BTREE</b></p>
<p style="margin-left:15%;">The btree format allows
arbitrary key/value pairs to be stored in a sorted, balanced
binary tree.</p>
<p style="margin-left:15%; margin-top: 1em">As with the
DB_HASH format, it is possible to provide a user defined
Perl routine to perform the comparison of keys. By default,
though, the keys are stored in lexical order.</p>
<p style="margin-left:9%;"><b>DB_RECNO</b></p>
<p style="margin-left:15%;">DB_RECNO allows both
fixed−length and variable−length flat text files
to be manipulated using the same key/value pair interface as
in DB_HASH and DB_BTREE. In this case the key will consist
of a record (line) number.</p>
<h3>Using DB_File with Berkeley DB version 2 or greater
<a name="Using DB_File with Berkeley DB version 2 or greater"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Although
<b>DB_File</b> is intended to be used with Berkeley DB
version 1, it can also be used with version 2, 3 or 4. In
this case the interface is limited to the functionality
provided by Berkeley DB 1.x. Anywhere the version 2 or
greater interface differs, <b>DB_File</b> arranges for it to
work like version 1. This feature allows <b>DB_File</b>
scripts that were built with version 1 to be migrated to
version 2 or greater without any changes.</p>
<p style="margin-left:9%; margin-top: 1em">If you want to
make use of the new features available in Berkeley DB 2.x or
greater, use the Perl module BerkeleyDB
&lt;https://metacpan.org/pod/BerkeleyDB&gt; instead.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b> The
database file format has changed multiple times in Berkeley
DB version 2, 3 and 4. If you cannot recreate your
databases, you must dump any existing databases with either
the "db_dump" or the "db_dump185"
utility that comes with Berkeley DB. Once you have rebuilt
DB_File to use Berkeley DB version 2 or greater, your
databases can be recreated using "db_load". Refer
to the Berkeley DB documentation for further details.</p>
<p style="margin-left:9%; margin-top: 1em">Please read
"COPYRIGHT" before using version 2.x or greater of
Berkeley DB with DB_File.</p>
<h3>Interface to Berkeley DB
<a name="Interface to Berkeley DB"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em"><b>DB_File</b>
allows access to Berkeley DB files using the <b>tie()</b>
mechanism in Perl 5 (for full details, see
"<b>tie()</b>" in perlfunc). This facility allows
<b>DB_File</b> to access Berkeley DB files using either an
associative array (for DB_HASH &amp; DB_BTREE file types) or
an ordinary array (for the DB_RECNO file type).</p>
<p style="margin-left:9%; margin-top: 1em">In addition to
the <b>tie()</b> interface, it is also possible to access
most of the functions provided in the Berkeley DB API
directly. See "THE API INTERFACE".</p>
<h3>Opening a Berkeley DB Database File
<a name="Opening a Berkeley DB Database File"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Berkeley DB uses
the function <b>dbopen()</b> to open or create a database.
Here is the C prototype for <b>dbopen()</b>:</p>
<p style="margin-left:9%; margin-top: 1em">DB* <br/>
dbopen (const char * file, int flags, int mode, <br/>
DBTYPE type, const void * openinfo)</p>
<p style="margin-left:9%; margin-top: 1em">The parameter
"type" is an enumeration which specifies which of
the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is
to be used. Depending on which of these is actually chosen,
the final parameter, <i>openinfo</i> points to a data
structure which allows tailoring of the specific interface
method.</p>
<p style="margin-left:9%; margin-top: 1em">This interface
is handled slightly differently in <b>DB_File</b>. Here is
an equivalent call using <b>DB_File</b>:</p>
<p style="margin-left:9%; margin-top: 1em">tie %array,
'DB_File', $filename, $flags, $mode, $DB_HASH ;</p>
<p style="margin-left:9%; margin-top: 1em">The
"filename", "flags" and "mode"
parameters are the direct equivalent of their
<b>dbopen()</b> counterparts. The final parameter $DB_HASH
performs the function of both the "type" and
"openinfo" parameters in <b>dbopen()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">In the example
above $DB_HASH is actually a pre−defined reference to
a hash object. <b>DB_File</b> has three of these
pre−defined references. Apart from $DB_HASH, there is
also $DB_BTREE and $DB_RECNO.</p>
<p style="margin-left:9%; margin-top: 1em">The keys allowed
in each of these pre−defined references is limited to
the names used in the equivalent C structure. So, for
example, the $DB_HASH reference will only allow keys called
"bsize", "cachesize",
"ffactor", "hash", "lorder"
and "nelem".</p>
<p style="margin-left:9%; margin-top: 1em">To change one of
these elements, just assign to it like this:</p>
<p style="margin-left:9%; margin-top: 1em">$DB_HASH−&gt;{'cachesize'}
= 10000 ;</p>
<p style="margin-left:9%; margin-top: 1em">The three
predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are
usually adequate for most applications. If you do need to
create extra instances of these objects, constructors are
available for each file type.</p>
<p style="margin-left:9%; margin-top: 1em">Here are
examples of the constructors and the valid options available
for DB_HASH, DB_BTREE and DB_RECNO respectively.</p>
<p style="margin-left:9%; margin-top: 1em">$a =
DB_File::HASHINFO−&gt;new(); <br/>
$a−&gt;{'bsize'} ; <br/>
$a−&gt;{'cachesize'} ; <br/>
$a−&gt;{'ffactor'}; <br/>
$a−&gt;{'hash'} ; <br/>
$a−&gt;{'lorder'} ; <br/>
$a−&gt;{'nelem'} ; <br/>
$b = DB_File::BTREEINFO−&gt;new(); <br/>
$b−&gt;{'flags'} ; <br/>
$b−&gt;{'cachesize'} ; <br/>
$b−&gt;{'maxkeypage'} ; <br/>
$b−&gt;{'minkeypage'} ; <br/>
$b−&gt;{'psize'} ; <br/>
$b−&gt;{'compare'} ; <br/>
$b−&gt;{'prefix'} ; <br/>
$b−&gt;{'lorder'} ; <br/>
$c = DB_File::RECNOINFO−&gt;new(); <br/>
$c−&gt;{'bval'} ; <br/>
$c−&gt;{'cachesize'} ; <br/>
$c−&gt;{'psize'} ; <br/>
$c−&gt;{'flags'} ; <br/>
$c−&gt;{'lorder'} ; <br/>
$c−&gt;{'reclen'} ; <br/>
$c−&gt;{'bfname'} ;</p>
<p style="margin-left:9%; margin-top: 1em">The values
stored in the hashes above are mostly the direct equivalent
of their C counterpart. Like their C counterparts, all are
set to a default values − that means you don't have to
set <i>all</i> of the values when you only want to change
one. Here is an example:</p>
<p style="margin-left:9%; margin-top: 1em">$a =
DB_File::HASHINFO−&gt;new(); <br/>
$a−&gt;{'cachesize'} = 12345 ; <br/>
tie %y, 'DB_File', "filename", $flags, 0777, $a
;</p>
<p style="margin-left:9%; margin-top: 1em">A few of the
options need extra discussion here. When used, the C
equivalent of the keys "hash", "compare"
and "prefix" store pointers to C functions. In
<b>DB_File</b> these keys are used to store references to
Perl subs. Below are templates for each of the subs:</p>
<p style="margin-left:9%; margin-top: 1em">sub hash <br/>
{ <br/>
my ($data) = @_ ; <br/>
... <br/>
# return the hash value for $data <br/>
return $hash ; <br/>
} <br/>
sub compare <br/>
{ <br/>
my ($key, $key2) = @_ ; <br/>
... <br/>
# return 0 if $key1 eq $key2 <br/>
# −1 if $key1 lt $key2 <br/>
# 1 if $key1 gt $key2 <br/>
return (−1 , 0 or 1) ; <br/>
} <br/>
sub prefix <br/>
{ <br/>
my ($key, $key2) = @_ ; <br/>
... <br/>
# return number of bytes of $key2 which are <br/>
# necessary to determine that it is greater than $key1 <br/>
return $bytes ; <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">See
"Changing the BTREE sort order" for an example of
using the "compare" template.</p>
<p style="margin-left:9%; margin-top: 1em">If you are using
the DB_RECNO interface and you intend making use of
"bval", you should check out "The 'bval'
Option".</p>
<h3>Default Parameters
<a name="Default Parameters"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">It is possible
to omit some or all of the final 4 parameters in the call to
"tie" and let them take default values. As DB_HASH
is the most common file format used, the call:</p>
<p style="margin-left:9%; margin-top: 1em">tie %A,
"DB_File", "filename" ;</p>
<p style="margin-left:9%; margin-top: 1em">is equivalent
to:</p>
<p style="margin-left:9%; margin-top: 1em">tie %A,
"DB_File", "filename", O_CREAT|O_RDWR,
0666, $DB_HASH ;</p>
<p style="margin-left:9%; margin-top: 1em">It is also
possible to omit the filename parameter as well, so the
call:</p>
<p style="margin-left:9%; margin-top: 1em">tie %A,
"DB_File" ;</p>
<p style="margin-left:9%; margin-top: 1em">is equivalent
to:</p>
<p style="margin-left:9%; margin-top: 1em">tie %A,
"DB_File", undef, O_CREAT|O_RDWR, 0666, $DB_HASH
;</p>
<p style="margin-left:9%; margin-top: 1em">See "In
Memory Databases" for a discussion on the use of
"undef" in place of a filename.</p>
<h3>In Memory Databases
<a name="In Memory Databases"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Berkeley DB
allows the creation of in−memory databases by using
NULL (that is, a "(char *)0" in C) in place of the
filename. <b>DB_File</b> uses "undef" instead of
NULL to provide this functionality.</p>
<h2>DB_HASH
<a name="DB_HASH"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The DB_HASH file
format is probably the most commonly used of the three file
formats that <b>DB_File</b> supports. It is also very
straightforward to use.</p>
<h3>A Simple Example
<a name="A Simple Example"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This example
shows how to create a database, add key/value pairs to the
database, delete keys/value pairs and finally how to
enumerate the contents of the database.</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
our (%h, $k, $v) ; <br/>
unlink "fruit" ; <br/>
tie %h, "DB_File", "fruit",
O_RDWR|O_CREAT, 0666, $DB_HASH <br/>
or die "Cannot open file 'fruit': $!\n"; <br/>
# Add a few key/value pairs to the file <br/>
$h{"apple"} = "red" ; <br/>
$h{"orange"} = "orange" ; <br/>
$h{"banana"} = "yellow" ; <br/>
$h{"tomato"} = "red" ; <br/>
# Check for existence of a key <br/>
print "Banana Exists\n\n" if
$h{"banana"} ; <br/>
# Delete a key/value pair. <br/>
delete $h{"apple"} ; <br/>
# print the contents of the file <br/>
while (($k, $v) = each %h) <br/>
{ print "$k −&gt; $v\n" } <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">here is the
output:</p>
<p style="margin-left:9%; margin-top: 1em">Banana Exists
<br/>
orange −&gt; orange <br/>
tomato −&gt; red <br/>
banana −&gt; yellow</p>
<p style="margin-left:9%; margin-top: 1em">Note that the
like ordinary associative arrays, the order of the keys
retrieved is in an apparently random order.</p>
<h2>DB_BTREE
<a name="DB_BTREE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The DB_BTREE
format is useful when you want to store data in a given
order. By default the keys will be stored in lexical order,
but as you will see from the example shown in the next
section, it is very easy to define your own sorting
function.</p>
<h3>Changing the BTREE sort order
<a name="Changing the BTREE sort order"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">This script
shows how to override the default sorting algorithm that
BTREE uses. Instead of using the normal lexical ordering, a
case insensitive compare function will be used.</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my %h ; <br/>
sub Compare <br/>
{ <br/>
my ($key1, $key2) = @_ ; <br/>
"\L$key1" cmp "\L$key2" ; <br/>
} <br/>
# specify the Perl sub that will do the comparison <br/>
$DB_BTREE−&gt;{'compare'} = \&amp;Compare ; <br/>
unlink "tree" ; <br/>
tie %h, "DB_File", "tree",
O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
or die "Cannot open file 'tree': $!\n" ; <br/>
# Add a key/value pair to the file <br/>
$h{'Wall'} = 'Larry' ; <br/>
$h{'Smith'} = 'John' ; <br/>
$h{'mouse'} = 'mickey' ; <br/>
$h{'duck'} = 'donald' ; <br/>
# Delete <br/>
delete $h{"duck"} ; <br/>
# Cycle through the keys printing them in order. <br/>
# Note it is not necessary to sort the keys as <br/>
# the btree will have kept them in order automatically. <br/>
foreach (keys %h) <br/>
{ print "$_\n" } <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
output from the code above.</p>
<p style="margin-left:9%; margin-top: 1em">mouse <br/>
Smith <br/>
Wall</p>
<p style="margin-left:9%; margin-top: 1em">There are a few
point to bear in mind if you want to change the ordering in
a BTREE database:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="85%">
<p>The new compare function must be specified when you
create the database.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="3%"></td>
<td width="85%">
<p>You cannot change the ordering once the database has
been created. Thus you must use the same compare function
every time you access the database.</p></td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>3.</p></td>
<td width="3%"></td>
<td width="85%">
<p>Duplicate keys are entirely defined by the comparison
function. In the case−insensitive example above, the
keys: 'KEY' and 'key' would be considered duplicates, and
assigning to the second one would overwrite the first. If
duplicates are allowed for (with the R_DUP flag discussed
below), only a single copy of duplicate keys is stored in
the database −−− so (again with example
above) assigning three values to the keys: 'KEY', 'Key', and
'key' would leave just the first key: 'KEY' in the database
with three values. For some situations this results in
information loss, so care should be taken to provide fully
qualified comparison functions when necessary. For example,
the above comparison routine could be modified to
additionally compare case−sensitively if two keys are
equal in the case insensitive comparison:</p></td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">sub compare {
<br/>
my($key1, $key2) = @_; <br/>
lc $key1 cmp lc $key2 || <br/>
$key1 cmp $key2; <br/>
}</p>
<p style="margin-left:15%; margin-top: 1em">And now you
will only have duplicates when the keys themselves are truly
the same. (note: in versions of the db library prior to
about November 1996, such duplicate keys were retained so it
was possible to recover the original keys in sets of keys
that compared as equal).</p>
<h3>Handling Duplicate Keys
<a name="Handling Duplicate Keys"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The BTREE file
type optionally allows a single key to be associated with an
arbitrary number of values. This option is enabled by
setting the flags element of $DB_BTREE to R_DUP when
creating the database.</p>
<p style="margin-left:9%; margin-top: 1em">There are some
difficulties in using the tied hash interface if you want to
manipulate a BTREE database with duplicate keys. Consider
this code:</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my ($filename, %h) ; <br/>
$filename = "tree" ; <br/>
unlink $filename ; <br/>
# Enable duplicate records <br/>
$DB_BTREE−&gt;{'flags'} = R_DUP ; <br/>
tie %h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_BTREE <br/>
or die "Cannot open $filename: $!\n"; <br/>
# Add some key/value pairs to the file <br/>
$h{'Wall'} = 'Larry' ; <br/>
$h{'Wall'} = 'Brick' ; # Note the duplicate key <br/>
$h{'Wall'} = 'Brick' ; # Note the duplicate key and value
<br/>
$h{'Smith'} = 'John' ; <br/>
$h{'mouse'} = 'mickey' ; <br/>
# iterate through the associative array <br/>
# and print each key/value pair. <br/>
foreach (sort keys %h) <br/>
{ print "$_ −&gt; $h{$_}\n" } <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
output:</p>
<p style="margin-left:9%; margin-top: 1em">Smith
−&gt; John <br/>
Wall −&gt; Larry <br/>
Wall −&gt; Larry <br/>
Wall −&gt; Larry <br/>
mouse −&gt; mickey</p>
<p style="margin-left:9%; margin-top: 1em">As you can see 3
records have been successfully created with key
"Wall" − the only thing is, when they are
retrieved from the database they <i>seem</i> to have the
same value, namely "Larry". The problem is caused
by the way that the associative array interface works.
Basically, when the associative array interface is used to
fetch the value associated with a given key, it will only
ever retrieve the first value.</p>
<p style="margin-left:9%; margin-top: 1em">Although it may
not be immediately obvious from the code above, the
associative array interface can be used to write values with
duplicate keys, but it cannot be used to read them back from
the database.</p>
<p style="margin-left:9%; margin-top: 1em">The way to get
around this problem is to use the Berkeley DB API method
called "seq". This method allows sequential access
to key/value pairs. See "THE API INTERFACE" for
details of both the "seq" method and the API in
general.</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
script above rewritten using the "seq" API
method.</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my ($filename, $x, %h, $status, $key, $value) ; <br/>
$filename = "tree" ; <br/>
unlink $filename ; <br/>
# Enable duplicate records <br/>
$DB_BTREE−&gt;{'flags'} = R_DUP ; <br/>
$x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_BTREE <br/>
or die "Cannot open $filename: $!\n"; <br/>
# Add some key/value pairs to the file <br/>
$h{'Wall'} = 'Larry' ; <br/>
$h{'Wall'} = 'Brick' ; # Note the duplicate key <br/>
$h{'Wall'} = 'Brick' ; # Note the duplicate key and value
<br/>
$h{'Smith'} = 'John' ; <br/>
$h{'mouse'} = 'mickey' ; <br/>
# iterate through the btree using seq <br/>
# and print each key/value pair. <br/>
$key = $value = 0 ; <br/>
for ($status = $x−&gt;seq($key, $value, R_FIRST) ;
<br/>
$status == 0 ; <br/>
$status = $x−&gt;seq($key, $value, R_NEXT) ) <br/>
{ print "$key −&gt; $value\n" } <br/>
undef $x ; <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">that prints:</p>
<p style="margin-left:9%; margin-top: 1em">Smith
−&gt; John <br/>
Wall −&gt; Brick <br/>
Wall −&gt; Brick <br/>
Wall −&gt; Larry <br/>
mouse −&gt; mickey</p>
<p style="margin-left:9%; margin-top: 1em">This time we
have got all the key/value pairs, including the multiple
values associated with the key "Wall".</p>
<p style="margin-left:9%; margin-top: 1em">To make life
easier when dealing with duplicate keys, <b>DB_File</b>
comes with a few utility methods.</p>
<h3>The get_dup() Method
<a name="The get_dup() Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The
"get_dup" method assists in reading duplicate
values from BTREE databases. The method can take the
following forms:</p>
<p style="margin-left:9%; margin-top: 1em">$count =
$x−&gt;get_dup($key) ; <br/>
@list = $x−&gt;get_dup($key) ; <br/>
%list = $x−&gt;get_dup($key, 1) ;</p>
<p style="margin-left:9%; margin-top: 1em">In a scalar
context the method returns the number of values associated
with the key, $key.</p>
<p style="margin-left:9%; margin-top: 1em">In list context,
it returns all the values which match $key. Note that the
values will be returned in an apparently random order.</p>
<p style="margin-left:9%; margin-top: 1em">In list context,
if the second parameter is present and evaluates TRUE, the
method returns an associative array. The keys of the
associative array correspond to the values that matched in
the BTREE and the values of the array are a count of the
number of times that particular value occurred in the
BTREE.</p>
<p style="margin-left:9%; margin-top: 1em">So assuming the
database created above, we can use "get_dup" like
this:</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my ($filename, $x, %h) ; <br/>
$filename = "tree" ; <br/>
# Enable duplicate records <br/>
$DB_BTREE−&gt;{'flags'} = R_DUP ; <br/>
$x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_BTREE <br/>
or die "Cannot open $filename: $!\n"; <br/>
my $cnt = $x−&gt;get_dup("Wall") ; <br/>
print "Wall occurred $cnt times\n" ; <br/>
my %hash = $x−&gt;get_dup("Wall", 1) ; <br/>
print "Larry is there\n" if $hash{'Larry'} ; <br/>
print "There are $hash{'Brick'} Brick Walls\n" ;
<br/>
my @list = sort $x−&gt;get_dup("Wall") ;
<br/>
print "Wall =&gt; [@list]\n" ; <br/>
@list = $x−&gt;get_dup("Smith") ; <br/>
print "Smith =&gt; [@list]\n" ; <br/>
@list = $x−&gt;get_dup("Dog") ; <br/>
print "Dog =&gt; [@list]\n" ;</p>
<p style="margin-left:9%; margin-top: 1em">and it will
print:</p>
<p style="margin-left:9%; margin-top: 1em">Wall occurred 3
times <br/>
Larry is there <br/>
There are 2 Brick Walls <br/>
Wall =&gt; [Brick Brick Larry] <br/>
Smith =&gt; [John] <br/>
Dog =&gt; []</p>
<h3>The find_dup() Method
<a name="The find_dup() Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$status =
$X−&gt;find_dup($key, $value) ;</p>
<p style="margin-left:9%; margin-top: 1em">This method
checks for the existence of a specific key/value pair. If
the pair exists, the cursor is left pointing to the pair and
the method returns 0. Otherwise the method returns a
non−zero value.</p>
<p style="margin-left:9%; margin-top: 1em">Assuming the
database from the previous example:</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my ($filename, $x, %h, $found) ; <br/>
$filename = "tree" ; <br/>
# Enable duplicate records <br/>
$DB_BTREE−&gt;{'flags'} = R_DUP ; <br/>
$x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_BTREE <br/>
or die "Cannot open $filename: $!\n"; <br/>
$found = ( $x−&gt;find_dup("Wall",
"Larry") == 0 ? "" : "not") ;
<br/>
print "Larry Wall is $found there\n" ; <br/>
$found = ( $x−&gt;find_dup("Wall",
"Harry") == 0 ? "" : "not") ;
<br/>
print "Harry Wall is $found there\n" ; <br/>
undef $x ; <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">prints this</p>
<p style="margin-left:9%; margin-top: 1em">Larry Wall is
there <br/>
Harry Wall is not there</p>
<h3>The del_dup() Method
<a name="The del_dup() Method"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">$status =
$X−&gt;del_dup($key, $value) ;</p>
<p style="margin-left:9%; margin-top: 1em">This method
deletes a specific key/value pair. It returns 0 if they
exist and have been deleted successfully. Otherwise the
method returns a non−zero value.</p>
<p style="margin-left:9%; margin-top: 1em">Again assuming
the existence of the "tree" database</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my ($filename, $x, %h, $found) ; <br/>
$filename = "tree" ; <br/>
# Enable duplicate records <br/>
$DB_BTREE−&gt;{'flags'} = R_DUP ; <br/>
$x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_BTREE <br/>
or die "Cannot open $filename: $!\n"; <br/>
$x−&gt;del_dup("Wall", "Larry") ;
<br/>
$found = ( $x−&gt;find_dup("Wall",
"Larry") == 0 ? "" : "not") ;
<br/>
print "Larry Wall is $found there\n" ; <br/>
undef $x ; <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">prints this</p>
<p style="margin-left:9%; margin-top: 1em">Larry Wall is
not there</p>
<h3>Matching Partial Keys
<a name="Matching Partial Keys"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The BTREE
interface has a feature which allows partial keys to be
matched. This functionality is <i>only</i> available when
the "seq" method is used along with the R_CURSOR
flag.</p>
<p style="margin-left:9%; margin-top: 1em">$x−&gt;seq($key,
$value, R_CURSOR) ;</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
relevant quote from the dbopen man page where it defines the
use of the R_CURSOR flag with seq:</p>
<p style="margin-left:9%; margin-top: 1em">Note, for the
DB_BTREE access method, the returned key is not <br/>
necessarily an exact match for the specified key. The
returned key <br/>
is the smallest key greater than or equal to the specified
key, <br/>
permitting partial key matches and range searches.</p>
<p style="margin-left:9%; margin-top: 1em">In the example
script below, the "match" sub uses this feature to
find and print the first matching key/value pair given a
partial key.</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
use Fcntl ; <br/>
my ($filename, $x, %h, $st, $key, $value) ; <br/>
sub match <br/>
{ <br/>
my $key = shift ; <br/>
my $value = 0; <br/>
my $orig_key = $key ; <br/>
$x−&gt;seq($key, $value, R_CURSOR) ; <br/>
print "$orig_key\t−&gt; $key\t−&gt;
$value\n" ; <br/>
} <br/>
$filename = "tree" ; <br/>
unlink $filename ; <br/>
$x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_BTREE <br/>
or die "Cannot open $filename: $!\n"; <br/>
# Add some key/value pairs to the file <br/>
$h{'mouse'} = 'mickey' ; <br/>
$h{'Wall'} = 'Larry' ; <br/>
$h{'Walls'} = 'Brick' ; <br/>
$h{'Smith'} = 'John' ; <br/>
$key = $value = 0 ; <br/>
print "IN ORDER\n" ; <br/>
for ($st = $x−&gt;seq($key, $value, R_FIRST) ; <br/>
$st == 0 ; <br/>
$st = $x−&gt;seq($key, $value, R_NEXT) ) <br/>
{ print "$key −&gt; $value\n" } <br/>
print "\nPARTIAL MATCH\n" ; <br/>
match "Wa" ; <br/>
match "A" ; <br/>
match "a" ; <br/>
undef $x ; <br/>
untie %h ;</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
output:</p>
<p style="margin-left:9%; margin-top: 1em">IN ORDER <br/>
Smith −&gt; John <br/>
Wall −&gt; Larry <br/>
Walls −&gt; Brick <br/>
mouse −&gt; mickey <br/>
PARTIAL MATCH <br/>
Wa −&gt; Wall −&gt; Larry <br/>
A −&gt; Smith −&gt; John <br/>
a −&gt; mouse −&gt; mickey</p>
<h2>DB_RECNO
<a name="DB_RECNO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">DB_RECNO
provides an interface to flat text files. Both variable and
fixed length records are supported.</p>
<p style="margin-left:9%; margin-top: 1em">In order to make
RECNO more compatible with Perl, the array offset for all
RECNO arrays begins at 0 rather than 1 as in Berkeley
DB.</p>
<p style="margin-left:9%; margin-top: 1em">As with normal
Perl arrays, a RECNO array can be accessed using negative
indexes. The index −1 refers to the last element of
the array, −2 the second last, and so on. Attempting
to access an element before the start of the array will
raise a fatal run−time error.</p>
<h3>The 'bval' Option
<a name="The 'bval' Option"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The operation of
the bval option warrants some discussion. Here is the
definition of bval from the Berkeley DB 1.85 recno manual
page:</p>
<p style="margin-left:9%; margin-top: 1em">The delimiting
byte to be used to mark the end of a <br/>
record for variable−length records, and the pad
charac− <br/>
ter for fixed−length records. If no value is
speci− <br/>
fied, newlines (``\n'') are used to mark the end of <br/>
variable−length records and fixed−length records
are <br/>
padded with spaces.</p>
<p style="margin-left:9%; margin-top: 1em">The second
sentence is wrong. In actual fact bval will only default to
"\n" when the openinfo parameter in dbopen is
NULL. If a non−NULL openinfo parameter is used at all,
the value that happens to be in bval will be used. That
means you always have to specify bval when making use of any
of the options in the openinfo parameter. This documentation
error will be fixed in the next release of Berkeley DB.</p>
<p style="margin-left:9%; margin-top: 1em">That clarifies
the situation with regards Berkeley DB itself. What about
<b>DB_File</b>? Well, the behavior defined in the quote
above is quite useful, so <b>DB_File</b> conforms to it.</p>
<p style="margin-left:9%; margin-top: 1em">That means that
you can specify other options (e.g. cachesize) and still
have bval default to "\n" for variable length
records, and space for fixed length records.</p>
<p style="margin-left:9%; margin-top: 1em">Also note that
the bval option only allows you to specify a single byte as
a delimiter.</p>
<h3>A Simple Example
<a name="A Simple Example"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Here is a simple
example that uses RECNO (if you are using a version of Perl
earlier than 5.004_57 this example won't work −−
see "Extra RECNO Methods" for a workaround).</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my $filename = "text" ; <br/>
unlink $filename ; <br/>
my @h ; <br/>
tie @h, "DB_File", $filename, O_RDWR|O_CREAT,
0666, $DB_RECNO <br/>
or die "Cannot open file 'text': $!\n" ; <br/>
# Add a few key/value pairs to the file <br/>
$h[0] = "orange" ; <br/>
$h[1] = "blue" ; <br/>
$h[2] = "yellow" ; <br/>
push @h, "green", "black" ; <br/>
my $elements = scalar @h ; <br/>
print "The array contains $elements entries\n" ;
<br/>
my $last = pop @h ; <br/>
print "popped $last\n" ; <br/>
unshift @h, "white" ; <br/>
my $first = shift @h ; <br/>
print "shifted $first\n" ; <br/>
# Check for existence of a key <br/>
print "Element 1 Exists with value $h[1]\n" if
$h[1] ; <br/>
# use a negative index <br/>
print "The last element is $h[−1]\n" ; <br/>
print "The 2nd last element is $h[−2]\n" ;
<br/>
untie @h ;</p>
<p style="margin-left:9%; margin-top: 1em">Here is the
output from the script:</p>
<p style="margin-left:9%; margin-top: 1em">The array
contains 5 entries <br/>
popped black <br/>
shifted white <br/>
Element 1 Exists with value blue <br/>
The last element is green <br/>
The 2nd last element is yellow</p>
<h3>Extra RECNO Methods
<a name="Extra RECNO Methods"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If you are using
a version of Perl earlier than 5.004_57, the tied array
interface is quite limited. In the example script above
"push", "pop", "shift",
"unshift" or determining the array length will not
work with a tied array.</p>
<p style="margin-left:9%; margin-top: 1em">To make the
interface more useful for older versions of Perl, a number
of methods are supplied with <b>DB_File</b> to simulate the
missing array operations. All these methods are accessed via
the object returned from the tie call.</p>
<p style="margin-left:9%; margin-top: 1em">Here are the
methods: <b><br/>
$X−&gt;push(list) ;</b></p>
<p style="margin-left:15%;">Pushes the elements of
"list" to the end of the array.</p>
<p style="margin-left:9%;"><b>$value = $X−&gt;pop
;</b></p>
<p style="margin-left:15%;">Removes and returns the last
element of the array.</p>
<p style="margin-left:9%;"><b>$X−&gt;shift</b></p>
<p style="margin-left:15%;">Removes and returns the first
element of the array.</p>
<p style="margin-left:9%;"><b>$X−&gt;unshift(list)
;</b></p>
<p style="margin-left:15%;">Pushes the elements of
"list" to the start of the array.</p>
<p style="margin-left:9%;"><b>$X−&gt;length</b></p>
<p style="margin-left:15%;">Returns the number of elements
in the array.</p>
<p style="margin-left:9%;"><b>$X−&gt;splice(offset,
length, elements);</b></p>
<p style="margin-left:15%;">Returns a splice of the
array.</p>
<h3>Another Example
<a name="Another Example"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Here is a more
complete example that makes use of some of the methods
described above. It also makes use of the API interface
directly (see "THE API INTERFACE").</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
my (@h, $H, $file, $i) ; <br/>
use DB_File ; <br/>
use Fcntl ; <br/>
$file = "text" ; <br/>
unlink $file ; <br/>
$H = tie @h, "DB_File", $file, O_RDWR|O_CREAT,
0666, $DB_RECNO <br/>
or die "Cannot open file $file: $!\n" ; <br/>
# first create a text file to play with <br/>
$h[0] = "zero" ; <br/>
$h[1] = "one" ; <br/>
$h[2] = "two" ; <br/>
$h[3] = "three" ; <br/>
$h[4] = "four" ; <br/>
# Print the records in order. <br/>
# <br/>
# The length method is needed here because evaluating a tied
<br/>
# array in a scalar context does not return the number of
<br/>
# elements in the array. <br/>
print "\nORIGINAL\n" ; <br/>
foreach $i (0 .. $H−&gt;length − 1) { <br/>
print "$i: $h[$i]\n" ; <br/>
} <br/>
# use the push &amp; pop methods <br/>
$a = $H−&gt;pop ; <br/>
$H−&gt;push("last") ; <br/>
print "\nThe last record was [$a]\n" ; <br/>
# and the shift &amp; unshift methods <br/>
$a = $H−&gt;shift ; <br/>
$H−&gt;unshift("first") ; <br/>
print "The first record was [$a]\n" ; <br/>
# Use the API to add a new record after record 2. <br/>
$i = 2 ; <br/>
$H−&gt;put($i, "Newbie", R_IAFTER) ; <br/>
# and a new record before record 1. <br/>
$i = 1 ; <br/>
$H−&gt;put($i, "New One", R_IBEFORE) ; <br/>
# delete record 3 <br/>
$H−&gt;del(3) ; <br/>
# now print the records in reverse order <br/>
print "\nREVERSE\n" ; <br/>
for ($i = $H−&gt;length − 1 ; $i &gt;= 0 ;
−− $i) <br/>
{ print "$i: $h[$i]\n" } <br/>
# same again, but use the API functions instead <br/>
print "\nREVERSE again\n" ; <br/>
my ($s, $k, $v) = (0, 0, 0) ; <br/>
for ($s = $H−&gt;seq($k, $v, R_LAST) ; <br/>
$s == 0 ; <br/>
$s = $H−&gt;seq($k, $v, R_PREV)) <br/>
{ print "$k: $v\n" } <br/>
undef $H ; <br/>
untie @h ;</p>
<p style="margin-left:9%; margin-top: 1em">and this is what
it outputs:</p>
<p style="margin-left:9%; margin-top: 1em">ORIGINAL <br/>
0: zero <br/>
1: one <br/>
2: two <br/>
3: three <br/>
4: four <br/>
The last record was [four] <br/>
The first record was [zero] <br/>
REVERSE <br/>
5: last <br/>
4: three <br/>
3: Newbie <br/>
2: one <br/>
1: New One <br/>
0: first <br/>
REVERSE again <br/>
5: last <br/>
4: three <br/>
3: Newbie <br/>
2: one <br/>
1: New One <br/>
0: first</p>
<p style="margin-left:9%; margin-top: 1em">Notes:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="70%">
<p>Rather than iterating through the array, @h like
this:</p> </td>
<td width="15%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">foreach $i
(@h)</p>
<p style="margin-left:15%; margin-top: 1em">it is necessary
to use either this:</p>
<p style="margin-left:15%; margin-top: 1em">foreach $i (0
.. $H−&gt;length − 1)</p>
<p style="margin-left:15%; margin-top: 1em">or this:</p>
<p style="margin-left:15%; margin-top: 1em">for ($a =
$H−&gt;get($k, $v, R_FIRST) ; <br/>
$a == 0 ; <br/>
$a = $H−&gt;get($k, $v, R_NEXT) )</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="85%">
<p style="margin-top: 1em">Notice that both times the
"put" method was used the record index was
specified using a variable, $i, rather than the literal
value itself. This is because "put" will return
the record number of the inserted line via that
parameter.</p> </td></tr>
</table>
<h2>THE API INTERFACE
<a name="THE API INTERFACE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">As well as
accessing Berkeley DB using a tied hash or array, it is also
possible to make direct use of most of the API functions
defined in the Berkeley DB documentation.</p>
<p style="margin-left:9%; margin-top: 1em">To do this you
need to store a copy of the object returned from the
tie.</p>
<p style="margin-left:9%; margin-top: 1em">$db = tie %hash,
"DB_File", "filename" ;</p>
<p style="margin-left:9%; margin-top: 1em">Once you have
done that, you can access the Berkeley DB API functions as
<b>DB_File</b> methods directly like this:</p>
<p style="margin-left:9%; margin-top: 1em">$db−&gt;put($key,
$value, R_NOOVERWRITE) ;</p>
<p style="margin-left:9%; margin-top: 1em"><b>Important:</b>
If you have saved a copy of the object returned from
"tie", the underlying database file will
<i>not</i> be closed until both the tied variable is untied
and all copies of the saved object are destroyed.</p>
<p style="margin-left:9%; margin-top: 1em">use DB_File ;
<br/>
$db = tie %hash, "DB_File", "filename"
<br/>
or die "Cannot tie filename: $!" ; <br/>
... <br/>
undef $db ; <br/>
untie %hash ;</p>
<p style="margin-left:9%; margin-top: 1em">See "The
<b>untie()</b> Gotcha" for more details.</p>
<p style="margin-left:9%; margin-top: 1em">All the
functions defined in dbopen are available except for
<b>close()</b> and <b>dbopen()</b> itself. The
<b>DB_File</b> method interface to the supported functions
have been implemented to mirror the way Berkeley DB works
whenever possible. In particular note that:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="84%">
<p style="margin-top: 1em">The methods return a status
value. All return 0 on success. All return −1 to
signify an error and set $! to the exact error code. The
return code 1 generally (but not always) means that the key
specified did not exist in the database.</p></td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">Other return
codes are defined. See below and in the Berkeley DB
documentation for details. The Berkeley DB documentation
should be used as the definitive source.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p style="margin-top: 1em">•</p></td>
<td width="5%"></td>
<td width="84%">
<p style="margin-top: 1em">Whenever a Berkeley DB function
returns data via one of its parameters, the equivalent
<b>DB_File</b> method does exactly the same.</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="1%">
<p>•</p></td>
<td width="5%"></td>
<td width="84%">
<p>If you are careful, it is possible to mix API calls with
the tied hash/array interface in the same piece of code.
Although only a few of the methods used to implement the
tied interface currently make use of the cursor, you should
always assume that the cursor has been changed any time the
tied hash/array interface is used. As an example, this code
will probably not do what you expect:</p></td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:15%; margin-top: 1em">$X = tie %x,
'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE <br/>
or die "Cannot tie $filename: $!" ; <br/>
# Get the first key/value pair and set the cursor <br/>
$X−&gt;seq($key, $value, R_FIRST) ; <br/>
# this line will modify the cursor <br/>
$count = scalar keys %x ; <br/>
# Get the second key/value pair. <br/>
# oops, it didn't, it got the last key/value pair! <br/>
$X−&gt;seq($key, $value, R_NEXT) ;</p>
<p style="margin-left:15%; margin-top: 1em">The code above
can be rearranged to get around the problem, like this:</p>
<p style="margin-left:15%; margin-top: 1em">$X = tie %x,
'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE <br/>
or die "Cannot tie $filename: $!" ; <br/>
# this line will modify the cursor <br/>
$count = scalar keys %x ; <br/>
# Get the first key/value pair and set the cursor <br/>
$X−&gt;seq($key, $value, R_FIRST) ; <br/>
# Get the second key/value pair. <br/>
# worked this time. <br/>
$X−&gt;seq($key, $value, R_NEXT) ;</p>
<p style="margin-left:9%; margin-top: 1em">All the
constants defined in dbopen for use in the flags parameters
in the methods defined below are also available. Refer to
the Berkeley DB documentation for the precise meaning of the
flags values.</p>
<p style="margin-left:9%; margin-top: 1em">Below is a list
of the methods available. <b><br/>
$status = $X−&gt;get($key, $value [, $flags])
;</b></p>
<p style="margin-left:15%;">Given a key ($key) this method
reads the value associated with it from the database. The
value read from the database is returned in the $value
parameter.</p>
<p style="margin-left:15%; margin-top: 1em">If the key does
not exist the method returns 1.</p>
<p style="margin-left:15%; margin-top: 1em">No flags are
currently defined for this method.</p>
<p style="margin-left:9%;"><b>$status =
$X−&gt;put($key, $value [, $flags]) ;</b></p>
<p style="margin-left:15%;">Stores the key/value pair in
the database.</p>
<p style="margin-left:15%; margin-top: 1em">If you use
either the R_IAFTER or R_IBEFORE flags, the $key parameter
will have the record number of the inserted key/value pair
set.</p>
<p style="margin-left:15%; margin-top: 1em">Valid flags are
R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and
R_SETCURSOR.</p>
<p style="margin-left:9%;"><b>$status =
$X−&gt;del($key [, $flags]) ;</b></p>
<p style="margin-left:15%;">Removes all key/value pairs
with key $key from the database.</p>
<p style="margin-left:15%; margin-top: 1em">A return code
of 1 means that the requested key was not in the
database.</p>
<p style="margin-left:15%; margin-top: 1em">R_CURSOR is the
only valid flag at present.</p>
<p style="margin-left:9%;"><b>$status = $X−&gt;fd
;</b></p>
<p style="margin-left:15%;">Returns the file descriptor for
the underlying database.</p>
<p style="margin-left:15%; margin-top: 1em">See
"Locking: The Trouble with fd" for an explanation
for why you should not use "fd" to lock your
database.</p>
<p style="margin-left:9%;"><b>$status =
$X−&gt;seq($key, $value, $flags) ;</b></p>
<p style="margin-left:15%;">This interface allows
sequential retrieval from the database. See dbopen for full
details.</p>
<p style="margin-left:15%; margin-top: 1em">Both the $key
and $value parameters will be set to the key/value pair read
from the database.</p>
<p style="margin-left:15%; margin-top: 1em">The flags
parameter is mandatory. The valid flag values are R_CURSOR,
R_FIRST, R_LAST, R_NEXT and R_PREV.</p>
<p style="margin-left:9%;"><b>$status =
$X−&gt;sync([$flags]) ;</b></p>
<p style="margin-left:15%;">Flushes any cached buffers to
disk.</p>
<p style="margin-left:15%; margin-top: 1em">R_RECNOSYNC is
the only valid flag at present.</p>
<h2>DBM FILTERS
<a name="DBM FILTERS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">A DBM Filter is
a piece of code that is be used when you <i>always</i> want
to make the same transformation to all keys and/or values in
a DBM database. An example is when you need to encode your
data in UTF−8 before writing to the database and then
decode the UTF−8 when reading from the database
file.</p>
<p style="margin-left:9%; margin-top: 1em">There are two
ways to use a DBM Filter.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="84%">
<p>Using the low−level API defined below.</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="3%"></td>
<td width="84%">
<p>Using the DBM_Filter module. This module hides the
complexity of the API defined below and comes with a number
of "canned" filters that cover some of the common
use−cases.</p> </td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Use of the
DBM_Filter module is recommended.</p>
<h3>DBM Filter Low−level API
<a name="DBM Filter Low−level API"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">There are four
methods associated with DBM Filters. All work identically,
and each is used to install (or uninstall) a single DBM
Filter. Each expects a single parameter, namely a reference
to a sub. The only difference between them is the place that
the filter is installed.</p>
<p style="margin-left:9%; margin-top: 1em">To summarise:
<b><br/>
filter_store_key</b></p>
<p style="margin-left:15%;">If a filter has been installed
with this method, it will be invoked every time you write a
key to a DBM database.</p>
<p style="margin-left:9%;"><b>filter_store_value</b></p>
<p style="margin-left:15%;">If a filter has been installed
with this method, it will be invoked every time you write a
value to a DBM database.</p>
<p style="margin-left:9%;"><b>filter_fetch_key</b></p>
<p style="margin-left:15%;">If a filter has been installed
with this method, it will be invoked every time you read a
key from a DBM database.</p>
<p style="margin-left:9%;"><b>filter_fetch_value</b></p>
<p style="margin-left:15%;">If a filter has been installed
with this method, it will be invoked every time you read a
value from a DBM database.</p>
<p style="margin-left:9%; margin-top: 1em">You can use any
combination of the methods, from none, to all four.</p>
<p style="margin-left:9%; margin-top: 1em">All filter
methods return the existing filter, if present, or
"undef" in not.</p>
<p style="margin-left:9%; margin-top: 1em">To delete a
filter pass "undef" to it.</p>
<h3>The Filter
<a name="The Filter"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">When each filter
is called by Perl, a local copy of $_ will contain the key
or value to be filtered. Filtering is achieved by modifying
the contents of $_. The return code from the filter is
ignored.</p>
<h3>An Example −− the NULL termination problem.
<a name="An Example −− the NULL termination problem."></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Consider the
following scenario. You have a DBM database that you need to
share with a third−party C application. The C
application assumes that <i>all</i> keys and values are NULL
terminated. Unfortunately when Perl writes to DBM databases
it doesn't use NULL termination, so your Perl application
will have to manage NULL termination itself. When you write
to the database you will have to use something like
this:</p>
<p style="margin-left:9%; margin-top: 1em">$hash{"$key\0"}
= "$value\0" ;</p>
<p style="margin-left:9%; margin-top: 1em">Similarly the
NULL needs to be taken into account when you are considering
the length of existing keys/values.</p>
<p style="margin-left:9%; margin-top: 1em">It would be much
better if you could ignore the NULL terminations issue in
the main application code and have a mechanism that
automatically added the terminating NULL to all keys and
values whenever you write to the database and have them
removed when you read from the database. As I'm sure you
have already guessed, this is a problem that DBM Filters can
fix very easily.</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my %hash ; <br/>
my $filename = "filt" ; <br/>
unlink $filename ; <br/>
my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR,
0666, $DB_HASH <br/>
or die "Cannot open $filename: $!\n" ; <br/>
# Install DBM Filters <br/>
$db−&gt;filter_fetch_key ( sub { s/\0$// } ) ; <br/>
$db−&gt;filter_store_key ( sub { $_ .= "\0"
} ) ; <br/>
$db−&gt;filter_fetch_value( sub { s/\0$// } ) ; <br/>
$db−&gt;filter_store_value( sub { $_ .= "\0"
} ) ; <br/>
$hash{"abc"} = "def" ; <br/>
my $a = $hash{"ABC"} ; <br/>
# ... <br/>
undef $db ; <br/>
untie %hash ;</p>
<p style="margin-left:9%; margin-top: 1em">Hopefully the
contents of each of the filters should be
self−explanatory. Both "fetch" filters
remove the terminating NULL, and both "store"
filters add a terminating NULL.</p>
<h3>Another Example −− Key is a C int.
<a name="Another Example −− Key is a C int."></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Here is another
real−life example. By default, whenever Perl writes to
a DBM database it always writes the key and value as
strings. So when you use this:</p>
<p style="margin-left:9%; margin-top: 1em">$hash{12345} =
"something" ;</p>
<p style="margin-left:9%; margin-top: 1em">the key 12345
will get stored in the DBM database as the 5 byte string
"12345". If you actually want the key to be stored
in the DBM database as a C int, you will have to use
"pack" when writing, and "unpack" when
reading.</p>
<p style="margin-left:9%; margin-top: 1em">Here is a DBM
Filter that does it:</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my %hash ; <br/>
my $filename = "filt" ; <br/>
unlink $filename ; <br/>
my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR,
0666, $DB_HASH <br/>
or die "Cannot open $filename: $!\n" ; <br/>
$db−&gt;filter_fetch_key ( sub { $_ =
unpack("i", $_) } ) ; <br/>
$db−&gt;filter_store_key ( sub { $_ = pack
("i", $_) } ) ; <br/>
$hash{123} = "def" ; <br/>
# ... <br/>
undef $db ; <br/>
untie %hash ;</p>
<p style="margin-left:9%; margin-top: 1em">This time only
two filters have been used −− we only need to
manipulate the contents of the key, so it wasn't necessary
to install any value filters.</p>
<h2>HINTS AND TIPS
<a name="HINTS AND TIPS"></a>
</h2>
<h3>Locking: The Trouble with fd
<a name="Locking: The Trouble with fd"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Until version
1.72 of this module, the recommended technique for locking
<b>DB_File</b> databases was to flock the filehandle
returned from the "fd" function. Unfortunately
this technique has been shown to be fundamentally flawed
(Kudos to David Harris for tracking this down). Use it at
your own peril!</p>
<p style="margin-left:9%; margin-top: 1em">The locking
technique went like this.</p>
<p style="margin-left:9%; margin-top: 1em">$db = tie(%db,
'DB_File', 'foo.db', O_CREAT|O_RDWR, 0644) <br/>
|| die "dbcreat foo.db $!"; <br/>
$fd = $db−&gt;fd; <br/>
open(DB_FH, "+&lt;&amp;=$fd") || die "dup
$!"; <br/>
flock (DB_FH, LOCK_EX) || die "flock: $!"; <br/>
... <br/>
$db{"Tom"} = "Jerry" ; <br/>
... <br/>
flock(DB_FH, LOCK_UN); <br/>
undef $db; <br/>
untie %db; <br/>
close(DB_FH);</p>
<p style="margin-left:9%; margin-top: 1em">In simple terms,
this is what happens:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="44%">
<p>Use "tie" to open the database.</p></td>
<td width="41%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="3%"></td>
<td width="44%">
<p>Lock the database with fd &amp; flock.</p></td>
<td width="41%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>3.</p></td>
<td width="3%"></td>
<td width="44%">
<p>Read &amp; Write to the database.</p></td>
<td width="41%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>4.</p></td>
<td width="3%"></td>
<td width="44%">
<p>Unlock and close the database.</p></td>
<td width="41%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Here is the crux
of the problem. A side−effect of opening the
<b>DB_File</b> database in step 2 is that an initial block
from the database will get read from disk and cached in
memory.</p>
<p style="margin-left:9%; margin-top: 1em">To see why this
is a problem, consider what can happen when two processes,
say "A" and "B", both want to update the
same <b>DB_File</b> database using the locking steps
outlined above. Assume process "A" has already
opened the database and has a write lock, but it hasn't
actually updated the database yet (it has finished step 2,
but not started step 3 yet). Now process "B" tries
to open the same database − step 1 will succeed, but
it will block on step 2 until process "A" releases
the lock. The important thing to notice here is that at this
point in time both processes will have cached identical
initial blocks from the database.</p>
<p style="margin-left:9%; margin-top: 1em">Now process
"A" updates the database and happens to change
some of the data held in the initial buffer. Process
"A" terminates, flushing all cached data to disk
and releasing the database lock. At this point the database
on disk will correctly reflect the changes made by process
"A".</p>
<p style="margin-left:9%; margin-top: 1em">With the lock
released, process "B" can now continue. It also
updates the database and unfortunately it too modifies the
data that was in its initial buffer. Once that data gets
flushed to disk it will overwrite some/all of the changes
process "A" made to the database.</p>
<p style="margin-left:9%; margin-top: 1em">The result of
this scenario is at best a database that doesn't contain
what you expect. At worst the database will corrupt.</p>
<p style="margin-left:9%; margin-top: 1em">The above won't
happen every time competing process update the same
<b>DB_File</b> database, but it does illustrate why the
technique should not be used.</p>
<h3>Safe ways to lock a database
<a name="Safe ways to lock a database"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Starting with
version 2.x, Berkeley DB has internal support for locking.
The companion module to this one, BerkeleyDB
&lt;https://metacpan.org/pod/BerkeleyDB&gt;, provides an
interface to this locking functionality. If you are serious
about locking Berkeley DB databases, I strongly recommend
using BerkeleyDB
&lt;https://metacpan.org/pod/BerkeleyDB&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">If using
BerkeleyDB &lt;https://metacpan.org/pod/BerkeleyDB&gt; isn't
an option, there are a number of modules available on CPAN
that can be used to implement locking. Each one implements
locking differently and has different goals in mind. It is
therefore worth knowing the difference, so that you can pick
the right one for your application. Here are the three
locking wrappers: <b><br/>
Tie::DB_Lock</b></p>
<p style="margin-left:15%;">A <b>DB_File</b> wrapper which
creates copies of the database file for read access, so that
you have a kind of a multiversioning concurrent read system.
However, updates are still serial. Use for databases where
reads may be lengthy and consistency problems may occur.</p>
<p style="margin-left:9%;"><b>Tie::DB_LockFile</b></p>
<p style="margin-left:15%;">A <b>DB_File</b> wrapper that
has the ability to lock and unlock the database while it is
being used. Avoids the tie−before−flock problem
by simply re−tie−ing the database when you get
or drop a lock. Because of the flexibility in dropping and
re−acquiring the lock in the middle of a session, this
can be massaged into a system that will work with long
updates and/or reads if the application follows the hints in
the POD documentation.</p>
<p style="margin-left:9%;"><b>DB_File::Lock</b></p>
<p style="margin-left:15%;">An extremely lightweight
<b>DB_File</b> wrapper that simply flocks a lockfile before
tie−ing the database and drops the lock after the
untie. Allows one to use the same lockfile for multiple
databases to avoid deadlock problems, if desired. Use for
databases where updates are reads are quick and simple flock
locking semantics are enough.</p>
<h3>Sharing Databases With C Applications
<a name="Sharing Databases With C Applications"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">There is no
technical reason why a Berkeley DB database cannot be shared
by both a Perl and a C application.</p>
<p style="margin-left:9%; margin-top: 1em">The vast
majority of problems that are reported in this area boil
down to the fact that C strings are NULL terminated, whilst
Perl strings are not. See "DBM FILTERS" for a
generic way to work around this problem.</p>
<p style="margin-left:9%; margin-top: 1em">Here is a real
example. Netscape 2.0 keeps a record of the locations you
visit along with the time you last visited them in a DB_HASH
database. This is usually stored in the file
<i>˜/.netscape/history.db</i>. The key field in the
database is the location string and the value field is the
time the location was last visited stored as a 4 byte binary
value.</p>
<p style="margin-left:9%; margin-top: 1em">If you haven't
already guessed, the location string is stored with a
terminating NULL. This means you need to be careful when
accessing the database.</p>
<p style="margin-left:9%; margin-top: 1em">Here is a
snippet of code that is loosely based on Tom Christiansen's
<i>ggh</i> script (available from your nearest CPAN archive
in <i>authors/id/TOMC/scripts/nshist.gz</i>).</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
use Fcntl ; <br/>
my ($dotdir, $HISTORY, %hist_db, $href, $binary_time, $date)
; <br/>
$dotdir = $ENV{HOME} || $ENV{LOGNAME}; <br/>
$HISTORY = "$dotdir/.netscape/history.db"; <br/>
tie %hist_db, 'DB_File', $HISTORY <br/>
or die "Cannot open $HISTORY: $!\n" ;; <br/>
# Dump the complete database <br/>
while ( ($href, $binary_time) = each %hist_db ) { <br/>
# remove the terminating NULL <br/>
$href =˜ s/\x00$// ; <br/>
# convert the binary time into a user friendly string <br/>
$date = localtime unpack("V", $binary_time); <br/>
print "$date $href\n" ; <br/>
} <br/>
# check for the existence of a specific key <br/>
# remember to add the NULL <br/>
if ( $binary_time =
$hist_db{"http://mox.perl.com/\x00"} ) { <br/>
$date = localtime unpack("V", $binary_time) ; <br/>
print "Last visited mox.perl.com on $date\n" ;
<br/>
} <br/>
else { <br/>
print "Never visited mox.perl.com\n" <br/>
} <br/>
untie %hist_db ;</p>
<h3>The untie() Gotcha
<a name="The untie() Gotcha"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If you make use
of the Berkeley DB API, it is <i>very</i> strongly
recommended that you read "The untie Gotcha" in
perltie.</p>
<p style="margin-left:9%; margin-top: 1em">Even if you
don't currently make use of the API interface, it is still
worth reading it.</p>
<p style="margin-left:9%; margin-top: 1em">Here is an
example which illustrates the problem from a <b>DB_File</b>
perspective:</p>
<p style="margin-left:9%; margin-top: 1em">use DB_File ;
<br/>
use Fcntl ; <br/>
my %x ; <br/>
my $X ; <br/>
$X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_TRUNC <br/>
or die "Cannot tie first time: $!" ; <br/>
$x{123} = 456 ; <br/>
untie %x ; <br/>
tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT <br/>
or die "Cannot tie second time: $!" ; <br/>
untie %x ;</p>
<p style="margin-left:9%; margin-top: 1em">When run, the
script will produce this error message:</p>
<p style="margin-left:9%; margin-top: 1em">Cannot tie
second time: Invalid argument at bad.file line 14.</p>
<p style="margin-left:9%; margin-top: 1em">Although the
error message above refers to the second <b>tie()</b>
statement in the script, the source of the problem is really
with the <b>untie()</b> statement that precedes it.</p>
<p style="margin-left:9%; margin-top: 1em">Having read
perltie you will probably have already guessed that the
error is caused by the extra copy of the tied object stored
in $X. If you haven't, then the problem boils down to the
fact that the <b>DB_File</b> destructor, DESTROY, will not
be called until <i>all</i> references to the tied object are
destroyed. Both the tied variable, %x, and $X above hold a
reference to the object. The call to <b>untie()</b> will
destroy the first, but $X still holds a valid reference, so
the destructor will not get called and the database file
<i>tst.fil</i> will remain open. The fact that Berkeley DB
then reports the attempt to open a database that is already
open via the catch−all "Invalid argument"
doesn't help.</p>
<p style="margin-left:9%; margin-top: 1em">If you run the
script with the "−w" flag the error message
becomes:</p>
<p style="margin-left:9%; margin-top: 1em">untie attempted
while 1 inner references still exist at bad.file line 12.
<br/>
Cannot tie second time: Invalid argument at bad.file line
14.</p>
<p style="margin-left:9%; margin-top: 1em">which pinpoints
the real problem. Finally the script can now be modified to
fix the original problem by destroying the API object before
the untie:</p>
<p style="margin-left:9%; margin-top: 1em">... <br/>
$x{123} = 456 ; <br/>
undef $X ; <br/>
untie %x ; <br/>
$X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT <br/>
...</p>
<h2>COMMON QUESTIONS
<a name="COMMON QUESTIONS"></a>
</h2>
<h3>Why is there Perl source in my database?
<a name="Why is there Perl source in my database?"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">If you look at
the contents of a database file created by DB_File, there
can sometimes be part of a Perl script included in it.</p>
<p style="margin-left:9%; margin-top: 1em">This happens
because Berkeley DB uses dynamic memory to allocate buffers
which will subsequently be written to the database file.
Being dynamic, the memory could have been used for anything
before DB malloced it. As Berkeley DB doesn't clear the
memory once it has been allocated, the unused portions will
contain random junk. In the case where a Perl script gets
written to the database, the random junk will correspond to
an area of dynamic memory that happened to be used during
the compilation of the script.</p>
<p style="margin-left:9%; margin-top: 1em">Unless you don't
like the possibility of there being part of your Perl
scripts embedded in a database file, this is nothing to
worry about.</p>
<h3>How do I store complex data structures with DB_File?
<a name="How do I store complex data structures with DB_File?"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Although
<b>DB_File</b> cannot do this directly, there is a module
which can layer transparently over <b>DB_File</b> to
accomplish this feat.</p>
<p style="margin-left:9%; margin-top: 1em">Check out the
MLDBM module, available on CPAN in the directory
<i>modules/by−module/MLDBM</i>.</p>
<h3>What does "wide character in subroutine entry" mean?
<a name='What does "wide character in subroutine entry" mean?'></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">You will usually
get this message if you are working with UTF−8 data
and want to read/write it from/to a Berkeley DB database
file.</p>
<p style="margin-left:9%; margin-top: 1em">The easist way
to deal with this issue is to use the pre−defined
"utf8" <b>DBM_Filter</b> (see DBM_Filter) that was
designed to deal with this situation.</p>
<p style="margin-left:9%; margin-top: 1em">The example
below shows what you need if <i>both</i> the key and value
are expected to be in UTF−8.</p>
<p style="margin-left:9%; margin-top: 1em">use DB_File;
<br/>
use DBM_Filter; <br/>
my $db = tie %h, 'DB_File', '/tmp/try.db', O_CREAT|O_RDWR,
0666, $DB_BTREE; <br/>
$db−&gt;Filter_Key_Push('utf8'); <br/>
$db−&gt;Filter_Value_Push('utf8'); <br/>
my $key = "\N{LATIN SMALL LETTER A WITH ACUTE}";
<br/>
my $value = "\N{LATIN SMALL LETTER E WITH ACUTE}";
<br/>
$h{ $key } = $value;</p>
<h3>What does "Invalid Argument" mean?
<a name='What does "Invalid Argument" mean?'></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">You will get
this error message when one of the parameters in the
"tie" call is wrong. Unfortunately there are quite
a few parameters to get wrong, so it can be difficult to
figure out which one it is.</p>
<p style="margin-left:9%; margin-top: 1em">Here are a
couple of possibilities:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="3%"></td>
<td width="66%">
<p>Attempting to reopen a database without closing it.</p></td>
<td width="19%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="3%"></td>
<td width="66%">
<p>Using the O_WRONLY flag.</p></td>
<td width="19%">
</td></tr>
</table>
<h3>What does "Bareword 'DB_File' not allowed" mean?
<a name="What does &quot;Bareword 'DB_File' not allowed&quot; mean?"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">You will
encounter this particular error message when you have the
"strict 'subs'" pragma (or the full strict pragma)
in your script. Consider this script:</p>
<p style="margin-left:9%; margin-top: 1em">use warnings ;
<br/>
use strict ; <br/>
use DB_File ; <br/>
my %x ; <br/>
tie %x, DB_File, "filename" ;</p>
<p style="margin-left:9%; margin-top: 1em">Running it
produces the error in question:</p>
<p style="margin-left:9%; margin-top: 1em">Bareword
"DB_File" not allowed while "strict
subs" in use</p>
<p style="margin-left:9%; margin-top: 1em">To get around
the error, place the word "DB_File" in either
single or double quotes, like this:</p>
<p style="margin-left:9%; margin-top: 1em">tie %x,
"DB_File", "filename" ;</p>
<p style="margin-left:9%; margin-top: 1em">Although it
might seem like a real pain, it is really worth the effort
of having a "use strict" in all your scripts.</p>
<h2>REFERENCES
<a name="REFERENCES"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Articles that
are either about <b>DB_File</b> or make use of it.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="85%">
<p style="margin-top: 1em"><i>Full−Text Searching in
Perl</i>, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb's
Journal, Issue 295, January 1999, pp 34−41</p></td></tr>
</table>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Moved to the
Changes file.</p>
<h2>BUGS
<a name="BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Some older
versions of Berkeley DB had problems with fixed length
records using the RECNO file format. This problem has been
fixed since version 1.85 of Berkeley DB.</p>
<p style="margin-left:9%; margin-top: 1em">I am sure there
are bugs in the code. If you do find any, or can suggest any
enhancements, I would welcome your comments.</p>
<h2>SUPPORT
<a name="SUPPORT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">General
feedback/questions/bug reports should be sent to
&lt;https://github.com/pmqs/DB_File/issues&gt; (preferred)
or
&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=DB_File&gt;.</p>
<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em"><b>DB_File</b>
comes with the standard Perl source distribution. Look in
the directory <i>ext/DB_File</i>. Given the amount of time
between releases of Perl the version that ships with Perl is
quite likely to be out of date, so the most recent version
can always be found on CPAN (see "CPAN" in
perlmodlib for details), in the directory
<i>modules/by−module/DB_File</i>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>DB_File</b>
is designed to work with any version of Berkeley DB, but is
limited to the functionality provided by version 1. If you
want to make use of the new features available in Berkeley
DB 2.x, or greater, use the Perl module BerkeleyDB
&lt;https://metacpan.org/pod/BerkeleyDB&gt; instead.</p>
<p style="margin-left:9%; margin-top: 1em">The official web
site for Berkeley DB is
&lt;http://www.oracle.com/technology/products/berkeley−db/db/index.html&gt;.
All versions of Berkeley DB are available there.</p>
<p style="margin-left:9%; margin-top: 1em">Alternatively,
Berkeley DB version 1 is available at your nearest CPAN
archive in <i>src/misc/db.1.85.tar.gz</i>.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright (c)
1995−2023 Paul Marquess. All rights reserved. This
program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.</p>
<p style="margin-left:9%; margin-top: 1em">Although
<b>DB_File</b> is covered by the Perl license, the library
it makes use of, namely Berkeley DB, is not. Berkeley DB has
its own copyright and its own license. See AGPL
&lt;https://www.oracle.com/downloads/licenses/berkeleydb-oslicense.html&gt;
for more details. Please take the time to read the Berkeley
DB license and decide how it impacts your use of this Perl
module.</p>
<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">perl,
<b>dbopen</b>(3), <b>hash</b>(3), <b>recno</b>(3),
<b>btree</b>(3), perldbmfilter, DBM_Filter</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The DB_File
interface was written by Paul Marquess
&lt;pmqs@cpan.org&gt;.</p>
<hr/>
</body>
</html>
