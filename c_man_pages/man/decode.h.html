<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:43:13 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>decode.h</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">decode.h</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Macros">Macros</a><br/>
<a href="#Typedefs">Typedefs</a><br/>
<a href="#Enumerations">Enumerations</a><br/>
<a href="#Functions">Functions</a><br/>
<a href="#Detailed Description">Detailed Description</a><br/>
<a href="#Macro Definition Documentation">Macro Definition Documentation</a><br/>
<a href="##define BROTLI_DECODER_ERROR_CODES_LIST(BROTLI_ERROR_CODE, SEPARATOR)">#define BROTLI_DECODER_ERROR_CODES_LIST(BROTLI_ERROR_CODE, SEPARATOR)</a><br/>
<a href="##define BROTLI_LAST_ERROR_CODE BROTLI_DECODER_ERROR_UNREACHABLE">#define BROTLI_LAST_ERROR_CODE BROTLI_DECODER_ERROR_UNREACHABLE</a><br/>
<a href="#Typedef Documentation">Typedef Documentation</a><br/>
<a href="#typedef void(* brotli_decoder_metadata_chunk_func) (void *opaque, constuint8_t *data, size_t size)">typedef void(* brotli_decoder_metadata_chunk_func) (void *opaque, constuint8_t *data, size_t size)</a><br/>
<a href="#typedef void(* brotli_decoder_metadata_start_func) (void *opaque, size_tsize)">typedef void(* brotli_decoder_metadata_start_func) (void *opaque, size_tsize)</a><br/>
<a href="#typedef enum BrotliDecoderParameter BrotliDecoderParameter">typedef enum BrotliDecoderParameter BrotliDecoderParameter</a><br/>
<a href="#typedef struct BrotliDecoderStateStruct BrotliDecoderState">typedef struct BrotliDecoderStateStruct BrotliDecoderState</a><br/>
<a href="#Enumeration Type Documentation">Enumeration Type Documentation</a><br/>
<a href="#enum BrotliDecoderErrorCode">enum BrotliDecoderErrorCode</a><br/>
<a href="#enum BrotliDecoderParameter">enum BrotliDecoderParameter</a><br/>
<a href="#enum BrotliDecoderResult">enum BrotliDecoderResult</a><br/>
<a href="#Function Documentation">Function Documentation</a><br/>
<a href="#BROTLI_BOOL BrotliDecoderAttachDictionary (BrotliDecoderState * state,BrotliSharedDictionaryType type, size_t data_size, const uint8_tdata[data_size])">BROTLI_BOOL BrotliDecoderAttachDictionary (BrotliDecoderState * state,BrotliSharedDictionaryType type, size_t data_size, const uint8_tdata[data_size])</a><br/>
<a href="#BrotliDecoderState* BrotliDecoderCreateInstance (brotli_alloc_funcalloc_func, brotli_free_func free_func, void * opaque)">BrotliDecoderState* BrotliDecoderCreateInstance (brotli_alloc_funcalloc_func, brotli_free_func free_func, void * opaque)</a><br/>
<a href="#BrotliDecoderResult BrotliDecoderDecompress (size_t encoded_size, constuint8_t encoded_buffer[encoded_size], size_t * decoded_size, uint8_tdecoded_buffer[*decoded_size])">BrotliDecoderResult BrotliDecoderDecompress (size_t encoded_size, constuint8_t encoded_buffer[encoded_size], size_t * decoded_size, uint8_tdecoded_buffer[*decoded_size])</a><br/>
<a href="#BrotliDecoderResult BrotliDecoderDecompressStream (BrotliDecoderState *state, size_t * available_in, const uint8_t ** next_in, size_t *available_out, uint8_t ** next_out, size_t * total_out)">BrotliDecoderResult BrotliDecoderDecompressStream (BrotliDecoderState *state, size_t * available_in, const uint8_t ** next_in, size_t *available_out, uint8_t ** next_out, size_t * total_out)</a><br/>
<a href="#void BrotliDecoderDestroyInstance (BrotliDecoderState * state)">void BrotliDecoderDestroyInstance (BrotliDecoderState * state)</a><br/>
<a href="#BrotliDecoderErrorCode BrotliDecoderGetErrorCode (const BrotliDecoderState* state)">BrotliDecoderErrorCode BrotliDecoderGetErrorCode (const BrotliDecoderState* state)</a><br/>
<a href="#BROTLI_BOOL BrotliDecoderHasMoreOutput (const BrotliDecoderState * state)">BROTLI_BOOL BrotliDecoderHasMoreOutput (const BrotliDecoderState * state)</a><br/>
<a href="#BROTLI_BOOL BrotliDecoderIsFinished (const BrotliDecoderState * state)">BROTLI_BOOL BrotliDecoderIsFinished (const BrotliDecoderState * state)</a><br/>
<a href="#BROTLI_BOOL BrotliDecoderIsUsed (const BrotliDecoderState * state)">BROTLI_BOOL BrotliDecoderIsUsed (const BrotliDecoderState * state)</a><br/>
<a href="#void BrotliDecoderSetMetadataCallbacks (BrotliDecoderState * state,brotli_decoder_metadata_start_func start_func,brotli_decoder_metadata_chunk_func chunk_func, void * opaque)">void BrotliDecoderSetMetadataCallbacks (BrotliDecoderState * state,brotli_decoder_metadata_start_func start_func,brotli_decoder_metadata_chunk_func chunk_func, void * opaque)</a><br/>
<a href="#BROTLI_BOOL BrotliDecoderSetParameter (BrotliDecoderState * state,BrotliDecoderParameter param, uint32_t value)">BROTLI_BOOL BrotliDecoderSetParameter (BrotliDecoderState * state,BrotliDecoderParameter param, uint32_t value)</a><br/>
<a href="#const uint8_t* BrotliDecoderTakeOutput (BrotliDecoderState * state, size_t* size)">const uint8_t* BrotliDecoderTakeOutput (BrotliDecoderState * state, size_t* size)</a><br/>
<a href="#uint32_t BrotliDecoderVersion (void)">uint32_t BrotliDecoderVersion (void)</a><br/>
<a href="#Author">Author</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">decode.h −
API for Brotli decompression.</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<h3>Macros
<a name="Macros"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">#define
<b>BROTLI_DECODER_ERROR_CODES_LIST</b>(BROTLI_ERROR_CODE,
SEPARATOR) <i><br/>
Template that evaluates items of</i>
<b>BrotliDecoderErrorCode</b><i>.</i> <br/>
#define <b>BROTLI_LAST_ERROR_CODE</b>
BROTLI_DECODER_ERROR_UNREACHABLE <i><br/>
The value of the last error code, negative integer.</i></p>
<h3>Typedefs
<a name="Typedefs"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">typedef void(*
<b>brotli_decoder_metadata_chunk_func</b>) (void *opaque,
const uint8_t *data, size_t size) <i><br/>
Callback to fire on metadata block chunk becomes
available.</i> <br/>
typedef void(* <b>brotli_decoder_metadata_start_func</b>)
(void *opaque, size_t size) <i><br/>
Callback to fire on metadata block start.</i> <br/>
typedef enum <b>BrotliDecoderParameter
BrotliDecoderParameter</b> <i><br/>
Options to be used with</i>
<b>BrotliDecoderSetParameter</b><i>.</i> <br/>
typedef struct BrotliDecoderStateStruct
<b>BrotliDecoderState</b> <i><br/>
Opaque structure that holds decoder state.</i></p>
<h3>Enumerations
<a name="Enumerations"></a>
</h3>
<h3>Functions
<a name="Functions"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em"><i><b>BROTLI_BOOL
BrotliDecoderAttachDictionary</b></i>
(<b>BrotliDecoderState</b> *state,
BrotliSharedDictionaryType type, size_t data_size, const
uint8_t data[data_size]) <i><br/>
Adds LZ77 prefix dictionary, adds or replaces built-in
static dictionary and transforms.</i> <b><br/>
BrotliDecoderState</b> * <b>BrotliDecoderCreateInstance</b>
(<b>brotli_alloc_func</b> alloc_func,
<b>brotli_free_func</b> free_func, void *opaque) <i><br/>
Creates an instance of</i> <b>BrotliDecoderState</b> <i>and
initializes it.</i> <b><br/>
BrotliDecoderResult BrotliDecoderDecompress</b> (size_t
encoded_size, const uint8_t encoded_buffer[encoded_size],
size_t *decoded_size, uint8_t decoded_buffer[*decoded_size])
<i><br/>
Performs one-shot memory-to-memory decompression.</i>
<b><br/>
BrotliDecoderResult BrotliDecoderDecompressStream</b>
(<b>BrotliDecoderState</b> *state, size_t *available_in,
const uint8_t **next_in, size_t *available_out, uint8_t
**next_out, size_t *total_out) <i><br/>
Decompresses the input stream to the output stream.</i> <br/>
void <b>BrotliDecoderDestroyInstance</b>
(<b>BrotliDecoderState</b> *state) <i><br/>
Deinitializes and frees</i> <b>BrotliDecoderState</b>
<i>instance.</i> <br/>
const char * <b>BrotliDecoderErrorString</b>
(<b>BrotliDecoderErrorCode</b> c) <i><br/>
Converts error code to a c-string.</i> <b><br/>
BrotliDecoderErrorCode BrotliDecoderGetErrorCode</b> (const
<b>BrotliDecoderState</b> *state) <i><br/>
Acquires a detailed error code.</i> <b><br/>
BROTLI_BOOL BrotliDecoderHasMoreOutput</b> (const
<b>BrotliDecoderState</b> *state) <i><br/>
Checks if decoder has more output.</i> <b><br/>
BROTLI_BOOL BrotliDecoderIsFinished</b> (const
<b>BrotliDecoderState</b> *state) <i><br/>
Checks if decoder instance reached the final state.</i>
<b><br/>
BROTLI_BOOL BrotliDecoderIsUsed</b> (const
<b>BrotliDecoderState</b> *state) <i><br/>
Checks if instance has already consumed input.</i> <br/>
void <b>BrotliDecoderSetMetadataCallbacks</b>
(<b>BrotliDecoderState</b> *state,
<b>brotli_decoder_metadata_start_func</b> start_func,
<b>brotli_decoder_metadata_chunk_func</b> chunk_func, void
*opaque) <i><br/>
Sets callback for receiving metadata blocks.</i> <b><br/>
BROTLI_BOOL BrotliDecoderSetParameter</b>
(<b>BrotliDecoderState</b> *state,
<b>BrotliDecoderParameter</b> param, uint32_t value) <i><br/>
Sets the specified parameter to the given decoder
instance.</i> <br/>
const uint8_t * <b>BrotliDecoderTakeOutput</b>
(<b>BrotliDecoderState</b> *state, size_t *size) <i><br/>
Acquires pointer to internal output buffer.</i> <br/>
uint32_t <b>BrotliDecoderVersion</b> (void) <i><br/>
Gets a decoder library version.</i></p>
<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">API for Brotli
decompression.</p>
<h2>Macro Definition Documentation
<a name="Macro Definition Documentation"></a>
</h2>
<h3>#define BROTLI_DECODER_ERROR_CODES_LIST(BROTLI_ERROR_CODE, SEPARATOR)
<a name="#define BROTLI_DECODER_ERROR_CODES_LIST(BROTLI_ERROR_CODE, SEPARATOR)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Template that
evaluates items of <b>BrotliDecoderErrorCode</b>.
Example:</p>
<p style="margin-left:9%; margin-top: 1em">// Log Brotli
error code. <br/>
switch (brotliDecoderErrorCode) { <br/>
#define CASE_(PREFIX, NAME, CODE) case BROTLI_DECODER ##
PREFIX ## NAME: LOG(INFO) &lt;&lt; "error code:"
&lt;&lt; #NAME; break; <br/>
#define NEWLINE_ <br/>
BROTLI_DECODER_ERROR_CODES_LIST(CASE_, NEWLINE_) <br/>
#undef CASE_ <br/>
#undef NEWLINE_ <br/>
default: LOG(FATAL) &lt;&lt; "unknown brotli error
code"; <br/>
}</p>
<h3>#define BROTLI_LAST_ERROR_CODE BROTLI_DECODER_ERROR_UNREACHABLE
<a name="#define BROTLI_LAST_ERROR_CODE BROTLI_DECODER_ERROR_UNREACHABLE"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">The value of the
last error code, negative integer. All other error code
values are in the range from <b>BROTLI_LAST_ERROR_CODE</b>
to <tt>-1</tt>. There are also 4 other possible non-error
codes <tt>0</tt> .. <tt>3</tt> in
<b>BrotliDecoderErrorCode</b> enumeration.</p>
<h2>Typedef Documentation
<a name="Typedef Documentation"></a>
</h2>
<h3>typedef void(* brotli_decoder_metadata_chunk_func) (void *opaque, constuint8_t *data, size_t size)
<a name="typedef void(* brotli_decoder_metadata_chunk_func) (void *opaque, constuint8_t *data, size_t size)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Callback to fire
on metadata block chunk becomes available. This function can
be invoked multiple times per metadata block; block should
be considered finished when sum of <tt>size</tt> matches the
announced metadata block size. Chunks contents pointed by
<tt>data</tt> are transient and shouln not be accessed after
leaving the callback.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>opaque</i> callback handle
<i><br/>
data</i> pointer to metadata contents <i><br/>
size</i> size of metadata block chunk, at least
<tt>1</tt></p>
<h3>typedef void(* brotli_decoder_metadata_start_func) (void *opaque, size_tsize)
<a name="typedef void(* brotli_decoder_metadata_start_func) (void *opaque, size_tsize)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Callback to fire
on metadata block start. After this callback is fired, if
<tt>size</tt> is not <tt>0</tt>, it is followed by
<b>brotli_decoder_metadata_chunk_func</b> as more metadata
block contents become accessible.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>opaque</i> callback handle
<i><br/>
size</i> size of metadata block</p>
<h3>typedef enum BrotliDecoderParameter BrotliDecoderParameter
<a name="typedef enum BrotliDecoderParameter BrotliDecoderParameter"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Options to be
used with <b>BrotliDecoderSetParameter</b>.</p>
<h3>typedef struct BrotliDecoderStateStruct BrotliDecoderState
<a name="typedef struct BrotliDecoderStateStruct BrotliDecoderState"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Opaque structure
that holds decoder state. Allocated and initialized with
<b>BrotliDecoderCreateInstance</b>. Cleaned up and
deallocated with <b>BrotliDecoderDestroyInstance</b>.</p>
<h2>Enumeration Type Documentation
<a name="Enumeration Type Documentation"></a>
</h2>
<h3>enum BrotliDecoderErrorCode
<a name="enum BrotliDecoderErrorCode"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Error code for
detailed logging / production debugging. See
<b>BrotliDecoderGetErrorCode</b> and
<b>BROTLI_LAST_ERROR_CODE</b>.</p>
<h3>enum BrotliDecoderParameter
<a name="enum BrotliDecoderParameter"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Options to be
used with <b>BrotliDecoderSetParameter</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Enumerator</b>
<i><br/>

BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION</i></p>
<p style="margin-left:18%;">Disable ’canny’
ring buffer allocation strategy. Ring buffer is allocated
according to window size, despite the real size of the
content.</p>
<p style="margin-left:9%;"><i>BROTLI_DECODER_PARAM_LARGE_WINDOW</i></p>
<p style="margin-left:18%;">Flag that determines if
’Large Window Brotli’ is used.</p>
<h3>enum BrotliDecoderResult
<a name="enum BrotliDecoderResult"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Result type for
<b>BrotliDecoderDecompress</b> and
<b>BrotliDecoderDecompressStream</b> functions.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Enumerator</b>
<i><br/>
BROTLI_DECODER_RESULT_ERROR</i></p>
<p style="margin-left:18%;">Decoding error, e.g. corrupted
input or memory allocation problem.</p>
<p style="margin-left:9%;"><i>BROTLI_DECODER_RESULT_SUCCESS</i></p>
<p style="margin-left:18%;">Decoding successfully
completed.</p>
<p style="margin-left:9%;"><i>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</i></p>
<p style="margin-left:18%;">Partially done; should be
called again with more input.</p>
<p style="margin-left:9%;"><i>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</i></p>
<p style="margin-left:18%;">Partially done; should be
called again with more output.</p>
<h2>Function Documentation
<a name="Function Documentation"></a>
</h2>
<h3>BROTLI_BOOL BrotliDecoderAttachDictionary (BrotliDecoderState * state,BrotliSharedDictionaryType type, size_t data_size, const uint8_tdata[data_size])
<a name="BROTLI_BOOL BrotliDecoderAttachDictionary (BrotliDecoderState * state,BrotliSharedDictionaryType type, size_t data_size, const uint8_tdata[data_size])"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Adds LZ77 prefix
dictionary, adds or replaces built-in static dictionary and
transforms. Attached dictionary ownership is not
transferred. Data provided to this method should be kept
accessible until decoding is finished and decoder instance
is destroyed.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b></p>
<p style="margin-left:14%;">Dictionaries can NOT be
attached after actual decoding is started.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder instance
<i><br/>
type</i> dictionary data format <i><br/>
data_size</i> length of memory region pointed by
<tt>data</tt> <i><br/>
data</i> dictionary data in format corresponding to
<tt>type</tt></p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_FALSE</b> if
dictionary is corrupted, or dictionary count limit is
reached</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_TRUE</b>
if dictionary is accepted / attached</p>
<h3>BrotliDecoderState* BrotliDecoderCreateInstance (brotli_alloc_funcalloc_func, brotli_free_func free_func, void * opaque)
<a name="BrotliDecoderState* BrotliDecoderCreateInstance (brotli_alloc_funcalloc_func, brotli_free_func free_func, void * opaque)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Creates an
instance of <b>BrotliDecoderState</b> and initializes it.
The instance can be used once for decoding and should then
be destroyed with <b>BrotliDecoderDestroyInstance</b>, it
cannot be reused for a new decoding session.</p>
<p style="margin-left:9%; margin-top: 1em"><tt>alloc_func</tt>
and <tt>free_func</tt> <b>MUST</b> be both zero or both
non-zero. In the case they are both zero, default memory
allocators are used. <tt>opaque</tt> is passed to
<tt>alloc_func</tt> and <tt>free_func</tt> when they are
called. <tt>free_func</tt> has to return without doing
anything when asked to free a NULL pointer.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>alloc_func</i> custom memory
allocation function <i><br/>
free_func</i> custom memory free function <i><br/>
opaque</i> custom memory manager handle</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><tt>0</tt> if instance can not
be allocated or initialized</p>
<p style="margin-left:14%; margin-top: 1em">pointer to
initialized <b>BrotliDecoderState</b> otherwise</p>
<h3>BrotliDecoderResult BrotliDecoderDecompress (size_t encoded_size, constuint8_t encoded_buffer[encoded_size], size_t * decoded_size, uint8_tdecoded_buffer[*decoded_size])
<a name="BrotliDecoderResult BrotliDecoderDecompress (size_t encoded_size, constuint8_t encoded_buffer[encoded_size], size_t * decoded_size, uint8_tdecoded_buffer[*decoded_size])"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Performs
one-shot memory-to-memory decompression. Decompresses the
data in <tt>encoded_buffer</tt> into
<tt>decoded_buffer</tt>, and sets <tt>*decoded_size</tt> to
the decompressed length.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>encoded_size</i> size of
<tt>encoded_buffer</tt> <i><br/>
encoded_buffer</i> compressed data buffer with at least
<tt>encoded_size</tt> addressable bytes <i><br/>
decoded_size</i> <b>in:</b> size of <tt>decoded_buffer</tt>;
<b><br/>
out:</b> length of decompressed data written to
<tt>decoded_buffer</tt> <i><br/>
decoded_buffer</i> decompressed data destination buffer</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_DECODER_RESULT_ERROR</b>
if input is corrupted, memory allocation failed, or
<tt>decoded_buffer</tt> is not large enough;</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_DECODER_RESULT_SUCCESS</b>
otherwise</p>
<h3>BrotliDecoderResult BrotliDecoderDecompressStream (BrotliDecoderState *state, size_t * available_in, const uint8_t ** next_in, size_t *available_out, uint8_t ** next_out, size_t * total_out)
<a name="BrotliDecoderResult BrotliDecoderDecompressStream (BrotliDecoderState *state, size_t * available_in, const uint8_t ** next_in, size_t *available_out, uint8_t ** next_out, size_t * total_out)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Decompresses the
input stream to the output stream. The values
<tt>*available_in</tt> and <tt>*available_out</tt> must
specify the number of bytes addressable at <tt>*next_in</tt>
and <tt>*next_out</tt> respectively. When
<tt>*available_out</tt> is <tt>0</tt>, <tt>next_out</tt> is
allowed to be <tt>NULL</tt>.</p>
<p style="margin-left:9%; margin-top: 1em">After each call,
<tt>*available_in</tt> will be decremented by the amount of
input bytes consumed, and the <tt>*next_in</tt> pointer will
be incremented by that amount. Similarly,
<tt>*available_out</tt> will be decremented by the amount of
output bytes written, and the <tt>*next_out</tt> pointer
will be incremented by that amount.</p>
<p style="margin-left:9%; margin-top: 1em"><tt>total_out</tt>,
if it is not a null-pointer, will be set to the number of
bytes decompressed since the last <tt>state</tt>
initialization.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b></p>
<p style="margin-left:14%;">Input is never overconsumed, so
<tt>next_in</tt> and <tt>available_in</tt> could be passed
to the next consumer after decoding is complete.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder instance
<i><br/>
available_in</i> <b>in:</b> amount of available input;
<b><br/>
out:</b> amount of unused input <i><br/>
next_in</i> pointer to the next compressed byte <i><br/>
available_out</i> <b>in:</b> length of output buffer;
<b><br/>
out:</b> remaining size of output buffer <i><br/>
next_out</i> output buffer cursor; can be <tt>NULL</tt> if
<tt>available_out</tt> is <tt>0</tt> <i><br/>
total_out</i> number of bytes decompressed so far; can be
<tt>NULL</tt></p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_DECODER_RESULT_ERROR</b>
if input is corrupted, memory allocation failed, arguments
were invalid, etc.; use <b>BrotliDecoderGetErrorCode</b> to
get detailed error code</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</b>
decoding is blocked until more input data is provided</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</b>
decoding is blocked until more output space is provided</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_DECODER_RESULT_SUCCESS</b>
decoding is finished, no more input might be consumed and no
more output will be produced</p>
<h3>void BrotliDecoderDestroyInstance (BrotliDecoderState * state)
<a name="void BrotliDecoderDestroyInstance (BrotliDecoderState * state)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Deinitializes
and frees <b>BrotliDecoderState</b> instance.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder instance
to be cleaned up and deallocated</p>
<h3>BrotliDecoderErrorCode BrotliDecoderGetErrorCode (const BrotliDecoderState* state)
<a name="BrotliDecoderErrorCode BrotliDecoderGetErrorCode (const BrotliDecoderState* state)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Acquires a
detailed error code. Should be used only after
<b>BrotliDecoderDecompressStream</b> returns
<b>BROTLI_DECODER_RESULT_ERROR</b>.</p>
<p style="margin-left:9%; margin-top: 1em">See also
<b>BrotliDecoderErrorString</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder
instance</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;">last saved error code</p>
<h3>BROTLI_BOOL BrotliDecoderHasMoreOutput (const BrotliDecoderState * state)
<a name="BROTLI_BOOL BrotliDecoderHasMoreOutput (const BrotliDecoderState * state)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Checks if
decoder has more output.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder
instance</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_TRUE</b>, if decoder
has some unconsumed output</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_FALSE</b>
otherwise</p>
<h3>BROTLI_BOOL BrotliDecoderIsFinished (const BrotliDecoderState * state)
<a name="BROTLI_BOOL BrotliDecoderIsFinished (const BrotliDecoderState * state)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Checks if
decoder instance reached the final state.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder
instance</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_TRUE</b> if decoder
is in a state where it reached the end of the input and
produced all of the output</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_FALSE</b>
otherwise</p>
<h3>BROTLI_BOOL BrotliDecoderIsUsed (const BrotliDecoderState * state)
<a name="BROTLI_BOOL BrotliDecoderIsUsed (const BrotliDecoderState * state)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Checks if
instance has already consumed input. Instance that returns
<b>BROTLI_FALSE</b> is considered ’fresh’ and
could be reused.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder
instance</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_TRUE</b> if decoder
has already used some input bytes</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_FALSE</b>
otherwise</p>
<h3>void BrotliDecoderSetMetadataCallbacks (BrotliDecoderState * state,brotli_decoder_metadata_start_func start_func,brotli_decoder_metadata_chunk_func chunk_func, void * opaque)
<a name="void BrotliDecoderSetMetadataCallbacks (BrotliDecoderState * state,brotli_decoder_metadata_start_func start_func,brotli_decoder_metadata_chunk_func chunk_func, void * opaque)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Sets callback
for receiving metadata blocks.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder instance
<i><br/>
start_func</i> callback on metadata block start <i><br/>
chunk_func</i> callback on metadata block chunk <i><br/>
opaque</i> callback handle</p>
<h3>BROTLI_BOOL BrotliDecoderSetParameter (BrotliDecoderState * state,BrotliDecoderParameter param, uint32_t value)
<a name="BROTLI_BOOL BrotliDecoderSetParameter (BrotliDecoderState * state,BrotliDecoderParameter param, uint32_t value)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Sets the
specified parameter to the given decoder instance.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder instance
<i><br/>
param</i> parameter to set <i><br/>
value</i> new parameter value</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;"><b>BROTLI_FALSE</b> if
parameter is unrecognized, or value is invalid</p>
<p style="margin-left:14%; margin-top: 1em"><b>BROTLI_TRUE</b>
if value is accepted</p>
<h3>const uint8_t* BrotliDecoderTakeOutput (BrotliDecoderState * state, size_t* size)
<a name="const uint8_t* BrotliDecoderTakeOutput (BrotliDecoderState * state, size_t* size)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Acquires pointer
to internal output buffer. This method is used to make
language bindings easier and more efficient:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>1.</p></td>
<td width="2%"></td>
<td width="86%">
<p>push data to <b>BrotliDecoderDecompressStream</b>, until
<b>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</b> is
reported</p> </td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="86%">
<p>use <b>BrotliDecoderTakeOutput</b> to peek bytes and
copy to language-specific entity</p></td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Also this could
be useful if there is an output stream that is able to
consume all the provided data (e.g. when data is saved to
file system).</p>
<p style="margin-left:9%; margin-top: 1em"><b>Attention:</b></p>
<p style="margin-left:14%;">After every call to
<b>BrotliDecoderTakeOutput</b> <tt>*size</tt> bytes of
output are considered consumed for all consecutive calls to
the instance methods; returned pointer becomes invalidated
as well.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note:</b></p>
<p style="margin-left:14%;">Decoder output is not
guaranteed to be contiguous. This means that after the
size-unrestricted call to <b>BrotliDecoderTakeOutput</b>,
immediate next call to <b>BrotliDecoderTakeOutput</b> may
return more data.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters:</b></p>
<p style="margin-left:14%;"><i>state</i> decoder instance
<i><br/>
size</i> <b>in:</b> number of bytes caller is ready to take,
<tt>0</tt> if any amount could be handled; <b><br/>
out:</b> amount of data pointed by returned pointer and
considered consumed; <br/>
out value is never greater than in value, unless it is
<tt>0</tt></p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns:</b></p>
<p style="margin-left:14%;">pointer to output data</p>
<h3>uint32_t BrotliDecoderVersion (void)
<a name="uint32_t BrotliDecoderVersion (void)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Gets a decoder
library version. Look at BROTLI_MAKE_HEX_VERSION for more
information.</p>
<h2>Author
<a name="Author"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated
automatically by Doxygen for Brotli from the source
code.</p>
<hr/>
</body>
</html>
