<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:51:58 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>Text::Balanced</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">Text::Balanced</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#DESCRIPTION">DESCRIPTION</a><br/>
<a href="#General Behaviour in List Contexts">General Behaviour in List Contexts</a><br/>
<a href="#General Behaviour in Scalar and Void Contexts">General Behaviour in Scalar and Void Contexts</a><br/>
<a href="#A Note About Prefixes">A Note About Prefixes</a><br/>
<a href="#Functions">Functions</a><br/>
<a href="#DIAGNOSTICS">DIAGNOSTICS</a><br/>
<a href="#EXPORTS">EXPORTS</a><br/>
<a href="#KNOWN BUGS">KNOWN BUGS</a><br/>
<a href="#FEEDBACK">FEEDBACK</a><br/>
<a href="#AVAILABILITY">AVAILABILITY</a><br/>
<a href="#INSTALLATION">INSTALLATION</a><br/>
<a href="#AUTHOR">AUTHOR</a><br/>
<a href="#COPYRIGHT">COPYRIGHT</a><br/>
<a href="#LICENCE">LICENCE</a><br/>
<a href="#VERSION">VERSION</a><br/>
<a href="#DATE">DATE</a><br/>
<a href="#HISTORY">HISTORY</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Text::Balanced
− Extract delimited text sequences from strings.</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">use
Text::Balanced qw ( <br/>
extract_delimited <br/>
extract_bracketed <br/>
extract_quotelike <br/>
extract_codeblock <br/>
extract_variable <br/>
extract_tagged <br/>
extract_multiple <br/>
gen_delimited_pat <br/>
gen_extract_tagged <br/>
); <br/>
# Extract the initial substring of $text that is delimited
by <br/>
# two (unescaped) instances of the first character in
$delim. <br/>
($extracted, $remainder) = extract_delimited($text,$delim);
<br/>
# Extract the initial substring of $text that is bracketed
<br/>
# with a delimiter(s) specified by $delim (where the string
<br/>
# in $delim contains one or more of '(){}[]&lt;&gt;'). <br/>
($extracted, $remainder) = extract_bracketed($text,$delim);
<br/>
# Extract the initial substring of $text that is bounded by
<br/>
# an XML tag. <br/>
($extracted, $remainder) = extract_tagged($text); <br/>
# Extract the initial substring of $text that is bounded by
<br/>
# a C&lt;BEGIN&gt;...C&lt;END&gt; pair. Don't allow nested
C&lt;BEGIN&gt; tags <br/>
($extracted, $remainder) = <br/>

extract_tagged($text,"BEGIN","END",undef,{bad=&gt;["BEGIN"]});
<br/>
# Extract the initial substring of $text that represents a
<br/>
# Perl "quote or quote−like operation" <br/>
($extracted, $remainder) = extract_quotelike($text); <br/>
# Extract the initial substring of $text that represents a
block <br/>
# of Perl code, bracketed by any of character(s) specified
by $delim <br/>
# (where the string $delim contains one or more of
'(){}[]&lt;&gt;'). <br/>
($extracted, $remainder) = extract_codeblock($text,$delim);
<br/>
# Extract the initial substrings of $text that would be
extracted by <br/>
# one or more sequential applications of the specified
functions <br/>
# or regular expressions <br/>
@extracted = extract_multiple($text, <br/>
[ \&amp;extract_bracketed, <br/>
\&amp;extract_quotelike, <br/>
\&amp;some_other_extractor_sub, <br/>
qr/[xyz]*/, <br/>
'literal', <br/>
]); <br/>
# Create a string representing an optimized pattern (a la
Friedl) <br/>
# that matches a substring delimited by any of the specified
characters <br/>
# (in this case: any type of quote or a slash) <br/>
$patstring = gen_delimited_pat(q{'"`/}); <br/>
# Generate a reference to an anonymous sub that is just like
extract_tagged <br/>
# but pre−compiled and optimized for a specific pair
of tags, and <br/>
# consequently much faster (i.e. 3 times faster). It uses
qr// for better <br/>
# performance on repeated calls. <br/>
$extract_head =
gen_extract_tagged('&lt;HEAD&gt;','&lt;/HEAD&gt;'); <br/>
($extracted, $remainder) =
$extract_head−&gt;($text);</p>
<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The various
"extract_..." subroutines may be used to extract a
delimited substring, possibly after skipping a specified
prefix string. By default, that prefix is optional
whitespace ("/\s*/"), but you can change it to
whatever you wish (see below).</p>
<p style="margin-left:9%; margin-top: 1em">The substring to
be extracted must appear at the current "pos"
location of the string's variable (or at index zero, if no
"pos" position is defined). In other words, the
"extract_..." subroutines <i>don't</i> extract the
first occurrence of a substring anywhere in a string (like
an unanchored regex would). Rather, they extract an
occurrence of the substring appearing immediately at the
current matching position in the string (like a
"\G"−anchored regex would).</p>
<h3>General Behaviour in List Contexts
<a name="General Behaviour in List Contexts"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In a list
context, all the subroutines return a list, the first three
elements of which are always:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>[0]</p></td>
<td width="1%"></td>
<td width="83%">
<p>The extracted string, including the specified
delimiters. If the extraction fails "undef" is
returned.</p> </td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>[1]</p></td>
<td width="1%"></td>
<td width="83%">
<p>The remainder of the input string (i.e. the characters
after the extracted string). On failure, the entire string
is returned.</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="9%"></td>
<td width="4%">
<p>[2]</p></td>
<td width="1%"></td>
<td width="83%">
<p>The skipped prefix (i.e. the characters before the
extracted string). On failure, "undef" is
returned.</p> </td>
<td width="3%">
</td></tr>
</table>
<p style="margin-left:9%; margin-top: 1em">Note that in a
list context, the contents of the original input text (the
first argument) are not modified in any way.</p>
<p style="margin-left:9%; margin-top: 1em">However, if the
input text was passed in a variable, that variable's
"pos" value is updated to point at the first
character after the extracted text. That means that in a
list context the various subroutines can be used much like
regular expressions. For example:</p>
<p style="margin-left:9%; margin-top: 1em">while ( $next =
(extract_quotelike($text))[0] ) <br/>
{ <br/>
# process next quote−like (in $next) <br/>
}</p>
<h3>General Behaviour in Scalar and Void Contexts
<a name="General Behaviour in Scalar and Void Contexts"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">In a scalar
context, the extracted string is returned, having first been
removed from the input text. Thus, the following code also
processes each quote−like operation, but actually
removes them from $text:</p>
<p style="margin-left:9%; margin-top: 1em">while ( $next =
extract_quotelike($text) ) <br/>
{ <br/>
# process next quote−like (in $next) <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">Note that if the
input text is a read−only string (i.e. a literal), no
attempt is made to remove the extracted text.</p>
<p style="margin-left:9%; margin-top: 1em">In a void
context the behaviour of the extraction subroutines is
exactly the same as in a scalar context, except (of course)
that the extracted substring is not returned.</p>
<h3>A Note About Prefixes
<a name="A Note About Prefixes"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prefix patterns
are matched without any trailing modifiers
("/gimsox" etc.) This can bite you if you're
expecting a prefix specification like '.*?(?=&lt;H1&gt;)' to
skip everything up to the first &lt;H1&gt; tag. Such a
prefix pattern will only succeed if the &lt;H1&gt; tag is on
the current line, since . normally doesn't match
newlines.</p>
<p style="margin-left:9%; margin-top: 1em">To overcome this
limitation, you need to turn on /s matching within the
prefix pattern, using the "(?s)" directive:
'(?s).*?(?=&lt;H1&gt;)'</p>
<h3>Functions
<a name="Functions"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">"extract_delimited"</p>
<p style="margin-left:14%;">The
"extract_delimited" function formalizes the common
idiom of extracting a single−character−delimited
substring from the start of a string. For example, to
extract a single−quote delimited string, the following
code is typically used:</p>
<p style="margin-left:14%; margin-top: 1em">($remainder =
$text) =˜ s/\A('(\\.|[ˆ'])*')//s; <br/>
$extracted = $1;</p>
<p style="margin-left:14%; margin-top: 1em">but with
"extract_delimited" it can be simplified to:</p>
<p style="margin-left:14%; margin-top: 1em">($extracted,$remainder)
= extract_delimited($text, "'");</p>
<p style="margin-left:14%; margin-top: 1em">"extract_delimited"
takes up to four scalars (the input text, the delimiters, a
prefix pattern to be skipped, and any escape characters) and
extracts the initial substring of the text that is
appropriately delimited. If the delimiter string has
multiple characters, the first one encountered in the text
is taken to delimit the substring. The third argument
specifies a prefix pattern that is to be skipped (but must
be present!) before the substring is extracted. The final
argument specifies the escape character to be used for each
delimiter.</p>
<p style="margin-left:14%; margin-top: 1em">All arguments
are optional. If the escape characters are not specified,
every delimiter is escaped with a backslash ("\").
If the prefix is not specified, the pattern '\s*' −
optional whitespace − is used. If the delimiter set is
also not specified, the set "/["'`]/" is
used. If the text to be processed is not specified either,
$_ is used.</p>
<p style="margin-left:14%; margin-top: 1em">In list
context, "extract_delimited" returns a array of
three elements, the extracted substring (<i>including the
surrounding delimiters</i>), the remainder of the text, and
the skipped prefix (if any). If a suitable delimited
substring is not found, the first element of the array is
the empty string, the second is the complete original text,
and the prefix returned in the third element is an empty
string.</p>
<p style="margin-left:14%; margin-top: 1em">In a scalar
context, just the extracted substring is returned. In a void
context, the extracted substring (and any prefix) are simply
removed from the beginning of the first argument.</p>
<p style="margin-left:14%; margin-top: 1em">Examples:</p>
<p style="margin-left:14%; margin-top: 1em"># Remove a
single−quoted substring from the very beginning of
$text: <br/>
$substring = extract_delimited($text, "'", '');
<br/>
# Remove a single−quoted Pascalish substring (i.e. one
in which <br/>
# doubling the quote character escapes it) from the very
<br/>
# beginning of $text: <br/>
$substring = extract_delimited($text, "'", '',
"'"); <br/>
# Extract a single− or double− quoted substring
from the <br/>
# beginning of $text, optionally after some whitespace <br/>
# (note the list context to protect $text from
modification): <br/>
($substring) = extract_delimited $text, q{"'}; <br/>
# Delete the substring delimited by the first '/' in $text:
<br/>
$text = join '',
(extract_delimited($text,'/','[ˆ/]*')[2,1];</p>
<p style="margin-left:14%; margin-top: 1em">Note that this
last example is <i>not</i> the same as deleting the first
quote−like pattern. For instance, if $text contained
the string:</p>
<p style="margin-left:14%; margin-top: 1em">"if
('./cmd' =˜ m/$UNIXCMD/s) { $cmd = $1; }"</p>
<p style="margin-left:14%; margin-top: 1em">then after the
deletion it would contain:</p>
<p style="margin-left:14%; margin-top: 1em">"if
('.$UNIXCMD/s) { $cmd = $1; }"</p>
<p style="margin-left:14%; margin-top: 1em">not:</p>
<p style="margin-left:14%; margin-top: 1em">"if
('./cmd' =˜ ms) { $cmd = $1; }"</p>
<p style="margin-left:14%; margin-top: 1em">See
"extract_quotelike" for a (partial) solution to
this problem.</p>
<p style="margin-left:9%;">"extract_bracketed"</p>
<p style="margin-left:14%;">Like
"extract_delimited", the
"extract_bracketed" function takes up to three
optional scalar arguments: a string to extract from, a
delimiter specifier, and a prefix pattern. As before, a
missing prefix defaults to optional whitespace and a missing
text defaults to $_. However, a missing delimiter specifier
defaults to '{}()[]&lt;&gt;' (see below).</p>
<p style="margin-left:14%; margin-top: 1em">"extract_bracketed"
extracts a balanced−bracket−delimited substring
(using any one (or more) of the user−specified
delimiter brackets: '(..)', '{..}', '[..]', or
'&lt;..&gt;'). Optionally it will also respect quoted
unbalanced brackets (see below).</p>
<p style="margin-left:14%; margin-top: 1em">A
"delimiter bracket" is a bracket in list of
delimiters passed as "extract_bracketed"'s second
argument. Delimiter brackets are specified by giving either
the left or right (or both!) versions of the required
bracket(s). Note that the order in which two or more
delimiter brackets are specified is not significant.</p>
<p style="margin-left:14%; margin-top: 1em">A
"balanced−bracket−delimited substring"
is a substring bounded by matched brackets, such that any
other (left or right) delimiter bracket <i>within</i> the
substring is also matched by an opposite (right or left)
delimiter bracket <i>at the same level of nesting</i>. Any
type of bracket not in the delimiter list is treated as an
ordinary character.</p>
<p style="margin-left:14%; margin-top: 1em">In other words,
each type of bracket specified as a delimiter must be
balanced and correctly nested within the substring, and any
other kind of ("non−delimiter") bracket in
the substring is ignored.</p>
<p style="margin-left:14%; margin-top: 1em">For example,
given the string:</p>
<p style="margin-left:14%; margin-top: 1em">$text = "{
an '[irregularly :−(] {} parenthesized &gt;:−)'
string }";</p>
<p style="margin-left:14%; margin-top: 1em">then a call to
"extract_bracketed" in a list context:</p>
<p style="margin-left:14%; margin-top: 1em">@result =
extract_bracketed( $text, '{}' );</p>
<p style="margin-left:14%; margin-top: 1em">would
return:</p>
<p style="margin-left:14%; margin-top: 1em">( "{ an
'[irregularly :−(] {} parenthesized &gt;:−)'
string }" , "" , "" )</p>
<p style="margin-left:14%; margin-top: 1em">since both sets
of '{..}' brackets are properly nested and evenly balanced.
(In a scalar context just the first element of the array
would be returned. In a void context, $text would be
replaced by an empty string.)</p>
<p style="margin-left:14%; margin-top: 1em">Likewise the
call in:</p>
<p style="margin-left:14%; margin-top: 1em">@result =
extract_bracketed( $text, '{[' );</p>
<p style="margin-left:14%; margin-top: 1em">would return
the same result, since all sets of both types of specified
delimiter brackets are correctly nested and balanced.</p>
<p style="margin-left:14%; margin-top: 1em">However, the
call in:</p>
<p style="margin-left:14%; margin-top: 1em">@result =
extract_bracketed( $text, '{([&lt;' );</p>
<p style="margin-left:14%; margin-top: 1em">would fail,
returning:</p>
<p style="margin-left:14%; margin-top: 1em">( undef ,
"{ an '[irregularly :−(] {} parenthesized
&gt;:−)' string }" );</p>
<p style="margin-left:14%; margin-top: 1em">because the
embedded pairs of '(..)'s and '[..]'s are
"cross−nested" and the embedded '&gt;' is
unbalanced. (In a scalar context, this call would return an
empty string. In a void context, $text would be
unchanged.)</p>
<p style="margin-left:14%; margin-top: 1em">Note that the
embedded single−quotes in the string don't help in
this case, since they have not been specified as acceptable
delimiters and are therefore treated as non−delimiter
characters (and ignored).</p>
<p style="margin-left:14%; margin-top: 1em">However, if a
particular species of quote character is included in the
delimiter specification, then that type of quote will be
correctly handled. for example, if $text is:</p>
<p style="margin-left:14%; margin-top: 1em">$text = '&lt;A
HREF="&gt;&gt;&gt;&gt;"&gt;link&lt;/A&gt;';</p>
<p style="margin-left:14%; margin-top: 1em">then</p>
<p style="margin-left:14%; margin-top: 1em">@result =
extract_bracketed( $text, '&lt;"&gt;' );</p>
<p style="margin-left:14%; margin-top: 1em">returns:</p>
<p style="margin-left:14%; margin-top: 1em">( '&lt;A
HREF="&gt;&gt;&gt;&gt;"&gt;', 'link&lt;/A&gt;',
"" )</p>
<p style="margin-left:14%; margin-top: 1em">as expected.
Without the specification of """ as an
embedded quoter:</p>
<p style="margin-left:14%; margin-top: 1em">@result =
extract_bracketed( $text, '&lt;&gt;' );</p>
<p style="margin-left:14%; margin-top: 1em">the result
would be:</p>
<p style="margin-left:14%; margin-top: 1em">( '&lt;A
HREF="&gt;', '&gt;&gt;&gt;"&gt;link&lt;/A&gt;',
"" )</p>
<p style="margin-left:14%; margin-top: 1em">In addition to
the quote delimiters "'", """, and
"`", full Perl quote−like quoting (i.e.
q{string}, qq{string}, etc) can be specified by including
the letter 'q' as a delimiter. Hence:</p>
<p style="margin-left:14%; margin-top: 1em">@result =
extract_bracketed( $text, '&lt;q&gt;' );</p>
<p style="margin-left:14%; margin-top: 1em">would correctly
match something like this:</p>
<p style="margin-left:14%; margin-top: 1em">$text =
'&lt;leftop: conj /and/ conj&gt;';</p>
<p style="margin-left:14%; margin-top: 1em">See also:
"extract_quotelike" and
"extract_codeblock".</p>
<p style="margin-left:9%;">"extract_variable"</p>
<p style="margin-left:14%;">"extract_variable"
extracts any valid Perl variable or variable−involved
expression, including scalars, arrays, hashes, array
accesses, hash look−ups, method calls through objects,
subroutine calls through subroutine references, etc.</p>
<p style="margin-left:14%; margin-top: 1em">The subroutine
takes up to two optional arguments:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>1.</p></td>
<td width="2%"></td>
<td width="80%">
<p>A string to be processed ($_ if the string is omitted or
"undef")</p> </td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="80%">
<p>A string specifying a pattern to be matched as a prefix
(which is to be skipped). If omitted, optional whitespace is
skipped.</p> </td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">On success in a
list context, an array of 3 elements is returned. The
elements are:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p style="margin-top: 1em">[0]</p></td>
<td width="1%"></td>
<td width="62%">
<p style="margin-top: 1em">the extracted variable, or
variablish expression</p></td>
<td width="19%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[1]</p></td>
<td width="1%"></td>
<td width="62%">
<p>the remainder of the input text,</p></td>
<td width="19%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[2]</p></td>
<td width="1%"></td>
<td width="62%">
<p>the prefix substring (if any),</p></td>
<td width="19%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">On failure, all
of these values (except the remaining text) are
"undef".</p>
<p style="margin-left:14%; margin-top: 1em">In a scalar
context, "extract_variable" returns just the
complete substring that matched a variablish expression.
"undef" is returned on failure. In addition, the
original input text has the returned substring (and any
prefix) removed from it.</p>
<p style="margin-left:14%; margin-top: 1em">In a void
context, the input text just has the matched substring (and
any specified prefix) removed.</p>
<p style="margin-left:9%;">"extract_tagged"</p>
<p style="margin-left:14%;">"extract_tagged"
extracts and segments text between (balanced) specified
tags.</p>
<p style="margin-left:14%; margin-top: 1em">The subroutine
takes up to five optional arguments:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>1.</p></td>
<td width="2%"></td>
<td width="81%">
<p>A string to be processed ($_ if the string is omitted or
"undef")</p> </td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="81%">
<p>A string specifying a pattern (i.e. regex) to be matched
as the opening tag. If the pattern string is omitted (or
"undef") then a pattern that matches any standard
XML tag is used.</p></td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>3.</p></td>
<td width="2%"></td>
<td width="81%">
<p>A string specifying a pattern to be matched at the
closing tag. If the pattern string is omitted (or
"undef") then the closing tag is constructed by
inserting a "/" after any leading bracket
characters in the actual opening tag that was matched
(<i>not</i> the pattern that matched the tag). For example,
if the opening tag pattern is specified as '{{\w+}}' and
actually matched the opening tag "{{DATA}}", then
the constructed closing tag would be
"{{/DATA}}".</p> </td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>4.</p></td>
<td width="2%"></td>
<td width="81%">
<p>A string specifying a pattern to be matched as a prefix
(which is to be skipped). If omitted, optional whitespace is
skipped.</p> </td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>5.</p></td>
<td width="2%"></td>
<td width="81%">
<p>A hash reference containing various parsing options (see
below)</p> </td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">The various
options that can be specified are: <br/>
"reject =&gt; $listref"</p>
<p style="margin-left:19%;">The list reference contains one
or more strings specifying patterns that must <i>not</i>
appear within the tagged text.</p>
<p style="margin-left:19%; margin-top: 1em">For example, to
extract an HTML link (which should not contain nested links)
use:</p>
<p style="margin-left:19%; margin-top: 1em">extract_tagged($text,
'&lt;A&gt;', '&lt;/A&gt;', undef, {reject =&gt;
['&lt;A&gt;']} );</p>
<p style="margin-left:14%;">"ignore =&gt;
$listref"</p>
<p style="margin-left:19%;">The list reference contains one
or more strings specifying patterns that are <i>not</i> to
be treated as nested tags within the tagged text (even if
they would match the start tag pattern).</p>
<p style="margin-left:19%; margin-top: 1em">For example, to
extract an arbitrary XML tag, but ignore "empty"
elements:</p>
<p style="margin-left:19%; margin-top: 1em">extract_tagged($text,
undef, undef, undef, {ignore =&gt;
['&lt;[ˆ&gt;]*/&gt;']} );</p>
<p style="margin-left:19%; margin-top: 1em">(also see
"gen_delimited_pat" below).</p>
<p style="margin-left:14%;">"fail =&gt; $str"</p>
<p style="margin-left:19%;">The "fail" option
indicates the action to be taken if a matching end tag is
not encountered (i.e. before the end of the string or some
"reject" pattern matches). By default, a failure
to match a closing tag causes "extract_tagged" to
immediately fail.</p>
<p style="margin-left:19%; margin-top: 1em">However, if the
string value associated with &lt;reject&gt; is
"MAX", then "extract_tagged" returns the
complete text up to the point of failure. If the string is
"PARA", "extract_tagged" returns only
the first paragraph after the tag (up to the first line that
is either empty or contains only whitespace characters). If
the string is "", the default behaviour (i.e.
failure) is reinstated.</p>
<p style="margin-left:19%; margin-top: 1em">For example,
suppose the start tag "/para" introduces a
paragraph, which then continues until the next
"/endpara" tag or until another "/para"
tag is encountered:</p>
<p style="margin-left:19%; margin-top: 1em">$text =
"/para line 1\n\nline 3\n/para line 4"; <br/>
extract_tagged($text, '/para', '/endpara', undef, <br/>
{reject =&gt; '/para', fail =&gt; MAX ); <br/>
# EXTRACTED: "/para line 1\n\nline 3\n"</p>
<p style="margin-left:19%; margin-top: 1em">Suppose
instead, that if no matching "/endpara" tag is
found, the "/para" tag refers only to the
immediately following paragraph:</p>
<p style="margin-left:19%; margin-top: 1em">$text =
"/para line 1\n\nline 3\n/para line 4"; <br/>
extract_tagged($text, '/para', '/endpara', undef, <br/>
{reject =&gt; '/para', fail =&gt; MAX ); <br/>
# EXTRACTED: "/para line 1\n"</p>
<p style="margin-left:19%; margin-top: 1em">Note that the
specified "fail" behaviour applies to nested tags
as well.</p>
<p style="margin-left:14%; margin-top: 1em">On success in a
list context, an array of 6 elements is returned. The
elements are:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[0]</p></td>
<td width="1%"></td>
<td width="80%">
<p>the extracted tagged substring (including the outermost
tags),</p> </td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[1]</p></td>
<td width="1%"></td>
<td width="80%">
<p>the remainder of the input text,</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[2]</p></td>
<td width="1%"></td>
<td width="80%">
<p>the prefix substring (if any),</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[3]</p></td>
<td width="1%"></td>
<td width="80%">
<p>the opening tag</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[4]</p></td>
<td width="1%"></td>
<td width="80%">
<p>the text between the opening and closing tags</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[5]</p></td>
<td width="1%"></td>
<td width="80%">
<p>the closing tag (or "" if no closing tag was
found)</p> </td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">On failure, all
of these values (except the remaining text) are
"undef".</p>
<p style="margin-left:14%; margin-top: 1em">In a scalar
context, "extract_tagged" returns just the
complete substring that matched a tagged text (including the
start and end tags). "undef" is returned on
failure. In addition, the original input text has the
returned substring (and any prefix) removed from it.</p>
<p style="margin-left:14%; margin-top: 1em">In a void
context, the input text just has the matched substring (and
any specified prefix) removed.</p>
<p style="margin-left:9%;">"gen_extract_tagged"</p>
<p style="margin-left:14%;">"gen_extract_tagged"
generates a new anonymous subroutine which extracts text
between (balanced) specified tags. In other words, it
generates a function identical in function to
"extract_tagged".</p>
<p style="margin-left:14%; margin-top: 1em">The difference
between "extract_tagged" and the anonymous
subroutines generated by "gen_extract_tagged", is
that those generated subroutines:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="78%">
<p>do not have to reparse tag specification or parsing
options every time they are called (whereas
"extract_tagged" has to effectively rebuild its
tag parser on every call);</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="1%">
<p>•</p></td>
<td width="4%"></td>
<td width="78%">
<p>make use of the new qr// construct to pre−compile
the regexes they use (whereas "extract_tagged"
uses standard string variable interpolation to create
tag−matching patterns).</p></td>
<td width="3%">
</td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">The subroutine
takes up to four optional arguments (the same set as
"extract_tagged" except for the string to be
processed). It returns a reference to a subroutine which in
turn takes a single argument (the text to be extracted
from).</p>
<p style="margin-left:14%; margin-top: 1em">In other words,
the implementation of "extract_tagged" is exactly
equivalent to:</p>
<p style="margin-left:14%; margin-top: 1em">sub
extract_tagged <br/>
{ <br/>
my $text = shift; <br/>
$extractor = gen_extract_tagged(@_); <br/>
return $extractor−&gt;($text); <br/>
}</p>
<p style="margin-left:14%; margin-top: 1em">(although
"extract_tagged" is not currently implemented that
way).</p>
<p style="margin-left:14%; margin-top: 1em">Using
"gen_extract_tagged" to create extraction
functions for specific tags is a good idea if those
functions are going to be called more than once, since their
performance is typically twice as good as the more
general−purpose "extract_tagged".</p>
<p style="margin-left:9%;">"extract_quotelike"</p>
<p style="margin-left:14%;">"extract_quotelike"
attempts to recognize, extract, and segment any one of the
various Perl quotes and quotelike operators (see
<b>perlop</b>(3)) Nested backslashed delimiters, embedded
balanced bracket delimiters (for the quotelike operators),
and trailing modifiers are all caught. For example, in:</p>
<p style="margin-left:14%; margin-top: 1em">extract_quotelike
'q # an octothorpe: \# (not the end of the q!) #' <br/>
extract_quotelike ' "You said, \"Use
sed\"." ' <br/>
extract_quotelike ' s{([A−Z]{1,8}\.[A−Z]{3})}
/\L$1\E/; ' <br/>
extract_quotelike ' tr/\\\/\\\\/\\\//ds; '</p>
<p style="margin-left:14%; margin-top: 1em">the full Perl
quotelike operations are all extracted correctly.</p>
<p style="margin-left:14%; margin-top: 1em">Note too that,
when using the /x modifier on a regex, any comment
containing the current pattern delimiter will cause the
regex to be immediately terminated. In other words:</p>
<p style="margin-left:14%; margin-top: 1em">'m / <br/>
(?i) # CASE INSENSITIVE <br/>
[a−z_] # LEADING ALPHABETIC/UNDERSCORE <br/>
[a−z0−9]* # FOLLOWED BY ANY NUMBER OF
ALPHANUMERICS <br/>
/x'</p>
<p style="margin-left:14%; margin-top: 1em">will be
extracted as if it were:</p>
<p style="margin-left:14%; margin-top: 1em">'m / <br/>
(?i) # CASE INSENSITIVE <br/>
[a−z_] # LEADING ALPHABETIC/'</p>
<p style="margin-left:14%; margin-top: 1em">This behaviour
is identical to that of the actual compiler.</p>
<p style="margin-left:14%; margin-top: 1em">"extract_quotelike"
takes two arguments: the text to be processed and a prefix
to be matched at the very beginning of the text. If no
prefix is specified, optional whitespace is the default. If
no text is given, $_ is used.</p>
<p style="margin-left:14%; margin-top: 1em">In a list
context, an array of 11 elements is returned. The elements
are:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[0]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the extracted quotelike substring (including trailing
modifiers),</p> </td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[1]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the remainder of the input text,</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[2]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the prefix substring (if any),</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[3]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the name of the quotelike operator (if any),</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[4]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the left delimiter of the first block of the
operation,</p> </td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[5]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the text of the first block of the operation (that is,
the contents of a quote, the regex of a match or
substitution or the target list of a translation),</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[6]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the right delimiter of the first block of the
operation,</p> </td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[7]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the left delimiter of the second block of the operation
(that is, if it is a "s", "tr", or
"y"),</p> </td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[8]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the text of the second block of the operation (that is,
the replacement of a substitution or the translation list of
a translation),</p></td>
<td width="3%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[9]</p></td>
<td width="1%"></td>
<td width="78%">
<p>the right delimiter of the second block of the operation
(if any),</p></td>
<td width="3%">
</td></tr>
</table>
<p style="margin-left:14%;">[10]</p>
<p style="margin-left:19%;">the trailing modifiers on the
operation (if any).</p>
<p style="margin-left:14%; margin-top: 1em">For each of the
fields marked "(if any)" the default value on
success is an empty string. On failure, all of these values
(except the remaining text) are "undef".</p>
<p style="margin-left:14%; margin-top: 1em">In a scalar
context, "extract_quotelike" returns just the
complete substring that matched a quotelike operation (or
"undef" on failure). In a scalar or void context,
the input text has the same substring (and any specified
prefix) removed.</p>
<p style="margin-left:14%; margin-top: 1em">Examples:</p>
<p style="margin-left:14%; margin-top: 1em"># Remove the
first quotelike literal that appears in text <br/>
$quotelike = extract_quotelike($text,'.*?'); <br/>
# Replace one or more leading whitespace−separated
quotelike <br/>
# literals in $_ with "&lt;QLL&gt;" <br/>
do { $_ = join '&lt;QLL&gt;', (extract_quotelike)[2,1] }
until $@; <br/>
# Isolate the search pattern in a quotelike operation from
$text <br/>
($op,$pat) = (extract_quotelike $text)[3,5]; <br/>
if ($op =˜ /[ms]/) <br/>
{ <br/>
print "search pattern: $pat\n"; <br/>
} <br/>
else <br/>
{ <br/>
print "$op is not a pattern matching operation\n";
<br/>
}</p>
<p style="margin-left:9%;">"extract_quotelike"</p>
<p style="margin-left:14%;">"extract_quotelike"
can successfully extract "here documents" from an
input string, but with an important caveat in list
contexts.</p>
<p style="margin-left:14%; margin-top: 1em">Unlike other
types of quote−like literals, a here document is
rarely a contiguous substring. For example, a typical piece
of code using here document might look like this:</p>
<p style="margin-left:14%; margin-top: 1em">&lt;&lt;'EOMSG'
|| die; <br/>
This is the message. <br/>
EOMSG <br/>
exit;</p>
<p style="margin-left:14%; margin-top: 1em">Given this as
an input string in a scalar context,
"extract_quotelike" would correctly return the
string "&lt;&lt;'EOMSG'\nThis is the
message.\nEOMSG", leaving the string " ||
die;\nexit;" in the original variable. In other words,
the two separate pieces of the here document are
successfully extracted and concatenated.</p>
<p style="margin-left:14%; margin-top: 1em">In a list
context, "extract_quotelike" would return the
list</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[0]</p></td>
<td width="1%"></td>
<td width="80%">
<p>"&lt;&lt;'EOMSG'\nThis is the
message.\nEOMSG\n" (i.e. the full extracted here
document, including fore and aft delimiters),</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[1]</p></td>
<td width="1%"></td>
<td width="80%">
<p>" || die;\nexit;" (i.e. the remainder of the
input text, concatenated),</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[2]</p></td>
<td width="1%"></td>
<td width="80%">
<p>"" (i.e. the prefix substring −−
trivial in this case),</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[3]</p></td>
<td width="1%"></td>
<td width="80%">
<p>"&lt;&lt;" (i.e. the "name" of the
quotelike operator)</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[4]</p></td>
<td width="1%"></td>
<td width="80%">
<p>"'EOMSG'" (i.e. the left delimiter of the here
document, including any quotes),</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[5]</p></td>
<td width="1%"></td>
<td width="80%">
<p>"This is the message.\n" (i.e. the text of the
here document),</p></td>
<td width="1%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="4%">
<p>[6]</p></td>
<td width="1%"></td>
<td width="80%">
<p>"EOMSG" (i.e. the right delimiter of the here
document),</p> </td>
<td width="1%">
</td></tr>
</table>
<p style="margin-left:14%;">[7..10]</p>
<p style="margin-left:19%;">"" (a here document
has no second left delimiter, second text, second right
delimiter, or trailing modifiers).</p>
<p style="margin-left:14%; margin-top: 1em">However, the
matching position of the input variable would be set to
"exit;" (i.e. <i>after</i> the closing delimiter
of the here document), which would cause the earlier "
|| die;\nexit;" to be skipped in any sequence of code
fragment extractions.</p>
<p style="margin-left:14%; margin-top: 1em">To avoid this
problem, when it encounters a here document whilst
extracting from a modifiable string,
"extract_quotelike" silently rearranges the string
to an equivalent piece of Perl:</p>
<p style="margin-left:14%; margin-top: 1em">&lt;&lt;'EOMSG'
<br/>
This is the message. <br/>
EOMSG <br/>
|| die; <br/>
exit;</p>
<p style="margin-left:14%; margin-top: 1em">in which the
here document <i>is</i> contiguous. It still leaves the
matching position after the here document, but now the rest
of the line on which the here document starts is not
skipped.</p>
<p style="margin-left:14%; margin-top: 1em">To prevent
&lt;extract_quotelike&gt; from mucking about with the input
in this way (this is the only case where a
list−context "extract_quotelike" does so),
you can pass the input variable as an interpolated
literal:</p>
<p style="margin-left:14%; margin-top: 1em">$quotelike =
extract_quotelike("$var");</p>
<p style="margin-left:9%;">"extract_codeblock"</p>
<p style="margin-left:14%;">"extract_codeblock"
attempts to recognize and extract a balanced bracket
delimited substring that may contain unbalanced brackets
inside Perl quotes or quotelike operations. That is,
"extract_codeblock" is like a combination of
"extract_bracketed" and
"extract_quotelike".</p>
<p style="margin-left:14%; margin-top: 1em">"extract_codeblock"
takes the same initial three parameters as
"extract_bracketed": a text to process, a set of
delimiter brackets to look for, and a prefix to match first.
It also takes an optional fourth parameter, which allows the
outermost delimiter brackets to be specified separately (see
below), and a fifth parameter used only by
Parse::RecDescent.</p>
<p style="margin-left:14%; margin-top: 1em">Omitting the
first argument (input text) means process $_ instead.
Omitting the second argument (delimiter brackets) indicates
that only '{' is to be used. Omitting the third argument
(prefix argument) implies optional whitespace at the start.
Omitting the fourth argument (outermost delimiter brackets)
indicates that the value of the second argument is to be
used for the outermost delimiters.</p>
<p style="margin-left:14%; margin-top: 1em">Once the prefix
and the outermost opening delimiter bracket have been
recognized, code blocks are extracted by stepping through
the input text and trying the following alternatives in
sequence:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>1.</p></td>
<td width="2%"></td>
<td width="81%">
<p>Try and match a closing delimiter bracket. If the
bracket was the same species as the last opening bracket,
return the substring to that point. If the bracket was
mismatched, return an error.</p></td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="81%">
<p>Try to match a quote or quotelike operator. If found,
call "extract_quotelike" to eat it. If
"extract_quotelike" fails, return the error it
returned. Otherwise go back to step 1.</p></td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>3.</p></td>
<td width="2%"></td>
<td width="81%">
<p>Try to match an opening delimiter bracket. If found,
call "extract_codeblock" recursively to eat the
embedded block. If the recursive call fails, return an
error. Otherwise, go back to step 1.</p></td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>4.</p></td>
<td width="2%"></td>
<td width="81%">
<p>Unconditionally match a bareword or any other single
character, and then go back to step 1.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">Examples:</p>
<p style="margin-left:14%; margin-top: 1em"># Find a while
loop in the text <br/>
if ($text =˜ s/.*?while\s*\{/{/) <br/>
{ <br/>
$loop = "while " . extract_codeblock($text); <br/>
} <br/>
# Remove the first round−bracketed list (which may
include <br/>
# round− or curly−bracketed code blocks or
quotelike operators) <br/>
extract_codeblock $text, "(){}", '[ˆ(]*';</p>
<p style="margin-left:14%; margin-top: 1em">The ability to
specify a different outermost delimiter bracket is useful in
some circumstances. For example, in the Parse::RecDescent
module, parser actions which are to be performed only on a
successful parse are specified using a
"&lt;defer:...&gt;" directive. For example:</p>
<p style="margin-left:14%; margin-top: 1em">sentence:
subject verb object <br/>
&lt;defer: {$::theVerb = $item{verb}} &gt;</p>
<p style="margin-left:14%; margin-top: 1em">Parse::RecDescent
uses "extract_codeblock($text, '{}&lt;&gt;')" to
extract the code within the "&lt;defer:...&gt;"
directive, but there's a problem.</p>
<p style="margin-left:14%; margin-top: 1em">A deferred
action like this:</p>
<p style="margin-left:14%; margin-top: 1em">&lt;defer: {if
($count&gt;10) {$count−−}} &gt;</p>
<p style="margin-left:14%; margin-top: 1em">will be
incorrectly parsed as:</p>
<p style="margin-left:14%; margin-top: 1em">&lt;defer: {if
($count&gt;</p>
<p style="margin-left:14%; margin-top: 1em">because the
"less than" operator is interpreted as a closing
delimiter.</p>
<p style="margin-left:14%; margin-top: 1em">But, by
extracting the directive using
"extract_codeblock($text, '{}', undef, '&lt;&gt;')"
the '&gt;' character is only treated as a delimited at the
outermost level of the code block, so the directive is
parsed correctly.</p>
<p style="margin-left:9%;">"extract_multiple"</p>
<p style="margin-left:14%;">The
"extract_multiple" subroutine takes a string to be
processed and a list of extractors (subroutines or regular
expressions) to apply to that string.</p>
<p style="margin-left:14%; margin-top: 1em">In an array
context "extract_multiple" returns an array of
substrings of the original string, as extracted by the
specified extractors. In a scalar context,
"extract_multiple" returns the first substring
successfully extracted from the original string. In both
scalar and void contexts the original string has the first
successfully extracted substring removed from it. In all
contexts "extract_multiple" starts at the current
"pos" of the string, and sets that "pos"
appropriately after it matches.</p>
<p style="margin-left:14%; margin-top: 1em">Hence, the aim
of a call to "extract_multiple" in a list context
is to split the processed string into as many
non−overlapping fields as possible, by repeatedly
applying each of the specified extractors to the remainder
of the string. Thus "extract_multiple" is a
generalized form of Perl's "split" subroutine.</p>
<p style="margin-left:14%; margin-top: 1em">The subroutine
takes up to four optional arguments:</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>1.</p></td>
<td width="2%"></td>
<td width="77%">
<p>A string to be processed ($_ if the string is omitted or
"undef")</p> </td>
<td width="4%">
</td></tr>
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p>2.</p></td>
<td width="2%"></td>
<td width="77%">
<p>A reference to a list of subroutine references and/or
qr// objects and/or literal strings and/or hash references,
specifying the extractors to be used to split the string. If
this argument is omitted (or "undef") the
list:</p> </td>
<td width="4%">
</td></tr>
</table>
<p style="margin-left:19%; margin-top: 1em">[ <br/>
sub { extract_variable($_[0], '') }, <br/>
sub { extract_quotelike($_[0],'') }, <br/>
sub { extract_codeblock($_[0],'{}','') }, <br/>
]</p>
<p style="margin-left:19%; margin-top: 1em">is used.</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p style="margin-top: 1em">3.</p></td>
<td width="2%"></td>
<td width="81%">
<p style="margin-top: 1em">An number specifying the maximum
number of fields to return. If this argument is omitted (or
"undef"), split continues as long as possible.</p></td></tr>
</table>
<p style="margin-left:19%; margin-top: 1em">If the third
argument is <i>N</i>, then extraction continues until
<i>N</i> fields have been successfully extracted, or until
the string has been completely processed.</p>
<p style="margin-left:19%; margin-top: 1em">Note that in
scalar and void contexts the value of this argument is
automatically reset to 1 (under "−w", a
warning is issued if the argument has to be reset).</p>
<table border="0" cellpadding="0" cellspacing="0" frame="void" rules="none" width="100%">
<tr align="left" valign="top">
<td width="14%"></td>
<td width="3%">
<p style="margin-top: 1em">4.</p></td>
<td width="2%"></td>
<td width="81%">
<p style="margin-top: 1em">A value indicating whether
unmatched substrings (see below) within the text should be
skipped or returned as fields. If the value is true, such
substrings are skipped. Otherwise, they are returned.</p></td></tr>
</table>
<p style="margin-left:14%; margin-top: 1em">The extraction
process works by applying each extractor in sequence to the
text string.</p>
<p style="margin-left:14%; margin-top: 1em">If the
extractor is a subroutine it is called in a list context and
is expected to return a list of a single element, namely the
extracted text. It may optionally also return two further
arguments: a string representing the text left after
extraction (like $' for a pattern match), and a string
representing any prefix skipped before the extraction (like
$` in a pattern match). Note that this is designed to
facilitate the use of other Text::Balanced subroutines with
"extract_multiple". Note too that the value
returned by an extractor subroutine need not bear any
relationship to the corresponding substring of the original
text (see examples below).</p>
<p style="margin-left:14%; margin-top: 1em">If the
extractor is a precompiled regular expression or a string,
it is matched against the text in a scalar context with a
leading '\G' and the gc modifiers enabled. The extracted
value is either $1 if that variable is defined after the
match, or else the complete match (i.e. $&amp;).</p>
<p style="margin-left:14%; margin-top: 1em">If the
extractor is a hash reference, it must contain exactly one
element. The value of that element is one of the above
extractor types (subroutine reference, regular expression,
or string). The key of that element is the name of a class
into which the successful return value of the extractor will
be blessed.</p>
<p style="margin-left:14%; margin-top: 1em">If an extractor
returns a defined value, that value is immediately treated
as the next extracted field and pushed onto the list of
fields. If the extractor was specified in a hash reference,
the field is also blessed into the appropriate class,</p>
<p style="margin-left:14%; margin-top: 1em">If the
extractor fails to match (in the case of a regex extractor),
or returns an empty list or an undefined value (in the case
of a subroutine extractor), it is assumed to have failed to
extract. If none of the extractor subroutines succeeds, then
one character is extracted from the start of the text and
the extraction subroutines reapplied. Characters which are
thus removed are accumulated and eventually become the next
field (unless the fourth argument is true, in which case
they are discarded).</p>
<p style="margin-left:14%; margin-top: 1em">For example,
the following extracts substrings that are valid Perl
variables:</p>
<p style="margin-left:14%; margin-top: 1em">@fields =
extract_multiple($text, <br/>
[ sub { extract_variable($_[0]) } ], <br/>
undef, 1);</p>
<p style="margin-left:14%; margin-top: 1em">This example
separates a text into fields which are quote delimited,
curly bracketed, and anything else. The delimited and
bracketed parts are also blessed to identify them (the
"anything else" is unblessed):</p>
<p style="margin-left:14%; margin-top: 1em">@fields =
extract_multiple($text, <br/>
[ <br/>
{ Delim =&gt; sub { extract_delimited($_[0],q{'"}) } },
<br/>
{ Brack =&gt; sub { extract_bracketed($_[0],'{}') } }, <br/>
]);</p>
<p style="margin-left:14%; margin-top: 1em">This call
extracts the next single substring that is a valid Perl
quotelike operator (and removes it from $text):</p>
<p style="margin-left:14%; margin-top: 1em">$quotelike =
extract_multiple($text, <br/>
[ <br/>
sub { extract_quotelike($_[0]) }, <br/>
], undef, 1);</p>
<p style="margin-left:14%; margin-top: 1em">Finally, here
is yet another way to do comma−separated value
parsing:</p>
<p style="margin-left:14%; margin-top: 1em">$csv_text =
"a,'x b',c"; <br/>
@fields = extract_multiple($csv_text, <br/>
[ <br/>
sub { extract_delimited($_[0],q{'"}) }, <br/>
qr/([ˆ,]+)/, <br/>
], <br/>
undef,1); <br/>
# @fields is now ('a', "'x b'", 'c')</p>
<p style="margin-left:14%; margin-top: 1em">The list in the
second argument means: <i>"Try and extract a ' or
" delimited string, otherwise extract anything up to a
comma..."</i>. The undef third argument means:
<i>"...as many times as possible..."</i>, and the
true value in the fourth argument means
<i>"...discarding anything else that appears (i.e. the
commas)"</i>.</p>
<p style="margin-left:14%; margin-top: 1em">If you wanted
the commas preserved as separate fields (i.e. like split
does if your split pattern has capturing parentheses), you
would just make the last parameter undefined (or remove
it).</p>
<p style="margin-left:9%;">"gen_delimited_pat"</p>
<p style="margin-left:14%;">The
"gen_delimited_pat" subroutine takes a single
(string) argument and builds a Friedl−style optimized
regex that matches a string delimited by any one of the
characters in the single argument. For example:</p>
<p style="margin-left:14%; margin-top: 1em">gen_delimited_pat(q{'"})</p>
<p style="margin-left:14%; margin-top: 1em">returns the
regex:</p>
<p style="margin-left:14%; margin-top: 1em">(?:\"(?:\\\"|(?!\").)*\"|\'(?:\\\'|(?!\').)*\')</p>
<p style="margin-left:14%; margin-top: 1em">Note that the
specified delimiters are automatically quotemeta'd.</p>
<p style="margin-left:14%; margin-top: 1em">A typical use
of "gen_delimited_pat" would be to build special
purpose tags for "extract_tagged". For example, to
properly ignore "empty" XML elements (which might
contain quoted strings):</p>
<p style="margin-left:14%; margin-top: 1em">my $empty_tag =
'&lt;(' . gen_delimited_pat(q{'"}) . '|.)+/&gt;'; <br/>
extract_tagged($text, undef, undef, undef, {ignore =&gt;
[$empty_tag]} );</p>
<p style="margin-left:14%; margin-top: 1em">"gen_delimited_pat"
may also be called with an optional second argument, which
specifies the "escape" character(s) to be used for
each delimiter. For example to match a Pascal−style
string (where ' is the delimiter and '' is a literal '
within the string):</p>
<p style="margin-left:14%; margin-top: 1em">gen_delimited_pat(q{'},q{'});</p>
<p style="margin-left:14%; margin-top: 1em">Different
escape characters can be specified for different delimiters.
For example, to specify that '/' is the escape for single
quotes and '%' is the escape for double quotes:</p>
<p style="margin-left:14%; margin-top: 1em">gen_delimited_pat(q{'"},q{/%});</p>
<p style="margin-left:14%; margin-top: 1em">If more
delimiters than escape chars are specified, the last escape
char is used for the remaining delimiters. If no escape char
is specified for a given specified delimiter, '\' is
used.</p>
<p style="margin-left:9%;">"delimited_pat"</p>
<p style="margin-left:14%;">Note that
"gen_delimited_pat" was previously called
"delimited_pat". That name may still be used, but
is now deprecated.</p>
<h2>DIAGNOSTICS
<a name="DIAGNOSTICS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">In a list
context, all the functions return
"(undef,$original_text)" on failure. In a scalar
context, failure is indicated by returning "undef"
(in this case the input text is not modified in any
way).</p>
<p style="margin-left:9%; margin-top: 1em">In addition, on
failure in <i>any</i> context, the $@ variable is set.
Accessing "$@−&gt;{error}" returns one of
the error diagnostics listed below. Accessing
"$@−&gt;{pos}" returns the offset into the
original string at which the error was detected (although
not necessarily where it occurred!) Printing $@ directly
produces the error message, with the offset appended. On
success, the $@ variable is guaranteed to be
"undef".</p>
<p style="margin-left:9%; margin-top: 1em">The available
diagnostics are: <br/>
"Did not find a suitable bracket:
"%s""</p>
<p style="margin-left:14%;">The delimiter provided to
"extract_bracketed" was not one of
'()[]&lt;&gt;{}'.</p>
<p style="margin-left:9%;">"Did not find prefix:
/%s/"</p>
<p style="margin-left:14%;">A non−optional prefix was
specified but wasn't found at the start of the text.</p>
<p style="margin-left:9%;">"Did not find opening
bracket after prefix: "%s""</p>
<p style="margin-left:14%;">"extract_bracketed"
or "extract_codeblock" was expecting a particular
kind of bracket at the start of the text, and didn't find
it.</p>
<p style="margin-left:9%;">"No quotelike operator
found after prefix: "%s""</p>
<p style="margin-left:14%;">"extract_quotelike"
didn't find one of the quotelike operators "q",
"qq", "qw", "qx",
"s", "tr" or "y" at the start
of the substring it was extracting.</p>
<p style="margin-left:9%;">"Unmatched closing bracket:
"%c""</p>
<p style="margin-left:14%;">"extract_bracketed",
"extract_quotelike" or
"extract_codeblock" encountered a closing bracket
where none was expected.</p>
<p style="margin-left:9%;">"Unmatched opening
bracket(s): "%s""</p>
<p style="margin-left:14%;">"extract_bracketed",
"extract_quotelike" or
"extract_codeblock" ran out of characters in the
text before closing one or more levels of nested
brackets.</p>
<p style="margin-left:9%;">"Unmatched embedded quote
(%s)"</p>
<p style="margin-left:14%;">"extract_bracketed"
attempted to match an embedded quoted substring, but failed
to find a closing quote to match it.</p>
<p style="margin-left:9%;">"Did not find closing
delimiter to match '%s'"</p>
<p style="margin-left:14%;">"extract_quotelike"
was unable to find a closing delimiter to match the one that
opened the quote−like operation.</p>
<p style="margin-left:9%;">"Mismatched closing
bracket: expected "%c" but found
"%s""</p>
<p style="margin-left:14%;">"extract_bracketed",
"extract_quotelike" or
"extract_codeblock" found a valid bracket
delimiter, but it was the wrong species. This usually
indicates a nesting error, but may indicate incorrect
quoting or escaping.</p>
<p style="margin-left:9%;">"No block delimiter found
after quotelike "%s""</p>
<p style="margin-left:14%;">"extract_quotelike"
or "extract_codeblock" found one of the quotelike
operators "q", "qq", "qw",
"qx", "s", "tr" or
"y" without a suitable block after it.</p>
<p style="margin-left:9%;">"Did not find leading
dereferencer"</p>
<p style="margin-left:14%;">"extract_variable"
was expecting one of '$', '@', or '%' at the start of a
variable, but didn't find any of them.</p>
<p style="margin-left:9%;">"Bad identifier after
dereferencer"</p>
<p style="margin-left:14%;">"extract_variable"
found a '$', '@', or '%' indicating a variable, but that
character was not followed by a legal Perl identifier.</p>
<p style="margin-left:9%;">"Did not find expected
opening bracket at %s"</p>
<p style="margin-left:14%;">"extract_codeblock"
failed to find any of the outermost opening brackets that
were specified.</p>
<p style="margin-left:9%;">"Improperly nested
codeblock at %s"</p>
<p style="margin-left:14%;">A nested code block was found
that started with a delimiter that was specified as being
only to be used as an outermost bracket.</p>
<p style="margin-left:9%;">"Missing second block for
quotelike "%s""</p>
<p style="margin-left:14%;">"extract_codeblock"
or "extract_quotelike" found one of the quotelike
operators "s", "tr" or "y"
followed by only one block.</p>
<p style="margin-left:9%;">"No match found for opening
bracket"</p>
<p style="margin-left:14%;">"extract_codeblock"
failed to find a closing bracket to match the outermost
opening bracket.</p>
<p style="margin-left:9%;">"Did not find opening tag:
/%s/"</p>
<p style="margin-left:14%;">"extract_tagged" did
not find a suitable opening tag (after any specified prefix
was removed).</p>
<p style="margin-left:9%;">"Unable to construct
closing tag to match: /%s/"</p>
<p style="margin-left:14%;">"extract_tagged"
matched the specified opening tag and tried to modify the
matched text to produce a matching closing tag (because none
was specified). It failed to generate the closing tag,
almost certainly because the opening tag did not start with
a bracket of some kind.</p>
<p style="margin-left:9%;">"Found invalid nested tag:
%s"</p>
<p style="margin-left:14%;">"extract_tagged"
found a nested tag that appeared in the "reject"
list (and the failure mode was not "MAX" or
"PARA").</p>
<p style="margin-left:9%;">"Found unbalanced nested
tag: %s"</p>
<p style="margin-left:14%;">"extract_tagged"
found a nested opening tag that was not matched by a
corresponding nested closing tag (and the failure mode was
not "MAX" or "PARA").</p>
<p style="margin-left:9%;">"Did not find closing
tag"</p>
<p style="margin-left:14%;">"extract_tagged"
reached the end of the text without finding a closing tag to
match the original opening tag (and the failure mode was not
"MAX" or "PARA").</p>
<h2>EXPORTS
<a name="EXPORTS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The following
symbols are, or can be, exported by this module: <br/>
Default Exports</p>
<p style="margin-left:14%;"><i>None</i>.</p>
<p style="margin-left:9%;">Optional Exports</p>
<p style="margin-left:14%;">"extract_delimited",
"extract_bracketed",
"extract_quotelike",
"extract_codeblock", "extract_variable",
"extract_tagged", "extract_multiple",
"gen_delimited_pat",
"gen_extract_tagged",
"delimited_pat".</p>
<p style="margin-left:9%;">Export Tags</p>
<p style="margin-left:14%;">":ALL"</p>
<p style="margin-left:19%;">"extract_delimited",
"extract_bracketed",
"extract_quotelike",
"extract_codeblock", "extract_variable",
"extract_tagged", "extract_multiple",
"gen_delimited_pat",
"gen_extract_tagged",
"delimited_pat".</p>
<h2>KNOWN BUGS
<a name="KNOWN BUGS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See
&lt;https://rt.cpan.org/Dist/Display.html?Status=Active&amp;Queue=Text−Balanced&gt;.</p>
<h2>FEEDBACK
<a name="FEEDBACK"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Patches, bug
reports, suggestions or any other feedback is welcome.</p>
<p style="margin-left:9%; margin-top: 1em">Patches can be
sent as GitHub pull requests at
&lt;https://github.com/steve−m−hay/Text−Balanced/pulls&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Bug reports and
suggestions can be made on the CPAN Request Tracker at
&lt;https://rt.cpan.org/Public/Bug/Report.html?Queue=Text−Balanced&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Currently active
requests on the CPAN Request Tracker can be viewed at
&lt;https://rt.cpan.org/Public/Dist/Display.html?Status=Active;Queue=Text−Balanced&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Please test this
distribution. See CPAN Testers Reports at
&lt;https://www.cpantesters.org/&gt; for details of how to
get involved.</p>
<p style="margin-left:9%; margin-top: 1em">Previous test
results on CPAN Testers Reports can be viewed at
&lt;https://www.cpantesters.org/distro/T/Text−Balanced.html&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Please rate this
distribution on CPAN Ratings at
&lt;https://cpanratings.perl.org/rate/?distribution=Text−Balanced&gt;.</p>
<h2>AVAILABILITY
<a name="AVAILABILITY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">The latest
version of this module is available from CPAN (see
"CPAN" in perlmodlib for details) at</p>
<p style="margin-left:9%; margin-top: 1em">&lt;https://metacpan.org/release/Text−Balanced&gt;
or</p>
<p style="margin-left:9%; margin-top: 1em">&lt;https://www.cpan.org/authors/id/S/SH/SHAY/&gt;
or</p>
<p style="margin-left:9%; margin-top: 1em">&lt;https://www.cpan.org/modules/by−module/Text/&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">The latest
source code is available from GitHub at
&lt;https://github.com/steve−m−hay/Text−Balanced&gt;.</p>
<h2>INSTALLATION
<a name="INSTALLATION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See the
<i>INSTALL</i> file.</p>
<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Damian Conway
&lt;damian@conway.org
&lt;mailto:damian@conway.org&gt;&gt;.</p>
<p style="margin-left:9%; margin-top: 1em">Steve Hay
&lt;shay@cpan.org &lt;mailto:shay@cpan.org&gt;&gt; is now
maintaining Text::Balanced as of version 2.03.</p>
<h2>COPYRIGHT
<a name="COPYRIGHT"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Copyright (C)
1997−2001 Damian Conway. All rights reserved.</p>
<p style="margin-left:9%; margin-top: 1em">Copyright (C)
2009 Adam Kennedy.</p>
<p style="margin-left:9%; margin-top: 1em">Copyright (C)
2015, 2020, 2022 Steve Hay and other contributors. All
rights reserved.</p>
<h2>LICENCE
<a name="LICENCE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">This module is
free software; you can redistribute it and/or modify it
under the same terms as Perl itself, i.e. under the terms of
either the GNU General Public License or the Artistic
License, as specified in the <i>LICENCE</i> file.</p>
<h2>VERSION
<a name="VERSION"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Version 2.06</p>
<h2>DATE
<a name="DATE"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">05 Jun 2022</p>
<h2>HISTORY
<a name="HISTORY"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">See the
<i>Changes</i> file.</p>
<hr/>
</body>
</html>
