<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 19:54:52 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>wl_display</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">wl_display</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Public Member Functions">Public Member Functions</a><br/>
<a href="#Data Fields">Data Fields</a><br/>
<a href="#Detailed Description">Detailed Description</a><br/>
<a href="#Member Function Documentation">Member Function Documentation</a><br/>
<a href="#struct wl_client * wl_client_create (struct wl_display * display, int fd)">struct wl_client * wl_client_create (struct wl_display * display, int fd)</a><br/>
<a href="#struct wl_protocol_logger * wl_display_add_protocol_logger (structwl_display * display, wl_protocol_logger_func_t func, void * user_data)">struct wl_protocol_logger * wl_display_add_protocol_logger (structwl_display * display, wl_protocol_logger_func_t func, void * user_data)</a><br/>
<a href="#uint32_t * wl_display_add_shm_format (struct wl_display * display, uint32_tformat)">uint32_t * wl_display_add_shm_format (struct wl_display * display, uint32_tformat)</a><br/>
<a href="#int wl_display_add_socket (struct wl_display * display, const char * name)">int wl_display_add_socket (struct wl_display * display, const char * name)</a><br/>
<a href="#int wl_display_add_socket_fd (struct wl_display * display, int sock_fd)">int wl_display_add_socket_fd (struct wl_display * display, int sock_fd)</a><br/>
<a href="#void wl_display_cancel_read (struct wl_display * display)">void wl_display_cancel_read (struct wl_display * display)</a><br/>
<a href="#struct wl_display * wl_display_connect (const char * name)">struct wl_display * wl_display_connect (const char * name)</a><br/>
<a href="#struct wl_display * wl_display_connect_to_fd (int fd)">struct wl_display * wl_display_connect_to_fd (int fd)</a><br/>
<a href="#struct wl_display * wl_display_create (void )">struct wl_display * wl_display_create (void )</a><br/>
<a href="#struct wl_event_queue * wl_display_create_queue (struct wl_display *display)">struct wl_event_queue * wl_display_create_queue (struct wl_display *display)</a><br/>
<a href="#struct wl_event_queue * wl_display_create_queue_with_name (structwl_display * display, const char * name)">struct wl_event_queue * wl_display_create_queue_with_name (structwl_display * display, const char * name)</a><br/>
<a href="#void wl_display_destroy (struct wl_display * display)">void wl_display_destroy (struct wl_display * display)</a><br/>
<a href="#void wl_display_destroy_clients (struct wl_display * display)">void wl_display_destroy_clients (struct wl_display * display)</a><br/>
<a href="#void wl_display_disconnect (struct wl_display * display)">void wl_display_disconnect (struct wl_display * display)</a><br/>
<a href="#int wl_display_dispatch (struct wl_display * display)">int wl_display_dispatch (struct wl_display * display)</a><br/>
<a href="#int wl_display_dispatch_pending (struct wl_display * display)">int wl_display_dispatch_pending (struct wl_display * display)</a><br/>
<a href="#int wl_display_dispatch_queue (struct wl_display * display, structwl_event_queue * queue)">int wl_display_dispatch_queue (struct wl_display * display, structwl_event_queue * queue)</a><br/>
<a href="#int wl_display_dispatch_queue_pending (struct wl_display * display, structwl_event_queue * queue)">int wl_display_dispatch_queue_pending (struct wl_display * display, structwl_event_queue * queue)</a><br/>
<a href="#int wl_display_flush (struct wl_display * display)">int wl_display_flush (struct wl_display * display)</a><br/>
<a href="#struct wl_list * wl_display_get_client_list (struct wl_display * display)">struct wl_list * wl_display_get_client_list (struct wl_display * display)</a><br/>
<a href="#int wl_display_get_error (struct wl_display * display)">int wl_display_get_error (struct wl_display * display)</a><br/>
<a href="#int wl_display_get_fd (struct wl_display * display)">int wl_display_get_fd (struct wl_display * display)</a><br/>
<a href="#uint32_t wl_display_get_protocol_error (struct wl_display * display, conststruct wl_interface ** interface, uint32_t * id)">uint32_t wl_display_get_protocol_error (struct wl_display * display, conststruct wl_interface ** interface, uint32_t * id)</a><br/>
<a href="#uint32_t wl_display_get_serial (struct wl_display * display)">uint32_t wl_display_get_serial (struct wl_display * display)</a><br/>
<a href="#uint32_t wl_display_next_serial (struct wl_display * display)">uint32_t wl_display_next_serial (struct wl_display * display)</a><br/>
<a href="#int wl_display_prepare_read (struct wl_display * display)">int wl_display_prepare_read (struct wl_display * display)</a><br/>
<a href="#int wl_display_prepare_read_queue (struct wl_display * display, structwl_event_queue * queue)">int wl_display_prepare_read_queue (struct wl_display * display, structwl_event_queue * queue)</a><br/>
<a href="#int wl_display_read_events (struct wl_display * display)">int wl_display_read_events (struct wl_display * display)</a><br/>
<a href="#int wl_display_roundtrip (struct wl_display * display)">int wl_display_roundtrip (struct wl_display * display)</a><br/>
<a href="#int wl_display_roundtrip_queue (struct wl_display * display, structwl_event_queue * queue)">int wl_display_roundtrip_queue (struct wl_display * display, structwl_event_queue * queue)</a><br/>
<a href="#void wl_display_set_default_max_buffer_size (struct wl_display * display,size_t max_buffer_size)">void wl_display_set_default_max_buffer_size (struct wl_display * display,size_t max_buffer_size)</a><br/>
<a href="#void wl_display_set_global_filter (struct wl_display * display,wl_display_global_filter_func_t filter, void * data)">void wl_display_set_global_filter (struct wl_display * display,wl_display_global_filter_func_t filter, void * data)</a><br/>
<a href="#void wl_display_set_max_buffer_size (struct wl_display * display, size_tmax_buffer_size)">void wl_display_set_max_buffer_size (struct wl_display * display, size_tmax_buffer_size)</a><br/>
<a href="#Field Documentation">Field Documentation</a><br/>
<a href="#struct wl_array wl_display::additional_shm_formats">struct wl_array wl_display::additional_shm_formats</a><br/>
<a href="#struct wl_list wl_display::client_list">struct wl_list wl_display::client_list</a><br/>
<a href="#struct wl_priv_signal wl_display::create_client_signal">struct wl_priv_signal wl_display::create_client_signal</a><br/>
<a href="#struct wl_priv_signal wl_display::destroy_signal">struct wl_priv_signal wl_display::destroy_signal</a><br/>
<a href="#wl_display_global_filter_func_t wl_display::global_filter">wl_display_global_filter_func_t wl_display::global_filter</a><br/>
<a href="#void* wl_display::global_filter_data">void* wl_display::global_filter_data</a><br/>
<a href="#struct wl_list wl_display::global_list">struct wl_list wl_display::global_list</a><br/>
<a href="#struct wl_event_loop* wl_display::loop">struct wl_event_loop* wl_display::loop</a><br/>
<a href="#size_t wl_display::max_buffer_size">size_t wl_display::max_buffer_size</a><br/>
<a href="#uint32_t wl_display::next_global_name">uint32_t wl_display::next_global_name</a><br/>
<a href="#struct wl_list wl_display::protocol_loggers">struct wl_list wl_display::protocol_loggers</a><br/>
<a href="#struct wl_list wl_display::registry_resource_list">struct wl_list wl_display::registry_resource_list</a><br/>
<a href="#bool wl_display::run">bool wl_display::run</a><br/>
<a href="#uint32_t wl_display::serial">uint32_t wl_display::serial</a><br/>
<a href="#struct wl_list wl_display::socket_list">struct wl_list wl_display::socket_list</a><br/>
<a href="#struct wl_event_source* wl_display::term_source">struct wl_event_source* wl_display::term_source</a><br/>
<a href="#int wl_display::terminate_efd">int wl_display::terminate_efd</a><br/>
<a href="#Author">Author</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">wl_display
− Represents a connection to the compositor and acts
as a proxy to the <b>wl_display</b> singleton object.</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;wayland−client−core.h&gt;</p>
<h3>Public Member Functions
<a name="Public Member Functions"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">struct
<b>wl_client</b> * <b>wl_client_create</b> (struct
<b>wl_display</b> *display, int fd) <br/>
struct <b>wl_display</b> * <b>wl_display_create</b> (void)
<br/>
void <b>wl_display_destroy</b> (struct <b>wl_display</b>
*display) <br/>
void <b>wl_display_set_global_filter</b> (struct
<b>wl_display</b> *display,
<b>wl_display_global_filter_func_t</b> filter, void *data)
<br/>
uint32_t <b>wl_display_get_serial</b> (struct
<b>wl_display</b> *display) <br/>
uint32_t <b>wl_display_next_serial</b> (struct
<b>wl_display</b> *display) <br/>
void <b>wl_display_destroy_clients</b> (struct
<b>wl_display</b> *display) <br/>
void <b>wl_display_set_default_max_buffer_size</b> (struct
<b>wl_display</b> *display, size_t <b>max_buffer_size</b>)
<br/>
int <b>wl_display_add_socket_fd</b> (struct
<b>wl_display</b> *display, int sock_fd) <br/>
int <b>wl_display_add_socket</b> (struct <b>wl_display</b>
*display, const char *name) <br/>
struct <b>wl_protocol_logger</b> *
<b>wl_display_add_protocol_logger</b> (struct
<b>wl_display</b> *display, <b>wl_protocol_logger_func_t</b>
func, void *user_data) <br/>
uint32_t * <b>wl_display_add_shm_format</b> (struct
<b>wl_display</b> *display, uint32_t format) <br/>
struct <b>wl_list</b> * <b>wl_display_get_client_list</b>
(struct <b>wl_display</b> *display) <br/>
struct <b>wl_event_queue</b> *
<b>wl_display_create_queue</b> (struct <b>wl_display</b>
*display) <br/>
struct <b>wl_event_queue</b> *
<b>wl_display_create_queue_with_name</b> (struct
<b>wl_display</b> *display, const char *name) <br/>
struct <b>wl_display</b> * <b>wl_display_connect_to_fd</b>
(int fd) <br/>
struct <b>wl_display</b> * <b>wl_display_connect</b> (const
char *name) <br/>
void <b>wl_display_disconnect</b> (struct <b>wl_display</b>
*display) <br/>
int <b>wl_display_get_fd</b> (struct <b>wl_display</b>
*display) <br/>
int <b>wl_display_roundtrip_queue</b> (struct
<b>wl_display</b> *display, struct <b>wl_event_queue</b>
*queue) <br/>
int <b>wl_display_roundtrip</b> (struct <b>wl_display</b>
*display) <br/>
int <b>wl_display_read_events</b> (struct <b>wl_display</b>
*display) <br/>
int <b>wl_display_prepare_read_queue</b> (struct
<b>wl_display</b> *display, struct <b>wl_event_queue</b>
*queue) <br/>
int <b>wl_display_prepare_read</b> (struct <b>wl_display</b>
*display) <br/>
void <b>wl_display_cancel_read</b> (struct <b>wl_display</b>
*display) <br/>
int <b>wl_display_dispatch_queue</b> (struct
<b>wl_display</b> *display, struct <b>wl_event_queue</b>
*queue) <br/>
int <b>wl_display_dispatch_queue_pending</b> (struct
<b>wl_display</b> *display, struct <b>wl_event_queue</b>
*queue) <br/>
int <b>wl_display_dispatch</b> (struct <b>wl_display</b>
*display) <br/>
int <b>wl_display_dispatch_pending</b> (struct
<b>wl_display</b> *display) <br/>
int <b>wl_display_get_error</b> (struct <b>wl_display</b>
*display) <br/>
uint32_t <b>wl_display_get_protocol_error</b> (struct
<b>wl_display</b> *display, const struct <b>wl_interface</b>
**interface, uint32_t *id) <br/>
int <b>wl_display_flush</b> (struct <b>wl_display</b>
*display) <br/>
void <b>wl_display_set_max_buffer_size</b> (struct
<b>wl_display</b> *display, size_t
<b>max_buffer_size</b>)</p>
<h3>Data Fields
<a name="Data Fields"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">struct
<b>wl_event_loop</b> * <b>loop</b> <br/>
bool <b>run</b> <br/>
uint32_t <b>next_global_name</b> <br/>
uint32_t <b>serial</b> <br/>
struct <b>wl_list registry_resource_list</b> <br/>
struct <b>wl_list global_list</b> <br/>
struct <b>wl_list socket_list</b> <br/>
struct <b>wl_list client_list</b> <br/>
struct <b>wl_list protocol_loggers</b> <br/>
struct wl_priv_signal <b>destroy_signal</b> <br/>
struct wl_priv_signal <b>create_client_signal</b> <br/>
struct <b>wl_array additional_shm_formats <br/>
wl_display_global_filter_func_t global_filter</b> <br/>
void * <b>global_filter_data</b> <br/>
int <b>terminate_efd</b> <br/>
struct <b>wl_event_source</b> * <b>term_source</b> <br/>
size_t <b>max_buffer_size</b></p>
<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Represents a
connection to the compositor and acts as a proxy to the
<b>wl_display</b> singleton object.</p>
<p style="margin-left:9%; margin-top: 1em">A
<b>wl_display</b> object represents a client connection to a
Wayland compositor. It is created with either
<b>wl_display_connect()</b> or
<b>wl_display_connect_to_fd()</b>. A connection is
terminated using <b>wl_display_disconnect()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">A
<b>wl_display</b> is also used as the <b>wl_proxy</b> for
the <b>wl_display</b> singleton object on the compositor
side.</p>
<p style="margin-left:9%; margin-top: 1em">A
<b>wl_display</b> object handles all the data sent from and
to the compositor. When a <b>wl_proxy</b> marshals a
request, it will write its wire representation to the
display’s write buffer. The data is sent to the
compositor when the client calls
<b>wl_display_flush()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Incoming data is
handled in two steps: queueing and dispatching. In the queue
step, the data coming from the display fd is interpreted and
added to a queue. On the dispatch step, the handler for the
incoming event set by the client on the corresponding
<b>wl_proxy</b> is called.</p>
<p style="margin-left:9%; margin-top: 1em">A
<b>wl_display</b> has at least one event queue, called the
<i>default queue</i>. Clients can create additional event
queues with <b>wl_display_create_queue()</b> and assign
<b>wl_proxy</b>’s to it. Events occurring in a
particular proxy are always queued in its assigned queue. A
client can ensure that a certain assumption, such as holding
a lock or running from a given thread, is true when a proxy
event handler is called by assigning that proxy to an event
queue and making sure that this queue is only dispatched
when the assumption holds.</p>
<p style="margin-left:9%; margin-top: 1em">The default
queue is dispatched by calling <b>wl_display_dispatch()</b>.
This will dispatch any events queued on the default queue
and attempt to read from the display fd if it’s empty.
Events read are then queued on the appropriate queues
according to the proxy assignment.</p>
<p style="margin-left:9%; margin-top: 1em">A user created
queue is dispatched with <b>wl_display_dispatch_queue()</b>.
This function behaves exactly the same as
<b>wl_display_dispatch()</b> but it dispatches given queue
instead of the default queue.</p>
<p style="margin-left:9%; margin-top: 1em">A real world
example of event queue usage is Mesa’s implementation
of eglSwapBuffers() for the Wayland platform. This function
might need to block until a frame callback is received, but
dispatching the default queue could cause an event handler
on the client to start drawing again. This problem is solved
using another event queue, so that only the events handled
by the EGL code are dispatched during the block.</p>
<p style="margin-left:9%; margin-top: 1em">This creates a
problem where a thread dispatches a non-default queue,
reading all the data from the display fd. If the application
would call <i>poll(2)</i> after that it would block, even
though there might be events queued on the default queue.
Those events should be dispatched with
<b>wl_display_dispatch_pending()</b> or
<b>wl_display_dispatch_queue_pending()</b> before flushing
and blocking.</p>
<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>
<h3>struct wl_client * wl_client_create (struct wl_display * display, int fd)
<a name="struct wl_client * wl_client_create (struct wl_display * display, int fd)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a client
for the given file descriptor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object <i><br/>
fd</i> The file descriptor for the socket to the client</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The new client object or NULL
on failure.</p>
<p style="margin-left:9%; margin-top: 1em">Given a file
descriptor corresponding to one end of a socket, this
function will create a <b>wl_client</b> struct and add the
new client to the compositors client list. At that point,
the client is initialized and ready to run, as if the client
had connected to the servers listening socket. When the
client eventually sends requests to the compositor, the
<b>wl_client</b> argument to the request handler will be the
<b>wl_client</b> returned from this function.</p>
<p style="margin-left:9%; margin-top: 1em">The other end of
the socket can be passed to
<b>wl_display_connect_to_fd()</b> on the client side or used
with the WAYLAND_SOCKET environment variable on the client
side.</p>
<p style="margin-left:9%; margin-top: 1em">Listeners added
with <b>wl_display_add_client_created_listener()</b> will be
notified by this function after the client is fully
constructed.</p>
<p style="margin-left:9%; margin-top: 1em">On failure this
function sets errno accordingly and returns NULL.</p>
<p style="margin-left:9%; margin-top: 1em">On success, the
new client object takes the ownership of the file
descriptor. On failure, the ownership of the socket endpoint
file descriptor is unchanged, it is the responsibility of
the caller to perform cleanup, e.g. call close().</p>
<h3>struct wl_protocol_logger * wl_display_add_protocol_logger (structwl_display * display, wl_protocol_logger_func_t func, void * user_data)
<a name="struct wl_protocol_logger * wl_display_add_protocol_logger (structwl_display * display, wl_protocol_logger_func_t func, void * user_data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Adds a new
protocol logger.</p>
<p style="margin-left:9%; margin-top: 1em">When a new
protocol message arrives or is sent from the server all the
protocol logger functions will be called, carrying the
<i>user_data</i> pointer, the type of the message (request
or event) and the actual message. The lifetime of the
messages passed to the logger function ends when they return
so the messages cannot be stored and accessed later.</p>
<p style="margin-left:9%; margin-top: 1em"><i>errno</i> is
set on error.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object <i><br/>
func</i> The function to call to log a new protocol message
<i><br/>
user_data</i> The user data pointer to pass to
<i>func</i></p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The protol logger object on
success, NULL on failure.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_protocol_logger_destroy</b></p>
<h3>uint32_t * wl_display_add_shm_format (struct wl_display * display, uint32_tformat)
<a name="uint32_t * wl_display_add_shm_format (struct wl_display * display, uint32_tformat)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Add support for
a wl_shm pixel format</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object <i><br/>
format</i> The wl_shm pixel format to advertise</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A pointer to the wl_shm format
that was added to the list or NULL if adding it to the list
failed.</p>
<p style="margin-left:9%; margin-top: 1em">Add the
specified wl_shm format to the list of formats the wl_shm
object advertises when a client binds to it. Adding a format
to the list means that clients will know that the compositor
supports this format and may use it for creating wl_shm
buffers. The compositor must be able to handle the pixel
format when a client requests it.</p>
<p style="margin-left:9%; margin-top: 1em">The compositor
by default supports WL_SHM_FORMAT_ARGB8888 and
WL_SHM_FORMAT_XRGB8888.</p>
<h3>int wl_display_add_socket (struct wl_display * display, const char * name)
<a name="int wl_display_add_socket (struct wl_display * display, const char * name)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Add a socket to
Wayland display for the clients to connect.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> Wayland display
to which the socket should be added. <i><br/>
name</i> Name of the Unix socket.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 if success. -1 if failed.</p>
<p style="margin-left:9%; margin-top: 1em">This adds a Unix
socket to Wayland display which can be used by clients to
connect to Wayland display.</p>
<p style="margin-left:9%; margin-top: 1em">If NULL is
passed as name, then it would look for WAYLAND_DISPLAY env
variable for the socket name. If WAYLAND_DISPLAY is not set,
then default wayland-0 is used.</p>
<p style="margin-left:9%; margin-top: 1em">If the socket
name is a relative path, the Unix socket will be created in
the directory pointed to by environment variable
XDG_RUNTIME_DIR. If XDG_RUNTIME_DIR is invalid or not set,
then this function fails and returns -1.</p>
<p style="margin-left:9%; margin-top: 1em">If the socket
name is an absolute path, then it is used as-is for the the
Unix socket.</p>
<p style="margin-left:9%; margin-top: 1em">The length of
the computed socket path must not exceed the maximum length
of a Unix socket path. The function also fails if the user
does not have write permission in the directory or if the
path is already in use.</p>
<h3>int wl_display_add_socket_fd (struct wl_display * display, int sock_fd)
<a name="int wl_display_add_socket_fd (struct wl_display * display, int sock_fd)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Add a socket
with an existing fd to Wayland display for the clients to
connect.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> Wayland display
to which the socket should be added. <i><br/>
sock_fd</i> The existing socket file descriptor to be
used</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 if success. -1 if failed.</p>
<p style="margin-left:9%; margin-top: 1em">The existing
socket fd must already be created, opened, and locked. The
fd must be properly set to CLOEXEC and bound to a socket
file with both bind() and listen() already called.</p>
<p style="margin-left:9%; margin-top: 1em">On success, the
socket fd ownership is transferred to libwayland: libwayland
will close the socket when the display is destroyed.</p>
<h3>void wl_display_cancel_read (struct wl_display * display)
<a name="void wl_display_cancel_read (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Cancel read
intention on display’s fd</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em">After a thread
successfully called <b>wl_display_prepare_read()</b> it must
either call <b>wl_display_read_events()</b> or
<b>wl_display_cancel_read()</b>. If the threads do not
follow this rule it will lead to deadlock.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_prepare_read()</b>,
<b>wl_display_read_events()</b></p>
<h3>struct wl_display * wl_display_connect (const char * name)
<a name="struct wl_display * wl_display_connect (const char * name)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Connect to a
Wayland display</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>name</i> Name of the Wayland
display to connect to</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A <b>wl_display</b> object or
NULL on failure</p>
<p style="margin-left:9%; margin-top: 1em">Connect to the
Wayland display named name. If name is NULL, its value will
be replaced with the WAYLAND_DISPLAY environment variable if
it is set, otherwise display ’wayland-0’ will be
used.</p>
<p style="margin-left:9%; margin-top: 1em">If
WAYLAND_SOCKET is set, it’s interpreted as a file
descriptor number referring to an already opened socket. In
this case, the socket is used as-is and name is ignored.</p>
<p style="margin-left:9%; margin-top: 1em">If name is a
relative path, then the socket is opened relative to the
XDG_RUNTIME_DIR directory.</p>
<p style="margin-left:9%; margin-top: 1em">If name is an
absolute path, then that path is used as-is for the location
of the socket at which the Wayland server is listening; no
qualification inside XDG_RUNTIME_DIR is attempted.</p>
<p style="margin-left:9%; margin-top: 1em">If name is NULL
and the WAYLAND_DISPLAY environment variable is set to an
absolute pathname, then that pathname is used as-is for the
socket in the same manner as if name held an absolute path.
Support for absolute paths in name and WAYLAND_DISPLAY is
present since Wayland version 1.15.</p>
<h3>struct wl_display * wl_display_connect_to_fd (int fd)
<a name="struct wl_display * wl_display_connect_to_fd (int fd)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Connect to
Wayland display on an already open fd</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>fd</i> The fd to use for the
connection</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A <b>wl_display</b> object or
NULL on failure</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>wl_display</b> takes ownership of the fd and will close
it when the display is destroyed. The fd will also be closed
in case of failure.</p>
<h3>struct wl_display * wl_display_create (void )
<a name="struct wl_display * wl_display_create (void )"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create Wayland
display object.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The Wayland display object.
Null if failed to create</p>
<p style="margin-left:9%; margin-top: 1em">This creates the
<b>wl_display</b> object.</p>
<h3>struct wl_event_queue * wl_display_create_queue (struct wl_display *display)
<a name="struct wl_event_queue * wl_display_create_queue (struct wl_display *display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a new
event queue for this display</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new event queue associated
with this display or NULL on failure.</p>
<h3>struct wl_event_queue * wl_display_create_queue_with_name (structwl_display * display, const char * name)
<a name="struct wl_event_queue * wl_display_create_queue_with_name (structwl_display * display, const char * name)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a new
event queue for this display and give it a name</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object <i><br/>
name</i> A human readable queue name</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new event queue associated
with this display or NULL on failure.</p>
<h3>void wl_display_destroy (struct wl_display * display)
<a name="void wl_display_destroy (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Destroy Wayland
display object.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The Wayland
display object which should be destroyed.</p>
<p style="margin-left:9%; margin-top: 1em">This function
emits the <b>wl_display</b> destroy signal, releases all the
sockets added to this display, free’s all the globals
associated with this display, free’s memory of
additional shared memory formats and destroy the display
object.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_add_destroy_listener</b></p>
<h3>void wl_display_destroy_clients (struct wl_display * display)
<a name="void wl_display_destroy_clients (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Destroy all
clients connected to the display</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object</p>
<p style="margin-left:9%; margin-top: 1em">This function
should be called right before <b>wl_display_destroy()</b> to
ensure all client resources are closed properly. Destroying
a client from within <b>wl_display_destroy_clients()</b> is
safe, but creating one will leak resources and raise a
warning.</p>
<h3>void wl_display_disconnect (struct wl_display * display)
<a name="void wl_display_disconnect (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Close a
connection to a Wayland display</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em">Close the
connection to display. The <b>wl_proxy</b> and
<b>wl_event_queue</b> objects need to be manually destroyed
by the caller before disconnecting.</p>
<h3>int wl_display_dispatch (struct wl_display * display)
<a name="int wl_display_dispatch (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Process incoming
events</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of dispatched events
on success or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">Dispatch events
on the default event queue.</p>
<p style="margin-left:9%; margin-top: 1em">If the default
event queue is empty, this function blocks until there are
events to be read from the display fd. Events are read and
queued on the appropriate event queues. Finally, events on
the default event queue are dispatched. On failure -1 is
returned and errno set appropriately.</p>
<p style="margin-left:9%; margin-top: 1em">In a multi
threaded environment, do not manually wait using poll() (or
equivalent) before calling this function, as doing so might
cause a dead lock. If external reliance on poll() (or
equivalent) is required, see
<b>wl_display_prepare_read_queue()</b> of how to do so.</p>
<p style="margin-left:9%; margin-top: 1em">This function is
thread safe as long as it dispatches the right queue on the
right thread. It is also compatible with the multi thread
event reading preparation API (see
<b>wl_display_prepare_read_queue()</b>), and uses the
equivalent functionality internally. It is not allowed to
call this function while the thread is being prepared for
reading events, and doing so will cause a dead lock.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">It is not possible to check if
there are events on the queue or not. For dispatching
default queue events without blocking, see
<b>wl_display_dispatch_pending()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_dispatch_pending()</b>,
<b>wl_display_dispatch_queue()</b>,
<b>wl_display_read_events()</b></p>
<h3>int wl_display_dispatch_pending (struct wl_display * display)
<a name="int wl_display_dispatch_pending (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Dispatch default
queue events without reading from the display fd</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of dispatched events
or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">This function
dispatches events on the main event queue. It does not
attempt to read the display fd and simply returns zero if
the main queue is empty, i.e., it doesn’t block.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_dispatch()</b>,
<b>wl_display_dispatch_queue()</b>,
<b>wl_display_flush()</b></p>
<h3>int wl_display_dispatch_queue (struct wl_display * display, structwl_event_queue * queue)
<a name="int wl_display_dispatch_queue (struct wl_display * display, structwl_event_queue * queue)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Dispatch events
in an event queue</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object <i><br/>
queue</i> The event queue to dispatch</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of dispatched events
on success or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">Dispatch events
on the given event queue.</p>
<p style="margin-left:9%; margin-top: 1em">If the given
event queue is empty, this function blocks until there are
events to be read from the display fd. Events are read and
queued on the appropriate event queues. Finally, events on
given event queue are dispatched. On failure -1 is returned
and errno set appropriately.</p>
<p style="margin-left:9%; margin-top: 1em">In a multi
threaded environment, do not manually wait using poll() (or
equivalent) before calling this function, as doing so might
cause a dead lock. If external reliance on poll() (or
equivalent) is required, see
<b>wl_display_prepare_read_queue()</b> of how to do so.</p>
<p style="margin-left:9%; margin-top: 1em">This function is
thread safe as long as it dispatches the right queue on the
right thread. It is also compatible with the multi thread
event reading preparation API (see
<b>wl_display_prepare_read_queue()</b>), and uses the
equivalent functionality internally. It is not allowed to
call this function while the thread is being prepared for
reading events, and doing so will cause a dead lock.</p>
<p style="margin-left:9%; margin-top: 1em">It can be used
as a helper function to ease the procedure of reading and
dispatching events.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">Since Wayland 1.5 the display
has an extra queue for its own events (i. e. delete_id).
This queue is dispatched always, no matter what queue we
passed as an argument to this function. That means that this
function can return non-0 value even when it haven’t
dispatched any event for the given queue.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_dispatch()</b>,
<b>wl_display_dispatch_pending()</b>,
<b>wl_display_dispatch_queue_pending()</b>,
<b>wl_display_prepare_read_queue()</b></p>
<h3>int wl_display_dispatch_queue_pending (struct wl_display * display, structwl_event_queue * queue)
<a name="int wl_display_dispatch_queue_pending (struct wl_display * display, structwl_event_queue * queue)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Dispatch pending
events in an event queue</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object <i><br/>
queue</i> The event queue to dispatch</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of dispatched events
on success or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">Dispatch all
incoming events for objects assigned to the given event
queue. On failure -1 is returned and errno set
appropriately. If there are no events queued, this function
returns immediately.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.0.2</p>
<h3>int wl_display_flush (struct wl_display * display)
<a name="int wl_display_flush (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Send all
buffered requests on the display to the server</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of bytes sent on
success or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">Send all
buffered data on the client side to the server. Clients
should always call this function before blocking on input
from the display fd. On success, the number of bytes sent to
the server is returned. On failure, this function returns -1
and errno is set appropriately.</p>
<p style="margin-left:9%; margin-top: 1em"><b>wl_display_flush()</b>
never blocks. It will write as much data as possible, but if
all data could not be written, errno will be set to EAGAIN
and -1 returned. In that case, use poll on the display file
descriptor to wait for it to become writable again.</p>
<h3>struct wl_list * wl_display_get_client_list (struct wl_display * display)
<a name="struct wl_list * wl_display_get_client_list (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the list of
currently connected clients</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object</p>
<p style="margin-left:9%; margin-top: 1em">This function
returns a pointer to the list of clients currently connected
to the display. You can iterate on the list by using the
<i>wl_client_for_each</i> macro. The returned value is valid
for the lifetime of the <i>display</i>. You must not modify
the returned list, but only access it.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_client_for_each()</b></p>
<p style="margin-left:14%; margin-top: 1em"><b>wl_client_get_link()</b></p>
<p style="margin-left:14%; margin-top: 1em"><b>wl_client_from_link()</b></p>
<h3>int wl_display_get_error (struct wl_display * display)
<a name="int wl_display_get_error (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Retrieve the
last error that occurred on a display</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The last error that occurred on
display or 0 if no error occurred</p>
<p style="margin-left:9%; margin-top: 1em">Return the last
error that occurred on the display. This may be an error
sent by the server or caused by the local client.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">Errors are <b>fatal</b>. If
this function returns non-zero the display can no longer be
used.</p>
<h3>int wl_display_get_fd (struct wl_display * display)
<a name="int wl_display_get_fd (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get a display
context’s file descriptor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">Display object file
descriptor</p>
<p style="margin-left:9%; margin-top: 1em">Return the file
descriptor associated with a display so it can be integrated
into the client’s main loop.</p>
<h3>uint32_t wl_display_get_protocol_error (struct wl_display * display, conststruct wl_interface ** interface, uint32_t * id)
<a name="uint32_t wl_display_get_protocol_error (struct wl_display * display, conststruct wl_interface ** interface, uint32_t * id)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Retrieves the
information about a protocol error:</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The Wayland
display <i><br/>
interface</i> if not NULL, stores the interface where the
error occurred, or NULL, if unknown. <i><br/>
id</i> if not NULL, stores the object id that generated the
error, or 0, if the object id is unknown. There’s no
guarantee the object is still valid; the client must know if
it deleted the object.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The error code as defined in
the interface specification.</p>
<p style="margin-left:9%; margin-top: 1em">int err =
wl_display_get_error(display);</p>
<p style="margin-left:9%; margin-top: 1em">if (err ==
EPROTO) { <br/>
code = wl_display_get_protocol_error(display,
&amp;interface, &amp;id); <br/>
handle_error(code, interface, id); <br/>
}</p>
<p style="margin-left:9%; margin-top: 1em">...</p>
<h3>uint32_t wl_display_get_serial (struct wl_display * display)
<a name="uint32_t wl_display_get_serial (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the current
serial number</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object</p>
<p style="margin-left:9%; margin-top: 1em">This function
returns the most recent serial number, but does not
increment it.</p>
<h3>uint32_t wl_display_next_serial (struct wl_display * display)
<a name="uint32_t wl_display_next_serial (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the next
serial number</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object</p>
<p style="margin-left:9%; margin-top: 1em">This function
increments the display serial number and returns the new
value.</p>
<h3>int wl_display_prepare_read (struct wl_display * display)
<a name="int wl_display_prepare_read (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare to read
events from the display’s file descriptor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success or -1 if event
queue was not empty</p>
<p style="margin-left:9%; margin-top: 1em">This function
does the same thing as
<b>wl_display_prepare_read_queue()</b> with the default
queue passed as the queue.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_prepare_read_queue</b></p>
<h3>int wl_display_prepare_read_queue (struct wl_display * display, structwl_event_queue * queue)
<a name="int wl_display_prepare_read_queue (struct wl_display * display, structwl_event_queue * queue)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare to read
events from the display’s file descriptor to a
queue</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object <i><br/>
queue</i> The event queue to use</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success or -1 if event
queue was not empty</p>
<p style="margin-left:9%; margin-top: 1em">This function
(or <b>wl_display_prepare_read()</b>) must be called before
reading from the file descriptor using
<b>wl_display_read_events()</b>. Calling
<b>wl_display_prepare_read_queue()</b> announces the calling
thread’s intention to read and ensures that until the
thread is ready to read and calls
<b>wl_display_read_events()</b>, no other thread will read
from the file descriptor. This only succeeds if the event
queue is empty, and if not -1 is returned and errno set to
EAGAIN.</p>
<p style="margin-left:9%; margin-top: 1em">If a thread
successfully calls <b>wl_display_prepare_read_queue()</b>,
it must either call <b>wl_display_read_events()</b> when
it’s ready or cancel the read intention by calling
<b>wl_display_cancel_read()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">Use this
function before polling on the display fd or integrate the
fd into a toolkit event loop in a race-free way. A correct
usage would be (with most error checking left out):</p>
<p style="margin-left:9%; margin-top: 1em">while
(wl_display_prepare_read_queue(display, queue) != 0) <br/>
wl_display_dispatch_queue_pending(display, queue); <br/>
wl_display_flush(display);</p>
<p style="margin-left:9%; margin-top: 1em">ret = poll(fds,
nfds, −1); <br/>
if (has_error(ret)) <br/>
wl_display_cancel_read(display); <br/>
else <br/>
wl_display_read_events(display);</p>
<p style="margin-left:9%; margin-top: 1em">wl_display_dispatch_queue_pending(display,
queue);</p>
<p style="margin-left:9%; margin-top: 1em">Here we call
<b>wl_display_prepare_read_queue()</b>, which ensures that
between returning from that call and eventually calling
<b>wl_display_read_events()</b>, no other thread will read
from the fd and queue events in our queue. If the call to
<b>wl_display_prepare_read_queue()</b> fails, we dispatch
the pending events and try again until we’re
successful.</p>
<p style="margin-left:9%; margin-top: 1em">The
<b>wl_display_prepare_read_queue()</b> function
doesn’t acquire exclusive access to the
display’s fd. It only registers that the thread
calling this function has intention to read from fd. When
all registered readers call <b>wl_display_read_events()</b>,
only one (at random) eventually reads and queues the events
and the others are sleeping meanwhile. This way we avoid
races and still can read from more threads.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_cancel_read()</b>,
<b>wl_display_read_events()</b>,
<b>wl_display_prepare_read()</b></p>
<h3>int wl_display_read_events (struct wl_display * display)
<a name="int wl_display_read_events (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Read events from
display file descriptor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success or -1 on error. In
case of error errno will be set accordingly</p>
<p style="margin-left:9%; margin-top: 1em">Calling this
function will result in data available on the display file
descriptor being read and read events will be queued on
their corresponding event queues.</p>
<p style="margin-left:9%; margin-top: 1em">Before calling
this function, depending on what thread it is to be called
from, <b>wl_display_prepare_read_queue()</b> or
<b>wl_display_prepare_read()</b> needs to be called. See
<b>wl_display_prepare_read_queue()</b> for more details.</p>
<p style="margin-left:9%; margin-top: 1em">When being
called at a point where other threads have been prepared to
read (using <b>wl_display_prepare_read_queue()</b> or
<b>wl_display_prepare_read()</b>) this function will sleep
until all other prepared threads have either been cancelled
(using <b>wl_display_cancel_read()</b>) or them self entered
this function. The last thread that calls this function will
then read and queue events on their corresponding event
queues, and finally wake up all other
<b>wl_display_read_events()</b> calls causing them to
return.</p>
<p style="margin-left:9%; margin-top: 1em">If a thread
cancels a read preparation when all other threads that have
prepared to read has either called
<b>wl_display_cancel_read()</b> or
<b>wl_display_read_events()</b>, all reader threads will
return without having read any data.</p>
<p style="margin-left:9%; margin-top: 1em">To dispatch
events that may have been queued, call
<b>wl_display_dispatch_pending()</b> or
<b>wl_display_dispatch_queue_pending()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_prepare_read()</b>,
<b>wl_display_cancel_read()</b>,
<b>wl_display_dispatch_pending()</b>,
<b>wl_display_dispatch()</b></p>
<h3>int wl_display_roundtrip (struct wl_display * display)
<a name="int wl_display_roundtrip (struct wl_display * display)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Block until all
pending request are processed by the server</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of dispatched events
on success or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">This function
blocks until the server has processed all currently issued
requests by sending a request to the display server and
waiting for a reply before returning.</p>
<p style="margin-left:9%; margin-top: 1em">This function
uses <b>wl_display_dispatch_queue()</b> internally. It is
not allowed to call this function while the thread is being
prepared for reading events, and doing so will cause a dead
lock.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This function may dispatch
other events being received on the default queue.</p>
<h3>int wl_display_roundtrip_queue (struct wl_display * display, structwl_event_queue * queue)
<a name="int wl_display_roundtrip_queue (struct wl_display * display, structwl_event_queue * queue)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Block until all
pending request are processed by the server</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object <i><br/>
queue</i> The queue on which to run the roundtrip</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The number of dispatched events
on success or -1 on failure</p>
<p style="margin-left:9%; margin-top: 1em">This function
blocks until the server has processed all currently issued
requests by sending a request to the display server and
waiting for a reply before returning.</p>
<p style="margin-left:9%; margin-top: 1em">This function
uses <b>wl_display_dispatch_queue()</b> internally. It is
not allowed to call this function while the thread is being
prepared for reading events, and doing so will cause a dead
lock.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This function may dispatch
other events being received on the given queue.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_roundtrip()</b></p>
<h3>void wl_display_set_default_max_buffer_size (struct wl_display * display,size_t max_buffer_size)
<a name="void wl_display_set_default_max_buffer_size (struct wl_display * display,size_t max_buffer_size)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Sets the default
maximum size for connection buffers of new clients</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
object <i><br/>
max_buffer_size</i> The default maximum size of the
connection buffers</p>
<p style="margin-left:9%; margin-top: 1em">This function
sets the default size of the internal connection buffers for
new clients. It doesn’t change the buffer size for
existing <b>wl_client</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The connection
buffer size of an existing <b>wl_client</b> can be adjusted
using <b>wl_client_set_max_buffer_size()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The actual size
of the connection buffers is a power of two, the requested
<i>max_buffer_size</i> is therefore rounded up to the
nearest power of two value.</p>
<p style="margin-left:9%; margin-top: 1em">The minimum
buffer size is 4096.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_client_set_max_buffer_size</b></p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.22.90</p>
<h3>void wl_display_set_global_filter (struct wl_display * display,wl_display_global_filter_func_t filter, void * data)
<a name="void wl_display_set_global_filter (struct wl_display * display,wl_display_global_filter_func_t filter, void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Set a filter
function for global objects</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The Wayland
display object. <i><br/>
filter</i> The global filter function. <i><br/>
data</i> User data to be associated with the global
filter.</p>
<p style="margin-left:9%; margin-top: 1em">Set a filter for
the <b>wl_display</b> to advertise or hide global objects to
clients. The set filter will be used during <b>wl_global</b>
advertisement to determine whether a global object should be
advertised to a given client, and during <b>wl_global</b>
binding to determine whether a given client should be
allowed to bind to a global.</p>
<p style="margin-left:9%; margin-top: 1em">Clients that try
to bind to a global that was filtered out will have an error
raised.</p>
<p style="margin-left:9%; margin-top: 1em">Setting the
filter NULL will result in all globals being advertised to
all clients. The default is no filter.</p>
<p style="margin-left:9%; margin-top: 1em">The filter
should be installed before any client connects and should
always take the same decision given a client and a global.
Not doing so will result in inconsistent filtering and
broken wl_registry event sequences.</p>
<h3>void wl_display_set_max_buffer_size (struct wl_display * display, size_tmax_buffer_size)
<a name="void wl_display_set_max_buffer_size (struct wl_display * display, size_tmax_buffer_size)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Adjust the
maximum size of the client connection buffers</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>display</i> The display
context object <i><br/>
max_buffer_size</i> The maximum size of the connection
buffers</p>
<p style="margin-left:9%; margin-top: 1em">Client buffers
are unbounded by default. This function sets a limit to the
size of the connection buffers.</p>
<p style="margin-left:9%; margin-top: 1em">A value of 0 for
<i>max_buffer_size</i> requests the buffers to be
unbounded.</p>
<p style="margin-left:9%; margin-top: 1em">The actual size
of the connection buffers is a power of two, the requested
<i>max_buffer_size</i> is therefore rounded up to the
nearest power of two value.</p>
<p style="margin-left:9%; margin-top: 1em">Lowering the
maximum size may not take effect immediately if the current
content of the buffer does not fit within the new size
limit.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.22.90</p>
<h2>Field Documentation
<a name="Field Documentation"></a>
</h2>
<h3>struct wl_array wl_display::additional_shm_formats
<a name="struct wl_array wl_display::additional_shm_formats"></a>
</h3>
<h3>struct wl_list wl_display::client_list
<a name="struct wl_list wl_display::client_list"></a>
</h3>
<h3>struct wl_priv_signal wl_display::create_client_signal
<a name="struct wl_priv_signal wl_display::create_client_signal"></a>
</h3>
<h3>struct wl_priv_signal wl_display::destroy_signal
<a name="struct wl_priv_signal wl_display::destroy_signal"></a>
</h3>
<h3>wl_display_global_filter_func_t wl_display::global_filter
<a name="wl_display_global_filter_func_t wl_display::global_filter"></a>
</h3>
<h3>void* wl_display::global_filter_data
<a name="void* wl_display::global_filter_data"></a>
</h3>
<h3>struct wl_list wl_display::global_list
<a name="struct wl_list wl_display::global_list"></a>
</h3>
<h3>struct wl_event_loop* wl_display::loop
<a name="struct wl_event_loop* wl_display::loop"></a>
</h3>
<h3>size_t wl_display::max_buffer_size
<a name="size_t wl_display::max_buffer_size"></a>
</h3>
<h3>uint32_t wl_display::next_global_name
<a name="uint32_t wl_display::next_global_name"></a>
</h3>
<h3>struct wl_list wl_display::protocol_loggers
<a name="struct wl_list wl_display::protocol_loggers"></a>
</h3>
<h3>struct wl_list wl_display::registry_resource_list
<a name="struct wl_list wl_display::registry_resource_list"></a>
</h3>
<h3>bool wl_display::run
<a name="bool wl_display::run"></a>
</h3>
<h3>uint32_t wl_display::serial
<a name="uint32_t wl_display::serial"></a>
</h3>
<h3>struct wl_list wl_display::socket_list
<a name="struct wl_list wl_display::socket_list"></a>
</h3>
<h3>struct wl_event_source* wl_display::term_source
<a name="struct wl_event_source* wl_display::term_source"></a>
</h3>
<h3>int wl_display::terminate_efd
<a name="int wl_display::terminate_efd"></a>
</h3>
<h2>Author
<a name="Author"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated
automatically by Doxygen for Wayland from the source
code.</p>
<hr/>
</body>
</html>
