<!-- Creator     : groff version 1.23.0 -->
<!-- CreationDate: Sat Apr  5 20:52:41 2025 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
<meta content="groff -Thtml, see www.gnu.org" name="generator"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="text/css" name="Content-Style"/>
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>wl_proxy</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><style>
            :root {
                --primary-color: #3498db;
                --background-color: #f9f9f9;
                --text-color: #333;
                --code-bg: #f0f0f0;
                --header-color: #2c3e50;
                --link-color: #2980b9;
            }
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                color: var(--text-color);
                background-color: var(--background-color);
                max-width: 900px;
                margin: 0 auto;
                padding: 2rem;
            }
            h1, h2, h3, h4 {
                color: var(--header-color);
            }
            h1 {
                border-bottom: 2px solid var(--primary-color);
                padding-bottom: 0.5rem;
            }
            pre {
                background-color: var(--code-bg);
                padding: 1rem;
                border-radius: 4px;
                overflow-x: auto;
            }
            a {
                color: var(--link-color);
                text-decoration: none;
            }
            a:hover {
                text-decoration: underline;
            }
            .man-navigation {
                background-color: #fff;
                border-bottom: 1px solid #ddd;
                padding: 0.5rem 0;
                position: sticky;
                top: 0;
                z-index: 100;
            }
            .section {
                margin-top: 2rem;
            }
            @media (prefers-color-scheme: dark) {
                :root {
                    --primary-color: #3498db;
                    --background-color: #222;
                    --text-color: #f0f0f0;
                    --code-bg: #333;
                    --header-color: #3498db;
                    --link-color: #5dade2;
                }
            }
            .back-to-index {
                display: inline-block;
                margin: 1rem 0;
                padding: 0.5rem 1rem;
                background-color: var(--primary-color);
                color: white;
                border-radius: 4px;
                text-decoration: none;
            }
            .back-to-index:hover {
                background-color: var(--link-color);
                text-decoration: none;
            }
        </style></head>
<body><div><a class="back-to-index" href="../index.html">← Back to Index</a></div>
<h1 align="center">wl_proxy</h1>
<a href="#NAME">NAME</a><br/>
<a href="#SYNOPSIS">SYNOPSIS</a><br/>
<a href="#Public Member Functions">Public Member Functions</a><br/>
<a href="#Related Symbols">Related Symbols</a><br/>
<a href="#Detailed Description">Detailed Description</a><br/>
<a href="#Member Function Documentation">Member Function Documentation</a><br/>
<a href="#const char * wl_event_queue_get_name (const struct wl_event_queue * queue)">const char * wl_event_queue_get_name (const struct wl_event_queue * queue)</a><br/>
<a href="#int wl_proxy_add_dispatcher (struct wl_proxy * proxy, wl_dispatcher_func_tdispatcher, const void * implementation, void * data)">int wl_proxy_add_dispatcher (struct wl_proxy * proxy, wl_dispatcher_func_tdispatcher, const void * implementation, void * data)</a><br/>
<a href="#int wl_proxy_add_listener (struct wl_proxy * proxy, void(** implementation)(void), void * data)">int wl_proxy_add_listener (struct wl_proxy * proxy, void(** implementation)(void), void * data)</a><br/>
<a href="#struct wl_proxy * wl_proxy_create (struct wl_proxy * factory, const structwl_interface * interface)">struct wl_proxy * wl_proxy_create (struct wl_proxy * factory, const structwl_interface * interface)</a><br/>
<a href="#void * wl_proxy_create_wrapper (void * proxy)">void * wl_proxy_create_wrapper (void * proxy)</a><br/>
<a href="#void wl_proxy_destroy (struct wl_proxy * proxy)">void wl_proxy_destroy (struct wl_proxy * proxy)</a><br/>
<a href="#const char * wl_proxy_get_class (struct wl_proxy * proxy)">const char * wl_proxy_get_class (struct wl_proxy * proxy)</a><br/>
<a href="#struct wl_display * wl_proxy_get_display (struct wl_proxy * proxy)">struct wl_display * wl_proxy_get_display (struct wl_proxy * proxy)</a><br/>
<a href="#uint32_t wl_proxy_get_id (struct wl_proxy * proxy)">uint32_t wl_proxy_get_id (struct wl_proxy * proxy)</a><br/>
<a href="#const void * wl_proxy_get_listener (struct wl_proxy * proxy)">const void * wl_proxy_get_listener (struct wl_proxy * proxy)</a><br/>
<a href="#const char *const * wl_proxy_get_tag (struct wl_proxy * proxy)">const char *const * wl_proxy_get_tag (struct wl_proxy * proxy)</a><br/>
<a href="#void * wl_proxy_get_user_data (struct wl_proxy * proxy)">void * wl_proxy_get_user_data (struct wl_proxy * proxy)</a><br/>
<a href="#uint32_t wl_proxy_get_version (struct wl_proxy * proxy)">uint32_t wl_proxy_get_version (struct wl_proxy * proxy)</a><br/>
<a href="#void wl_proxy_marshal (struct wl_proxy * proxy, uint32_t opcode, ...)">void wl_proxy_marshal (struct wl_proxy * proxy, uint32_t opcode, ...)</a><br/>
<a href="#void wl_proxy_marshal_array (struct wl_proxy * proxy, uint32_t opcode,union wl_argument * args)">void wl_proxy_marshal_array (struct wl_proxy * proxy, uint32_t opcode,union wl_argument * args)</a><br/>
<a href="#struct wl_proxy * wl_proxy_marshal_array_constructor (struct wl_proxy *proxy, uint32_t opcode, union wl_argument * args, const structwl_interface * interface)">struct wl_proxy * wl_proxy_marshal_array_constructor (struct wl_proxy *proxy, uint32_t opcode, union wl_argument * args, const structwl_interface * interface)</a><br/>
<a href="#struct wl_proxy * wl_proxy_marshal_array_constructor_versioned (structwl_proxy * proxy, uint32_t opcode, union wl_argument * args, conststruct wl_interface * interface, uint32_t version)">struct wl_proxy * wl_proxy_marshal_array_constructor_versioned (structwl_proxy * proxy, uint32_t opcode, union wl_argument * args, conststruct wl_interface * interface, uint32_t version)</a><br/>
<a href="#struct wl_proxy * wl_proxy_marshal_array_flags (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, uint32_tversion, uint32_t flags, union wl_argument * args)">struct wl_proxy * wl_proxy_marshal_array_flags (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, uint32_tversion, uint32_t flags, union wl_argument * args)</a><br/>
<a href="#struct wl_proxy * wl_proxy_marshal_constructor (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, ...)">struct wl_proxy * wl_proxy_marshal_constructor (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, ...)</a><br/>
<a href="#struct wl_proxy * wl_proxy_marshal_constructor_versioned (struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface * interface, uint32_tversion, ...)">struct wl_proxy * wl_proxy_marshal_constructor_versioned (struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface * interface, uint32_tversion, ...)</a><br/>
<a href="#struct wl_proxy * wl_proxy_marshal_flags (struct wl_proxy * proxy, uint32_topcode, const struct wl_interface * interface, uint32_t version,uint32_t flags, ...)">struct wl_proxy * wl_proxy_marshal_flags (struct wl_proxy * proxy, uint32_topcode, const struct wl_interface * interface, uint32_t version,uint32_t flags, ...)</a><br/>
<a href="#void wl_proxy_set_queue (struct wl_proxy * proxy, struct wl_event_queue *queue)">void wl_proxy_set_queue (struct wl_proxy * proxy, struct wl_event_queue *queue)</a><br/>
<a href="#void wl_proxy_set_tag (struct wl_proxy * proxy, const char *const * tag)">void wl_proxy_set_tag (struct wl_proxy * proxy, const char *const * tag)</a><br/>
<a href="#void wl_proxy_set_user_data (struct wl_proxy * proxy, void * user_data)">void wl_proxy_set_user_data (struct wl_proxy * proxy, void * user_data)</a><br/>
<a href="#void wl_proxy_wrapper_destroy (void * proxy_wrapper)">void wl_proxy_wrapper_destroy (void * proxy_wrapper)</a><br/>
<a href="#Friends And Related Symbol Documentation">Friends And Related Symbol Documentation</a><br/>
<a href="##define WL_MARSHAL_FLAG_DESTROY (1 &lt;&lt; 0) [related]">#define WL_MARSHAL_FLAG_DESTROY (1 &lt;&lt; 0) [related]</a><br/>
<a href="#Author">Author</a><br/>
<hr/>
<h2>NAME
<a name="NAME"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">wl_proxy −
Represents a protocol object on the client side.</p>
<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">#include
&lt;wayland−client−core.h&gt;</p>
<h3>Public Member Functions
<a name="Public Member Functions"></a>
</h3>
<p style="margin-left:14%; margin-top: 1em">struct
<b>wl_proxy</b> * <b>wl_proxy_create</b> (struct
<b>wl_proxy</b> *factory, const struct <b>wl_interface</b>
*interface) <br/>
void <b>wl_proxy_destroy</b> (struct <b>wl_proxy</b> *proxy)
<br/>
int <b>wl_proxy_add_listener</b> (struct <b>wl_proxy</b>
*proxy, void(**implementation)(void), void *data) <br/>
const void * <b>wl_proxy_get_listener</b> (struct
<b>wl_proxy</b> *proxy) <br/>
int <b>wl_proxy_add_dispatcher</b> (struct <b>wl_proxy</b>
*proxy, <b>wl_dispatcher_func_t</b> dispatcher, const void
*implementation, void *data) <br/>
struct <b>wl_proxy</b> *
<b>wl_proxy_marshal_array_constructor</b> (struct
<b>wl_proxy</b> *proxy, uint32_t opcode, union
<b>wl_argument</b> *args, const struct <b>wl_interface</b>
*interface) <br/>
struct <b>wl_proxy</b> *
<b>wl_proxy_marshal_array_constructor_versioned</b> (struct
<b>wl_proxy</b> *proxy, uint32_t opcode, union
<b>wl_argument</b> *args, const struct <b>wl_interface</b>
*interface, uint32_t version) <br/>
struct <b>wl_proxy</b> * <b>wl_proxy_marshal_flags</b>
(struct <b>wl_proxy</b> *proxy, uint32_t opcode, const
struct <b>wl_interface</b> *interface, uint32_t version,
uint32_t flags,...) <br/>
struct <b>wl_proxy</b> * <b>wl_proxy_marshal_array_flags</b>
(struct <b>wl_proxy</b> *proxy, uint32_t opcode, const
struct <b>wl_interface</b> *interface, uint32_t version,
uint32_t flags, union <b>wl_argument</b> *args) <br/>
void <b>wl_proxy_marshal</b> (struct <b>wl_proxy</b> *proxy,
uint32_t opcode,...) <br/>
struct <b>wl_proxy</b> * <b>wl_proxy_marshal_constructor</b>
(struct <b>wl_proxy</b> *proxy, uint32_t opcode, const
struct <b>wl_interface</b> *interface,...) <br/>
struct <b>wl_proxy</b> *
<b>wl_proxy_marshal_constructor_versioned</b> (struct
<b>wl_proxy</b> *proxy, uint32_t opcode, const struct
<b>wl_interface</b> *interface, uint32_t version,...) <br/>
void <b>wl_proxy_marshal_array</b> (struct <b>wl_proxy</b>
*proxy, uint32_t opcode, union <b>wl_argument</b> *args)
<br/>
void <b>wl_proxy_set_user_data</b> (struct <b>wl_proxy</b>
*proxy, void *user_data) <br/>
void * <b>wl_proxy_get_user_data</b> (struct <b>wl_proxy</b>
*proxy) <br/>
uint32_t <b>wl_proxy_get_version</b> (struct <b>wl_proxy</b>
*proxy) <br/>
uint32_t <b>wl_proxy_get_id</b> (struct <b>wl_proxy</b>
*proxy) <br/>
void <b>wl_proxy_set_tag</b> (struct <b>wl_proxy</b> *proxy,
const char *const *tag) <br/>
const char *const * <b>wl_proxy_get_tag</b> (struct
<b>wl_proxy</b> *proxy) <br/>
const char * <b>wl_proxy_get_class</b> (struct
<b>wl_proxy</b> *proxy) <br/>
struct <b>wl_display</b> * <b>wl_proxy_get_display</b>
(struct <b>wl_proxy</b> *proxy) <br/>
void <b>wl_proxy_set_queue</b> (struct <b>wl_proxy</b>
*proxy, struct <b>wl_event_queue</b> *queue) <br/>
const char * <b>wl_event_queue_get_name</b> (const struct
<b>wl_event_queue</b> *queue) <br/>
void * <b>wl_proxy_create_wrapper</b> (void *proxy) <br/>
void <b>wl_proxy_wrapper_destroy</b> (void
*proxy_wrapper)</p>
<h3>Related Symbols
<a name="Related Symbols"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">(Note that these
are not member symbols.)</p>
<p style="margin-left:14%;">#define
<b>WL_MARSHAL_FLAG_DESTROY</b> (1 &lt;&lt; 0)</p>
<h2>Detailed Description
<a name="Detailed Description"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Represents a
protocol object on the client side.</p>
<p style="margin-left:9%; margin-top: 1em">A
<b>wl_proxy</b> acts as a client side proxy to an object
existing in the compositor. The proxy is responsible for
converting requests made by the clients with
<b>wl_proxy_marshal()</b> into Wayland’s wire format.
Events coming from the compositor are also handled by the
proxy, which will in turn call the handler set with
<b>wl_proxy_add_listener()</b>.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">With the exception of function
<b>wl_proxy_set_queue()</b>, functions accessing a
<b>wl_proxy</b> are not normally used by client code.
Clients should normally use the higher level interface
generated by the scanner to interact with compositor
objects.</p>
<h2>Member Function Documentation
<a name="Member Function Documentation"></a>
</h2>
<h3>const char * wl_event_queue_get_name (const struct wl_event_queue * queue)
<a name="const char * wl_event_queue_get_name (const struct wl_event_queue * queue)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the name of
an event queue</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>queue</i> The queue to
query</p>
<p style="margin-left:9%; margin-top: 1em">Return the human
readable name for the event queue</p>
<p style="margin-left:9%; margin-top: 1em">This may be NULL
if no name has been set.</p>
<h3>int wl_proxy_add_dispatcher (struct wl_proxy * proxy, wl_dispatcher_func_tdispatcher, const void * implementation, void * data)
<a name="int wl_proxy_add_dispatcher (struct wl_proxy * proxy, wl_dispatcher_func_tdispatcher, const void * implementation, void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Set a
proxy’s listener (with dispatcher)</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
dispatcher</i> The dispatcher to be used for this proxy
<i><br/>
implementation</i> The dispatcher-specific listener
implementation <i><br/>
data</i> User data to be associated with the proxy</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success or -1 on
failure</p>
<p style="margin-left:9%; margin-top: 1em">Set
proxy’s listener to use dispatcher_func as its
dispatcher and dispatcher_data as its dispatcher-specific
implementation and its user data to data. If a listener has
already been set, this function fails and nothing is
changed.</p>
<p style="margin-left:9%; margin-top: 1em">The exact
details of dispatcher_data depend on the dispatcher used.
This function is intended to be used by language bindings,
not user code.</p>
<p style="margin-left:9%; margin-top: 1em">proxy must not
be a proxy wrapper.</p>
<h3>int wl_proxy_add_listener (struct wl_proxy * proxy, void(** implementation)(void), void * data)
<a name="int wl_proxy_add_listener (struct wl_proxy * proxy, void(** implementation)(void), void * data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Set a
proxy’s listener</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
implementation</i> The listener to be added to proxy <i><br/>
data</i> User data to be associated with the proxy</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">0 on success or -1 on
failure</p>
<p style="margin-left:9%; margin-top: 1em">Set
proxy’s listener to implementation and its user data
to data. If a listener has already been set, this function
fails and nothing is changed.</p>
<p style="margin-left:9%; margin-top: 1em">implementation
is a vector of function pointers. For an opcode n,
implementation[n] should point to the handler of n for the
given object.</p>
<p style="margin-left:9%; margin-top: 1em">proxy must not
be a proxy wrapper.</p>
<h3>struct wl_proxy * wl_proxy_create (struct wl_proxy * factory, const structwl_interface * interface)
<a name="struct wl_proxy * wl_proxy_create (struct wl_proxy * factory, const structwl_interface * interface)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a proxy
object with a given interface</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>factory</i> Factory proxy
object <i><br/>
interface</i> Interface the proxy object should use</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A newly allocated proxy object
or NULL on failure</p>
<p style="margin-left:9%; margin-top: 1em">This function
creates a new proxy object with the supplied interface. The
proxy object will have an id assigned from the client id
space. The id should be created on the compositor side by
sending an appropriate request with
<b>wl_proxy_marshal()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">The proxy will
inherit the display and event queue of the factory
object.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This should not normally be
used by non-generated code.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display</b>,
<b>wl_event_queue</b>, <b>wl_proxy_marshal()</b></p>
<h3>void * wl_proxy_create_wrapper (void * proxy)
<a name="void * wl_proxy_create_wrapper (void * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Create a proxy
wrapper for making queue assignments thread-safe</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
to be wrapped</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A proxy wrapper for the given
proxy or NULL on failure</p>
<p style="margin-left:9%; margin-top: 1em">A proxy wrapper
is type of ’struct <b>wl_proxy</b>’ instance
that can be used when sending requests instead of using the
original proxy. A proxy wrapper does not have an
implementation or dispatcher, and events received on the
object is still emitted on the original proxy. Trying to set
an implementation or dispatcher will have no effect but
result in a warning being logged.</p>
<p style="margin-left:9%; margin-top: 1em">Setting the
proxy queue of the proxy wrapper will make new objects
created using the proxy wrapper use the set proxy queue.
Even though there is no implementation nor dispatcher, the
proxy queue can be changed. This will affect the default
queue of new objects created by requests sent via the proxy
wrapper.</p>
<p style="margin-left:9%; margin-top: 1em">A proxy wrapper
can only be destroyed using
<b>wl_proxy_wrapper_destroy()</b>.</p>
<p style="margin-left:9%; margin-top: 1em">A proxy wrapper
must be destroyed before the proxy it was created from.</p>
<p style="margin-left:9%; margin-top: 1em">If a user reads
and dispatches events on more than one thread, it is
necessary to use a proxy wrapper when sending requests on
objects when the intention is that a newly created proxy is
to use a proxy queue different from the proxy the request
was sent on, as creating the new proxy and then setting the
queue is not thread safe.</p>
<p style="margin-left:9%; margin-top: 1em">For example, a
module that runs using its own proxy queue that needs to do
display roundtrip must wrap the <b>wl_display</b> proxy
object before sending the wl_display.sync request. For
example:</p>
<p style="margin-left:9%; margin-top: 1em">struct
wl_event_queue *queue = ...; <br/>
struct wl_display *wrapped_display; <br/>
struct wl_callback *callback;</p>
<p style="margin-left:9%; margin-top: 1em">wrapped_display
= wl_proxy_create_wrapper(display); <br/>
wl_proxy_set_queue((struct wl_proxy *) wrapped_display,
queue); <br/>
callback = wl_display_sync(wrapped_display); <br/>
wl_proxy_wrapper_destroy(wrapped_display); <br/>
wl_callback_add_listener(callback, ...);</p>
<h3>void wl_proxy_destroy (struct wl_proxy * proxy)
<a name="void wl_proxy_destroy (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Destroy a proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy to be
destroyed</p>
<p style="margin-left:9%; margin-top: 1em">proxy must not
be a proxy wrapper.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This function will abort in
response to egregious errors, and will do so with the
display lock held. This means SIGABRT handlers must not
perform any actions that would attempt to take that lock, or
a deadlock would occur.</p>
<h3>const char * wl_proxy_get_class (struct wl_proxy * proxy)
<a name="const char * wl_proxy_get_class (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the
interface name (class) of a proxy object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The interface name of the
object associated with the proxy</p>
<h3>struct wl_display * wl_proxy_get_display (struct wl_proxy * proxy)
<a name="struct wl_display * wl_proxy_get_display (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the display
of a proxy object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The <b>wl_display</b> the proxy
is associated with</p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.23</p>
<h3>uint32_t wl_proxy_get_id (struct wl_proxy * proxy)
<a name="uint32_t wl_proxy_get_id (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the id of a
proxy object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The id the object associated
with the proxy</p>
<h3>const void * wl_proxy_get_listener (struct wl_proxy * proxy)
<a name="const void * wl_proxy_get_listener (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get a
proxy’s listener</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The address of the
proxy’s listener or NULL if no listener is set</p>
<p style="margin-left:9%; margin-top: 1em">Gets the address
to the proxy’s listener; which is the listener set
with <b>wl_proxy_add_listener</b>.</p>
<p style="margin-left:9%; margin-top: 1em">This function is
useful in clients with multiple listeners on the same
interface to allow the identification of which code to
execute.</p>
<h3>const char *const * wl_proxy_get_tag (struct wl_proxy * proxy)
<a name="const char *const * wl_proxy_get_tag (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the tag of a
proxy object</p>
<p style="margin-left:9%; margin-top: 1em">See
wl_proxy_set_tag for details.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.17.90</p>
<h3>void * wl_proxy_get_user_data (struct wl_proxy * proxy)
<a name="void * wl_proxy_get_user_data (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the user
data associated with a proxy</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The user data associated with
proxy</p>
<h3>uint32_t wl_proxy_get_version (struct wl_proxy * proxy)
<a name="uint32_t wl_proxy_get_version (struct wl_proxy * proxy)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Get the protocol
object version of a proxy object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy
object</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">The protocol object version of
the proxy or 0</p>
<p style="margin-left:9%; margin-top: 1em">Gets the
protocol object version of a proxy object, or 0 if the proxy
was created with unversioned API.</p>
<p style="margin-left:9%; margin-top: 1em">A returned value
of 0 means that no version information is available, so the
caller must make safe assumptions about the object’s
real version.</p>
<p style="margin-left:9%; margin-top: 1em"><b>wl_display</b>’s
version will always return 0.</p>
<h3>void wl_proxy_marshal (struct wl_proxy * proxy, uint32_t opcode, ...)
<a name="void wl_proxy_marshal (struct wl_proxy * proxy, uint32_t opcode, ...)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
...</i> Extra arguments for the given request</p>
<p style="margin-left:9%; margin-top: 1em">This function is
similar to <b>wl_proxy_marshal_constructor()</b>, except it
doesn’t create proxies for new-id arguments.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This should not normally be
used by non-generated code.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_proxy_create()</b></p>
<h3>void wl_proxy_marshal_array (struct wl_proxy * proxy, uint32_t opcode,union wl_argument * args)
<a name="void wl_proxy_marshal_array (struct wl_proxy * proxy, uint32_t opcode,union wl_argument * args)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
args</i> Extra arguments for the given request</p>
<p style="margin-left:9%; margin-top: 1em">This function is
similar to <b>wl_proxy_marshal_array_constructor()</b>,
except it doesn’t create proxies for new-id
arguments.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This is intended to be used by
language bindings and not in non-generated code.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_proxy_marshal()</b></p>
<h3>struct wl_proxy * wl_proxy_marshal_array_constructor (struct wl_proxy *proxy, uint32_t opcode, union wl_argument * args, const structwl_interface * interface)
<a name="struct wl_proxy * wl_proxy_marshal_array_constructor (struct wl_proxy *proxy, uint32_t opcode, union wl_argument * args, const structwl_interface * interface)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
args</i> Extra arguments for the given request <i><br/>
interface</i> The interface to use for the new proxy</p>
<p style="margin-left:9%; margin-top: 1em">This function
translates a request given an opcode, an interface and a
<b>wl_argument</b> array to the wire format and writes it to
the connection buffer.</p>
<p style="margin-left:9%; margin-top: 1em">For new-id
arguments, this function will allocate a new <b>wl_proxy</b>
and send the ID to the server. The new <b>wl_proxy</b> will
be returned on success or NULL on error with errno set
accordingly. The newly created proxy will inherit their
version from their parent.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This is intended to be used by
language bindings and not in non-generated code.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_proxy_marshal()</b></p>
<h3>struct wl_proxy * wl_proxy_marshal_array_constructor_versioned (structwl_proxy * proxy, uint32_t opcode, union wl_argument * args, conststruct wl_interface * interface, uint32_t version)
<a name="struct wl_proxy * wl_proxy_marshal_array_constructor_versioned (structwl_proxy * proxy, uint32_t opcode, union wl_argument * args, conststruct wl_interface * interface, uint32_t version)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
args</i> Extra arguments for the given request <i><br/>
interface</i> The interface to use for the new proxy <i><br/>
version</i> The protocol object version for the new
proxy</p>
<p style="margin-left:9%; margin-top: 1em">Translates the
request given by opcode and the extra arguments into the
wire format and write it to the connection buffer. This
version takes an array of the union type
<b>wl_argument</b>.</p>
<p style="margin-left:9%; margin-top: 1em">For new-id
arguments, this function will allocate a new <b>wl_proxy</b>
and send the ID to the server. The new <b>wl_proxy</b> will
be returned on success or NULL on error with errno set
accordingly. The newly created proxy will have the version
specified.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This is intended to be used by
language bindings and not in non-generated code.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_proxy_marshal()</b></p>
<h3>struct wl_proxy * wl_proxy_marshal_array_flags (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, uint32_tversion, uint32_t flags, union wl_argument * args)
<a name="struct wl_proxy * wl_proxy_marshal_array_flags (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, uint32_tversion, uint32_t flags, union wl_argument * args)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
interface</i> The interface to use for the new proxy <i><br/>
version</i> The protocol object version for the new proxy
<i><br/>
flags</i> Flags that modify marshalling behaviour <i><br/>
args</i> Extra arguments for the given request</p>
<p style="margin-left:9%; margin-top: 1em">Translates the
request given by opcode and the extra arguments into the
wire format and write it to the connection buffer. This
version takes an array of the union type
<b>wl_argument</b>.</p>
<p style="margin-left:9%; margin-top: 1em">For new-id
arguments, this function will allocate a new <b>wl_proxy</b>
and send the ID to the server. The new <b>wl_proxy</b> will
be returned on success or NULL on error with errno set
accordingly. The newly created proxy will have the version
specified.</p>
<p style="margin-left:9%; margin-top: 1em">The flag
WL_MARSHAL_FLAG_DESTROY may be passed to ensure the proxy is
destroyed atomically with the marshalling in order to
prevent races that can occur if the display lock is dropped
between the marshal and destroy operations.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This is intended to be used by
language bindings and not in non-generated code.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_proxy_marshal_flags()</b></p>
<h3>struct wl_proxy * wl_proxy_marshal_constructor (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, ...)
<a name="struct wl_proxy * wl_proxy_marshal_constructor (struct wl_proxy * proxy,uint32_t opcode, const struct wl_interface * interface, ...)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
interface</i> The interface to use for the new proxy <i><br/>
...</i> Extra arguments for the given request</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new <b>wl_proxy</b> for the
new_id argument or NULL on error</p>
<p style="margin-left:9%; margin-top: 1em">This function
translates a request given an opcode, an interface and extra
arguments to the wire format and writes it to the connection
buffer. The types of the extra arguments must correspond to
the argument types of the method associated with the opcode
in the interface.</p>
<p style="margin-left:9%; margin-top: 1em">For new-id
arguments, this function will allocate a new <b>wl_proxy</b>
and send the ID to the server. The new <b>wl_proxy</b> will
be returned on success or NULL on error with errno set
accordingly. The newly created proxy will inherit their
version from their parent.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This should not normally be
used by non-generated code.</p>
<h3>struct wl_proxy * wl_proxy_marshal_constructor_versioned (struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface * interface, uint32_tversion, ...)
<a name="struct wl_proxy * wl_proxy_marshal_constructor_versioned (struct wl_proxy *proxy, uint32_t opcode, const struct wl_interface * interface, uint32_tversion, ...)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
interface</i> The interface to use for the new proxy <i><br/>
version</i> The protocol object version of the new proxy
<i><br/>
...</i> Extra arguments for the given request</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new <b>wl_proxy</b> for the
new_id argument or NULL on error</p>
<p style="margin-left:9%; margin-top: 1em">Translates the
request given by opcode and the extra arguments into the
wire format and write it to the connection buffer.</p>
<p style="margin-left:9%; margin-top: 1em">For new-id
arguments, this function will allocate a new <b>wl_proxy</b>
and send the ID to the server. The new <b>wl_proxy</b> will
be returned on success or NULL on error with errno set
accordingly. The newly created proxy will have the version
specified.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This should not normally be
used by non-generated code.</p>
<h3>struct wl_proxy * wl_proxy_marshal_flags (struct wl_proxy * proxy, uint32_topcode, const struct wl_interface * interface, uint32_t version,uint32_t flags, ...)
<a name="struct wl_proxy * wl_proxy_marshal_flags (struct wl_proxy * proxy, uint32_topcode, const struct wl_interface * interface, uint32_t version,uint32_t flags, ...)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Prepare a
request to be sent to the compositor</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
opcode</i> Opcode of the request to be sent <i><br/>
interface</i> The interface to use for the new proxy <i><br/>
version</i> The protocol object version of the new proxy
<i><br/>
flags</i> Flags that modify marshalling behaviour <i><br/>
...</i> Extra arguments for the given request</p>
<p style="margin-left:9%; margin-top: 1em"><b>Returns</b></p>
<p style="margin-left:14%;">A new <b>wl_proxy</b> for the
new_id argument or NULL on error</p>
<p style="margin-left:9%; margin-top: 1em">Translates the
request given by opcode and the extra arguments into the
wire format and write it to the connection buffer.</p>
<p style="margin-left:9%; margin-top: 1em">For new-id
arguments, this function will allocate a new <b>wl_proxy</b>
and send the ID to the server. The new <b>wl_proxy</b> will
be returned on success or NULL on error with errno set
accordingly. The newly created proxy will have the version
specified.</p>
<p style="margin-left:9%; margin-top: 1em">The flag
WL_MARSHAL_FLAG_DESTROY may be passed to ensure the proxy is
destroyed atomically with the marshalling in order to
prevent races that can occur if the display lock is dropped
between the marshal and destroy operations.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">This should not normally be
used by non-generated code.</p>
<h3>void wl_proxy_set_queue (struct wl_proxy * proxy, struct wl_event_queue *queue)
<a name="void wl_proxy_set_queue (struct wl_proxy * proxy, struct wl_event_queue *queue)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Assign a proxy
to an event queue</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
queue</i> The event queue that will handle this proxy or
NULL</p>
<p style="margin-left:9%; margin-top: 1em">Assign proxy to
event queue. Events coming from proxy will be queued in
queue from now. If queue is NULL, then the display’s
default queue is set to the proxy.</p>
<p style="margin-left:9%; margin-top: 1em">In order to
guarantee proper handing of all events which were queued
before the queue change takes effect, it is required to
dispatch the proxy’s old event queue after setting a
new event queue.</p>
<p style="margin-left:9%; margin-top: 1em">This is
particularly important for multi-threaded setups, where it
is possible for events to be queued to the proxy’s old
queue from a different thread during the invocation of this
function.</p>
<p style="margin-left:9%; margin-top: 1em">To ensure that
all events for a newly created proxy are dispatched on a
particular queue, it is necessary to use a proxy wrapper if
events are read and dispatched on more than one thread. See
<b>wl_proxy_create_wrapper()</b> for more details.</p>
<p style="margin-left:9%; margin-top: 1em"><b>Note</b></p>
<p style="margin-left:14%;">By default, the queue set in
proxy is the one inherited from parent.</p>
<p style="margin-left:9%; margin-top: 1em"><b>See
also</b></p>
<p style="margin-left:14%;"><b>wl_display_dispatch_queue()</b></p>
<h3>void wl_proxy_set_tag (struct wl_proxy * proxy, const char *const * tag)
<a name="void wl_proxy_set_tag (struct wl_proxy * proxy, const char *const * tag)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Set the tag of a
proxy object</p>
<p style="margin-left:9%; margin-top: 1em">A toolkit or
application can set a unique tag on a proxy in order to
identify whether an object is managed by itself or some
external part.</p>
<p style="margin-left:9%; margin-top: 1em">To create a tag,
the recommended way is to define a statically allocated
constant char array containing some descriptive string. The
tag will be the pointer to the non-const pointer to the
beginning of the array.</p>
<p style="margin-left:9%; margin-top: 1em">For example, to
define and set a tag on a surface managed by a certain
subsystem:</p>
<p style="margin-left:9%; margin-top: 1em">static const
char *my_tag = ’my tag’;</p>
<p style="margin-left:9%; margin-top: 1em">wl_proxy_set_tag((struct
wl_proxy *) surface, &amp;my_tag);</p>
<p style="margin-left:9%; margin-top: 1em">Then, in a
callback with wl_surface as an argument, in order to check
whether it’s a surface managed by the same
subsystem.</p>
<p style="margin-left:9%; margin-top: 1em">const char *
const *tag;</p>
<p style="margin-left:9%; margin-top: 1em">tag =
wl_proxy_get_tag((struct wl_proxy *) surface); <br/>
if (tag != &amp;my_tag) <br/>
return;</p>
<p style="margin-left:9%; margin-top: 1em">...</p>
<p style="margin-left:9%; margin-top: 1em">For debugging
purposes, a tag should be suitable to be included in a debug
log entry, e.g.</p>
<p style="margin-left:9%; margin-top: 1em">const char *
const *tag;</p>
<p style="margin-left:9%; margin-top: 1em">tag =
wl_proxy_get_tag((struct wl_proxy *) surface); <br/>
printf(’Got a surface with the tag %p (%s)\n’,
<br/>
tag, (tag &amp;&amp; *tag) ? *tag : ’’);</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
tag</i> The tag</p>
<p style="margin-left:9%; margin-top: 1em"><b>Since</b></p>
<p style="margin-left:14%;">1.17.90</p>
<h3>void wl_proxy_set_user_data (struct wl_proxy * proxy, void * user_data)
<a name="void wl_proxy_set_user_data (struct wl_proxy * proxy, void * user_data)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Set the user
data associated with a proxy</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy</i> The proxy object
<i><br/>
user_data</i> The data to be associated with proxy</p>
<p style="margin-left:9%; margin-top: 1em">Set the user
data associated with proxy. When events for this proxy are
received, user_data will be supplied to its listener.</p>
<h3>void wl_proxy_wrapper_destroy (void * proxy_wrapper)
<a name="void wl_proxy_wrapper_destroy (void * proxy_wrapper)"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Destroy a proxy
wrapper</p>
<p style="margin-left:9%; margin-top: 1em"><b>Parameters</b></p>
<p style="margin-left:14%;"><i>proxy_wrapper</i> The proxy
wrapper to be destroyed</p>
<h2>Friends And Related Symbol Documentation
<a name="Friends And Related Symbol Documentation"></a>
</h2>
<h3>#define WL_MARSHAL_FLAG_DESTROY (1 &lt;&lt; 0) [related]
<a name="#define WL_MARSHAL_FLAG_DESTROY (1 &lt;&lt; 0) [related]"></a>
</h3>
<p style="margin-left:9%; margin-top: 1em">Destroy proxy
after marshalling</p>
<h2>Author
<a name="Author"></a>
</h2>
<p style="margin-left:9%; margin-top: 1em">Generated
automatically by Doxygen for Wayland from the source
code.</p>
<hr/>
</body>
</html>
